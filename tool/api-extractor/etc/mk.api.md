## API Report File for "mk"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as cc_2 from 'cc';

// Warning: (ae-forgotten-export) The symbol "mk_asset" needs to be exported by the entry point mk_export.d.ts
//
// @public (undocumented)
export const asset: mk_asset;

// @public (undocumented)
export namespace asset_ {
    export interface get_config<T extends cc_2.Asset = cc_2.Asset, T2 = T> {
        bundle_s?: string;
        completed_f?: (error: Error | null, asset: T2) => void;
        progress_f?: (
        current_n: number,
        total_n: number) => void;
        // Warning: (ae-forgotten-export) The symbol "_mk_asset" needs to be exported by the entry point mk_export.d.ts
        remote_option?: _mk_asset.load_remote_option_type;
        type: cc_2.Constructor<T>;
    }
    export type get_dir_config<T extends cc_2.Asset> = get_config<T, T[]>;
}

// Warning: (ae-forgotten-export) The symbol "mk_audio_base" needs to be exported by the entry point mk_export.d.ts
//
// @public (undocumented)
export const audio: mk_audio_base;

// @public (undocumented)
export namespace audio_ {
    export interface add_config {
        dir_b?: boolean;
        group_ns?: number[];
        load_config: asset_.get_dir_config<cc_2.AudioClip>;
    }
    export interface event_protocol {
        end(): void;
        init(): void;
        pause(): void;
        play(): void;
        resume(): void;
        stop(): void;
    }
    export class group {
        constructor(init_: mk_audio_base, priority_n_: number);
        add_audio(audio_: unit | unit[]): void;
        audio_unit_as: ReadonlyArray<_unit>;
        clear(): unit[];
        del_audio(audio_: unit | unit[]): void;
        pause(): void;
        play(contains_state_n_?: number): void;
        get play_b(): boolean;
        readonly priority_n: number;
        stop(state_b_?: boolean): void;
        get stop_b(): boolean;
        get volume_n(): number;
        set volume_n(value_n_: number);
    }
    export interface play_config {
        loop_b: boolean;
        use_play_b: boolean;
        volume_n: number;
    }
    export enum state {
        pause = 2,
        play = 4,
        stop = 1
    }
    export interface unit {
        readonly audio_source?: cc_2.AudioSource;
        clip: cc_2.AudioClip | null;
        clone<T extends this>(): T;
        clone<T extends this>(value_n_: number): T[];
        curr_time_s_n: number;
        readonly event: event_target<event_protocol>;
        readonly group_ns: ReadonlyArray<number>;
        readonly init_b: boolean;
        loop_b: boolean;
        readonly real_volume_n: number;
        readonly state: state;
        readonly stop_group_n: number | null;
        readonly total_time_s_n: number;
        readonly type: number;
        use_play_b?: boolean;
        volume_n: number;
        wait_play_b?: boolean;
        readonly wait_play_n: number;
    }
    export abstract class _unit {
        constructor(init_?: Partial<_unit>);
        get audio_source(): cc_2.AudioSource | undefined;
        set audio_source(value_: cc_2.AudioSource | undefined);
        clip: cc_2.AudioClip | null;
        clone(): _unit;
        clone(value_n_: number): _unit[];
        protected abstract _clone(): _unit;
        get curr_time_s_n(): number;
        set curr_time_s_n(value_n_: number);
        get event(): event_target<event_protocol>;
        _event?: event_target<event_protocol>;
        group_ns: number[];
        get init_b(): boolean;
        set init_b(value_b_: boolean);
        protected _init_b: boolean;
        get loop_b(): boolean;
        set loop_b(value_b_: boolean);
        real_volume_n: number;
        state: state;
        stop_group_n: number | null;
        get total_time_s_n(): number;
        // Warning: (ae-forgotten-export) The symbol "global_config" needs to be exported by the entry point mk_export.d.ts
        type: global_config.audio.type;
        abstract update_volume(): void;
        use_play_b?: boolean;
        get volume_n(): number;
        set volume_n(value_n_: number);
        get wait_play_b(): boolean;
        set wait_play_b(value_b_: boolean);
        wait_play_n: number;
    }
    const // (undocumented)
    unit: Omit<unit, keyof Function> & (new (init_?: Partial<unit>) => Omit<unit, keyof Function>);
        {};
}

// Warning: (ae-forgotten-export) The symbol "mk_bundle" needs to be exported by the entry point mk_export.d.ts
//
// @public (undocumented)
export const bundle: mk_bundle;

// @public (undocumented)
export namespace bundle_ {
    export class bundle_info {
        constructor(init_: bundle_info);
        bundle_s: string;
        manage?: bundle_manage_base;
        origin_s?: string;
        version_s?: string;
    }
    export abstract class bundle_manage_base {
        constructor();
        close(): boolean | null | Promise<boolean | null>;
        data?: data_sharer;
        abstract event: event_target<any>;
        abstract name_s: string;
        network?: mk_network_base;
        node_pool_tab: Record<string, cc_2.NodePool>;
        open(): void | Promise<void>;
        valid_b: boolean;
    }
    export class load_config {
        constructor(init_: load_config);
        bundle_s: string;
        progress_callback_f?: (curr_n: number, total_n: number) => void;
    }
    export class switch_scene_config {
        constructor(init_?: Partial<switch_scene_config>);
        before_load_callback_f?: cc_2.Director.OnBeforeLoadScene;
        bundle_s: string;
        launched_callback_f?: cc_2.Director.OnSceneLaunched;
        preload_b?: boolean;
        progress_callback_f?: (finish_n: number, total_n: number, item?: cc_2.AssetManager.RequestItem) => void;
        unloaded_callback_f?: cc_2.Director.OnUnload;
    }
}

// @public
export abstract class codec_base {
    constructor(option_?: codec_base_.config);
    protected _config: codec_base_.config;
    decode(...args_as_: any[]): any;
    encode(...args_as_: any[]): any;
    protected get _log(): logger;
}

// @public (undocumented)
export namespace codec_base_ {
    export class config {
        decrypt_f?: (data: any) => any;
        encryption_f?: (data: any) => any;
    }
}

// @public
export class data_sharer<CT = any> extends instance_base {
    clear(): void;
    get<T extends keyof CT, T2 = CT[T]>(key_: T): T2 | null;
    get<T extends keyof CT, T2 extends true | false, T3 = CT[T]>(key_: T, request_: T2): T2 extends true ? Promise<T3> : T3 | null;
    // (undocumented)
    key: {
        [k in keyof CT]: k;
    };
    set<T extends keyof CT, T2 = CT[T]>(key_: CT, data_: T2): void;
}

// Warning: (ae-forgotten-export) The symbol "mk_http" needs to be exported by the entry point mk_export.d.ts
//
// @public (undocumented)
const _default: mk_http;

// Warning: (ae-forgotten-export) The symbol "mk_dynamic_module" needs to be exported by the entry point mk_export.d.ts
//
// @public (undocumented)
export const dynamic_module: mk_dynamic_module;

// @public (undocumented)
export class event_target<CT> extends cc_2.EventTarget {
    // (undocumented)
    clear(): void;
    // (undocumented)
    emit<T extends keyof CT, T2 extends Parameters<CT[T]>>(type_: T | T[], ...args_: T2): void;
    // (undocumented)
    hasEventListener<T extends keyof CT, T2 extends (...event_: Parameters<CT[T]>) => void>(type_: T, callback_?: T2, target_?: any): boolean;
    // (undocumented)
    key: {
        [k in keyof CT]: k;
    };
    // (undocumented)
    off<T extends keyof CT, T2 extends (...event_: Parameters<CT[T]>) => void>(type_: T | T[], callback_?: T2, this_?: any): void;
    // (undocumented)
    on<T extends keyof CT, T2 extends (...event_: Parameters<CT[T]>) => void>(type_: T | T[], callback_: T2, this_?: any, once_b_?: boolean): typeof callback_ | null;
    // (undocumented)
    once<T extends keyof CT, T2 extends (...event_: Parameters<CT[T]>) => void>(type_: T | T[], callback_: T2, this_?: any): typeof callback_ | null;
    request<T extends keyof CT, T2 extends Parameters<CT[T]>, T3 extends ReturnType<CT[T]>>(type_: T | T[], ...args_: T2): Promise<T3>[];
}

// Warning: (ae-forgotten-export) The symbol "mk_game" needs to be exported by the entry point mk_export.d.ts
//
// @public (undocumented)
export const game: mk_game;

declare namespace guide {
    export {
        mk_guide_step_base as step_base,
        mk_touch_mask as touch_mask,
        mk_polygon_mask as polygon_mask
    }
}
export { guide }

// @public
export class guide_manage {
    constructor(init_: guide_manage_.init_config);
    event: event_target<guide_manage_.event_protocol>;
    finish(): void;
    get_step(): number;
    get pause_b(): boolean;
    set pause_b(value_b_: boolean);
    regis_step(step_: mk_guide_step_base | mk_guide_step_base[]): void;
    run(): Promise<void>;
    set_step(step_n_: number, init_data_?: any): Promise<void>;
}

// @public (undocumented)
export namespace guide_manage_ {
    export interface event_protocol {
        break(): void;
        finish(): void;
        loading_step(): void;
        loading_step_complete(): void;
        pause(): void;
        resume(): void;
        switch(): void;
    }
    export interface init_config {
        end_step_n?: number;
        name_s?: string;
        operate_tab?: Record<string, operate_cell>;
        // (undocumented)
        step_update_callback_f(step_n: number): any;
    }
    // (undocumented)
    export interface operate_cell {
        load: () => any;
        reset?: () => any;
        unload?: () => any;
    }
}

// @public
export abstract class instance_base {
    static instance<T extends new (...args_as: any[]) => any>(this: T, ...args_as_: ConstructorParameters<T>): InstanceType<T>;
}

declare namespace language {
    export {
        mk_language_label as label,
        mk_language_texture as texture,
        mk_language_node as node
    }
}
export { language }

// @public (undocumented)
export namespace language_ {
    export abstract class base_data<CT extends data_struct> {
        constructor(init_: CT);
        data: data_struct<Exclude<keyof CT, symbol>>;
        key: {
            [k in keyof CT]: k;
        };
    }
    // Warning: (ae-forgotten-export) The symbol "_mk_language_manage" needs to be exported by the entry point mk_export.d.ts
    export type data_struct<T extends _mk_language_manage.type_type = any> = Record<T, Record<keyof typeof global_config.language.type, string>>;
    export class label_config {
        constructor(init_?: Partial<label_config>);
        args_ss?: string[];
        language: global_config.language.type;
    }
    export class label_data<CT extends data_struct> extends base_data<CT> {
        constructor(type_: string, init_: CT);
    }
    export class texture_data<CT extends data_struct> extends base_data<CT> {
        constructor(type_: string, init_: CT);
    }
}

// Warning: (ae-forgotten-export) The symbol "mk_language_manage" needs to be exported by the entry point mk_export.d.ts
//
// @public (undocumented)
export const language_manage: mk_language_manage;

// @public (undocumented)
export const log: logger;

// @public (undocumented)
export class logger extends instance_base {
    constructor(name_s_: string);
    // Warning: (ae-forgotten-export) The symbol "_mk_logger" needs to be exported by the entry point mk_export.d.ts
    static config: _mk_logger.global_config;
    // (undocumented)
    debug(...args_as_: any[]): void;
    // (undocumented)
    error(...args_as_: any[]): void;
    static limit(module_ss_: string[]): void;
    // (undocumented)
    log(...args_as_: any[]): void;
    static only(module_ss_: string[]): void;
    time_end(name_s_: string, ...args_as_: any[]): void;
    time_log(name_s_: string, ...args_as_: any[]): void;
    time_start(name_s_: string, ...args_as_: any[]): void;
    // (undocumented)
    warn(...args_as_: any[]): void;
}

// @public (undocumented)
export namespace logger_ {
    const // (undocumented)
    level: typeof _mk_logger.level;
    // (undocumented)
    export type level = _mk_logger.level;
}

// @public
abstract class mk_guide_step_base {
    describe_s?: string;
    guide_manage: guide_manage;
    init_data: any;
    abstract load(): void | Promise<void>;
    protected _next(init_data_?: any): void;
    next_step_n?: number;
    operate_ss: any[];
    operate_tab: Record<PropertyKey, any>;
    pre_load?(): void | Promise<void>;
    abstract scene_s: string;
    abstract step_n: number;
    step_update_data: any;
    unload?(): void | Promise<void>;
}

// @public (undocumented)
namespace mk_http_ {
    class config {
        constructor(init_?: Partial<config>);
        body?: Document | Blob | BufferSource | FormData | URLSearchParams | string;
        codec?: codec_base;
        header?: Record<string, string>;
        open_callback_f?: (http: XMLHttpRequest) => void;
        return_type?: XMLHttpRequestResponseType;
        timeout_n: number;
    }
}

// Warning: (ae-forgotten-export) The symbol "mk_language_base" needs to be exported by the entry point mk_export.d.ts
//
// @public (undocumented)
class mk_language_label extends mk_language_base {
    get args_ss(): string[];
    set args_ss(value_ss_: string[]);
    // (undocumented)
    protected _init_data(): void;
    // (undocumented)
    protected _init_event(state_b_: boolean): void;
    protected _reset_data(): void;
    // (undocumented)
    protected _set_type(value_: number): void;
    // (undocumented)
    protected _set_type_s(value_s_: string): void;
    // (undocumented)
    get type(): number;
    set type(value_: number);
    protected _type_s: string;
    // (undocumented)
    protected _update_content(): void;
    // (undocumented)
    protected _update_mark(): void;
}

// @public
class mk_language_node {
    clear(): void;
    init(): void;
    get language(): number;
    set language(value_n_: number);
    language_s: string;
    get node(): cc_2.Node;
    // Warning: (ae-forgotten-export) The symbol "_mk_language_node" needs to be exported by the entry point mk_export.d.ts
    node_as: _mk_language_node.node[];
}

// @public (undocumented)
class mk_language_texture extends mk_language_base {
    // (undocumented)
    protected _init_data(): void;
    // (undocumented)
    protected _init_event(state_b_: boolean): void;
    protected _reset_data(): void;
    // (undocumented)
    protected _set_type(value_: number): void;
    // (undocumented)
    protected _set_type_s(value_s_: string): void;
    // (undocumented)
    get type(): number;
    set type(value_n_: number);
    // (undocumented)
    protected _type_s: string;
    // (undocumented)
    protected _update_content(): Promise<void>;
    // (undocumented)
    protected _update_mark(): void;
}

// @public
class mk_layer extends cc_2.Component {
    get child_layer_n(): number;
    set child_layer_n(value_n_: number);
    // (undocumented)
    static config: _mk_layer.global_config;
    get init_editor(): void;
    protected _init_editor(): void;
    layer_type_n: number;
    // (undocumented)
    onLoad(): void;
}

// @public (undocumented)
namespace _mk_layer {
    interface global_config {
        layer_spacing_n: number;
        layer_type: any;
    }
}

// @public
class mk_life_cycle extends mk_layer {
    constructor(...args: any[]);
    close?(): void | Promise<void>;
    // @internal
    _close(config_?: _mk_life_cycle.close_config): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "_mk_life_cycle" needs to be exported by the entry point mk_export.d.ts
    set config(config_: _mk_life_cycle.create_config);
    create?(): void | Promise<void>;
    init(data_?: any): void | Promise<void>;
    init_data?: any;
    protected _late_close?(): void | Promise<void>;
    protected _late_open?(): void | Promise<void>;
    protected _load_task: mk_status_task<void>;
    protected get _log(): logger;
    // (undocumented)
    onLoad(): void;
    open?(): void | Promise<void>;
    // @internal
    _open(config_?: _mk_life_cycle.open_config): Promise<void>;
    get open_b(): boolean;
    protected _open_task: mk_status_task<void>;
    protected _state: _mk_life_cycle.run_state;
    get static_b(): boolean;
    protected _static_b: boolean;
}

// @public (undocumented)
abstract class mk_network_base<CT extends codec_base = codec_base> extends instance_base {
    constructor(init_?: Partial<mk_network_base_.init_config<CT>>);
    protected _addr_s: string;
    protected _cancel_reconnect(status_b_: boolean): void;
    close(): void;
    protected _close(event_: any): void;
    get codec(): CT | undefined;
    set codec(value_: CT | undefined);
    config: Readonly<mk_network_base_.init_config<CT>>;
    connect(addr_s_: string): void;
    protected _error(event_: any): void;
    // Warning: (ae-forgotten-export) The symbol "_mk_network_base" needs to be exported by the entry point mk_export.d.ts
    event: event_target<_mk_network_base.event_protocol<CT>>;
    // (undocumented)
    protected _event_restart(): void;
    protected _log: logger;
    message: _mk_network_base.message_event<CT>;
    protected _message(event_: any): Promise<void>;
    protected _open(event_: any): void;
    protected abstract _reset_socket(): void;
    // @internal
    _send(data_: Parameters<CT["encode"]>[0]): void;
    // (undocumented)
    protected _set_write_sleep_b(value_b_: boolean): void;
    protected abstract _socket: any;
    protected _start_heartbeat(): void;
    get state(): mk_network_base_.status;
    protected _state: mk_network_base_.status;
    protected _timer_reconnect(): void;
    protected _timer_send(): Promise<void>;
    protected _trigger_wait_task(data_: any): void;
    // @internal
    _wait<T, T2 = T["prototype"] extends Object ? T["prototype"] : any>(key_: T, timeout_ms_n_?: number): Promise<T2 | null> | null;
    protected _write_as: any[];
    // @internal
    protected _write_sleep2_b: boolean;
}

// @public (undocumented)
namespace mk_network_base_ {
    class init_config<CT extends codec_base = codec_base> {
        constructor(init_?: Partial<init_config<CT>>);
        codec?: CT;
        heartbeat_config?: {
            interval_ms_n?: number;
            timeout_ms_n: number;
            init_f(done_f: () => void): null | (() => any);
        };
        max_reconnect_n: number;
        parse_message_id_f(data: any): string | number;
        parse_message_sequence_f(data: any): string | number | undefined;
        reconnect_interval_ms_n: number;
        send_interval_ms_n: number;
        wait_timeout_ms_n: number;
    }
    class send_tide<CT extends codec_base = codec_base> {
        constructor(network_: mk_network_base, interval_ms_n_: number);
        send(data_: Parameters<CT["encode"]>[0]): void;
        trigger(): void;
    }
    enum status {
        closed = 3,
        closing = 2,
        connecting = 0,
        open = 1
    }
}

// @public
class mk_polygon_mask extends cc_2.Component {
    // (undocumented)
    get init_editor(): void;
    // (undocumented)
    onLoad(): void;
    get track_node(): cc_2.Node;
    set track_node(value_: cc_2.Node);
}

// @public
class mk_scene_drive extends mk_life_cycle {
    // (undocumented)
    onDestroy(): void;
    // (undocumented)
    onLoad(): Promise<void>;
}

// @public
class mk_status_task<CT = void> {
    // Warning: (ae-forgotten-export) The symbol "mk_status_task_" needs to be exported by the entry point mk_export.d.ts
    constructor(finish_b_: boolean, init_config_?: mk_status_task_.init_config<CT>);
    finish<T extends false>(finish_b_: T): void;
    finish<T extends true>(finish_b_: T, data_: CT): void;
    get finish_b(): boolean;
    task: Promise<CT>;
}

// @public
class mk_task_pipeline {
    add(task_f_: Function): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "_mk_task_pipeline" needs to be exported by the entry point mk_export.d.ts
    event: event_target<_mk_task_pipeline.event_protocol>;
    get pause_b(): boolean;
    set pause_b(value_b_: boolean);
}

// @public
class mk_touch_mask extends cc_2.Component {
    // (undocumented)
    onDisable(): void;
    // (undocumented)
    onEnable(): void;
    // (undocumented)
    onLoad(): void;
    get track_node(): cc_2.Node;
    set track_node(value_: cc_2.Node);
}

// @public
class mk_view_base extends mk_life_cycle {
    // (undocumented)
    get auto_block_input_b(): boolean;
    set auto_block_input_b(value_b_: boolean);
    // (undocumented)
    get auto_mask_b(): boolean;
    set auto_mask_b(value_b_: boolean);
    auto_release<T extends cc_2.Node | cc_2.Node[]>(args_: T): T;
    // (undocumented)
    auto_release<T extends cc_2.Asset | cc_2.Asset[]>(args_: T): T;
    // (undocumented)
    auto_release<T extends _mk_view_base.release_object_type | _mk_view_base.release_object_type[]>(args_: T): T;
    // (undocumented)
    get auto_widget_b(): boolean;
    set auto_widget_b(value_b_: boolean);
    close(config_?: Omit<ui_manage_.close_config<any>, "type" | "all_b">): void | Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "_mk_view_base" needs to be exported by the entry point mk_export.d.ts
    //
    // (undocumented)
    static config: _mk_view_base.global_config;
    set config(config_: _mk_view_base.create_config);
    data?: any;
    protected _init_editor(): void;
    // (undocumented)
    protected _late_close?(): Promise<void>;
    // (undocumented)
    open(): void | Promise<void>;
    protected _reset_data_b: boolean;
    // (undocumented)
    show_alone_b: boolean;
    get type_s(): string;
    protected _view_config: mk_view_base_.view_config;
    get wind_b(): boolean;
    set wind_b(value_b_: boolean);
    // (undocumented)
    wind_config: _mk_view_base.wind_config;
}

// @public (undocumented)
namespace mk_view_base_ {
    class view_config {
        constructor(init_?: Partial<view_config>);
        prefab_tab?: Record<string, cc_2.Prefab | string> & {
            default: cc_2.Prefab | string;
        };
        type_s: string;
    }
}

// @public
class mk_websocket<CT extends codec_base = codec_base> extends mk_network_base<CT> {
    constructor(config_?: Partial<mk_websocket_.init_config<CT>>);
    // (undocumented)
    config: Readonly<mk_websocket_.init_config<CT>>;
    protected _reset_socket(): void;
    // (undocumented)
    protected _socket: WebSocket;
}

// @public (undocumented)
namespace mk_websocket_ {
    // (undocumented)
    class init_config<CT extends codec_base = codec_base> extends mk_network_base_.init_config<CT> {
        constructor(init_?: Partial<init_config<CT>>);
        binaryType: "blob" | "arraybuffer";
        protocol_ss: string[];
    }
}

// @public
class mk_websocket_wx<CT extends codec_base = codec_base> extends mk_network_base<CT> {
    // Warning: (ae-forgotten-export) The symbol "mk_websocket_wx_" needs to be exported by the entry point mk_export.d.ts
    constructor(config_?: Partial<mk_websocket_wx_.init_config<CT>>);
    // (undocumented)
    config: Readonly<mk_websocket_wx_.init_config<CT>>;
    protected _reset_socket(): void;
    // (undocumented)
    protected _socket: wx.SocketTask;
}

declare namespace module_2 {
    export {
        mk_layer as layer,
        _mk_layer as layer_,
        mk_life_cycle as life_cycle,
        mk_scene_drive as scene_drive,
        mk_view_base as view_base,
        mk_view_base_ as view_base_
    }
}
export { module_2 as module }

// Warning: (ae-forgotten-export) The symbol "mk_monitor" needs to be exported by the entry point mk_export.d.ts
//
// @public (undocumented)
export const monitor: mk_monitor;

declare namespace network {
    export {
        mk_websocket as websocket,
        mk_websocket_ as websocket_,
        mk_websocket_wx as websocket_wx,
        _default as http,
        mk_http_ as http_,
        mk_network_base as base,
        mk_network_base_ as base_
    }
}
export { network }

// @public
export class obj_pool<CT> {
    // Warning: (ae-forgotten-export) The symbol "_mk_obj_pool" needs to be exported by the entry point mk_export.d.ts
    constructor(init_: _mk_obj_pool.config<CT>);
    clear(): Promise<void>;
    get(): Promise<CT>;
    put(obj_: any): Promise<void>;
}

// @public (undocumented)
export namespace obj_pool {
    export class sync<CT> {
        constructor(init_?: _mk_obj_pool.sync.config<CT>);
        clear(): void;
        get(): CT;
        put(obj_: CT): void;
    }
}

// @public
export class storage<CT extends Object> {
    // Warning: (ae-forgotten-export) The symbol "mk_storage_" needs to be exported by the entry point mk_export.d.ts
    constructor(init_: mk_storage_.init_config<CT>);
    static clear(): void;
    clear(): void;
    del<T extends keyof CT>(key_: T): void;
    get<T extends keyof CT, T2 extends CT[T]>(key_: T): T2;
    key: {
        [k in keyof CT]: k;
    };
    set<T extends keyof CT>(key_: T, data_: any): boolean;
}

declare namespace task {
    export {
        mk_status_task as status,
        mk_task_pipeline as pipeline
    }
}
export { task }

// Warning: (ae-forgotten-export) The symbol "mk_ui_manage" needs to be exported by the entry point mk_export.d.ts
//
// @public (undocumented)
export const ui_manage: mk_ui_manage;

// @public (undocumented)
export namespace ui_manage_ {
    export class close_config<CT extends cc_2.Constructor<mk_view_base>> {
        constructor(init_?: close_config<CT>);
        all_b?: boolean;
        destroy_b?: boolean;
        destroy_children_b?: boolean;
        type?: CT["type_s"];
    }
    export class open_config<CT extends cc_2.Constructor<mk_view_base>> {
        constructor(init_?: open_config<CT>);
        init?: CT["init_data"];
        parent?: cc_2.Node;
        type?: CT["type_s"];
    }
    export class regis_config<CT extends cc_2.Constructor<mk_view_base>> {
        constructor(init_?: Partial<regis_config<CT>>);
        load_config?: asset_.get_config<cc_2.Prefab>;
        parent: cc_2.Node | undefined;
        pool_fill_n: number;
        pool_init_fill_n: number;
        pool_max_hold_n: number;
        repeat_b: boolean;
    }
    export class regis_data<CT extends cc_2.Constructor<mk_view_base>> extends regis_config<CT> {
        constructor(init_?: Partial<regis_data<CT>>);
        // Warning: (ae-forgotten-export) The symbol "_mk_ui_manage" needs to be exported by the entry point mk_export.d.ts
        source: _mk_ui_manage.source_type<CT>;
    }
}

// (No @packageDocumentation comment for this package)

```
