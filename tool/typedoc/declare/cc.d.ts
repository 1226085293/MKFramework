declare module "cc" {
    /**
     * @en
     * Predefined constants, see [[Macro]] for detailed contents.
     * @zh
     * 预定义常量，具体内容参考 [[Macro]] 文档。
     */
    export const macro: Macro;
    /**
     * @en
     * Predefined constants, see [[Macro]] for detailed contents.
     * @zh
     * 预定义常量，具体内容参考 [[Macro]] 文档。
     */
    /**
     * @en Interface declaration for predefined constants, for usage you should be importing [[macro]] directly.
     * @zh 预定义常量的接口声明，实际使用应该直接导入 [[macro]]。
     */
    export interface Macro {
        /**
         * @en
         * The image format supported by the engine, the actual supported formats may differ in different build platforms and device types.
         * Currently contains ['.astc', '.pkm', '.pvr', '.webp', '.jpg', '.jpeg', '.bmp', '.png'].
         * @zh
         * 引擎默认支持的图片格式，实际运行时支持的格式可能在不同的构建平台和设备类型上有所差别。
         * 目前包含的格式有 ['.astc', '.pkm', '.pvr', '.webp', '.jpg', '.jpeg', '.bmp', '.png']。
         */
        SUPPORT_TEXTURE_FORMATS: string[];
        /**
         * @en Key map for keyboard event
         * @zh 键盘事件的按键值。
         * @example {@link cocos/core/platform/CCCommon/KEY.js}
         * @deprecated since v3.3 please use [[KeyCode]] instead
         */
        KEY: typeof __private._cocos_core_platform_macro__KEY;
        /**
         * @en One angle in radian, equals to PI / 180
         * @zh 弧度制中的单位角度，等同于 PI / 180
         */
        RAD: number;
        /**
         * @en One radian in angle, equals to 180 / PI
         * @zh 角度制中的单位弧度，等同于 180 / PI
         */
        DEG: number;
        /**
         * @en A maximum value of number representing infinity repeat times
         * @zh 重复执行的最大值，实际取值为数字的最大值
         */
        REPEAT_FOREVER: number;
        /**
         * @en A float value for representing a minimum error in comparison
         * @zh 用于比较时可忽略的浮点误差值
         */
        FLT_EPSILON: number;
        /**
         * @en Oriented vertically
         * @zh 竖屏朝向
         */
        ORIENTATION_PORTRAIT: number;
        /**
         * @en Oriented horizontally
         * @zh 横屏朝向
         */
        ORIENTATION_LANDSCAPE: number;
        /**
         * @en Oriented automatically
         * @zh 自动适配朝向
         */
        ORIENTATION_AUTO: number;
        /**
         * @en
         * Whether or not enabled tiled map auto culling. If you set the TiledMap skew or rotation,
         * then need to manually disable this, otherwise, the rendering will be wrong.
         * Currently not used in 3D engine
         * @zh
         * 是否开启瓦片地图的自动裁减功能。瓦片地图如果设置了 skew, rotation 的话，需要手动关闭，否则渲染会出错。
         * 在 3D 引擎中暂时无效。
         * @default true
         * @deprecated since v3.0
         */
        ENABLE_TILEDMAP_CULLING: boolean;
        /**
         * @en
         * The timeout to determine whether a touch is no longer active and should be removed.
         * The reason to add this timeout is due to an issue in X5 browser core,
         * when X5 is presented in wechat on Android, if a touch is glissed from the bottom up, and leave the page area,
         * no touch cancel event is triggered, and the touch will be considered active forever.
         * After multiple times of this action, our maximum touches number will be reached and all new touches will be ignored.
         * So this new mechanism can remove the touch that should be inactive if it's not updated during the last 5000 milliseconds.
         * Though it might remove a real touch if it's just not moving for the last 5 seconds,
         * which is not easy with the sensibility of mobile touch screen.
         * You can modify this value to have a better behavior if you find it's not enough.
         * @zh
         * 用于甄别一个触点对象是否已经失效并且可以被移除的延时时长
         * 添加这个时长的原因是 X5 内核在微信浏览器中出现的一个 bug。
         * 在这个环境下，如果用户将一个触点从底向上移出页面区域，将不会触发任何 touch cancel 或 touch end 事件，而这个触点会被永远当作停留在页面上的有效触点。
         * 重复这样操作几次之后，屏幕上的触点数量将达到我们的事件系统所支持的最高触点数量，之后所有的触摸事件都将被忽略。
         * 所以这个新的机制可以在触点在一定时间内没有任何更新的情况下视为失效触点并从事件系统中移除。
         * 当然，这也可能移除一个真实的触点，如果用户的触点真的在一定时间段内完全没有移动（这在当前手机屏幕的灵敏度下会很难）。
         * 你可以修改这个值来获得你需要的效果，默认值是 5000 毫秒。
         * @default 5000
         */
        TOUCH_TIMEOUT: number;
        /**
         * @en
         * Boolean that indicates if the canvas contains an alpha channel, default sets to false for better performance.
         * Though if you want to make your canvas background transparent and show other dom elements at the background,
         * you can set it to true before [[game.init]].
         * Web only.
         * @zh
         * 用于设置 Canvas 背景是否支持 alpha 通道，默认为 false，这样可以有更高的性能表现。
         * 如果你希望 Canvas 背景是透明的，并显示背后的其他 DOM 元素，你可以在 [[game.init]] 之前将这个值设为 true。
         * 仅支持 Web
         * @default false
         */
        ENABLE_TRANSPARENT_CANVAS: boolean;
        /**
         * @en
         * Boolean that indicates if the GL context is created with `antialias` option turned on, default value is false.
         * Set it to true could make your game graphics slightly smoother, like texture hard edges when rotated.
         * Whether to use this really depend on your game design and targeted platform,
         * device with retina display usually have good detail on graphics with or without this option,
         * you probably don't want antialias if your game style is pixel art based.
         * Also, it could have great performance impact with some browser / device using software MSAA.
         * You can set it to true before [[game.init]].
         * Only affect OpenGL ES and WebGL backend
         * @zh
         * 用于设置在创建 GL Context 时是否开启抗锯齿选项，默认值是 false。
         * 将这个选项设置为 true 会让你的游戏画面稍稍平滑一些，比如旋转硬边贴图时的锯齿。是否开启这个选项很大程度上取决于你的游戏和面向的平台。
         * 在大多数拥有 retina 级别屏幕的设备上用户往往无法区分这个选项带来的变化；如果你的游戏选择像素艺术风格，你也多半不会想开启这个选项。
         * 同时，在少部分使用软件级别抗锯齿算法的设备或浏览器上，这个选项会对性能产生比较大的影响。
         * 你可以在 [[game.init]] 之前设置这个值，否则它不会生效。
         * 仅影响 WebGL 后端
         * @default true
         */
        ENABLE_WEBGL_ANTIALIAS: boolean;
        /**
         * @en
         * Used to set FXAA post-processing anti-aliasing, the default value is false.
         * @zh
         * 用于开启 FXAA 后处理抗锯齿, 默认值为 false。
         * @default false
         */
        ENABLE_ANTIALIAS_FXAA: boolean;
        /**
         * @en
         * Used to set bloom, the default value is false.
         * @zh
         * 用于开启 bloom, 默认值为 false。
         * @default false
         */
        ENABLE_BLOOM: boolean;
        /**
         * @en
         * Whether to clear the original image cache after uploaded a texture to GPU.
         * If cleared, [Dynamic Atlas](https://docs.cocos.com/creator/manual/en/advanced-topics/dynamic-atlas.html) will not be supported.
         * Normally you don't need to enable this option on the web platform, because Image object doesn't consume too much memory.
         * But on Wechat Game platform, the current version cache decoded data in Image object, which has high memory usage.
         * So we enabled this option by default on Wechat, so that we can release Image cache immediately after uploaded to GPU.
         * Currently not useful in 3D engine
         * @zh
         * 是否在将贴图上传至 GPU 之后删除原始图片缓存，删除之后图片将无法进行 [动态合图](https://docs.cocos.com/creator/manual/zh/advanced-topics/dynamic-atlas.html)。
         * 在 Web 平台，你通常不需要开启这个选项，因为在 Web 平台 Image 对象所占用的内存很小。
         * 但是在微信小游戏平台的当前版本，Image 对象会缓存解码后的图片数据，它所占用的内存空间很大。
         * 所以我们在微信平台默认开启了这个选项，这样我们就可以在上传 GL 贴图之后立即释放 Image 对象的内存，避免过高的内存占用。
         * 在 3D 引擎中暂时无效。
         * @default false
         */
        CLEANUP_IMAGE_CACHE: boolean;
        /**
         * @en
         * Whether to enable multi-touch.
         * @zh
         * 是否开启多点触摸
         * @default true
         */
        ENABLE_MULTI_TOUCH: boolean;
        /**
         * @en
         * The maximum size of the canvas pool used by Label, please adjust according to the number of label component in the same scene of the project
         * @zh
         * Label 使用的 canvas pool 的最大大小，请根据项目同场景的 label 数量进行调整
         * @default 20
         */
        MAX_LABEL_CANVAS_POOL_SIZE: number;
        /**
         * @en
         * Boolean that indicates if enable highp precision data in structure with fragment shader.
         * Enable this option will make the variables defined by the HIGHP_VALUE_STRUCT_DEFINE macro in the shader more accurate, such as position.
         * Enable this option can avoid some distorted lighting effects. That depends on whether your game has abnormal lighting effects on this platform.
         * There will be a slight performance loss if enable this option, but the impact is not significant.
         * Only affect WebGL backend
         * @zh
         * 用于设置是否在片元着色器中使用结构体的时候，允许其中的数据使用highp精度
         * 将这个选项设置为 true 会让shader中使用HIGHP_VALUE_STRUCT_DEFINE宏定义的变量精度更高，比如位置信息等，避免出现一些失真的光照效果。是否开启这个选项很大程度上取决于你的游戏在此平台上是否出现了异常的表现。
         * 开启后会有轻微的性能损失，但影响不大。
         * 仅影响 WebGL 后端
         * @default false
         */
        ENABLE_WEBGL_HIGHP_STRUCT_VALUES: boolean;
        /**
         * @zh Batcher2D 中内存增量的大小（KB）
         * 这个值决定了当场景中存在的 2d 渲染组件的顶点数量超过当前 batcher2D 中可容纳的顶点数量时，内存扩充的增加量
         * 这个值越大，共用同一个 meshBuffer 的 2d 渲染组件数量会更多，但每次扩充所占用的内存也会更大
         * 默认值在标准格式（[[VertexFormat.vfmtPosUvColor]]）下可容纳 4096 个顶点（4096*9*4/1024），你可以增加容量来提升每个批次可容纳的元素数量
         * @en The MeshBuffer chunk size in Batcher2D (KB)
         * This value determines the increase in memory expansion,
         * when the number of vertices of 2d rendering components present in the scene exceeds the number of vertices,
         * that can be accommodated in the current batcher2D.
         * The larger this value is, the more 2d rendering components will share the same meshBuffer, but the more memory will be used for each expansion
         * The default size can contain 4096 standard vertex ([[VertexFormat.vfmtPosUvColor]]) in one buffer,
         * you can user larger buffer size to increase the elements count per 2d draw batch.
         * @default 144 KB
         */
        BATCHER2D_MEM_INCREMENT: number;
        /**
         * @zh 自定义渲染管线的名字（实验性）
         * 引擎会根据名字创建对应的渲染管线（仅限Web平台）。如果名字为空，则不启用自定义渲染管线。
         * 目前仅支持'Forward', 'Deferred'两种。
         * @en The name of custom rendering pipeline (experimental)
         * Engine will use the name to create the custom pipeline (Web only). If the name is empty, custom pipeline will be disabled.
         * Currently only 'Forward' and 'Deferred' are supported.
         */
        CUSTOM_PIPELINE_NAME: string;
        /**
         * @internal
         */
        init(): void;
    }
    export function murmurhash2_32_gc(input: string | Uint8Array, seed: number): number;
    export class MeshBuffer {
        get attributes(): gfx.Attribute[];
        get vertexFormatBytes(): number;
        protected _byteOffset: number;
        get byteOffset(): number;
        set byteOffset(val: number);
        protected _vertexOffset: number;
        get vertexOffset(): number;
        set vertexOffset(val: number);
        protected _indexOffset: number;
        get indexOffset(): number;
        set indexOffset(val: number);
        protected _dirty: boolean;
        get dirty(): boolean;
        set dirty(val: boolean);
        protected _floatsPerVertex: number;
        get floatsPerVertex(): number;
        set floatsPerVertex(val: number);
        protected _vData: Float32Array;
        get vData(): Float32Array;
        set vData(val: Float32Array);
        protected _iData: Uint16Array;
        get iData(): Uint16Array;
        set iData(val: Uint16Array);
        protected _nativeObj: __private._cocos_2d_renderer_native_2d__NativeUIMeshBuffer;
        get nativeObj(): __private._cocos_2d_renderer_native_2d__NativeUIMeshBuffer;
        protected _sharedBuffer: Uint32Array;
        get sharedBuffer(): Uint32Array;
        initSharedBuffer(): void;
        syncSharedBufferToNative(): void;
        constructor();
        initialize(device: gfx.Device, attrs: gfx.Attribute[], vFloatCount: number, iCount: number): void;
        reset(): void;
        destroy(): void;
        setDirty(): void;
        /**
         * @deprecated since v3.4.0, please use BufferAccessor's request
         * @see [[BufferAccessor.request]]
         */
        request(vertexCount: number, indexCount: number): boolean;
        requireFreeIA(device: gfx.Device): gfx.InputAssembler;
        recycleIA(ia: gfx.InputAssembler): void;
        checkCapacity(vertexCount: number, indexCount: number): boolean;
        uploadBuffers(): void;
    }
    export class StencilManager {
        static sharedManager: StencilManager | null;
        get stage(): __private._cocos_2d_renderer_stencil_manager__Stage;
        set stage(val: __private._cocos_2d_renderer_stencil_manager__Stage);
        get pattern(): {
            stencilTest: boolean;
            func: gfx.ComparisonFunc;
            stencilMask: number;
            writeMask: number;
            failOp: gfx.StencilOp;
            zFailOp: gfx.StencilOp;
            passOp: gfx.StencilOp;
            ref: number;
        };
        pushMask(mask: any): void;
        clear(comp: UIRenderer | UIMeshRenderer): __private._cocos_2d_renderer_stencil_manager__Stage.CLEAR | __private._cocos_2d_renderer_stencil_manager__Stage.CLEAR_INVERTED;
        enableMask(): void;
        exitMask(): void;
        getWriteMask(): number;
        getExitWriteMask(): number;
        getStencilRef(): number;
        getMaskStackSize(): number;
        reset(): void;
        destroy(): void;
        getStencilStage(stage: __private._cocos_2d_renderer_stencil_manager__Stage, mat?: Material): gfx.DepthStencilState;
        getStencilHash(stage: __private._cocos_2d_renderer_stencil_manager__Stage): number;
    }
    export class CanvasPool {
        static getInstance(): CanvasPool;
        pool: __private._cocos_2d_assembler_label_font_utils__ISharedLabelData[];
        get(): __private._cocos_2d_assembler_label_font_utils__ISharedLabelData;
        put(canvas: __private._cocos_2d_assembler_label_font_utils__ISharedLabelData): void;
    }
    export const spriteAssembler: IAssemblerManager;
    export const labelAssembler: IAssemblerManager;
    export const graphicsAssembler: IAssemblerManager;
    export function earcut(datas: number[], holeIndices: number[] | null, dim: number): number[];
    /**
     * @en
     * Class for sprite atlas handling.
     * @zh
     * 精灵图集资源类。
     */
    export class SpriteAtlas extends Asset {
        spriteFrames: __private._cocos_2d_assets_sprite_atlas__ISpriteFrameList;
        /**
         * @en Get the [[Texture2D]] asset of the atlas.
         * @zh 获取精灵图集的贴图。请注意，由于结构调整优化，在 v1.1 版本之前，此函数的返回值为 imageAsset，在 v1.1 版本之后修正为 texture，想要获取 imageAsset 可使用 getTexture().image 获取
         * @returns The texture2d asset
         */
        getTexture(): __private._cocos_core_assets_texture_base__TextureBase | null;
        /**
         * @en Gets the [[SpriteFrame]] correspond to the given key in sprite atlas.
         * @zh 根据键值获取精灵。
         *
         * @param key The SpriteFrame name
         * @returns The SpriteFrame asset
         */
        getSpriteFrame(key: string): SpriteFrame | null;
        /**
         * @en Returns all sprite frames in the sprite atlas.
         * @zh 获取精灵图集所有精灵。
         * @returns All sprite frames
         */
        getSpriteFrames(): (SpriteFrame | null)[];
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _serialize(ctxForExporting: any): any;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _deserialize(serializeData: any, handle: any): void;
    }
    /**
     * @en Class for TTFFont asset.
     * @zh TTF 字体资源类。
     */
    export class TTFFont extends Font {
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _fontFamily: string | null;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        get _nativeAsset(): string | null;
        set _nativeAsset(value: string | null);
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        get _nativeDep(): {
            uuid: string;
            __nativeName__: string;
            ext: string;
            __isNative__: boolean;
        };
        initDefault(uuid?: string): void;
    }
    /**
     * @en Class for LabelAtlas handling.
     * @zh 艺术数字字体资源类。
     *
     */
    export class LabelAtlas extends BitmapFont {
    }
    /**
     * @en Class for BitmapFont handling.
     * @zh 位图字体资源类。
     */
    export class BitmapFont extends Font {
        fntDataStr: string;
        /**
         * @en [[SpriteFrame]] of the bitmap font
         * @zh 位图字体所使用的精灵。
         */
        spriteFrame: SpriteFrame | null;
        /**
         * @en The font size
         * @zh 文字尺寸。
         */
        fontSize: number;
        /**
         * @en Font configuration
         * @zh 字体配置。
         */
        fntConfig: __private._cocos_2d_assets_bitmap_font__IConfig | null;
        fontDefDictionary: __private._cocos_2d_assets_bitmap_font__FontAtlas;
        onLoaded(): void;
    }
    /**
     * @en Class for Font handling.
     * @zh 字体资源类。
     */
    export class Font extends Asset {
    }
    export interface IUV {
        u: number;
        v: number;
    }
    /**
     * @en
     * A `SpriteFrame` support several types
     *  1. Rectangle sprite frame
     *  2. Sliced 9 sprite frame
     *  3. Mesh sprite frame
     * It mainly contains:<br/>
     *  - texture: A `TextureBase` that will be used by render process<br/>
     *  - rectangle: A rectangle of the texture
     *  - Sliced 9 border insets: The distance of each side from the internal rect to the sprite frame rect
     *  - vertices: Vertex list for the mesh type sprite frame
     *  - uv: The quad uv
     *  - uvSliced: The sliced 9 uv
     *
     * @zh
     * 精灵帧资源。
     * 一个 SpriteFrame 支持多种类型
     *  1. 矩形精灵帧
     *  2. 九宫格精灵帧
     *  3. 网格精灵帧
     * 它主要包含下列数据：<br/>
     *  - 纹理：会被渲染流程使用的 `TextureBase` 资源。<br/>
     *  - 矩形：在纹理中的矩形区域。
     *  - 九宫格信息：九宫格的内部矩形四个边距离 SpriteFrame 外部矩形的距离
     *  - 网格信息：网格类型精灵帧的所有顶点列表
     *  - uv: 四边形 UV
     *  - uvSliced: 九宫格 UV
     * 可通过 `SpriteFrame` 获取该组件。
     *
     * @example
     * ```ts
     * import { resources } from 'cc';
     * // First way to use a SpriteFrame
     * const url = "assets/PurpleMonster/icon/spriteFrame";
     * resources.load(url, (err, spriteFrame) => {
     *   const node = new Node("New Sprite");
     *   const sprite = node.addComponent(Sprite);
     *   sprite.spriteFrame = spriteFrame;
     *   node.parent = self.node;
     * });
     *
     * // Second way to use a SpriteFrame
     * const self = this;
     * const url = "test_assets/PurpleMonster";
     * resources.load(url, (err, imageAsset) => {
     *  if(err){
     *    return;
     *  }
     *
     *  const node = new Node("New Sprite");
     *  const sprite = node.addComponent(Sprite);
     *  const spriteFrame = new SpriteFrame();
     *  const tex = imageAsset._texture;
     *  spriteFrame.texture = tex;
     *  sprite.spriteFrame = spriteFrame;
     *  node.parent = self.node;
     * });
     *
     * // Third way to use a SpriteFrame
     * const self = this;
     * const cameraComp = this.getComponent(Camera);
     * const renderTexture = new RenderTexture();
     * renderTexture.reset({
     *   width: 512,
     *   height: 512,
     *   depthStencilFormat: RenderTexture.DepthStencilFormat.DEPTH_24_STENCIL_8
     * });
     *
     * cameraComp.targetTexture = renderTexture;
     * const spriteFrame = new SpriteFrame();
     * spriteFrame.texture = renderTexture;
     * ```
     */
    export class SpriteFrame extends Asset {
        /**
         * @en Create a SpriteFrame object by an image asset or an native image asset
         * @zh 通过 Image 资源或者平台相关 Image 对象创建一个 SpriteFrame 对象
         * @param imageSourceOrImageAsset ImageAsset or ImageSource, ImageSource support HTMLCanvasElement HTMLImageElement IMemoryImageSource
         */
        static createWithImage(imageSourceOrImageAsset: __private._cocos_core_assets_image_asset__ImageSource | ImageAsset): SpriteFrame;
        /**
         * @en uv update event
         * @zh uv 更新事件
         */
        static EVENT_UV_UPDATED: string;
        static MeshType: typeof __private._cocos_2d_assets_sprite_frame__MeshType;
        /**
         * @en Top border distance of sliced 9 rect.
         * @zh 九宫格内部矩形顶部边框距离 SpriteFrame 矩形的距离。
         */
        get insetTop(): number;
        set insetTop(value: number);
        /**
         * @en Bottom border distance of sliced 9 rect.
         * @zh 九宫格内部矩形底部边框距离 SpriteFrame 矩形的距离。
         */
        get insetBottom(): number;
        set insetBottom(value: number);
        /**
         * @en Left border distance of sliced 9 rect.
         * @zh 九宫格内部矩形左边框距离 SpriteFrame 矩形的距离。
         */
        get insetLeft(): number;
        set insetLeft(value: number);
        /**
         * @en Right border distance of sliced 9 rect.
         * @zh 九宫格内部矩形右边框距离 SpriteFrame 矩形的距离。
         */
        get insetRight(): number;
        set insetRight(value: number);
        /**
         * @en Returns the rect of the sprite frame in the texture.
         * If it's an atlas texture, a transparent pixel area is proposed for the actual mapping of the current texture.
         * @zh 获取 SpriteFrame 的纹理矩形区域。
         * 如果是一个 atlas 的贴图，则为当前贴图的实际剔除透明像素区域。
         */
        get rect(): math.Rect;
        set rect(value: math.Rect);
        /**
         * @en The original size before trimmed.
         * @zh 修剪前的原始大小。
         */
        get originalSize(): math.Size;
        set originalSize(value: math.Size);
        /**
         * @en The offset of the sprite frame center.
         * Sprite frame in an atlas texture could be trimmed for clipping the transparent pixels, so the trimmed rect is smaller than the original one,
         * the offset defines the distance from the original center to the trimmed center.
         * @zh 精灵帧偏移量。
         * 在图集中的精灵帧可能会被剔除透明像素以获得更高的空间利用李，剔除后的矩形尺寸比剪裁前更小，偏移量指的是从原始矩形的中心到剪裁后的矩形中心的距离。
         */
        get offset(): math.Vec2;
        set offset(value: math.Vec2);
        /**
         * @en Whether the content of sprite frame is rotated.
         * @zh 是否旋转。
         */
        get rotated(): boolean;
        set rotated(rotated: boolean);
        /**
         * @en The texture of the sprite frame, could be `TextureBase`
         * @zh 贴图对象资源，可以是 `TextureBase` 类型
         */
        get texture(): __private._cocos_core_assets_texture_base__TextureBase;
        set texture(value: __private._cocos_core_assets_texture_base__TextureBase);
        /**
         * @en The uuid of the atlas asset, if exist
         * @zh 图集资源的 uuid。
         */
        get atlasUuid(): string;
        set atlasUuid(value: string);
        /**
         * @en The pixel width of the sprite frame
         * @zh 精灵帧的像素宽度
         */
        get width(): number;
        /**
         * @en The pixel height of the sprite frame
         * @zh 精灵帧的像素高度
         */
        get height(): number;
        set _textureSource(value: __private._cocos_core_assets_texture_base__TextureBase);
        /**
         * @en Whether flip the uv in X direction
         * @zh 延 X 轴方向, 翻转 UV
         */
        get flipUVX(): boolean;
        set flipUVX(value: boolean);
        /**
         * @en Whether flip the uv in Y direction
         * @zh 延 Y 轴方向, 翻转 UV
         */
        get flipUVY(): boolean;
        set flipUVY(value: boolean);
        get packable(): boolean;
        set packable(value: boolean);
        get original(): {
            _texture: __private._cocos_core_assets_texture_base__TextureBase;
            _x: number;
            _y: number;
        } | null;
        /**
         * @en Number of pixels corresponding to unit size in world space (pixels per meter)
         * @zh 世界空间中的单位大小对应的像素数量（像素每米）
         */
        get pixelsToUnit(): number;
        /**
         * @en Local origin position when generating the mesh
         * @zh 生成 mesh 时本地坐标原点位置
         */
        get pivot(): math.Vec2;
        /**
         * @en mesh information, you should call the [[ensureMeshData]] function before using it
         * @zh mesh 信息，你应该在使用它之前调用 [[ensureMeshData]] 函数来确保其可用
         */
        get mesh(): Mesh | null;
        /**
         * @internal
         */
        get trimmedBorder(): math.Vec4;
        /**
         * @en Vertex list for the mesh type sprite frame
         * @zh 网格类型精灵帧的所有顶点列表
         */
        vertices: __private._cocos_2d_assets_sprite_frame__IVertices | null;
        /**
         * @en UV for quad vertices
         * @zh 矩形的顶点 UV
         */
        uv: number[];
        unbiasUV: number[];
        /**
         * @en UV for sliced 9 vertices
         * @zh 九宫格的顶点 UV。
         */
        uvSliced: IUV[];
        protected _rect: math.Rect;
        protected _trimmedBorder: math.Vec4;
        protected _offset: math.Vec2;
        protected _originalSize: math.Size;
        protected _rotated: boolean;
        protected _capInsets: number[];
        protected _atlasUuid: string;
        protected _texture: __private._cocos_core_assets_texture_base__TextureBase;
        protected _isFlipUVY: boolean;
        protected _isFlipUVX: boolean;
        protected _original: {
            _texture: __private._cocos_core_assets_texture_base__TextureBase;
            _x: number;
            _y: number;
        } | null;
        protected _packable: boolean;
        protected _pixelsToUnit: number;
        protected _pivot: math.Vec2;
        protected _meshType: __private._cocos_2d_assets_sprite_frame__MeshType;
        protected _extrude: number;
        protected _customOutLine: never[];
        protected _mesh: Mesh | null;
        protected _minPos: math.Vec3;
        protected _maxPos: math.Vec3;
        constructor();
        /**
         * @en
         * Returns whether the texture have been loaded.
         * @zh
         * 返回是否已加载精灵帧。
         *
         * @deprecated since v3.3
         */
        textureLoaded(): boolean;
        /**
         * @en
         * Returns whether the sprite frame is rotated in the texture.
         * @zh
         * 获取 SpriteFrame 是否旋转。
         * @deprecated since v1.2, please use [[rotated]] instead
         */
        isRotated(): boolean;
        /**
         * @en
         * Set whether the sprite frame is rotated in the texture.
         * @zh
         * 设置 SpriteFrame 是否旋转。
         * @param value
         * @deprecated since v1.2, please use [[rotated]] instead
         */
        setRotated(rotated: boolean): void;
        /**
         * @en Returns the rect of the sprite frame in the texture.
         * If it's an atlas texture, a transparent pixel area is proposed for the actual mapping of the current texture.
         * @zh 获取 SpriteFrame 的纹理矩形区域。
         * 如果是一个 atlas 的贴图，则为当前贴图的实际剔除透明像素区域。
         * @deprecated since v1.2, please use [[rect]]
         */
        getRect(out?: math.Rect): math.Rect;
        /**
         * @en Sets the rect of the sprite frame in the texture.
         * @zh 设置 SpriteFrame 的纹理矩形区域。
         * @deprecated since v1.2, please use [[rect]]
         */
        setRect(rect: math.Rect): void;
        /**
         * @en Returns the original size before trimmed.
         * @zh 获取修剪前的原始大小。
         * @deprecated since v1.2, please use [[originalSize]]
         */
        getOriginalSize(out?: math.Size): math.Size;
        /**
         * @en Sets the original size before trimmed.
         * @zh 设置修剪前的原始大小。
         * @param size The new original size
         * @deprecated since v1.2, please use [[originalSize]]
         */
        setOriginalSize(size: math.Size): void;
        /**
         * @en Returns the offset of the frame
         * @zh 获取偏移量。
         * @param out The output offset object
         * @deprecated since v1.2, please use [[offset]]
         */
        getOffset(out?: math.Vec2): math.Vec2;
        /**
         * @en Sets the offset of the frame
         * @zh 设置偏移量。
         * @param offset The new offset
         * @deprecated since v1.2, please use [[offset]]
         */
        setOffset(offset: math.Vec2): void;
        /**
         * @en Gets the related GFX [[gfx.Texture]] resource
         * @zh 获取渲染贴图的 GFX 资源
         */
        getGFXTexture(): gfx.Texture | null;
        /**
         * @en Gets the sampler resource of its texture
         * @zh 贴图资源的采样器
         */
        getGFXSampler(): gfx.Sampler;
        /**
         * @en Gets the hash of its texture
         * @zh 贴图资源的哈希值
         */
        getHash(): number;
        /**
         * @en Gets the sampler hash of its texture
         * @zh 贴图资源的采样器哈希值
         */
        getSamplerInfo(): Readonly<gfx.SamplerInfo>;
        /**
         * @en Resets the sprite frame data
         * @zh 重置 SpriteFrame 数据。
         * @param info SpriteFrame initialization information
         */
        reset(info?: __private._cocos_2d_assets_sprite_frame__ISpriteFrameInitInfo, clearData?: boolean): void;
        /**
         * @en Check whether the rect of the sprite frame is out of the texture boundary
         * @zh 判断精灵计算的矩形区域是否越界。
         * @param texture
         */
        checkRect(texture: __private._cocos_core_assets_texture_base__TextureBase): boolean;
        /**
         * @en Make sure the mesh is available, you should call it before using the mesh
         * @zh 确保 mesh 可用，你应该在使用 mesh 之前调用它
         */
        ensureMeshData(): void;
        destroy(): boolean;
        /**
         * Calculate UV for sliced
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _calculateSlicedUV(): void;
        /**
         * Calculate UV
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _calculateUV(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _setDynamicAtlasFrame(frame: any): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _resetDynamicAtlasFrame(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _checkPackable(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _serialize(ctxForExporting: any): any;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _deserialize(serializeData: any, handle: any): void;
        clone(): SpriteFrame;
        protected _refreshTexture(texture: __private._cocos_core_assets_texture_base__TextureBase): void;
        onLoaded(): void;
        initDefault(uuid?: string): void;
        validate(): boolean;
        protected _initVertices(): void;
        protected _updateMeshVertices(): void;
        protected _createMesh(): void;
        protected _updateMesh(): void;
    }
    /**
     * @en
     * The root node of UI.
     * Provide an aligned window for all child nodes, also provides ease of setting screen adaptation policy interfaces from the editor.
     * Line-of-sight range is -999 to 1000.
     *
     * @zh
     * 作为 UI 根节点，为所有子节点提供对齐视窗，另外提供屏幕适配策略接口，方便从编辑器设置。
     * 注：由于本节点的尺寸会跟随屏幕拉伸，所以 anchorPoint 只支持 (0.5, 0.5)，否则适配不同屏幕时坐标会有偏差。
     * UI 的视距范围是 -999 ～ 1000.
     */
    export class Canvas extends RenderRoot2D {
        /**
         * @en
         * The render mode of Canvas.
         * When you choose the mode of INTERSPERSE, You can specify the rendering order of the Canvas with the camera in the scene.
         * When you choose the mode of OVERLAY, the builtin camera of Canvas will render after all scene cameras are rendered.
         * NOTE: The cameras in the scene (including the Canvas built-in camera) must have a ClearFlag selection of SOLID_COLOR,
         * otherwise a splash screen may appear on the mobile device.
         *
         * @zh
         * Canvas 渲染模式。
         * intersperse 下可以指定 Canvas 与场景中的相机的渲染顺序，overlay 下 Canvas 会在所有场景相机渲染完成后渲染。
         * 注意：场景里的相机（包括 Canvas 内置的相机）必须有一个的 ClearFlag 选择 SOLID_COLOR，否则在移动端可能会出现闪屏。
         *
         * @deprecated since v3.0, please use [[Camera.priority]] to control overlapping between cameras.
         */
        get renderMode(): number;
        set renderMode(val: number);
        get cameraComponent(): Camera | null;
        set cameraComponent(value: Camera | null);
        get alignCanvasWithScreen(): boolean;
        set alignCanvasWithScreen(value: boolean);
        protected _cameraComponent: Camera | null;
        protected _alignCanvasWithScreen: boolean;
        protected _thisOnCameraResized: () => void;
        protected _fitDesignResolution: (() => void) | undefined;
        constructor();
        __preload(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        protected _onResizeCamera(): void;
    }
    /**
     * @en Legacy 2D base class for rendering component, please use [[UIRenderer]] instead.
     * This component will setup NodeUIProperties.uiComp in its owner [[Node]]
     * @zh 旧的 2D 渲染组件基类，请使用 [[UIRenderer]] 替代。
     * 这个组件会设置 [[Node]] 上的 NodeUIProperties.uiComp。
     * @deprecated since v3.4.1
     */
    export class UIComponent extends Component {
        protected _lastParent: Node | null;
        __preload(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        /**
         * @en Post render data submission procedure, it's executed after assembler updated for all children.
         * It may assemble some extra render data to the geometry buffers, or it may only change some render states.
         * Don't call it unless you know what you are doing.
         * @zh 后置渲染数据组装程序，它会在所有子节点的渲染数据组装完成后被调用。
         * 它可能会组装额外的渲染数据到顶点数据缓冲区，也可能只是重置一些渲染状态。
         * 注意：不要手动调用该函数，除非你理解整个流程。
         */
        postUpdateAssembler(render: __private._cocos_2d_renderer_i_batcher__IBatcher): void;
        markForUpdateRenderData(enable?: boolean): void;
        stencilStage: __private._cocos_2d_renderer_stencil_manager__Stage;
        setNodeDirty(): void;
        setTextureDirty(): void;
    }
    /**
     * @en
     * The shader property type of the material after instantiation.
     *
     * @zh
     * 实例后的材质的着色器属性类型。
     */
    export enum InstanceMaterialType {
        /**
         * @en
         * The shader only has color properties.
         *
         * @zh
         * 着色器只带颜色属性。
         */
        ADD_COLOR = 0,
        /**
         * @en
         * The shader has color and texture properties.
         *
         * @zh
         * 着色器带颜色和贴图属性。
         */
        ADD_COLOR_AND_TEXTURE = 1,
        /**
         * @en
         * The shader has color and texture properties and uses grayscale mode.
         *
         * @zh
         * 着色器带颜色和贴图属性,并使用灰度模式。
         */
        GRAYSCALE = 2,
        /**
         * @en
         * The shader has color and texture properties and uses embedded alpha mode.
         *
         * @zh
         * 着色器带颜色和贴图属性,并使用透明通道分离贴图。
         */
        USE_ALPHA_SEPARATED = 3,
        /**
         * @en
         * The shader has color and texture properties and uses embedded alpha and grayscale mode.
         *
         * @zh
         * 着色器带颜色和贴图属性,并使用灰度模式。
         */
        USE_ALPHA_SEPARATED_AND_GRAY = 4
    }
    /**
     * @en Base class for UI components which supports rendering features.
     * This component will setup NodeUIProperties.uiComp in its owner [[Node]]
     *
     * @zh 所有支持渲染的 UI 组件的基类。
     * 这个组件会设置 [[Node]] 上的 NodeUIProperties.uiComp。
     */
    export class UIRenderer extends Renderer {
        /**
         * @en The blend factor enums
         * @zh 混合模式枚举类型
         * @see [[gfx.BlendFactor]]
         */
        static BlendState: typeof gfx.BlendFactor;
        /**
         * @en The render data assembler
         * @zh 渲染数据组装器
         */
        static Assembler: IAssemblerManager;
        /**
         * @en The post render data assembler
         * @zh 后置渲染数据组装器
         */
        static PostAssembler: IAssemblerManager | null;
        constructor();
        get sharedMaterials(): (Material | null)[];
        set sharedMaterials(val: (Material | null)[]);
        /**
         * @en The customMaterial
         * @zh 用户自定材质
         */
        get customMaterial(): Material | null;
        set customMaterial(val: Material | null);
        /**
         * @en Main color for rendering, it normally multiplies with texture color.
         * @zh 渲染颜色，一般情况下会和贴图颜色相乘。
         */
        get color(): Readonly<math.Color>;
        set color(value: Readonly<math.Color>);
        protected _renderData: RenderData | null;
        /**
         * @internal
         */
        get renderData(): RenderData | null;
        /**
         * @internal
         */
        get useVertexOpacity(): boolean;
        /**
         * @internal
         * @en The component stencil stage (please do not any modification directly on this object)
         * @zh 组件模板缓冲状态 (注意：请不要直接修改它的值)
         */
        get stencilStage(): __private._cocos_2d_renderer_stencil_manager__Stage;
        set stencilStage(val: __private._cocos_2d_renderer_stencil_manager__Stage);
        protected _materials: (Material | null)[];
        protected _customMaterial: Material | null;
        protected _srcBlendFactor: gfx.BlendFactor;
        protected _dstBlendFactor: gfx.BlendFactor;
        protected _color: math.Color;
        protected _stencilStage: __private._cocos_2d_renderer_stencil_manager__Stage;
        protected _assembler: IAssembler | null;
        protected _postAssembler: IAssembler | null;
        protected _renderDataFlag: boolean;
        protected _renderFlag: boolean;
        protected _renderEntity: __private._cocos_2d_renderer_render_entity__RenderEntity;
        protected _instanceMaterialType: number;
        protected _srcBlendFactorCache: gfx.BlendFactor;
        protected _dstBlendFactorCache: gfx.BlendFactor;
        /**
         * @internal
         */
        _dirtyVersion: number;
        /**
         * @internal
         */
        _internalId: number;
        get batcher(): UI;
        get renderEntity(): __private._cocos_2d_renderer_render_entity__RenderEntity;
        /**
         * @en Marks for calculating opacity per vertex
         * @zh 标记组件是否逐顶点计算透明度
         */
        protected _useVertexOpacity: boolean;
        protected _lastParent: Node | null;
        onLoad(): void;
        __preload(): void;
        onEnable(): void;
        onRestore(): void;
        onDisable(): void;
        onDestroy(): void;
        /**
         * @en Marks the render data of the current component as modified so that the render data is recalculated.
         * @zh 标记当前组件的渲染数据为已修改状态，这样渲染数据才会重新计算。
         * @param enable Marked necessary to update or not
         */
        markForUpdateRenderData(enable?: boolean): void;
        /**
         * @en Request new render data object.
         * @zh 请求新的渲染数据对象。
         * @return The new render data
         */
        requestRenderData(drawInfoType?: __private._cocos_2d_renderer_render_draw_info__RenderDrawInfoType): RenderData;
        /**
         * @en Destroy current render data.
         * @zh 销毁当前渲染数据。
         */
        destroyRenderData(): void;
        updateRenderer(): void;
        fillBuffers(render: __private._cocos_2d_renderer_i_batcher__IBatcher): void;
        /**
         * @en Post render data submission procedure, it's executed after assembler updated for all children.
         * It may assemble some extra render data to the geometry buffers, or it may only change some render states.
         * Don't call it unless you know what you are doing.
         * @zh 后置渲染数据组装程序，它会在所有子节点的渲染数据组装完成后被调用。
         * 它可能会组装额外的渲染数据到顶点数据缓冲区，也可能只是重置一些渲染状态。
         * 注意：不要手动调用该函数，除非你理解整个流程。
         */
        postUpdateAssembler(render: __private._cocos_2d_renderer_i_batcher__IBatcher): void;
        protected _render(render: __private._cocos_2d_renderer_i_batcher__IBatcher): void;
        protected _postRender(render: __private._cocos_2d_renderer_i_batcher__IBatcher): void;
        protected _canRender(): boolean;
        protected _postCanRender(): void;
        protected updateMaterial(): void;
        protected _updateColor(): void;
        static setEntityColorDirtyRecursively(node: Node, dirty: boolean): void;
        setEntityColor(color: math.Color): void;
        setEntityOpacity(opacity: number): void;
        setEntityEnabled(enabled: boolean): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _updateBlendFunc(): void;
        protected _nodeStateChange(transformType: TransformBit): void;
        protected _colorDirty(): void;
        protected _onMaterialModified(idx: number, material: Material | null): void;
        protected _updateBuiltinMaterial(): Material;
        protected _flushAssembler?(): void;
        setNodeDirty(): void;
        setTextureDirty(): void;
        protected createRenderEntity(): __private._cocos_2d_renderer_render_entity__RenderEntity;
    }
    /**
     * @en
     * The component of transform in UI.
     *
     * @zh
     * UI 变换组件。
     */
    export class UITransform extends Component {
        /**
         * @en
         * Size of the UI node.
         *
         * @zh
         * 内容尺寸。
         */
        get contentSize(): Readonly<math.Size>;
        set contentSize(value: Readonly<math.Size>);
        get width(): number;
        set width(value: number);
        get height(): number;
        set height(value: number);
        /**
         * @en
         * Anchor point of the UI node.
         *
         * @zh
         * 锚点位置。
         */
        get anchorPoint(): Readonly<math.Vec2>;
        set anchorPoint(value: Readonly<math.Vec2>);
        get anchorX(): number;
        set anchorX(value: number);
        get anchorY(): number;
        set anchorY(value: number);
        /**
         * @en
         * Render sequence.
         * Note: UI rendering is only about priority.
         *
         * @zh
         * 渲染先后顺序，按照广度渲染排列，按同级节点下进行一次排列。
         * @deprecated
         */
        get priority(): number;
        set priority(value: number);
        protected _priority: number;
        /**
         * @en Get the visibility bit-mask of the rendering camera
         * @zh 查找被渲染相机的可见性掩码。
         * @deprecated since v3.0
         */
        get visibility(): number;
        /**
         * @en Get the priority of the rendering camera
         * @zh 查找被渲染相机的渲染优先级。
         */
        get cameraPriority(): number;
        static EventType: typeof NodeEventType;
        protected _contentSize: math.Size;
        protected _anchorPoint: math.Vec2;
        __preload(): void;
        onLoad(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        /**
         * @en
         * Sets the untransformed size of the ui transform.<br/>
         * The contentSize remains the same no matter if the node is scaled or rotated.<br/>
         * @zh
         * 设置节点 UI Transform 的原始大小，不受该节点是否被缩放或者旋转的影响。
         *
         * @param size - The size of the UI transformation.
         * @example
         * ```ts
         * import { Size } from 'cc';
         * node.setContentSize(new Size(100, 100));
         * ```
         */
        setContentSize(size: math.Size): void;
        /**
         * @en
         * Sets the untransformed size of the ui transform.<br/>
         * The contentSize remains the same no matter if the node is scaled or rotated.<br/>
         * @zh
         * 设置节点 UI Transform 的原始大小，不受该节点是否被缩放或者旋转的影响。
         *
         * @param width - The width of the UI transformation.
         * @param height - The height of the UI transformation.
         * @example
         * ```ts
         * import { Size } from 'cc';
         * node.setContentSize(100, 100);
         * ```
         */
        setContentSize(width: number, height: number): void;
        /**
         * @en
         * Sets the anchor point in percent. <br/>
         * anchor point is the point around which all transformations and positioning manipulations take place. <br/>
         * It's like a pin in the node where it is "attached" to its parent. <br/>
         * The anchorPoint is normalized, like a percentage. (0,0) means the bottom-left corner and (1,1) means the top-right corner.<br/>
         * But you can use values higher than (1,1) and lower than (0,0) too.<br/>
         * The default anchor point is (0.5,0.5), so it starts at the center of the node.
         *
         * @zh
         * 设置锚点的百分比。<br>
         * 锚点应用于所有变换和坐标点的操作，它就像在节点上连接其父节点的大头针。<br>
         * 锚点是标准化的，就像百分比一样。(0，0) 表示左下角，(1，1) 表示右上角。<br>
         * 但是你可以使用比（1，1）更高的值或者比（0，0）更低的值。<br>
         * 默认的锚点是（0.5，0.5），因此它开始于节点的中心位置。<br>
         * 注意：Creator 中的锚点仅用于定位所在的节点，子节点的定位不受影响。
         *
         * @param point @en Node anchor point or node x-axis anchor.
         *              @zh 节点锚点或节点 x 轴锚。
         * @param y @en The y-axis anchor of the node.
         *          @zh 节点 y 轴锚。
         * @example
         * ```ts
         * import { Vec2 } from 'cc';
         * node.setAnchorPoint(new Vec2(1, 1));
         * node.setAnchorPoint(1, 1);
         * ```
         */
        setAnchorPoint(point: math.Vec2 | Readonly<math.Vec2> | number, y?: number): void;
        /**
         * @zh UI 空间中的点击测试。
         * @en Hit test with point in UI Space.
         *
         * @param uiPoint point in UI Space.
         * @deprecated since v3.5.0, please use `uiTransform.hitTest(screenPoint: Vec2)` instead.
         */
        isHit(uiPoint: math.Vec2): boolean;
        /**
         * @zh 屏幕空间中的点击测试。
         * @en Hit test with point in Screen Space.
         *
         * @param screenPoint point in Screen Space.
         */
        hitTest(screenPoint: math.Vec2): boolean;
        /**
         * @en
         * Converts a Point to node (local) space coordinates.
         *
         * @zh
         * 将一个 UI 节点世界坐标系下点转换到另一个 UI 节点 (局部) 空间坐标系，这个坐标系以锚点为原点。
         * 非 UI 节点转换到 UI 节点(局部) 空间坐标系，请走 Camera 的 `convertToUINode`。
         *
         * @param worldPoint @en Point in world space.
         *                   @zh 世界坐标点。
         * @param out @en Point in local space.
         *            @zh 转换后坐标。
         * @returns @en Return the relative position to the target node.
         *          @zh 返回与目标节点的相对位置。
         * @example
         * ```ts
         * const newVec3 = uiTransform.convertToNodeSpaceAR(cc.v3(100, 100, 0));
         * ```
         */
        convertToNodeSpaceAR(worldPoint: math.Vec3, out?: math.Vec3): math.Vec3;
        /**
         * @en
         * Converts a Point in node coordinates to world space coordinates.
         *
         * @zh
         * 将距当前节点坐标系下的一个点转换到世界坐标系。
         *
         * @param nodePoint @en Point in local space.
         *                  @zh 节点坐标。
         * @param out @en Point in world space.
         *            @zh 转换后坐标。
         * @returns @en Returns the coordinates in the UI world coordinate system.
         *          @zh 返回 UI 世界坐标系。
         * @example
         * ```ts
         * const newVec3 = uiTransform.convertToWorldSpaceAR(3(100, 100, 0));
         * ```
         */
        convertToWorldSpaceAR(nodePoint: math.Vec3, out?: math.Vec3): math.Vec3;
        /**
         * @en
         * Returns a "local" axis aligned bounding box of the node. <br/>
         * The returned box is relative only to its parent.
         *
         * @zh
         * 返回父节坐标系下的轴向对齐的包围盒。
         *
         * @return - 节点大小的包围盒
         * @example
         * ```ts
         * const boundingBox = uiTransform.getBoundingBox();
         * ```
         */
        getBoundingBox(): math.Rect;
        /**
         * @en
         * Returns a "world" axis aligned bounding box of the node.<br/>
         * The bounding box contains self and active children's world bounding box.
         *
         * @zh
         * 返回节点在世界坐标系下的对齐轴向的包围盒（AABB）。
         * 该边框包含自身和已激活的子节点的世界边框。
         *
         * @returns - 返回世界坐标系下包围盒。
         * @example
         * ```ts
         * const newRect = uiTransform.getBoundingBoxToWorld();
         * ```
         */
        getBoundingBoxToWorld(): math.Rect;
        /**
         * @en
         * Returns the minimum bounding box containing the current bounding box and its child nodes.
         *
         * @zh
         * 返回包含当前包围盒及其子节点包围盒的最小包围盒。
         *
         * @param parentMat @en The parent node matrix.
         *                  @zh 父节点矩阵。
         * @returns
         */
        getBoundingBoxTo(parentMat: math.Mat4): math.Rect;
        /**
         * @en
         * Compute the corresponding aabb in world space for raycast.
         *
         * @zh
         * 计算出此 UI_2D 节点在世界空间下的 aabb 包围盒
         */
        getComputeAABB(out?: geometry.AABB): geometry.AABB;
        protected _parentChanged(node: Node): void;
        static _sortSiblings(): void;
        static _cleanChangeMap(): void;
    }
    export class RenderRoot2D extends Component {
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
    }
    /**
     * @en 2D rendering component that provides the ability to render sprite in 3D space.
     * @zh 2D 渲染基础组件，提供精灵渲染在 3D 空间中的能力。
     */
    export class SpriteRenderer extends ModelRenderer {
        /**
         * @en The spriteFrame that the component should render
         * @zh 该组件应渲染的 spriteFrame
         */
        get spriteFrame(): SpriteFrame | null;
        set spriteFrame(value: SpriteFrame | null);
        /**
         * @en Rendering model of the component
         * @zh 该组件的渲染模型
         */
        get model(): renderer.scene.Model | null;
        protected _spriteFrame: SpriteFrame | null;
        protected _mode: __private._cocos_2d_framework_sprite_renderer__SpriteMode;
        protected _color: math.Color;
        protected _flipX: boolean;
        protected _flipY: boolean;
        protected _size: math.Vec2;
        onLoad(): void;
        onRestore(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        protected _updateModels(): void;
        protected _createModel(): void;
        protected _updateModelParams(): void;
        protected _getBuiltinMaterial(): Material;
        protected _onMaterialModified(idx: number, material: Material | null): void;
        protected _onRebuildPSO(idx: number, material: Material): void;
        protected _onUpdateLocalDescriptorSet(): void;
        protected _attachToScene(): void;
        protected _detachFromScene(): void;
    }
    /**
     * @en
     * The Mask Component.
     *
     * @zh
     * 遮罩组件。
     */
    export class Mask extends Component {
        /**
         * @en The type for mask.
         *
         * @zh 遮罩组件类型。
         */
        static Type: typeof __private._cocos_2d_components_mask__MaskType;
        /**
         * @en
         * The mask type.
         *
         * @zh
         * 遮罩类型。
         */
        get type(): __private._cocos_2d_components_mask__MaskType;
        set type(value: __private._cocos_2d_components_mask__MaskType);
        /**
         * @en
         * Reverse mask
         * @zh
         * 反向遮罩
         */
        get inverted(): boolean;
        set inverted(value: boolean);
        /**
         * @en
         * The segments for ellipse mask.
         *
         * TODO: remove segments, not supported by graphics
         * @zh
         * 椭圆遮罩的曲线细分数。
         */
        get segments(): number;
        set segments(value: number);
        /**
         * @en
         * The mask image.
         *
         * @zh
         * 遮罩所需要的贴图。
         * @deprecated since v3.6.1
         */
        get spriteFrame(): SpriteFrame | null;
        set spriteFrame(value: SpriteFrame | null);
        /**
         * @en
         * The alpha threshold.(Not supported Canvas Mode) <br/>
         * The content is drawn only where the stencil have pixel with alpha greater than the alphaThreshold. <br/>
         * Should be a float between 0 and 1. <br/>
         * This default to 0.1.
         * When it's set to 1, the stencil will discard all pixels, nothing will be shown.
         * @zh
         * Alpha 阈值（不支持 Canvas 模式）<br/>
         * 只有当模板的像素的 alpha 大于等于 alphaThreshold 时，才会绘制内容。<br/>
         * 该数值 0 ~ 1 之间的浮点数，默认值为 0.1
         * 当被设置为 1 时，会丢弃所有蒙版像素，所以不会显示任何内容
         */
        get alphaThreshold(): number;
        set alphaThreshold(value: number);
        get subComp(): Sprite | Graphics | null;
        protected _type: __private._cocos_2d_components_mask__MaskType;
        protected _inverted: boolean;
        protected _segments: number;
        protected _alphaThreshold: number;
        protected _sprite: Sprite | null;
        protected _graphics: Graphics | null;
        protected _stencilStage: __private._cocos_2d_renderer_stencil_manager__Stage;
        onLoad(): void;
        onEnable(): void;
        /**
         * @zh
         * 图形内容重塑。
         */
        onRestore(): void;
        onDisable(): void;
        onDestroy(): void;
        /**
         * Hit test with point in World Space.
         *
         * @param worldPt point in World Space.
         */
        isHit(worldPt: math.Vec2): boolean;
        protected _nodeStateChange(type: TransformBit): void;
        protected _createSprite(): void;
        protected _createGraphics(): void;
        protected _updateGraphics(): void;
        protected _enableRender(): void;
        protected _disableRender(): void;
        protected _removeMaskNode(): void;
        /**
         * @deprecated Since v3.6, Because mask changes the inheritance relationship, you can directly manipulate the rendering components under the same node to complete the operation
         */
        get customMaterial(): Material | null;
        set customMaterial(val: Material | null);
        /**
         * @deprecated Since v3.6, Because mask changes the inheritance relationship, you can directly manipulate the rendering components under the same node to complete the operation
         */
        get color(): Readonly<math.Color> | null;
        set color(value: Readonly<math.Color> | null);
        /**
         * @deprecated Since v3.6, Because mask changes the inheritance relationship, you can directly manipulate the rendering components under the same node to complete the operation
         */
        markForUpdateRenderData(enable?: boolean): void;
        /**
         * @deprecated Since v3.6, Because mask changes the inheritance relationship, you can directly manipulate the rendering components under the same node to complete the operation
         */
        requestRenderData(any: any): void;
        /**
         * @deprecated Since v3.6, Because mask changes the inheritance relationship, you can directly manipulate the rendering components under the same node to complete the operation
         */
        destroyRenderData(): void;
        /**
         * @deprecated Since v3.6, Because mask changes the inheritance relationship, you can directly manipulate the rendering components under the same node to complete the operation
         */
        updateRenderer(): void;
        /**
         * @deprecated Since v3.6, Because mask changes the inheritance relationship, you can directly manipulate the rendering components under the same node to complete the operation
         */
        fillBuffers(render: any): void;
        /**
         * @deprecated Since v3.6, Because mask changes the inheritance relationship, you can directly manipulate the rendering components under the same node to complete the operation
         */
        postUpdateAssembler(render: any): void;
        /**
         * @deprecated Since v3.6, Because mask changes the inheritance relationship, you can directly manipulate the rendering components under the same node to complete the operation
         */
        setNodeDirty(): void;
        /**
         * @deprecated Since v3.6, Because mask changes the inheritance relationship, you can directly manipulate the rendering components under the same node to complete the operation
         */
        setTextureDirty(): void;
        /**
         * @deprecated Since v3.6, Because mask changes the inheritance relationship, you can directly manipulate the rendering components under the same node to complete the operation
         */
        get sharedMaterial(): Material | null;
        /**
         * @deprecated Since v3.6, Because mask changes the inheritance relationship, you can directly manipulate the rendering components under the same node to complete the operation
         */
        get sharedMaterials(): (Material | null)[] | null;
        set sharedMaterials(val: (Material | null)[] | null);
        /**
         * @deprecated Since v3.6, Because mask changes the inheritance relationship, you can directly manipulate the rendering components under the same node to complete the operation
         */
        get material(): any;
        set material(val: any);
        /**
         * @deprecated Since v3.6, Because mask changes the inheritance relationship, you can directly manipulate the rendering components under the same node to complete the operation
         */
        get materials(): (any)[];
        set materials(val: (any)[]);
        /**
         * @deprecated Since v3.6, Because mask changes the inheritance relationship, you can directly manipulate the rendering components under the same node to complete the operation
         */
        getMaterial(idx: number): any;
        /**
         * @deprecated Since v3.6, Because mask changes the inheritance relationship, you can directly manipulate the rendering components under the same node to complete the operation
         */
        setMaterial(material: any, index: number): void;
        /**
         * @deprecated Since v3.6, Because mask changes the inheritance relationship, you can directly manipulate the rendering components under the same node to complete the operation
         */
        getMaterialInstance(idx: number): any;
        /**
         * @deprecated Since v3.6, Because mask changes the inheritance relationship, you can directly manipulate the rendering components under the same node to complete the operation
         */
        setMaterialInstance(matInst: any, index: number): void;
        /**
         * @deprecated Since v3.6, Because mask changes the inheritance relationship, you can directly manipulate the rendering components under the same node to complete the operation
         */
        getRenderMaterial(index: number): any;
    }
    /**
     * @en
     * The RichText Component.
     *
     * @zh
     * 富文本组件。
     */
    export class RichText extends Component {
        /**
         * @en
         * Content string of RichText.
         *
         * @zh
         * 富文本显示的文本内容。
         */
        get string(): string;
        set string(value: string);
        /**
         * @en
         * Horizontal Alignment of each line in RichText.
         *
         * @zh
         * 文本内容的水平对齐方式。
         */
        get horizontalAlign(): HorizontalTextAlignment;
        set horizontalAlign(value: HorizontalTextAlignment);
        /**
         * @en
         * Vertical Alignment of each line in RichText.
         *
         * @zh
         * 文本内容的竖直对齐方式。
         */
        get verticalAlign(): VerticalTextAlignment;
        set verticalAlign(value: VerticalTextAlignment);
        /**
         * @en
         * Font size of RichText.
         *
         * @zh
         * 富文本字体大小。
         */
        get fontSize(): number;
        set fontSize(value: number);
        /**
         * @en
         * Custom System font of RichText
         *
         * @zh
         * 富文本定制系统字体
         */
        get fontFamily(): string;
        set fontFamily(value: string);
        /**
         * @en
         * Custom System font of RichText.
         *
         * @zh
         * 富文本定制字体。
         */
        get font(): TTFFont | null;
        set font(value: TTFFont | null);
        /**
         * @en
         * Whether use system font name or not.
         *
         * @zh
         * 是否使用系统字体。
         */
        get useSystemFont(): boolean;
        set useSystemFont(value: boolean);
        /**
         * @en
         * The cache mode of label. This mode only supports system fonts.
         *
         * @zh
         * 文本缓存模式, 该模式只支持系统字体。
         */
        get cacheMode(): CacheMode;
        set cacheMode(value: CacheMode);
        /**
         * @en
         * The maximize width of the RichText.
         *
         * @zh
         * 富文本的最大宽度。
         */
        get maxWidth(): number;
        set maxWidth(value: number);
        /**
         * @en
         * Line Height of RichText.
         *
         * @zh
         * 富文本行高。
         */
        get lineHeight(): number;
        set lineHeight(value: number);
        /**
         * @en
         * The image atlas for the img tag. For each src value in the img tag, there should be a valid spriteFrame in the image atlas.
         *
         * @zh
         * 对于 img 标签里面的 src 属性名称，都需要在 imageAtlas 里面找到一个有效的 spriteFrame，否则 img tag 会判定为无效。
         */
        get imageAtlas(): SpriteAtlas | null;
        set imageAtlas(value: SpriteAtlas | null);
        /**
         * @en
         * Once checked, the RichText will block all input events (mouse and touch) within
         * the bounding box of the node, preventing the input from penetrating into the underlying node.
         *
         * @zh
         * 选中此选项后，RichText 将阻止节点边界框中的所有输入事件（鼠标和触摸），从而防止输入事件穿透到底层节点。
         */
        get handleTouchEvent(): boolean;
        set handleTouchEvent(value: boolean);
        static HorizontalAlign: typeof HorizontalTextAlignment;
        static VerticalAlign: typeof VerticalTextAlignment;
        protected _lineHeight: number;
        protected _string: string;
        protected _horizontalAlign: HorizontalTextAlignment;
        protected _verticalAlign: VerticalTextAlignment;
        protected _fontSize: number;
        protected _maxWidth: number;
        protected _fontFamily: string;
        protected _font: TTFFont | null;
        protected _isSystemFontUsed: boolean;
        protected _userDefinedFont: TTFFont | null;
        protected _cacheMode: CacheMode;
        protected _imageAtlas: SpriteAtlas | null;
        protected _handleTouchEvent: boolean;
        protected _textArray: IHtmlTextParserResultObj[];
        protected _segments: __private._cocos_2d_components_rich_text__ISegment[];
        protected _labelSegmentsCache: __private._cocos_2d_components_rich_text__ISegment[];
        protected _linesWidth: number[];
        protected _lineCount: number;
        protected _labelWidth: number;
        protected _labelHeight: number;
        protected _layoutDirty: boolean;
        protected _lineOffsetX: number;
        protected _updateRichTextStatus: () => void;
        protected _labelChildrenNum: number;
        constructor();
        onLoad(): void;
        onEnable(): void;
        onDisable(): void;
        onRestore(): void;
        onDestroy(): void;
        protected _addEventListeners(): void;
        protected _removeEventListeners(): void;
        protected _updateLabelSegmentTextAttributes(): void;
        protected _createFontLabel(str: string): __private._cocos_2d_components_rich_text__ISegment;
        protected _createImage(spriteFrame: SpriteFrame): __private._cocos_2d_components_rich_text__ISegment;
        protected _onTTFLoaded(): void;
        protected _measureText(styleIndex: number, string?: string): number | ((s: string) => number);
        protected _onTouchEnded(event: EventTouch): void;
        protected _containsTouchLocation(label: __private._cocos_2d_components_rich_text__ISegment, point: math.Vec2): boolean;
        protected _resetState(): void;
        protected _activateChildren(active: any): void;
        protected _addLabelSegment(stringToken: string, styleIndex: number): __private._cocos_2d_components_rich_text__ISegment;
        protected _updateRichTextWithMaxWidth(labelString: string, labelWidth: number, styleIndex: number): void;
        protected _isLastComponentCR(stringToken: any): boolean;
        protected _updateLineInfo(): void;
        protected _needsUpdateTextLayout(newTextArray: IHtmlTextParserResultObj[]): boolean;
        protected _addRichTextImageElement(richTextElement: IHtmlTextParserResultObj): void;
        protected _updateRichText(): void;
        protected _getFirstWordLen(text: string, startIndex: number, textLen: number): number;
        protected _updateRichTextPosition(): void;
        protected _convertLiteralColorValue(color: string): math.Color;
        protected _applyTextAttribute(labelSeg: __private._cocos_2d_components_rich_text__ISegment): void;
        protected _applyLayer(): void;
        protected _resetLabelState(label: Label): void;
    }
    /**
     * @en
     * Renders a sprite in the scene.
     *
     * @zh
     * 渲染精灵组件。
     */
    export class Sprite extends UIRenderer {
        /**
         * @en
         * The sprite atlas where the sprite is.
         *
         * @zh
         * 精灵的图集。
         */
        get spriteAtlas(): SpriteAtlas | null;
        set spriteAtlas(value: SpriteAtlas | null);
        /**
         * @en
         * The sprite frame of the sprite.
         *
         * @zh
         * 精灵的精灵帧。
         */
        get spriteFrame(): SpriteFrame | null;
        set spriteFrame(value: SpriteFrame | null);
        /**
         * @en
         * The sprite render type.
         *
         * @zh
         * 精灵渲染类型。
         *
         * @example
         * ```ts
         * import { Sprite } from 'cc';
         * sprite.type = Sprite.Type.SIMPLE;
         * ```
         */
        get type(): __private._cocos_2d_components_sprite__SpriteType;
        set type(value: __private._cocos_2d_components_sprite__SpriteType);
        /**
         * @en
         * The fill type, This will only have any effect if the "type" is set to “Sprite.Type.FILLED”.
         *
         * @zh
         * 精灵填充类型，仅渲染类型设置为 Sprite.Type.FILLED 时有效。
         *
         * @example
         * ```ts
         * import { Sprite } from 'cc';
         * sprite.fillType = Sprite.FillType.HORIZONTAL;
         * ```
         */
        get fillType(): __private._cocos_2d_components_sprite__FillType;
        set fillType(value: __private._cocos_2d_components_sprite__FillType);
        /**
         * @en
         * The fill Center, This will only have any effect if the "type" is set to “Sprite.Type.FILLED”.
         *
         * @zh
         * 填充中心点，仅渲染类型设置为 Sprite.Type.FILLED 时有效。
         *
         * @example
         * ```ts
         * import { Vec2 } from 'cc';
         * sprite.fillCenter = new Vec2(0, 0);
         * ```
         */
        get fillCenter(): math.Vec2;
        set fillCenter(value: math.Vec2);
        /**
         * @en
         * The fill Start, This will only have any effect if the "type" is set to “Sprite.Type.FILLED”.
         *
         * @zh
         * 填充起始点，仅渲染类型设置为 Sprite.Type.FILLED 时有效。
         *
         * @example
         * ```ts
         * // -1 To 1 between the numbers
         * sprite.fillStart = 0.5;
         * ```
         */
        get fillStart(): number;
        set fillStart(value: number);
        /**
         * @en
         * The fill Range, This will only have any effect if the "type" is set to “Sprite.Type.FILLED”.
         *
         * @zh
         * 填充范围，仅渲染类型设置为 Sprite.Type.FILLED 时有效。
         *
         * @example
         * ```ts
         * // -1 To 1 between the numbers
         * sprite.fillRange = 1;
         * ```
         */
        get fillRange(): number;
        set fillRange(value: number);
        /**
         * @en
         * specify the frame is trimmed or not.
         *
         * @zh
         * 是否使用裁剪模式。
         *
         * @example
         * ```ts
         * sprite.trim = true;
         * ```
         */
        get trim(): boolean;
        set trim(value: boolean);
        get grayscale(): boolean;
        set grayscale(value: boolean);
        /**
         * @en
         * Specify the size tracing mode.
         *
         * @zh
         * 精灵尺寸调整模式。
         *
         * @example
         * ```ts
         * import { Sprite } from 'cc';
         * sprite.sizeMode = Sprite.SizeMode.CUSTOM;
         * ```
         */
        get sizeMode(): __private._cocos_2d_components_sprite__SizeMode;
        set sizeMode(value: __private._cocos_2d_components_sprite__SizeMode);
        static FillType: typeof __private._cocos_2d_components_sprite__FillType;
        static Type: typeof __private._cocos_2d_components_sprite__SpriteType;
        static SizeMode: typeof __private._cocos_2d_components_sprite__SizeMode;
        static EventType: typeof __private._cocos_2d_components_sprite__EventType;
        protected _spriteFrame: SpriteFrame | null;
        protected _type: __private._cocos_2d_components_sprite__SpriteType;
        protected _fillType: __private._cocos_2d_components_sprite__FillType;
        protected _sizeMode: __private._cocos_2d_components_sprite__SizeMode;
        protected _fillCenter: math.Vec2;
        protected _fillStart: number;
        protected _fillRange: number;
        protected _isTrimmedMode: boolean;
        protected _useGrayscale: boolean;
        protected _atlas: SpriteAtlas | null;
        __preload(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        /**
         * @en
         * Quickly switch to other sprite frame in the sprite atlas.
         * If there is no atlas, the switch fails.
         *
         * @zh
         * 精灵图集内的精灵替换
         *
         * @returns
         */
        changeSpriteFrameFromAtlas(name: string): void;
        changeMaterialForDefine(): void;
        protected _updateBuiltinMaterial(): Material;
        protected _render(render: __private._cocos_2d_renderer_i_batcher__IBatcher): void;
        protected _canRender(): boolean;
        protected _flushAssembler(): void;
    }
    /**
     * @en
     * The component of model.
     * When you place particles or models in the UI, you must add this component to render.
     * The component must be placed on a node with the [[MeshRenderer]] or the [[ParticleSystem]].
     *
     * @zh
     * UI 模型基础组件。
     * 当你在 UI 中放置模型或者粒子的时候，必须添加该组件才能渲染。该组件必须放置在带有 [[MeshRenderer]] 或者 [[ParticleSystem]] 组件的节点上。
     */
    export class UIMeshRenderer extends Component {
        constructor();
        get modelComponent(): ModelRenderer | null;
        protected _renderEntity: __private._cocos_2d_renderer_render_entity__RenderEntity;
        _dirtyVersion: number;
        _internalId: number;
        __preload(): void;
        onEnable(): void;
        onDisable(): void;
        onLoad(): void;
        onDestroy(): void;
        /**
         * @en Render data submission procedure, it update and assemble the render data to 2D data buffers before all children submission process.
         * Usually called each frame when the ui flow assemble all render data to geometry buffers.
         * Don't call it unless you know what you are doing.
         * @zh 渲染数据组装程序，这个方法会在所有子节点数据组装之前更新并组装当前组件的渲染数据到 UI 的顶点数据缓冲区中。
         * 一般在 UI 渲染流程中调用，用于组装所有的渲染数据到顶点数据缓冲区。
         * 注意：不要手动调用该函数，除非你理解整个流程。
         */
        _render(render: __private._cocos_2d_renderer_i_batcher__IBatcher): boolean;
        fillBuffers(render: __private._cocos_2d_renderer_i_batcher__IBatcher): void;
        updateRenderer(): void;
        /**
         * @en Post render data submission procedure, it's executed after assembler updated for all children.
         * It may assemble some extra render data to the geometry buffers, or it may only change some render states.
         * Don't call it unless you know what you are doing.
         * @zh 后置渲染数据组装程序，它会在所有子节点的渲染数据组装完成后被调用。
         * 它可能会组装额外的渲染数据到顶点数据缓冲区，也可能只是重置一些渲染状态。
         * 注意：不要手动调用该函数，除非你理解整个流程。
         */
        postUpdateAssembler(render: __private._cocos_2d_renderer_i_batcher__IBatcher): void;
        update(): void;
        markForUpdateRenderData(enable?: boolean): void;
        stencilStage: __private._cocos_2d_renderer_stencil_manager__Stage;
        setNodeDirty(): void;
        setTextureDirty(): void;
        protected _canRender(): boolean;
        get renderEntity(): __private._cocos_2d_renderer_render_entity__RenderEntity;
        protected _renderData: RenderData | null;
        get renderData(): RenderData | null;
    }
    /**
     * @en
     * Outline effect used to change the display, only for system fonts or TTF fonts.
     *
     * @zh
     * 描边效果组件,用于字体描边,只能用于系统字体。
     *
     * @example
     * ```ts
     * import { Node, Label, LabelOutline } from 'cc';
     * // Create a new node and add label components.
     * const node = new Node("New Label");
     * const label = node.addComponent(Label);
     * const outline = node.addComponent(LabelOutline);
     * node.parent = this.node;
     * ```
     */
    export class LabelOutline extends Component {
        protected _color: math.Color;
        protected _width: number;
        /**
         * @en
         * Outline color.
         *
         * @zh
         * 改变描边的颜色。
         *
         * @example
         * ```ts
         * import { Color } from 'cc';
         * outline.color = new Color(0.5, 0.3, 0.7, 1.0);
         * ```
         */
        get color(): Readonly<math.Color>;
        set color(value: Readonly<math.Color>);
        /**
         * @en
         * Change the outline width.
         *
         * @zh
         * 改变描边的宽度。
         *
         * @example
         * ```ts
         * outline.width = 3;
         * ```
         */
        get width(): number;
        set width(value: number);
        onEnable(): void;
        onDisable(): void;
        protected _updateRenderData(): void;
    }
    /**
     * @en
     * Graphics component.
     *
     * @zh
     * 自定义图形类
     */
    export class Graphics extends UIRenderer {
        /**
         * @en
         * Current line width.
         *
         * @zh
         * 当前线条宽度。
         */
        get lineWidth(): number;
        set lineWidth(value: number);
        /**
         * @en
         * Determines how two connecting segments (of lines, arcs or curves) with non-zero lengths in a shape are joined together.
         *
         * @zh
         * 用来设置2个长度不为0的相连部分（线段，圆弧，曲线）如何连接在一起的属性。
         */
        get lineJoin(): __private._cocos_2d_assembler_graphics_types__LineJoin;
        set lineJoin(value: __private._cocos_2d_assembler_graphics_types__LineJoin);
        /**
         * @en
         * Determines how the end points of every line are drawn.
         *
         * @zh
         * 指定如何绘制每一条线段末端。
         */
        get lineCap(): __private._cocos_2d_assembler_graphics_types__LineCap;
        set lineCap(value: __private._cocos_2d_assembler_graphics_types__LineCap);
        /**
         * @en
         * Brush stroke color.
         *
         * @zh
         * 笔触的颜色。
         */
        get strokeColor(): Readonly<math.Color>;
        set strokeColor(value: Readonly<math.Color>);
        /**
         * @en
         * Fill paint color.
         *
         * @zh
         * 填充绘画的颜色。
         */
        get fillColor(): Readonly<math.Color>;
        set fillColor(value: Readonly<math.Color>);
        /**
         * @en
         * Set the miter limit ratio.
         *
         * @zh
         * 设置斜接面限制比例。
         */
        get miterLimit(): number;
        set miterLimit(value: number);
        get color(): math.Color;
        set color(value: math.Color);
        get srcBlendFactor(): gfx.BlendFactor;
        set srcBlendFactor(value: gfx.BlendFactor);
        get dstBlendFactor(): gfx.BlendFactor;
        set dstBlendFactor(value: gfx.BlendFactor);
        static LineJoin: typeof __private._cocos_2d_assembler_graphics_types__LineJoin;
        static LineCap: typeof __private._cocos_2d_assembler_graphics_types__LineCap;
        impl: __private._cocos_2d_assembler_graphics_webgl_impl__Impl | null;
        /**
         * @deprecated since v3.6.0, this is an engine private interface that will be removed in the future.
         */
        model: renderer.scene.Model | null;
        protected _lineWidth: number;
        protected _strokeColor: math.Color;
        protected _lineJoin: __private._cocos_2d_assembler_graphics_types__LineJoin;
        protected _lineCap: __private._cocos_2d_assembler_graphics_types__LineCap;
        protected _fillColor: math.Color;
        protected _miterLimit: number;
        protected _isDrawing: boolean;
        protected _isNeedUploadData: boolean;
        protected _graphicsNativeProxy: __private._cocos_2d_renderer_native_2d__NativeUIModelProxy;
        get graphicsNativeProxy(): __private._cocos_2d_renderer_native_2d__NativeUIModelProxy;
        constructor();
        onRestore(): void;
        onLoad(): void;
        onEnable(): void;
        onDestroy(): void;
        /**
         * @en
         * Move path start point to (x,y).
         *
         * @zh
         * 移动路径起点到坐标(x, y)。
         *
         * @param x @en The x-axis coordinate of the target position.
         *          @zh 目标位置的 X 轴坐标。
         * @param y @en The y-axis coordinate of the target position.
         *          @zh 目标位置的 y 轴坐标。
         */
        moveTo(x: number, y: number): void;
        /**
         * @en
         * Adds a straight line to the path.
         *
         * @zh
         * 绘制直线路径。
         *
         * @param x @en The x-axis coordinate of the target position.
         *          @zh 目标位置的 x 轴坐标。
         * @param y @en The x-axis coordinate of the target position.
         *          @zh 目标位置的 y 轴坐标。
         */
        lineTo(x: number, y: number): void;
        /**
         * @en
         * Adds a cubic Bézier curve to the path.
         *
         * @zh
         * 绘制三次贝赛尔曲线路径。
         *
         * @param c1x @en The x-axis coordinate of the first control point.
         *            @zh 第一个控制点的 x 轴坐标。
         * @param c1y @en The y-axis coordinate of the first control point.
         *            @zh 第一个控制点的 y 轴坐标。
         * @param c2x @en The x-axis coordinate of the second control point.
         *            @zh 第二个控制点的 x 轴坐标。
         * @param c2y @en The y-axis coordinate of the second control point.
         *            @zh 第二个控制点的 y 轴坐标。
         * @param x @en The x-axis coordinate of the last control point.
         *          @zh 最后一个控制点的 x 轴坐标。
         * @param y @en The y-axis coordinate of the last control point.
         *          @zh 最后一个控制点的 y 轴坐标。
         */
        bezierCurveTo(c1x: number, c1y: number, c2x: number, c2y: number, x: number, y: number): void;
        /**
         * @en
         * Adds a quadratic Bézier curve to the path.
         *
         * @zh
         * 绘制二次贝赛尔曲线路径。
         *
         * @param cx @en The x-axis coordinate of the starting control point.
         *           @zh 起始控制点的 x 轴坐标。
         * @param cy @en The y-axis coordinate of the starting control point.
         *           @zh 起始控制点的 y 轴坐标。
         * @param x @en The x-axis coordinates of the endpoint control point.
         *          @zh 终点控制点的 x 轴坐标。
         * @param y @en The y-axis coordinates of the endpoint control point.
         *          @zh 终点控制点的 x 轴坐标。
         */
        quadraticCurveTo(cx: number, cy: number, x: number, y: number): void;
        /**
         * @en
         * Adds an arc to the path which is centered at (cx, cy) position with radius r starting at startAngle
         * and ending at endAngle going in the given direction by counterclockwise (defaulting to false).
         *
         * @zh
         * 绘制圆弧路径。圆弧路径的圆心在 (cx, cy) 位置，半径为 r ，根据 counterclockwise （默认为false）指定的方向从 startAngle 开始绘制，到 endAngle 结束。
         *
         * @param cx @en The coordinate x-axis of the central control point.
         *           @zh 中心控制点的坐标 x 轴。
         * @param cy @en The coordinate y-axis of the central control point.
         *           @zh 中心控制点的坐标 y 轴。
         * @param r @en Angle in Radian.
         *          @zh 圆弧弧度。
         * @param startAngle @en The starting angle in radian, measured clockwise from the positive x-axis.
         *                   @zh 弧度起点，从正 x 轴顺时针方向测量。
         * @param endAngle @en The ending angle in radian, measured clockwise from the positive x-axis.
         *                 @zh 弧度终点，从正 x 轴顺时针方向测量。
         * @param counterclockwise @en If true, draws counterclockwise between the two angles. Default is clockwise.
         *                         @zh 如果为真，在两个角度之间逆时针绘制。默认顺时针。
         */
        arc(cx: number, cy: number, r: number, startAngle: number, endAngle: number, counterclockwise: boolean): void;
        /**
         * @en
         * Adds an ellipse to the path.
         *
         * @zh
         * 绘制椭圆路径。
         *
         * @param cx @en The x-axis coordinates of the center point.
         *           @zh 中心点的 x 轴坐标。
         * @param cy @en The y-axis coordinates of the center point.
         *           @zh 中心点的 y 轴坐标。
         * @param rx @en The radius of the x-axis of the ellipse.
         *           @zh 椭圆 x 轴半径。
         * @param ry @en The radius of the y-axis of the ellipse.
         *           @zh 椭圆 y 轴半径。
         */
        ellipse(cx: number, cy: number, rx: number, ry: number): void;
        /**
         * @en
         * Adds a circle to the path.
         *
         * @zh
         * 绘制圆形路径。
         *
         * @param cx @en The x-axis coordinates of the center point.
         *           @zh 中心点的 x 轴坐标。
         * @param cy @en The y-axis coordinates of the center point.
         *           @zh 中心点的 y 轴坐标。
         * @param r @en Radius.
         *          @zh 圆半径。
         */
        circle(cx: number, cy: number, r: number): void;
        /**
         * @en
         * Adds a rectangle to the path.
         *
         * @zh
         * 绘制矩形路径。
         *
         * @param x @en The x-axis coordinate of the top left point of the rectangle.
         *          @zh 矩形起始 x 轴坐标。
         * @param y @en The y-axis coordinate of the top left point of the rectangle.
         *          @zh 矩形起始 y 轴坐标。
         * @param w @en The width of the rectangle.
         *          @zh 矩形宽度。
         * @param h @en The height of the rectangle.
         *          @zh 矩形高度。
         */
        rect(x: number, y: number, w: number, h: number): void;
        /**
         * @en
         * Adds a round corner rectangle to the path.
         *
         * @zh
         * 绘制圆角矩形路径。
         *
         * @param x @en The x-axis coordinate of the top left point of the rectangle.
         *          @zh 矩形起始 x 轴坐标。
         * @param y @en The y-axis coordinate of the top left point of the rectangle.
         *          @zh 矩形起始 y 轴坐标。
         * @param w @en The width of the rectangle.
         *          @zh 矩形宽度。
         * @param h @en The height of the rectangle.
         *          @zh 矩形高度。
         * @param r @en Radius of rectangular rounded corners.
         *          @zh 矩形圆角半径。
         */
        roundRect(x: number, y: number, w: number, h: number, r: number): void;
        /**
         * @en
         * Draws a filled rectangle.
         *
         * @zh
         * 绘制填充矩形。
         *
         * @param x @en The x-axis coordinate of the top left point of the rectangle.
         *          @zh 矩形起始 x 轴坐标。
         * @param y @en The y-axis coordinate of the top left point of the rectangle.
         *          @zh 矩形起始 y 轴坐标。
         * @param w @en The width of the rectangle.
         *          @zh 矩形宽度。
         * @param h @en The height of the rectangle.
         *          @zh 矩形高度。
         */
        fillRect(x: any, y: any, w: any, h: any): void;
        /**
         * @en
         * Erasing any previously drawn content.
         *
         * @zh
         * 擦除之前绘制的所有内容的方法。
         */
        clear(): void;
        /**
         * @en
         * Causes the point of the pen to move back to the start of the current path.
         * It tries to add a straight line from the current point to the start.
         *
         * @zh
         * 将笔点返回到当前路径起始点的。它尝试从当前点到起始点绘制一条直线。
         */
        close(): void;
        /**
         * @en
         * Strokes the current or given path with the current stroke style.
         *
         * @zh
         * 根据当前的画线样式，绘制当前或已经存在的路径。
         */
        stroke(): void;
        /**
         * @en
         * Fills the current or given path with the current fill style.
         *
         * @zh
         * 根据当前的画线样式，填充当前或已经存在的路径。
         */
        fill(): void;
        activeSubModel(idx: number): void;
        protected _uploadData(): void;
        protected _render(render: __private._cocos_2d_renderer_i_batcher__IBatcher): void;
        protected _flushAssembler(): void;
        protected _canRender(): boolean;
        updateRenderer(): void;
        protected createRenderEntity(): __private._cocos_2d_renderer_render_entity__RenderEntity;
    }
    /**
     * @en
     * Static batch component of UI.
     * This component is placed on the root node of all node objects that need to be batch.
     * Only sprites and label participate in the batch.
     * Static batch must be enabled manually, otherwise dynamic batch is still used.
     * Note: Do not place mask, Graphics, and objects such as UI models or particles under child nodes,
     * otherwise rendering will be skipped after static batching is enabled.
     *
     * @zh
     * UI 静态合批组件。
     * 该组件放在所有需要被静态合批的节点对象的根节点上，子节点放置对象必须是精灵和文本，其余对象不参与静态合批。
     * 用户必须通过手动方式启用收集静态合批数据[[markAsDirty]]，否则合批方式仍然采用动态合批（采集数据的流程相同）。此后渲染的内容是采用收集到的合批渲染数据，子节点的任何修改将不再有效。
     * 注意：子节点下不要放置 Mask，Graphics，以及 UI 模型或者粒子之类对象，否则会在启用完静态合批后跳过渲染。
     */
    export class UIStaticBatch extends UIRenderer {
        get color(): Readonly<math.Color>;
        set color(value: Readonly<math.Color>);
        get drawBatchList(): __private._cocos_2d_renderer_draw_batch__DrawBatch2D[];
        protected _init: boolean;
        protected _bufferAccessor: __private._cocos_2d_renderer_static_vb_accessor__StaticVBAccessor | null;
        protected _dirty: boolean;
        postUpdateAssembler(render: __private._cocos_2d_renderer_i_batcher__IBatcher): void;
        /**
         * @en
         * Recollect data tags.
         * The render data will be recollected during the render phase of the current frame, and the next frame will be rendered using fixed data.
         * Note: 尽量不要频繁调用此接口, 会有一定内存损耗.
         *
         * @zh
         * 重新采集数据标记，会在当前帧的渲染阶段重新采集渲染数据，下一帧开始将会使用固定数据进行渲染。
         * 注意：尽量不要频繁调用此接口，因为会清空原先存储的 ia 数据重新采集，会有一定内存损耗。
         */
        markAsDirty(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _requireDrawBatch(): __private._cocos_2d_renderer_draw_batch__DrawBatch2D;
        protected _clearData(): void;
        protected _getBatcher(): UI | null;
    }
    /**
     * @en Shadow effect for Label component, only for system fonts or TTF fonts
     * @zh 用于给 Label 组件添加阴影效果，只能用于系统字体或 ttf 字体
     * @example
     * import { Node, Label, LabelShadow } from 'cc';
     * // Create a new node and add label components.
     * const node = new Node("New Label");
     * const label = node.addComponent(Label);
     * const shadow = node.addComponent(LabelShadow);
     * node.parent = this.node;
     */
    export class LabelShadow extends Component {
        protected _color: math.Color;
        protected _offset: math.Vec2;
        protected _blur: number;
        /**
         * @en
         * Shadow color.
         *
         * @zh
         * 阴影的颜色。
         *
         * @example
         * ```ts
         * import { Color } from 'cc';
         * labelShadow.color = new Color(0.5, 0.3, 0.7, 1.0);
         * ```
         */
        get color(): Readonly<math.Color>;
        set color(value: Readonly<math.Color>);
        /**
         * @en
         * Offset between font and shadow
         *
         * @zh
         * 字体与阴影的偏移。
         *
         * @example
         * ```ts
         * import { Vec2 } from 'cc';
         * labelShadow.offset = new Vec2(2, 2);
         * ```
         */
        get offset(): math.Vec2;
        set offset(value: math.Vec2);
        /**
         * @en
         * A non-negative float specifying the level of shadow blur
         *
         * @zh
         * 阴影的模糊程度
         *
         * @example
         * ```ts
         * labelShadow.blur = 2;
         * ```
         */
        get blur(): number;
        set blur(value: number);
        onEnable(): void;
        onDisable(): void;
        protected _updateRenderData(): void;
    }
    /**
     * @en
     * Set the UI transparency component.
     * This component can be used to influence subsequent render nodes.
     * Nodes that already have a rendering component can modify the alpha channel of color directly.
     *
     * @zh
     * UI 透明度设置组件。可以通过该组件设置透明度来影响后续的渲染节点。已经带有渲染组件的节点可以直接修改 color 的 alpha 通道。
     */
    export class UIOpacity extends Component {
        /**
         * @en
         * The transparency value of the impact.
         *
         * @zh
         * 透明度。
         */
        get opacity(): number;
        set opacity(value: number);
        static setEntityLocalOpacityDirtyRecursively(node: Node, dirty: boolean, interruptParentOpacity: number): void;
        protected _opacity: number;
        onEnable(): void;
        onDisable(): void;
    }
    /**
     * @en Enum for horizontal text alignment.
     *
     * @zh 文本横向对齐类型。
     */
    export enum HorizontalTextAlignment {
        /**
         * @en Alignment left for text.
         *
         * @zh 左对齐。
         */
        LEFT = 0,
        /**
         * @en Alignment center for text.
         *
         * @zh 中心对齐。
         */
        CENTER = 1,
        /**
         * @en Alignment right for text.
         *
         * @zh 右对齐。
         */
        RIGHT = 2
    }
    /**
     * @en Enum for vertical text alignment.
     *
     * @zh 文本垂直对齐类型。
     */
    export enum VerticalTextAlignment {
        /**
         * @en Alignment top for text.
         *
         * @zh 上对齐。
         */
        TOP = 0,
        /**
         * @en Alignment center for text.
         *
         * @zh 中心对齐。
         */
        CENTER = 1,
        /**
         * @en Alignment bottom for text.
         *
         * @zh 下对齐。
         */
        BOTTOM = 2
    }
    /**
     * @en Enum for Overflow.
     *
     * @zh 文本超载类型。
     */
    export enum Overflow {
        /**
         * @en None.
         *
         * @zh 不做任何限制。
         */
        NONE = 0,
        /**
         * @en In CLAMP mode, when label content goes out of the bounding box, it will be clipped.
         *
         * @zh CLAMP 模式中，当文本内容超出边界框时，多余的会被截断。
         */
        CLAMP = 1,
        /**
         * @en In SHRINK mode, the font size will change dynamically to adapt the content size.
         * This mode may takes up more CPU resources when the label is refreshed.
         *
         * @zh SHRINK 模式，字体大小会动态变化，以适应内容大小。这个模式在文本刷新的时候可能会占用较多 CPU 资源。
         */
        SHRINK = 2,
        /**
         * @en In RESIZE_HEIGHT mode, you can only change the width of label and the height is changed automatically.
         *
         * @zh 在 RESIZE_HEIGHT 模式下，只能更改文本的宽度，高度是自动改变的。
         */
        RESIZE_HEIGHT = 3
    }
    /**
     * @en Enum for cache mode.
     *
     * @zh 文本图集缓存类型。
     */
    export enum CacheMode {
        /**
         * @en Do not do any caching.
         *
         * @zh 不做任何缓存。
         */
        NONE = 0,
        /**
         * @en In BITMAP mode, cache the label as a static image and add it to the dynamic atlas for batch rendering,
         * and can batching with Sprites using broken images.
         *
         * @zh BITMAP 模式，将 label 缓存成静态图像并加入到动态图集，以便进行批次合并，可与使用碎图的 Sprite 进行合批。
         * （注：动态图集在 Chrome 以及微信小游戏暂时关闭，该功能无效）。
         */
        BITMAP = 1,
        /**
         * @en In CHAR mode, split text into characters and cache characters into a dynamic atlas which the size of 1024 * 1024.
         *
         * @zh CHAR 模式，将文本拆分为字符，并将字符缓存到一张单独的大小为 1024 * 1024 的图集中进行重复使用，不再使用动态图集。
         * （注：当图集满时将不再进行缓存，暂时不支持 SHRINK 自适应文本尺寸（后续完善））。
         */
        CHAR = 2
    }
    /**
     * @zh
     * Type 类型。
     */
    /**
     * @zh
     * TTF字体。
     */
    /**
     * @zh
     * 位图字体。
     */
    /**
     * @zh
     * 系统字体。
     */
    /**
     * @en
     * The Label Component.
     *
     * @zh
     * 文字标签组件。
     */
    export class Label extends UIRenderer {
        static HorizontalAlign: typeof HorizontalTextAlignment;
        static VerticalAlign: typeof VerticalTextAlignment;
        static Overflow: typeof Overflow;
        static CacheMode: typeof CacheMode;
        /**
         * @internal
         */
        static _canvasPool: CanvasPool;
        /**
         * @en
         * Content string of label.
         *
         * @zh
         * 标签显示的文本内容。
         */
        get string(): string;
        set string(value: string);
        /**
         * @en
         * Horizontal Alignment of label.
         *
         * @zh
         * 文本内容的水平对齐方式。
         */
        get horizontalAlign(): HorizontalTextAlignment;
        set horizontalAlign(value: HorizontalTextAlignment);
        /**
         * @en
         * Vertical Alignment of label.
         *
         * @zh
         * 文本内容的垂直对齐方式。
         */
        get verticalAlign(): VerticalTextAlignment;
        set verticalAlign(value: VerticalTextAlignment);
        /**
         * @en
         * The actual rendering font size in shrink mode.
         *
         * @zh
         * SHRINK 模式下面文本实际渲染的字体大小。
         */
        get actualFontSize(): number;
        set actualFontSize(value: number);
        /**
         * @en
         * Font size of label.
         *
         * @zh
         * 文本字体大小。
         */
        get fontSize(): number;
        set fontSize(value: number);
        /**
         * @en
         * Line Height of label.
         *
         * @zh
         * 文本行高。
         */
        get lineHeight(): number;
        set lineHeight(value: number);
        /**
         * @en
         * The spacing between text characters, only available in BMFont.
         *
         * @zh
         * 文本字符之间的间距。仅在使用 BMFont 位图字体时生效。
         */
        get spacingX(): number;
        set spacingX(value: number);
        /**
         * @en
         * Overflow of label.
         *
         * @zh
         * 文字显示超出范围时的处理方式。
         */
        get overflow(): Overflow;
        set overflow(value: Overflow);
        /**
         * @en
         * Whether auto wrap label when string width is large than label width.
         *
         * @zh
         * 是否自动换行。
         */
        get enableWrapText(): boolean;
        set enableWrapText(value: boolean);
        /**
         * @en
         * Whether use system font name or not.
         *
         * @zh
         * 是否使用系统字体。
         */
        get useSystemFont(): boolean;
        set useSystemFont(value: boolean);
        /**
         * @en
         * Font family of label, only take effect when useSystemFont property is true.
         *
         * @zh
         * 文本字体名称, 只在 useSystemFont 属性为 true 的时候生效。
         */
        get fontFamily(): string;
        set fontFamily(value: string);
        /**
         * @en
         * The font of label.
         *
         * @zh
         * 文本字体。
         */
        get font(): Font | null;
        set font(value: Font | null);
        /**
         * @en
         * The cache mode of label. This mode only supports system fonts.
         *
         * @zh
         * 文本缓存模式, 该模式只支持系统字体。
         */
        get cacheMode(): CacheMode;
        set cacheMode(value: CacheMode);
        /**
         * @en
         * Whether the font is bold.
         *
         * @zh
         * 字体是否加粗。
         */
        get isBold(): boolean;
        set isBold(value: boolean);
        /**
         * @en
         * Whether the font is italic.
         *
         * @zh
         * 字体是否倾斜。
         */
        get isItalic(): boolean;
        set isItalic(value: boolean);
        /**
         * @en
         * Whether the font is underline.
         *
         * @zh
         * 字体是否加下划线。
         */
        get isUnderline(): boolean;
        set isUnderline(value: boolean);
        /**
         * @en The height of underline.
         * @zh 下划线高度。
         */
        get underlineHeight(): number;
        set underlineHeight(value: number);
        get spriteFrame(): SpriteFrame | __private._cocos_2d_assembler_label_font_utils__LetterRenderTexture | null;
        get ttfSpriteFrame(): SpriteFrame | null;
        get assemblerData(): __private._cocos_2d_assembler_label_font_utils__ISharedLabelData | null;
        get fontAtlas(): __private._cocos_2d_assets_bitmap_font__FontAtlas | null;
        set fontAtlas(value: __private._cocos_2d_assets_bitmap_font__FontAtlas | null);
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        get _bmFontOriginalSize(): number;
        protected _string: string;
        protected _horizontalAlign: HorizontalTextAlignment;
        protected _verticalAlign: VerticalTextAlignment;
        protected _actualFontSize: number;
        protected _fontSize: number;
        protected _fontFamily: string;
        protected _lineHeight: number;
        protected _overflow: Overflow;
        protected _enableWrapText: boolean;
        protected _font: Font | null;
        protected _isSystemFontUsed: boolean;
        protected _spacingX: number;
        protected _isItalic: boolean;
        protected _isBold: boolean;
        protected _isUnderline: boolean;
        protected _underlineHeight: number;
        protected _cacheMode: CacheMode;
        protected _N$file: Font | null;
        protected _texture: SpriteFrame | __private._cocos_2d_assembler_label_font_utils__LetterRenderTexture | null;
        protected _ttfSpriteFrame: SpriteFrame | null;
        protected _userDefinedFont: Font | null;
        protected _assemblerData: __private._cocos_2d_assembler_label_font_utils__ISharedLabelData | null;
        protected _fontAtlas: __private._cocos_2d_assets_bitmap_font__FontAtlas | null;
        protected _letterTexture: __private._cocos_2d_assembler_label_font_utils__LetterRenderTexture | null;
        protected _contentWidth: number;
        constructor();
        onEnable(): void;
        onDestroy(): void;
        updateRenderData(force?: boolean): void;
        protected _render(render: __private._cocos_2d_renderer_i_batcher__IBatcher): void;
        protected _updateColor(): void;
        setEntityColor(color: math.Color): void;
        protected _canRender(): boolean;
        protected _flushAssembler(): void;
        protected _applyFontTexture(): void;
        protected changeMaterialForDefine(): void;
    }
    /**
     * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
     */
    export interface IRenderData {
        x: number;
        y: number;
        z: number;
        u: number;
        v: number;
        color: math.Color;
    }
    /**
     * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
     */
    export class BaseRenderData {
        get vertexCount(): number;
        get indexCount(): number;
        get stride(): number;
        get floatStride(): number;
        get vertexFormat(): gfx.Attribute[];
        get drawInfoType(): __private._cocos_2d_renderer_render_draw_info__RenderDrawInfoType;
        set drawInfoType(type: __private._cocos_2d_renderer_render_draw_info__RenderDrawInfoType);
        chunk: __private._cocos_2d_renderer_static_vb_accessor__StaticVBChunk;
        protected _renderDrawInfo: __private._cocos_2d_renderer_render_draw_info__RenderDrawInfo;
        get renderDrawInfo(): __private._cocos_2d_renderer_render_draw_info__RenderDrawInfo;
        protected _material: Material | null;
        get material(): Material | null;
        set material(val: Material | null);
        protected _dataHash: number;
        get dataHash(): number;
        set dataHash(val: number);
        _isMeshBuffer: boolean;
        protected _vc: number;
        protected _ic: number;
        protected _floatStride: number;
        protected _vertexFormat: gfx.Attribute[];
        protected _drawInfoType: __private._cocos_2d_renderer_render_draw_info__RenderDrawInfoType;
        protected _multiOwner: boolean;
        get multiOwner(): boolean;
        set multiOwner(val: boolean);
        protected _batcher: UI | null;
        get batcher(): UI;
        constructor(vertexFormat?: gfx.Attribute[]);
        isValid(): false | __private._cocos_2d_renderer_static_vb_accessor__StaticVBAccessor;
        initRenderDrawInfo(comp: UIRenderer, drawInfoType?: __private._cocos_2d_renderer_render_draw_info__RenderDrawInfoType): void;
        removeRenderDrawInfo(comp: UIRenderer): void;
        protected setRenderDrawInfoAttributes(): void;
    }
    /**
     * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
     */
    export class RenderData extends BaseRenderData {
        static add(vertexFormat?: gfx.Attribute[], accessor?: __private._cocos_2d_renderer_static_vb_accessor__StaticVBAccessor): RenderData;
        static remove(data: RenderData): void;
        get dataLength(): number;
        set dataLength(length: number);
        get data(): IRenderData[];
        _vertDirty: boolean;
        get vertDirty(): boolean;
        set vertDirty(val: boolean);
        protected _textureHash: number;
        get textureHash(): number;
        set textureHash(val: number);
        indices: Uint16Array | null;
        set frame(val: SpriteFrame | __private._cocos_core_assets_texture_base__TextureBase | null);
        get frame(): SpriteFrame | __private._cocos_core_assets_texture_base__TextureBase | null;
        layer: number;
        nodeDirty: boolean;
        passDirty: boolean;
        textureDirty: boolean;
        hashDirty: boolean;
        protected _accessor: __private._cocos_2d_renderer_static_vb_accessor__StaticVBAccessor;
        get accessor(): __private._cocos_2d_renderer_static_vb_accessor__StaticVBAccessor;
        vertexRow: number;
        vertexCol: number;
        constructor(vertexFormat?: gfx.Attribute[], accessor?: __private._cocos_2d_renderer_static_vb_accessor__StaticVBAccessor);
        resize(vertexCount: number, indexCount: number): void;
        protected setRenderDrawInfoAttributes(): void;
        /**
         * @internal
         */
        fillDrawInfoAttributes(drawInfo: __private._cocos_2d_renderer_render_draw_info__RenderDrawInfo): void;
        protected syncRender2dBuffer(): void;
        resizeAndCopy(vertexCount: number, indexCount: number): void;
        getMeshBuffer(): MeshBuffer | null;
        updateNode(comp: UIRenderer): void;
        updatePass(comp: UIRenderer): void;
        updateTexture(frame: SpriteFrame | __private._cocos_core_assets_texture_base__TextureBase): void;
        updateHash(): void;
        updateRenderData(comp: UIRenderer, frame: SpriteFrame | __private._cocos_core_assets_texture_base__TextureBase): void;
        updateSizeNPivot(width: number, height: number, pivotX: number, pivotY: number): void;
        clear(): void;
        static createStaticVBAccessor(attributes: gfx.Attribute[], vCount?: number, iCount?: number): __private._cocos_2d_renderer_static_vb_accessor__StaticVBAccessor;
    }
    /**
     * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
     */
    export class MeshRenderData extends BaseRenderData {
        static add(vertexFormat?: gfx.Attribute[]): MeshRenderData;
        static remove(data: MeshRenderData): void;
        /**
         * @deprecated
         */
        set formatByte(value: number);
        get formatByte(): number;
        get floatStride(): number;
        /**
         * Index of Float32Array: vData
         */
        get vDataOffset(): number;
        _isMeshBuffer: boolean;
        vData: Float32Array;
        iData: Uint16Array;
        /**
         * First vertex used in the current IA
         */
        vertexStart: number;
        /**
         * Vertex count used in the current IA
         */
        vertexRange: number;
        /**
         * First index used in the current IA
         */
        indexStart: number;
        /**
         * Index count used in the current IA
         */
        indexRange: number;
        lastFilledIndex: number;
        lastFilledVertex: number;
        frame: any;
        constructor(vertexFormat?: gfx.Attribute[]);
        request(vertexCount: number, indexCount: number): boolean;
        reserve(vertexCount: number, indexCount: number): boolean;
        resize(vertexCount: number, indexCount: number): void;
        updateRange(vertOffset: number, vertexCount: number, indexOffset: number, indexCount: number): void;
        requestIA(device: gfx.Device): gfx.InputAssembler;
        uploadBuffers(): void;
        freeIAPool(): void;
        reset(): void;
        clear(): void;
        protected _initIAInfo(device: gfx.Device): void;
        protected _reallocBuffer(vCount: any, iCount: any): void;
        setRenderDrawInfoAttributes(): void;
        particleInitRenderDrawInfo(entity: __private._cocos_2d_renderer_render_entity__RenderEntity): void;
    }
    export interface IAssembler {
        [key: string]: any;
    }
    export interface IAssemblerManager {
        getAssembler(component: UIRenderer): IAssembler;
    }
    export namespace UIVertexFormat {
        /**
         * @en Get total components count for all attributes per vertex.
         * @zh 获取每个顶点上所有属性的分量数总和
         * @param attrs All attributes of the vertex format
         * @returns Total components count
         */
        export function getComponentPerVertex(attrs: gfx.Attribute[]): number;
        /**
         * @en Get total stride for all attributes per vertex.
         * @zh 获取每个顶点上所有属性的总步进
         * @param attrs All attributes of the vertex format
         * @returns Total stride
         */
        export function getAttributeStride(attrs: gfx.Attribute[]): number;
        /**
         * @en Vertex format with vector 3 position attribute
         * @zh 包含三维位置属性的顶点格式
         */
        export const vfmt: gfx.Attribute[];
        /**
         * @en Vertex format with the following layout
         * 1. Vector 3 position attribute (Float32)
         * 2. Vector 4 color attribute (Float32)
         * @zh 包含以下数据的顶点格式
         * 1. 三维位置属性（Float32）
         * 2. RGBA 颜色属性（Float32）
         */
        export const vfmtPosColor: gfx.Attribute[];
        /**
         * @en Vertex format with the following layout
         * 1. Vector 3 position attribute (Float32)
         * 2. Vector 2 uv attribute (Float32)
         * 3. Vector 4 color attribute (Float32)
         * @zh 包含以下数据的顶点格式
         * 1. 三维位置属性（Float32）
         * 2. 二维贴图 UV 属性（Float32）
         * 3. RGBA 颜色属性（Float32）
         */
        export const vfmtPosUvColor: gfx.Attribute[];
        export const vfmtPosUvColor4B: gfx.Attribute[];
        /**
         * @en Vertex format with the following layout
         * 1. Vector 3 position attribute (Float32)
         * 2. Vector 2 uv attribute (Float32)
         * 3. First vector 4 color attribute (Float32)
         * 4. Second vector 4 color attribute (Float32)
         * @zh 包含以下数据的顶点格式
         * 1. 三维位置属性（Float32）
         * 2. 二维贴图 UV 属性（Float32）
         * 3. 第一套 RGBA 颜色属性（Float32）
         * 3. 第二套 RGBA 颜色属性（Float32）
         */
        export const vfmtPosUvTwoColor: gfx.Attribute[];
        export const vfmtPosUvTwoColor4B: gfx.Attribute[];
    }
    /**
     * @zh
     * UI 渲染流程
     */
    export class UI implements __private._cocos_2d_renderer_i_batcher__IBatcher {
        protected _nativeObj: __private._cocos_2d_renderer_native_2d__NativeBatcher2d;
        get nativeObj(): __private._cocos_2d_renderer_native_2d__NativeBatcher2d;
        get currBufferAccessor(): __private._cocos_2d_renderer_static_vb_accessor__StaticVBAccessor;
        get batches(): memop.CachedArray<__private._cocos_2d_renderer_draw_batch__DrawBatch2D>;
        set currStaticRoot(value: UIStaticBatch | null);
        set currIsStatic(value: boolean);
        device: gfx.Device;
        constructor(_root: Root);
        initialize(): boolean;
        destroy(): void;
        /**
         * @en
         * Add the managed Canvas.
         *
         * @zh
         * 添加屏幕组件管理。
         *
         * @param comp @en The render root of 2d.
         *             @zh 2d 渲染入口组件。
         */
        addScreen(comp: RenderRoot2D): void;
        /**
         * @zh
         * Removes the Canvas from the list.
         *
         * @param comp @en The target to removed.
         *             @zh 被移除的屏幕。
         */
        removeScreen(comp: RenderRoot2D): void;
        sortScreens(): void;
        getFirstRenderCamera(node: Node): renderer.scene.Camera | null;
        update(): void;
        uploadBuffers(): void;
        reset(): void;
        /**
         * @zh 如果有必要，为相应的顶点布局切换网格缓冲区。
         * @en Switch the mesh buffer for corresponding vertex layout if necessary.
         * @param attributes use VertexFormat.vfmtPosUvColor by default
         */
        switchBufferAccessor(attributes?: gfx.Attribute[]): __private._cocos_2d_renderer_static_vb_accessor__StaticVBAccessor;
        registerBufferAccessor(key: number, accessor: __private._cocos_2d_renderer_static_vb_accessor__StaticVBAccessor): void;
        updateBuffer(attributes: gfx.Attribute[], bid: number): void;
        /**
         * @en
         * Render component data submission process of UI.
         * The submitted vertex data is the UI for world coordinates.
         * For example: The UI components except Graphics and UIModel.
         *
         * @zh
         * UI 渲染组件数据提交流程（针对提交的顶点数据是世界坐标的提交流程，例如：除 Graphics 和 UIModel 的大部分 ui 组件）。
         * 此处的数据最终会生成需要提交渲染的 model 数据。
         *
         * @param comp - The committed renderable component
         * @param renderData - The render data being committed
         * @param frame - Texture or sprite frame related to the draw batch, could be null
         * @param assembler - The assembler for the current component, could be null
         * @param transform - Node type transform, if passed, then batcher will consider it's using model matrix, could be null
         */
        commitComp(comp: UIRenderer, renderData: BaseRenderData | null, frame: __private._cocos_core_assets_texture_base__TextureBase | SpriteFrame | null, assembler: any, transform: Node | null): void;
        /**
         * @en
         * Render component data submission process for individual [[gfx.InputAssembler]]
         * @zh
         * 渲染组件中针对独立 [[gfx.InputAssembler]] 的提交流程
         * 例如：Spine 和 DragonBones 等包含动态数据和材质的组件在内部管理 IA 并提交批次
         * @param comp - The committed renderable component
         * @param ia - The committed [[gfx.InputAssembler]]
         * @param tex - The texture used
         * @param mat - The material used
         * @param [transform] - The related node transform if the render data is based on node's local coordinates
         * @deprecated since v3.6.2, please use [[commitMiddleware]] instead
         */
        commitIA(renderComp: UIRenderer, ia: gfx.InputAssembler, tex?: __private._cocos_core_assets_texture_base__TextureBase, mat?: Material, transform?: Node): void;
        /**
         * @en
         * Render component data submission process for middleware2d components
         * @zh
         * 渲染组件中针对2D中间件组件渲染数据的提交流程
         * 例如：Spine 和 DragonBones 包含动态数据和材质的组件
         * @param comp - The committed renderable component
         * @param meshBuffer - The MeshBuffer used
         * @param indexOffset - indices offset
         * @param indexCount - indices count
         * @param tex - The texture used
         * @param mat - The material used
         * @param enableBatch - component support multi draw batch or not
         */
        commitMiddleware(comp: UIRenderer, meshBuffer: MeshBuffer, indexOffset: number, indexCount: number, tex: __private._cocos_core_assets_texture_base__TextureBase, mat: Material, enableBatch: boolean): void;
        /**
         * @en
         * Render component data submission process of UI.
         * The submitted vertex data is the UI for local coordinates.
         * For example: The UI components of Graphics and UIModel.
         *
         * @zh
         * UI 渲染组件数据提交流程（针对例如： Graphics 和 UIModel 等数据量较为庞大的 ui 组件）。
         *
         * @param comp - The committed renderable component
         * @param model - The committed model
         * @param mat - The material used, could be null
         */
        commitModel(comp: UIMeshRenderer | UIRenderer, model: renderer.scene.Model | null, mat: Material | null): void;
        setupStaticBatch(staticComp: UIStaticBatch, bufferAccessor: __private._cocos_2d_renderer_static_vb_accessor__StaticVBAccessor): void;
        endStaticBatch(): void;
        /**
         * @en
         * Submit separate render data.
         * This data does not participate in the batch.
         *
         * @zh
         * 提交独立渲染数据.
         * @param comp @en The UIStaticBatch component.
         *             @zh 静态组件
         */
        commitStaticBatch(comp: UIStaticBatch): void;
        /**
         * @en
         * End a section of render data and submit according to the batch condition.
         *
         * @zh
         * 根据合批条件，结束一段渲染数据并提交。
         */
        autoMergeBatches(renderComp?: UIRenderer): void;
        /**
         * @en
         * Force changes to current batch data and merge
         *
         * @zh
         * 强行修改当前批次数据并合并。
         *
         * @param material @en The material of the current batch.
         *                 @zh 当前批次的材质。
         * @param sprite @en Sprite frame of current batch.
         *               @zh 当前批次的精灵帧。
         */
        forceMergeBatches(material: Material, frame: __private._cocos_core_assets_texture_base__TextureBase | SpriteFrame | null, renderComp: UIRenderer): void;
        resetRenderStates(): void;
        /**
         * @en
         * Forced to merge the data of the previous batch to start a new batch.
         *
         * @zh
         * 强制合并上一个批次的数据，开启新一轮合批。
         */
        finishMergeBatches(): void;
        /**
         * @en
         * Force to change the current material.
         *
         * @zh
         * 强制刷新材质。
         */
        flushMaterial(mat: Material): void;
        walk(node: Node, level?: number): void;
        syncMeshBuffersToNative(accId: number, buffers: MeshBuffer[]): void;
    }
    /**
     * @deprecated since v3.6.0, this is an engine private interface that will be removed in the future.
     * @internal
     */
    export class UIDrawBatch extends __private._cocos_2d_renderer_draw_batch__DrawBatch2D {
    }
    export class QuadRenderData extends MeshRenderData {
        constructor(vertexFormat: any);
    }
    export const dynamicAtlasManager: __private._cocos_2d_utils_dynamic_atlas_atlas_manager__DynamicAtlasManager;
    /**
     * A utils class for parsing HTML texts. The parsed results will be an object array.
     * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
     */
    export interface IHtmlTextParserResultObj {
        text?: string;
        style?: IHtmlTextParserStack;
    }
    /**
     * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
     */
    export interface IHtmlTextParserStack {
        color?: string;
        size?: number;
        event?: {
            [k: string]: string;
        };
        isNewLine?: boolean;
        isImage?: boolean;
        src?: string;
        imageWidth?: number;
        imageHeight?: number;
        imageOffset?: string;
        imageAlign?: string;
        underline?: boolean;
        italic?: boolean;
        bold?: boolean;
        outline?: {
            color: string;
            width: number;
        };
    }
    /**
     * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
     */
    export class HtmlTextParser {
        constructor();
        parse(htmlString: string): IHtmlTextParserResultObj[];
    }
    export function getBaselineOffset(): number;
    export function isUnicodeCJK(ch: string): boolean;
    export function isUnicodeSpace(ch: string): boolean;
    export function safeMeasureText(ctx: CanvasRenderingContext2D, string: string, desc?: string): number;
    export function fragmentText(stringToken: string, allWidth: number, maxWidth: number, measureText: (string: string) => number): string[];
    export const BASELINE_RATIO = 0.26;
    export const MIDDLE_RATIO: number;
    export namespace utils {
        /**
         * @en Finds a node by hierarchy path, the path is case-sensitive.
         * It will traverse the hierarchy by splitting the path using '/' character.
         * This function will still returns the node even if it is inactive.
         * It is recommended to not use this function every frame instead cache the result at startup.
         * @zh 通过路径从节点树中查找节点的方法，路径是大小写敏感的，并且通过 `/` 来分隔节点层级。
         * 即使节点的状态是未启用的也可以找到，建议将结果缓存，而不是每次需要都去查找。
         * @param path The path of the target node
         * @param referenceNode If given, the search will be limited in the sub node tree of the reference node
         */
        export function find(path: string, referenceNode?: Node): Node | null;
        /**
         * @en
         * save a color buffer to a PPM file
         * @zh
         * 保存一个颜色缓冲到 PPM 文件中
         * @param buffer color buffer
         * @param w width
         * @param h height
         */
        export function toPPM(buffer: Uint8Array, w: number, h: number): string;
        export function readMesh(mesh: Mesh, iPrimitive?: number): primitives.IGeometry;
        /**
         * @deprecated
         */
        export function createMesh(geometry: primitives.IGeometry, out?: Mesh, options?: primitives.ICreateMeshOptions): Mesh;
        export namespace createMesh {
            /**
             * @deprecated
             */
            export interface IOptions {
                /**
                 * @en calculate mesh's aabb or not
                 * @zh 是否计算模型的包围盒。
                 */
                calculateBounds?: boolean;
            }
        }
        /**
         * @en mesh utility class, use to create mesh.
         * @zh 网格工具类，用于创建网格。
         */
        export class MeshUtils {
            /**
             * @en create a static mesh.
             * @zh 创建一个静态网格。
             * @param geometry @en geometry data use for creating @zh 用于创建的几何数据
             * @param out @en output static mesh @zh 输出的静态网格
             * @param options @en options of creating @zh 创建选项
             * @return @en The created static mesh, which is same as out @zh 新创建的静态网格，同 out 参数
             */
            static createMesh(geometry: primitives.IGeometry, out?: Mesh, options?: primitives.ICreateMeshOptions): Mesh;
            /**
             * @en create a dynamic mesh.
             * @zh 创建一个动态网格。
             * @param primitiveIndex @en sub mesh index @zh 子网格索引
             * @param geometry @en geometry data use for creating @zh 用于创建的几何数据
             * @param out @en output dynamic mesh @zh 输出的动态网格
             * @param options @en options of creating @zh 创建选项
             * @return @en The created dynamic mesh, which is same as out @zh 新创建的动态网格，同 out 参数
             */
            static createDynamicMesh(primitiveIndex: number, geometry: primitives.IDynamicGeometry, out?: Mesh, options?: primitives.ICreateDynamicMeshOptions): Mesh;
        }
        export function readBuffer(target: DataView, format?: gfx.Format, offset?: number, length?: number, stride?: number, out?: number[]): number[];
        export function writeBuffer(target: DataView, data: number[], format?: gfx.Format, offset?: number, stride?: number): void;
        export function mapBuffer(target: DataView, callback: (cur: number, idx: number, view: DataView) => number, format?: gfx.Format, offset?: number, length?: number, stride?: number, out?: DataView): DataView;
    }
    /**
     * @en Utility for 3d model static batching
     * @zh 服务于 3D 模型静态合批的工具类
     */
    export class BatchingUtility {
        /**
         * @en
         * Collect the Models under `staticModelRoot`,
         * merge all the meshes statically into one (while disabling each component),
         * and attach it to a new Model on `batchedRoot`.
         * The world transform of each model is guaranteed to be preserved.
         *
         * For a more fine-grained control over the process, use `Mesh.merge` directly.
         * @zh
         * 在`staticModelRoot`下收集模型。
         * 将所有的网格静态地合并成一个（同时禁用每个组件）。
         * 并将其附加到 `batchedRoot` 上的一个新模型。
         * 每个模型的世界变换都被保证保留下来。
         * 如果要对这个过程进行更精细的控制，可以直接使用 `Mesh.merge`。
         * @param staticModelRoot root of all the static models to be batched
         * @param batchedRoot the target output node
         */
        static batchStaticModel(staticModelRoot: Node, batchedRoot: Node): boolean;
        /**
         * @en
         * Undoes everything `batchStaticModel` did.
         * @zh
         * 回退 `batchStaticModel` 做的工作
         *
         * @param staticModelRoot root of all the static models to be batched
         * @param batchedRoot the target output node
         */
        static unbatchStaticModel(staticModelRoot: Node, batchedRoot: Node): boolean;
    }
    /**
     * @en A representation of a mesh asset
     * A mesh can contain multiple sub-mesh resources. The mesh mainly provides data such as vertices and indices for model instances.
     * @zh 代表一个网格资源
     * 一个网格可包含多个子网格资源，网格主要为模型实例提供顶点，索引等数据
     */
    export class Mesh extends Asset {
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        get _nativeAsset(): ArrayBuffer;
        set _nativeAsset(value: ArrayBuffer);
        /**
         * @en The sub meshes count of the mesh.
         * @zh 此网格的子网格数量。
         * @deprecated Please use [[renderingSubMeshes.length]] instead
         */
        get subMeshCount(): number;
        /**
         * @en The minimum position of all vertices in the mesh
         * @zh （各分量都）小于等于此网格任何顶点位置的最大位置。
         * @deprecated Please use [[struct.minPosition]] instead
         */
        get minPosition(): Readonly<math.Vec3> | undefined;
        /**
         * @en The maximum position of all vertices in the mesh
         * @zh （各分量都）大于等于此网格任何顶点位置的最大位置。
         * @deprecated Please use [[struct.maxPosition]] instead
         */
        get maxPosition(): Readonly<math.Vec3> | undefined;
        /**
         * @en The struct of the mesh
         * @zh 此网格的结构。
         */
        get struct(): Mesh.IStruct;
        /**
         * @en The actual data of the mesh
         * @zh 此网格的数据。
         */
        get data(): Uint8Array;
        /**
         * @en The hash of the mesh
         * @zh 此网格的哈希值。
         */
        get hash(): number;
        /**
         * @en The index of the joint buffer of all sub meshes in the joint map buffers
         * @zh 所有子网格的关节索引集合
         */
        get jointBufferIndices(): number[];
        /**
         * @en The sub meshes for rendering. Mesh could be split into different sub meshes for rendering.
         * @zh 此网格创建的渲染网格。
         */
        get renderingSubMeshes(): RenderingSubMesh[];
        /**
         * @en morph rendering data
         * @zh 变形渲染数据
         */
        morphRendering: __private._cocos_3d_assets_morph_rendering__MorphRendering | null;
        constructor();
        /**
         * @en complete loading callback
         * @zh 加载完成回调
         */
        onLoaded(): void;
        /**
         * @en mesh init
         * @zh 网格初始化函数
         */
        initialize(): void;
        /**
         * @en update dynamic sub mesh geometry
         * @zh 更新动态子网格的几何数据
         * @param primitiveIndex @en sub mesh index @zh 子网格索引
         * @param geometry @en sub mesh geometry data @zh 子网格几何数据
         */
        updateSubMesh(primitiveIndex: number, geometry: primitives.IDynamicGeometry): void;
        /**
         * @en Destroy the mesh and release all related GPU resources
         * @zh 销毁此网格，并释放它占有的所有 GPU 资源。
         */
        destroy(): boolean;
        /**
         * @en Release all related GPU resources
         * @zh 释放此网格占有的所有 GPU 资源。
         */
        destroyRenderingMesh(): void;
        /**
         * @en Reset the struct and data of the mesh
         * @zh 重置此网格的结构和数据。
         * @param struct @en The new struct @zh 新结构
         * @param data @en The new data @zh 新数据
         * @deprecated Will be removed in v3.0.0, please use [[reset]] instead
         */
        assign(struct: Mesh.IStruct, data: Uint8Array): void;
        /**
         * @en Reset the mesh with mesh creation information
         * @zh 重置此网格。
         * @param info @en Mesh creation information including struct and data @zh 网格创建信息，包含结构及数据
         */
        reset(info: Mesh.ICreateInfo): void;
        /**
         * @en Get [[geometry.AABB]] bounds in the skeleton's bone space
         * @zh 获取骨骼变换空间内下的 [[geometry.AABB]] 包围盒
         * @param skeleton @en skeleton data @zh 骨骼信息
         * @param skeleton @en skeleton data @zh 骨骼信息
         */
        getBoneSpaceBounds(skeleton: Skeleton): (geometry.AABB | null)[];
        /**
         * @en Merge the given mesh into the current mesh
         * @zh 合并指定的网格到此网格中。
         * @param mesh @en The mesh to be merged @zh 要合并的网格
         * @param worldMatrix @en The world matrix of the given mesh @zh 给定网格的模型变换矩阵
         * @param validate @en Whether to validate the mesh @zh 是否验证网格顶点布局
         * @returns @en whether the merging was successful or not @zh 返回合并成功与否
         */
        merge(mesh: Mesh, worldMatrix?: math.Mat4, validate?: boolean): boolean;
        /**
         * @en Validation for whether the given mesh can be merged into the current mesh.
         * To pass the validation, it must satisfy either of these two requirements:
         * - When the current mesh have no data
         * - When the two mesh have the same vertex bundle count, the same sub meshes count, and the same sub mesh layout.
         *
         * Same mesh layout means:
         * - They have the same primitive type and reference to the same amount vertex bundle with the same indices.
         * - And they all have or don't have index view
         * @zh 验证指定网格是否可以合并至当前网格。
         *
         * 当满足以下条件之一时，指定网格可以合并至当前网格：
         *  - 当前网格无数据而待合并网格有数据；
         *  - 它们的顶点块数目相同且对应顶点块的布局一致，并且它们的子网格数目相同且对应子网格的布局一致。
         *
         * 两个顶点块布局一致当且仅当：
         *  - 它们具有相同数量的顶点属性且对应的顶点属性具有相同的属性格式。
         *
         * 两个子网格布局一致，当且仅当：
         *  - 它们具有相同的图元类型并且引用相同数量、相同索引的顶点块；并且，
         *  - 要么都需要索引绘制，要么都不需要索引绘制。
         * @param mesh @en The other mesh to be validated @zh 待验证的网格
         */
        validateMergingMesh(mesh: Mesh): boolean;
        /**
         * @en Read the requested attribute of the given sub mesh
         * @zh 读取子网格的指定属性。
         * @param primitiveIndex @en Sub mesh index @zh 子网格索引
         * @param attributeName @en Attribute name @zh 属性名称
         * @returns @en Return null if not found or can't read, otherwise, will create a large enough typed array to contain all data of the attribute,
         * the array type will match the data type of the attribute. @zh 读取失败返回 null， 否则返回对应的类型数组
         */
        readAttribute(primitiveIndex: number, attributeName: gfx.AttributeName): __private._types_globals__TypedArray | null;
        /**
         * @en Read the requested attribute of the given sub mesh and fill into the given buffer.
         * @zh 读取子网格的指定属性到目标缓冲区中。
         * @param primitiveIndex @en Sub mesh index @zh 子网格索引
         * @param attributeName @en Attribute name @zh 属性名称
         * @param buffer @en The target array buffer @zh 目标缓冲区
         * @param stride @en attribute stride @zh 属性跨距
         * @param offset @en The offset of the first attribute in the target buffer @zh 第一个属性在目标缓冲区的偏移
         * @returns @en false if failed to access attribute, true otherwise @zh 是否成功拷贝
         */
        copyAttribute(primitiveIndex: number, attributeName: gfx.AttributeName, buffer: ArrayBuffer, stride: number, offset: number): boolean;
        /**
         * @en Read the indices data of the given sub mesh
         * @zh 读取子网格的索引数据。
         * @param primitiveIndex @en Sub mesh index @zh 子网格索引
         * @returns @en Return null if not found or can't read, otherwise, will create a large enough typed array to contain all indices data,
         * the array type will use the corresponding stride size. @zh 读取失败返回 null，否则返回索引数据
         */
        readIndices(primitiveIndex: number): Uint8Array | Uint16Array | Uint32Array | null;
        /**
         * @en Read the indices data of the given sub mesh and fill into the given array
         * @zh 读取子网格的索引数据到目标数组中。
         * @param primitiveIndex @en Sub mesh index @zh 子网格索引
         * @param outputArray @en The target output array @zh 目标索引数组
         * @returns @en Return false if failed to access the indices data, return true otherwise. @zh 拷贝失败返回 false， 否则返回 true
         */
        copyIndices(primitiveIndex: number, outputArray: number[] | ArrayBufferView): boolean;
        /**
         * @en Read the format by attributeName of submesh
         * @zh 根据属性名读取子网格的属性信息。
         * @param primitiveIndex @en Sub mesh index @zh 子网格索引
         * @param attributeName @en Attribute name @zh 属性名称
         * @returns @en Return null if failed to read format, return the format otherwise. @zh 读取失败返回 null， 否则返回 format
         */
        readAttributeFormat(primitiveIndex: number, attributeName: gfx.AttributeName): gfx.FormatInfo | null;
        /**
         * @en default init
         * @zh 默认初始化
         * @param uuid @en asset uuid @zh 资源 uuid
         */
        initDefault(uuid?: string): void;
        /**
         * @en Set whether the data of this mesh could be accessed (read or wrote), it could be used only for static mesh
         * @zh 设置此网格的数据是否可被存取，此接口只针对静态网格资源生效
         * @param allowDataAccess @en Indicate whether the data of this mesh could be accessed (read or wrote) @zh 是否允许存取网格数据
         */
        set allowDataAccess(allowDataAccess: boolean);
        /**
         * @en Get whether the data of this mesh could be read or wrote
         * @zh 获取此网格的数据是否可被存取
         * @return @en whether the data of this mesh could be accessed (read or wrote) @zh 此网格的数据是否可被存取
         */
        get allowDataAccess(): boolean;
    }
    export namespace Mesh {
        export interface IBufferView {
            offset: number;
            length: number;
            count: number;
            stride: number;
        }
        /**
         * @en Vertex bundle, it describes a set of interleaved vertex attributes and their values.
         * @zh 顶点块。顶点块描述了一组**交错排列**（interleaved）的顶点属性并存储了顶点属性的实际数据。<br>
         * 交错排列是指在实际数据的缓冲区中，每个顶点的所有属性总是依次排列，并总是出现在下一个顶点的所有属性之前。
         */
        export interface IVertexBundle {
            /**
             * @en The actual value for all vertex attributes.
             * You must use DataView to access the data.
             * Because there is no guarantee that the starting offsets of all properties are byte aligned as required by TypedArray.
             * @zh 所有顶点属性的实际数据块。
             * 你必须使用 DataView 来读取数据。
             * 因为不能保证所有属性的起始偏移都按 TypedArray 要求的字节对齐。
             */
            view: IBufferView;
            /**
             * @en All attributes included in the bundle
             * @zh 包含的所有顶点属性。
             */
            attributes: gfx.Attribute[];
        }
        /**
         * @en Sub mesh contains a list of primitives with the same type (Point, Line or Triangle)
         * @zh 子网格。子网格由一系列相同类型的图元组成（例如点、线、面等）。
         */
        export interface ISubMesh {
            /**
             * @en The vertex bundle references used by the sub mesh.
             * @zh 此子网格引用的顶点块，索引至网格的顶点块数组。
             */
            vertexBundelIndices: number[];
            /**
             * @en The primitive mode of the sub mesh
             * @zh 此子网格的图元类型。
             */
            primitiveMode: gfx.PrimitiveMode;
            /**
             * @en The index data of the sub mesh
             * @zh 此子网格使用的索引数据。
             */
            indexView?: IBufferView;
            /**
             * @en The joint map index in [[IStruct.jointMaps]]. Could be absent
             * @zh 此子网格使用的关节索引映射表在 [[IStruct.jointMaps]] 中的索引。
             * 如未定义或指向的映射表不存在，则默认 VB 内所有关节索引数据直接对应骨骼资源数据。
             */
            jointMapIndex?: number;
        }
        /**
         * @en dynamic info used to create dyanmic mesh
         * @zh 动态信息，用于创建动态网格
         */
        export interface IDynamicInfo {
            /**
             * @en max submesh count
             * @zh 最大子模型个数。
             */
            maxSubMeshes: number;
            /**
             * @en max submesh vertex count
             * @zh 子模型最大顶点个数。
             */
            maxSubMeshVertices: number;
            /**
             * @en max submesh index count
             * @zh 子模型最大索引个数。
             */
            maxSubMeshIndices: number;
        }
        /**
         * @en dynamic struct
         * @zh 动态结构体
         */
        export interface IDynamicStruct {
            /**
             * @en dynamic mesh info
             * @zh 动态模型信息。
             */
            info: IDynamicInfo;
            /**
             * @en dynamic submesh bounds
             * @zh 动态子模型包围盒。
             */
            bounds: geometry.AABB[];
        }
        /**
         * @en The structure of the mesh
         * @zh 描述了网格的结构。
         */
        export interface IStruct {
            /**
             * @en All vertex bundles of the mesh
             * @zh 此网格所有的顶点块。
             */
            vertexBundles: IVertexBundle[];
            /**
             * @en All sub meshes
             * @zh 此网格的所有子网格。
             */
            primitives: ISubMesh[];
            /**
             * @en The minimum position of all vertices in the mesh
             * @zh （各分量都）小于等于此网格任何顶点位置的最大位置。
             */
            minPosition?: math.Vec3;
            /**
             * @en The maximum position of all vertices in the mesh
             * @zh （各分量都）大于等于此网格任何顶点位置的最小位置。
             */
            maxPosition?: math.Vec3;
            /**
             * @en The joint index map list.
             * @zh 此网格使用的关节索引映射关系列表，数组长度应为子模型中实际使用到的所有关节，
             * 每个元素都对应一个原骨骼资源里的索引，按子模型 VB 内的实际索引排列。
             */
            jointMaps?: number[][];
            /**
             * @en The morph information of the mesh
             * @zh 网格的形变数据
             */
            morph?: Morph;
            /**
             * @en The specific data of the dynamic mesh
             * @zh 动态网格特有数据
             */
            dynamic?: IDynamicStruct;
        }
        /**
         * @en The create info of the mesh
         * @zh 网格创建信息
         */
        export interface ICreateInfo {
            /**
             * @en Mesh structure
             * @zh 网格结构。
             */
            struct: Mesh.IStruct;
            /**
             * @en Mesh binary data
             * @zh 网格二进制数据。
             */
            data: Uint8Array;
        }
    }
    /**
     * @en The skeleton asset. It stores the path related to [[SkinnedMeshRenderer.skinningRoot]] of all bones and its bind pose matrix.
     * @zh 骨骼资源。骨骼资源记录了每个关节（相对于 [[SkinnedMeshRenderer.skinningRoot]]）的路径以及它的绑定姿势矩阵。
     */
    export class Skeleton extends Asset {
        /**
         * @en The path of all bones, the length always equals the length of [[bindposes]]
         * @zh 所有关节的路径。该数组的长度始终与 [[bindposes]] 的长度相同。
         */
        get joints(): string[];
        set joints(value: string[]);
        /**
         * @en The bind poses matrix of all bones, the length always equals the length of [[joints]]
         * @zh 所有关节的绑定姿势矩阵。该数组的长度始终与 [[joints]] 的长度相同。
         */
        get bindposes(): math.Mat4[];
        set bindposes(value: math.Mat4[]);
        /**
         * @en Gets the inverse bind poses matrix
         * @zh 获取反向绑定姿势矩阵
         */
        get inverseBindposes(): math.Mat4[];
        /**
         * @en Gets the hash of the skeleton asset
         * @zh 获取骨骼资源的哈希值
         */
        get hash(): number;
        destroy(): boolean;
        /**
         * @en Check whether the skeleton is validate which means it has both joints and bindposes data.
         * @zh 检查当前骨骼对象是否是有效的，取决于它是否包含关节路径和绑定姿势数据。
         * @returns @en Whether the skeleton is valid or not @zh 此骨骼是否有效
         */
        validate(): boolean;
    }
    /**
     * @en Mesh morph data structure to describe the sub meshes data of all sub meshes,
     * it also contains all sub mesh morphs, global weights configuration and target names.
     * Normally the global weights configuration should be identical to the sub mesh morph weights,
     * but if not, the global weights in morph is less prioritized.
     * @zh 网格的形变数据结构，包含所有子网格形变数据，全局的权重配置和所有形变目标名称。
     * 一般来说，全局权重配置和子网格形变数据中保持一致，但如果有差异，以子网格形变数据中的权重配置为准。
     */
    export interface Morph {
        /**
         * Morph data of each sub-mesh.
         */
        subMeshMorphs: (SubMeshMorph | null)[];
        /**
         * Common initial weights of each sub-mesh.
         */
        weights?: number[];
        /**
         * Name of each target of each sub-mesh morph.
         * This field is only meaningful if every sub-mesh has the same number of targets.
         */
        targetNames?: string[];
    }
    /**
     * @en Morph target contains all displacements data of each vertex attribute like position and normal.
     * @zh 形变目标数据包含网格顶点属性在形变下的变化值，可能包含位移、法线等属性
     */
    export interface MorphTarget {
        /**
         * Displacement of each target attribute.
         */
        displacements: Mesh.IBufferView[];
    }
    /**
     * @en Sub mesh morph data describes all morph targets for one sub mesh,
     * including attributes in each morph target, morph targets data and weights corresponding each targets.
     * @zh 子网格形变数据描述一个子网格下所有的形变目标数据，包含顶点形变属性，形变目标数据和对应每个形变目标的权重。
     */
    export interface SubMeshMorph {
        /**
         * Attributes to morph.
         */
        attributes: gfx.AttributeName[];
        /**
         * Targets.
         */
        targets: MorphTarget[];
        /**
         * Initial weights of each target.
         */
        weights?: number[];
    }
    /**
     * @en Mesh renderer component for general 3d model rendering, it generates and link to a Model in the render scene.
     * It supports real time lighting and shadow, baked light map, and morph rendering.
     * @zh 用于通用模型渲染的网格渲染器组件，会创建并关联一个渲染场景中的模型对象。
     * 该组件支持实时光照和阴影，预烘焙光照贴图和形变网格渲染。
     */
    export class MeshRenderer extends ModelRenderer {
        /**
         * @en Shadow projection mode enumeration.
         * @zh 阴影投射方式枚举。
         */
        static ShadowCastingMode: {
            /**
             * @en Disable shadow projection.
             * @zh 不投射阴影。
             */
            OFF: number;
            /**
             * @en Enable shadow projection.
             * @zh 开启阴影投射。
             */
            ON: number;
        };
        /**
         * @en Shadow receive mode enumeration.
         * @zh 阴影接收方式枚举。
         */
        static ShadowReceivingMode: {
            /**
             * @en Disable shadow receiving.
             * @zh 不接收阴影。
             */
            OFF: number;
            /**
             * @en Enable shadow receiving.
             * @zh 开启阴影投射。
             */
            ON: number;
        };
        /**
         * @en The settings for light map baking
         * @zh 光照贴图烘焙的配置
         */
        lightmapSettings: __private._cocos_3d_framework_mesh_renderer__ModelLightmapSettings;
        protected _mesh: Mesh | null;
        protected _shadowCastingMode: number;
        protected _shadowReceivingMode: number;
        protected _shadowBias: number;
        protected _shadowNormalBias: number;
        /**
         * @en Local shadow bias for real time lighting.
         * @zh 实时光照下模型局部的阴影偏移。
         */
        get shadowBias(): number;
        set shadowBias(val: number);
        /**
         * @en local shadow normal bias for real time lighting.
         * @zh 实时光照下模型局部的阴影法线偏移。
         */
        get shadowNormalBias(): number;
        set shadowNormalBias(val: number);
        /**
         * @en Shadow projection mode.
         * @zh 实时光照下阴影投射方式。
         */
        get shadowCastingMode(): number;
        set shadowCastingMode(val: number);
        /**
         * @en receive shadow.
         * @zh 实时光照下是否接受阴影。
         */
        get receiveShadow(): number;
        set receiveShadow(val: number);
        /**
         * @en Gets or sets the mesh of the model.
         * Note, when set, all morph targets' weights would be reset to zero.
         * @zh 获取或设置模型的网格数据。
         * 注意，设置时，所有形变目标的权重都将归零。
         */
        get mesh(): Mesh | null;
        set mesh(val: Mesh | null);
        /**
         * @en Gets the model in [[RenderScene]].
         * @zh 获取渲染场景 [[RenderScene]] 中对应的模型。
         */
        get model(): renderer.scene.Model | null;
        /**
         * @en Whether to enable morph rendering.
         * @zh 是否启用形变网格渲染。
         */
        get enableMorph(): boolean;
        set enableMorph(value: boolean);
        protected _modelType: typeof renderer.scene.Model;
        protected _model: renderer.scene.Model | null;
        constructor();
        onLoad(): void;
        onRestore(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        onGeometryChanged(): void;
        /**
         * @zh 获取子网格指定形变目标的权重。
         * @en Gets the weight at specified morph target of the specified sub mesh.
         * @param subMeshIndex Index to the sub mesh.
         * @param shapeIndex Index to the morph target of the sub mesh.
         * @returns The weight.
         */
        getWeight(subMeshIndex: number, shapeIndex: number): number;
        /**
         * @zh
         * 设置子网格所有形变目标的权重。
         * `subMeshIndex` 是无效索引或 `weights` 的长度不匹配子网格的形变目标数量时，此方法不会生效。
         * @en
         * Sets weights of each morph target of the specified sub mesh.
         * If takes no effect if `subMeshIndex` is out of bounds or if `weights` has a different length with morph targets count of the sub mesh.
         * @param weights The weights.
         * @param subMeshIndex Index to the sub mesh.
         */
        setWeights(weights: number[], subMeshIndex: number): void;
        /**
         * @zh
         * 设置子网格指定外形的权重。
         * `subMeshIndex` 或 `shapeIndex` 是无效索引时，此方法不会生效。
         * @en
         * Sets the weight at specified shape of specified sub mesh.
         * If takes no effect if
         * `subMeshIndex` or `shapeIndex` out of bounds.
         * @param weight The weight.
         * @param subMeshIndex Index to the sub mesh.
         * @param shapeIndex Index to the shape of the sub mesh.
         */
        setWeight(weight: number, subMeshIndex: number, shapeIndex: number): void;
        setInstancedAttribute(name: string, value: ArrayLike<number>): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _updateLightmap(lightmap: Texture2D | null, uOff: number, vOff: number, scale: number, lum: number): void;
        protected _updateModels(): void;
        protected _createModel(): void;
        protected _attachToScene(): void;
        protected _detachFromScene(): void;
        protected _updateModelParams(): void;
        protected _onUpdateLightingmap(): void;
        protected _onUpdateLocalShadowBias(): void;
        protected _onMaterialModified(idx: number, material: Material | null): void;
        protected _onRebuildPSO(idx: number, material: Material): void;
        protected _onMeshChanged(old: Mesh | null): void;
        protected _clearMaterials(): void;
        protected _getBuiltinMaterial(): Material;
        protected _onVisibilityChange(val: number): void;
        protected _updateShadowBias(): void;
        protected _updateShadowNormalBias(): void;
        protected _updateCastShadow(): void;
        protected _updateReceiveShadow(): void;
        protected _isBatchingEnabled(): boolean;
    }
    export namespace MeshRenderer {
        /**
         * @en Shadow projection mode.
         * @zh 阴影投射方式。
         */
        export type ShadowCastingMode = __private._types_globals__EnumAlias<typeof __private._cocos_3d_framework_mesh_renderer__ModelShadowCastingMode>;
        /**
         * @en Shadow receive mode.
         * @zh 阴影接收方式。
         */
        export type ShadowReceivingMode = __private._types_globals__EnumAlias<typeof __private._cocos_3d_framework_mesh_renderer__ModelShadowReceivingMode>;
    }
    /**
     * @en The directional light component, only one real time directional light is permitted in one scene, it act as the main light of the scene.
     * @zh 平行光源组件，一个场景只允许存在一个实时的平行光源，作为场景的主光源存在。
     */
    export class DirectionalLight extends Light {
        protected _illuminanceHDR: number;
        protected _illuminanceLDR: number;
        protected _shadowEnabled: boolean;
        protected _shadowPcf: number;
        protected _shadowBias: number;
        protected _shadowNormalBias: number;
        protected _shadowSaturation: number;
        protected _shadowDistance: number;
        protected _shadowInvisibleOcclusionRange: number;
        protected _csmLevel: number;
        protected _csmLayerLambda: number;
        protected _csmOptimizationMode: number;
        protected _shadowFixedArea: boolean;
        protected _shadowNear: number;
        protected _shadowFar: number;
        protected _shadowOrthoSize: number;
        protected _type: renderer.scene.LightType;
        protected _light: renderer.scene.DirectionalLight | null;
        /**
         * @en The light source intensity.
         * @zh 光源强度。
         */
        get illuminance(): number;
        set illuminance(val: number);
        /**
         * @en Whether activate real time shadow.
         * @zh 是否启用实时阴影？
         */
        get shadowEnabled(): boolean;
        set shadowEnabled(val: boolean);
        /**
         * @en The shadow pcf for real time shadow.
         * @zh 实时阴影计算中的阴影 pcf 等级。
         */
        get shadowPcf(): number;
        set shadowPcf(val: number);
        /**
         * @en The shadow map sampler offset for real time shadow.
         * @zh 实时阴影计算中的阴影纹理偏移值。
         */
        get shadowBias(): number;
        set shadowBias(val: number);
        /**
         * @en The global normal bias for real time shadow.
         * @zh 实时阴影计算中的法线偏移。
         */
        get shadowNormalBias(): number;
        set shadowNormalBias(val: number);
        /**
         * @en The shadow color saturation for real time shadow.
         * @zh 实时阴影计算中的阴影颜色饱和度。
         */
        get shadowSaturation(): number;
        set shadowSaturation(val: number);
        /**
         * @en The potential shadow distance from the camera for real time shadow.
         * @zh 实时阴影计算中潜在阴影产生的范围
         */
        get shadowDistance(): number;
        set shadowDistance(val: number);
        /**
         * @en The occlusion range for real time shadow.
         * @zh 实时阴影计算中剔除阴影的范围
         */
        get shadowInvisibleOcclusionRange(): number;
        set shadowInvisibleOcclusionRange(val: number);
        /**
         * @en get or set shadow CSM level
         * @zh 获取或者设置阴影层级
         */
        get csmLevel(): number;
        set csmLevel(val: number);
        /**
         * @en enable csm
         * @zh 开启或关闭 csm 模式
         */
        get enableCSM(): boolean;
        set enableCSM(val: boolean);
        /**
         * @en get or set shadow CSM level ratio
         * @zh 获取或者设置阴影层级系数
         */
        get csmLayerLambda(): number;
        set csmLayerLambda(val: number);
        /**
         * @en get or set shadow CSM performance optimization mode
         * @zh 获取或者设置级联阴影性能优化模式
         * @internal
         */
        get csmOptimizationMode(): number;
        set csmOptimizationMode(val: number);
        /**
         * @en Whether to use fixed area shadow in real time shadow.
         * @zh 实时阴影计算中是否使用固定区域阴影。
         */
        get shadowFixedArea(): boolean;
        set shadowFixedArea(val: boolean);
        /**
         * @en The near clip plane of the shadow camera for fixed area shadow
         * @zh 固定区域阴影设置中阴影相机近裁剪面
         */
        get shadowNear(): number;
        set shadowNear(val: number);
        /**
         * @en The far clip plane of the shadow camera for fixed area shadow.
         * @zh 固定区域阴影设置中阴影相机远裁剪面。
         */
        get shadowFar(): number;
        set shadowFar(val: number);
        /**
         * @en The orthogonal size of the shadow camera for fixed area shadow.
         * @zh 固定区域阴影设置中阴影相机的正交尺寸
         */
        get shadowOrthoSize(): number;
        set shadowOrthoSize(val: number);
        constructor();
        protected _createLight(): void;
    }
    /**
     * @en The base class of all light components, contains basic light settings for both real time light and baked light.
     * @zh 光源组件基类，包含实时光源和烘焙光源的基本配置信息。
     */
    export class Light extends Component {
        /**
         * @en The light type enumeration.
         * @zh 光源类型枚举。
         */
        static Type: typeof renderer.scene.LightType;
        /**
         * @en The physical term used for light.
         * @zh 光源所使用的物理计量单位。
         */
        static PhotometricTerm: {
            LUMINOUS_FLUX: number;
            LUMINANCE: number;
        };
        protected _color: math.Color;
        protected _useColorTemperature: boolean;
        protected _colorTemperature: number;
        protected _staticSettings: __private._cocos_3d_lights_light_component__StaticLightSettings;
        protected _type: renderer.scene.LightType;
        protected _lightType: typeof renderer.scene.Light;
        protected _light: renderer.scene.Light | null;
        /**
         * @en The color of the light.
         * @zh 光源颜色。
         */
        get color(): Readonly<math.Color>;
        set color(val: Readonly<math.Color>);
        /**
         * @en
         * Whether to enable light color temperature.
         * @zh
         * 是否启用光源色温。
         */
        get useColorTemperature(): boolean;
        set useColorTemperature(enable: boolean);
        /**
         * @en
         * The light color temperature.
         * @zh
         * 光源色温。
         */
        get colorTemperature(): number;
        set colorTemperature(val: number);
        /**
         * @en
         * static light settings.
         * @zh
         * 静态灯光设置。
         */
        get staticSettings(): __private._cocos_3d_lights_light_component__StaticLightSettings;
        set staticSettings(val: __private._cocos_3d_lights_light_component__StaticLightSettings);
        /**
         * @en The light type.
         * @zh 光源类型。
         */
        get type(): renderer.scene.LightType;
        /**
         * @en Whether the light is baked
         * @zh 光源是否被烘焙
         */
        get baked(): boolean;
        set baked(val: boolean);
        constructor();
        onLoad(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        protected _createLight(): void;
        protected _destroyLight(): void;
        protected _attachToScene(): void;
        protected _detachFromScene(): void;
    }
    export namespace Light {
        export type Type = __private._types_globals__EnumAlias<typeof renderer.scene.LightType>;
        export type PhotometricTerm = __private._types_globals__EnumAlias<typeof __private._cocos_3d_lights_light_component__PhotometricTerm>;
    }
    /**
     * @en The sphere light component, multiple sphere lights can be added to one scene.
     * @zh 球面光源组件，场景中可以添加多个球面光源。
     */
    export class SphereLight extends Light {
        protected _size: number;
        protected _luminanceHDR: number;
        protected _luminanceLDR: number;
        protected _term: number;
        protected _range: number;
        protected _type: renderer.scene.LightType;
        protected _light: renderer.scene.SphereLight | null;
        /**
         * @en Luminous flux of the light.
         * @zh 光通量。
         */
        get luminousFlux(): number;
        set luminousFlux(val: number);
        /**
         * @en Luminance of the light.
         * @zh 光亮度。
         */
        get luminance(): number;
        set luminance(val: number);
        /**
         * @en The photometric term currently being used.
         * @zh 当前使用的光度学计量单位。
         */
        get term(): number;
        set term(val: number);
        /**
         * @en
         * Size of the light.
         * @zh
         * 光源大小。
         */
        get size(): number;
        set size(val: number);
        /**
         * @en
         * Range of the light.
         * @zh
         * 光源范围。
         */
        get range(): number;
        set range(val: number);
        constructor();
        protected _createLight(): void;
    }
    /**
     * @en The spot light component, multiple spot lights can be added to one scene.
     * @zh 聚光灯光源组件，场景中可以添加多个聚光灯光源。
     */
    export class SpotLight extends Light {
        protected _size: number;
        protected _luminanceHDR: number;
        protected _luminanceLDR: number;
        protected _term: number;
        protected _range: number;
        protected _spotAngle: number;
        protected _shadowEnabled: boolean;
        protected _shadowPcf: number;
        protected _shadowBias: number;
        protected _shadowNormalBias: number;
        protected _type: renderer.scene.LightType;
        protected _light: renderer.scene.SpotLight | null;
        /**
         * @en Luminous flux of the light.
         * @zh 光通量。
         */
        get luminousFlux(): number;
        set luminousFlux(val: number);
        /**
         * @en Luminance of the light.
         * @zh 光亮度。
         */
        get luminance(): number;
        set luminance(val: number);
        /**
         * @en The photometric term currently being used.
         * @zh 当前使用的光度学计量单位。
         */
        get term(): number;
        set term(val: number);
        /**
         * @en
         * Size of the light.
         * @zh
         * 光源大小。
         */
        get size(): number;
        set size(val: number);
        /**
         * @en
         * Range of the light.
         * @zh
         * 光源范围。
         */
        get range(): number;
        set range(val: number);
        /**
         * @en
         * The spot light cone angle.
         * @zh
         * 聚光灯锥角。
         */
        get spotAngle(): number;
        set spotAngle(val: number);
        /**
         * @en Whether activate shadow
         * @zh 是否启用阴影？
         */
        get shadowEnabled(): boolean;
        set shadowEnabled(val: boolean);
        /**
         * @en The pcf level of the shadow generation.
         * @zh 获取或者设置阴影 pcf 等级。
         */
        get shadowPcf(): number;
        set shadowPcf(val: number);
        /**
         * @en The depth offset of shadow to avoid moire pattern artifacts
         * @zh 阴影的深度偏移, 可以减弱跨像素导致的条纹状失真
         */
        get shadowBias(): number;
        set shadowBias(val: number);
        /**
         * @en The normal bias of the shadow map.
         * @zh 设置或者获取法线偏移。
         */
        get shadowNormalBias(): number;
        set shadowNormalBias(val: number);
        constructor();
        protected _createLight(): void;
    }
    /**
     * @en The skinned mesh renderer component.
     * @zh 蒙皮网格渲染器组件。
     */
    export class SkinnedMeshRenderer extends MeshRenderer {
        protected _skeleton: Skeleton | null;
        protected _skinningRoot: Node | null;
        protected _clip: AnimationClip | null;
        /**
         * @en The skeleton asset.
         * @zh 骨骼资源。
         */
        get skeleton(): Skeleton | null;
        set skeleton(val: Skeleton | null);
        /**
         * @en The skinning root. (The node where the controlling Animation is located)
         * @zh 骨骼根节点的引用，对应控制此模型的动画组件所在节点。
         */
        get skinningRoot(): Node | null;
        set skinningRoot(value: Node | null);
        get model(): __private._cocos_3d_models_skinning_model__SkinningModel | __private._cocos_3d_models_baked_skinning_model__BakedSkinningModel | null;
        /**
         * Set associated animation.
         * @internal This method only friends to skeletal animation component.
         */
        associatedAnimation: SkeletalAnimation | null;
        constructor();
        onLoad(): void;
        onDestroy(): void;
        uploadAnimation(clip: AnimationClip | null): void;
        /**
         * Set if bake mode should be used.
         * @internal This method only friends to skeletal animation component.
         */
        setUseBakedAnimation(val?: boolean, force?: boolean): void;
        setMaterial(material: Material | null, index: number): void;
        protected _updateModelParams(): void;
    }
    /**
     * @en The skinned mesh batch renderer component, batches multiple skeleton-sharing [[SkinnedMeshRenderer]].
     * @zh 蒙皮模型合批组件，用于合并绘制共享同一骨骼资源的所有蒙皮网格。
     */
    export class SkinnedMeshBatchRenderer extends SkinnedMeshRenderer {
        /**
         * @en Size of the generated texture atlas.
         * @zh 合图生成的最终图集的边长。
         */
        atlasSize: number;
        /**
         * @en
         * Texture properties that will be actually using the generated atlas.<br>
         * The first unit's texture will be used if not specified.
         * @zh
         * 材质中真正参与合图的贴图属性，不参与的属性统一使用第一个 unit 的贴图。
         */
        batchableTextureNames: string[];
        /**
         * @en Source skinning model components, containing all the data to be batched.
         * @zh 合批前的子蒙皮模型数组，最主要的数据来源。
         */
        units: SkinnedMeshUnit[];
        get mesh(): Mesh | null;
        set mesh(val: Mesh | null);
        get skeleton(): Skeleton | null;
        set skeleton(val: Skeleton | null);
        onLoad(): void;
        onDestroy(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _onMaterialModified(idx: number, material: Material | null): void;
        cook(): void;
        cookMaterials(): void;
        cookSkeletons(): void;
        cookMeshes(): void;
        protected cookTextures(target: Texture2D, prop: string, passIdx: number): void;
        protected createTexture(prop: string): Texture2D;
        protected resizeAtlases(): void;
    }
    export class SkinnedMeshUnit {
        /**
         * @en Skinned mesh of this unit.
         * @zh 子蒙皮模型的网格模型。
         */
        mesh: Mesh | null;
        /**
         * @en Skeleton of this unit.
         * @zh 子蒙皮模型的骨骼。
         */
        skeleton: Skeleton | null;
        /**
         * @en Skinning material of this unit.
         * @zh 子蒙皮模型使用的材质。
         */
        material: Material | null;
        /**
         * @en Local transform matrix
         * @zh 本地变换矩阵
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _localTransform: math.Mat4;
        /**
         * @en UV offset on texture atlas.
         * @zh 在图集中的 uv 坐标偏移。
         */
        set offset(offset: math.Vec2);
        get offset(): math.Vec2;
        /**
         * @en UV extent on texture atlas.
         * @zh 在图集中占的 UV 尺寸。
         */
        set size(size: math.Vec2);
        get size(): math.Vec2;
        /**
         * @en Convenient setter, copying all necessary information from target [[SkinnedMeshRenderer]] component.
         * @zh 复制目标 [[SkinnedMeshRenderer]] 的所有属性到本单元，方便快速配置。
         */
        set copyFrom(comp: SkinnedMeshRenderer | null);
        get copyFrom(): SkinnedMeshRenderer | null;
    }
    export namespace easing {
        export function constant(): number;
        export function linear(k: number): number;
        export function quadIn(k: number): number;
        export function quadOut(k: number): number;
        export function quadInOut(k: number): number;
        export function cubicIn(k: number): number;
        export function cubicOut(k: number): number;
        export function cubicInOut(k: number): number;
        export function quartIn(k: number): number;
        export function quartOut(k: number): number;
        export function quartInOut(k: number): number;
        export function quintIn(k: number): number;
        export function quintOut(k: number): number;
        export function quintInOut(k: number): number;
        export function sineIn(k: number): number;
        export function sineOut(k: number): number;
        export function sineInOut(k: number): number;
        export function expoIn(k: number): number;
        export function expoOut(k: number): number;
        export function expoInOut(k: number): number;
        export function circIn(k: number): number;
        export function circOut(k: number): number;
        export function circInOut(k: number): number;
        export function elasticIn(k: number): number;
        export function elasticOut(k: number): number;
        export function elasticInOut(k: number): number;
        export function backIn(k: number): number;
        export function backOut(k: number): number;
        export function backInOut(k: number): number;
        export function bounceIn(k: number): number;
        export function bounceOut(k: number): number;
        export function bounceInOut(k: number): number;
        export function smooth(k: number): number;
        export function fade(k: number): number;
        export const quadOutIn: (k: number) => number;
        export const cubicOutIn: (k: number) => number;
        export const quartOutIn: (k: number) => number;
        export const quintOutIn: (k: number) => number;
        export const sineOutIn: (k: number) => number;
        export const expoOutIn: (k: number) => number;
        export const circOutIn: (k: number) => number;
        export const elasticOutIn: (k: number) => number;
        export const backOutIn: (k: number) => number;
        export const bounceOutIn: (k: number) => number;
    }
    /**
     * @zh 动画剪辑表示一段使用动画编辑器编辑的关键帧动画或是外部美术工具生产的骨骼动画。
     * 它的数据主要被分为几层：轨道、关键帧和曲线。
     * @en The animation clip represents a sequence of key frame animation created with the animation editor or skeletal animation other DCC tools.
     * The data is divided in different levels: tracks, key frames, curves.
     */
    export class AnimationClip extends Asset {
        static WrapMode: typeof __private._cocos_core_animation_types__WrapMode;
        /**
         * @en Crate clip with a set of sprite frames
         * @zh 使用一组序列帧图片来创建动画剪辑
         * @example
         * ```
         * import { AnimationClip } from 'cc';
         * const clip = AnimationClip.createWithSpriteFrames(spriteFrames, 10);
         * ```
         */
        static createWithSpriteFrames(spriteFrames: SpriteFrame[], sample: number): AnimationClip;
        /**
         * @zh 动画帧率，单位为帧/秒。注意此属性仅用于编辑器动画编辑。
         * @en Animation frame rate: frames per second.
         * Note this property is only used for animation editing in Editor.
         */
        sample: number;
        /**
         * @zh 动画的播放速度。
         * @en Animation playback speed.
         */
        speed: number;
        /**
         * @zh 动画的循环模式。
         * @en Animation loop mode.
         */
        wrapMode: __private._cocos_core_animation_types__WrapMode;
        /**
         * Sets if node TRS curves in this animation can be blended.
         * Normally this flag is enabled for model animation and disabled for other case.
         * @internal This is an internal slot. Never use it in your code.
         */
        enableTrsBlending: boolean;
        /**
         * @zh 动画的周期。
         * @en Animation duration.
         */
        get duration(): number;
        set duration(value: number);
        /**
         * @en
         * Gets the count of tracks this animation owns.
         * @zh
         * 获取此动画中的轨道数量。
         */
        get tracksCount(): number;
        /**
         * @en
         * Gets an iterable to tracks.
         * @zh
         * 获取可用于迭代轨道的对象。
         */
        get tracks(): Iterable<animation.Track>;
        get hash(): number;
        /**
         * @zh 动画包含的事件数据。
         * @en Associated event data.
         */
        get events(): AnimationClip.IEvent[];
        set events(value: AnimationClip.IEvent[]);
        get [exoticAnimationTag](): ExoticAnimation | null;
        set [exoticAnimationTag](value: ExoticAnimation | null);
        onLoaded(): void;
        /**
         * @en
         * Counts the time range that the tracks within this animation span.
         * @zh
         * 获取此动画所有轨道占据的时间范围。
         * @returns The time range.
         */
        range(): __private._cocos_core_animation_tracks_utils__Range;
        /**
         * @en
         * Gets the specified track.
         * @zh
         * 获取指定的轨道。
         * @param index Index to the track.
         * @returns The track.
         */
        getTrack(index: number): animation.Track;
        /**
         * @en
         * Adds a track into this animation.
         * @zh
         * 添加一个轨道到此动画中。
         * @param track The track.
         * @returns Index to the track.
         */
        addTrack(track: animation.Track): number;
        /**
         * @en
         * Removes a track from this animation.
         * @zh
         * 移除此动画中的指定轨道。
         * @param index Index to the track.
         */
        removeTrack(index: number): void;
        /**
         * @en
         * Removes all tracks from this animation.
         * @zh
         * 移除此动画的所有轨道。
         */
        clearTracks(): void;
        /**
         * Returns if this clip has any event.
         * @internal Do not use this in your code.
         */
        containsAnyEvent(): boolean;
        /**
         * Creates an event evaluator for this animation.
         * @param targetNode Target node used to fire events.
         * @internal Do not use this in your code.
         */
        createEventEvaluator(targetNode: Node): __private._cocos_core_animation_animation_clip__EventEvaluator;
        /**
         * Returns if this clip has any embedded player.
         * @internal Do not use this in your code.
         */
        containsAnyEmbeddedPlayer(): boolean;
        /**
         * Creates an embedded player evaluator for this animation.
         * @param targetNode Target node.
         * @internal Do not use this in your code.
         */
        createEmbeddedPlayerEvaluator(targetNode: Node): __private._cocos_core_animation_animation_clip__EmbeddedPlayerEvaluation;
        /**
         * Creates an evaluator for this animation.
         * @param context The context.
         * @returns The evaluator.
         * @internal Do not use this in your code.
         */
        createEvaluator(context: __private._cocos_core_animation_animation_clip__AnimationClipEvalContext): __private._cocos_core_animation_animation_clip__AnimationClipEvaluation;
        destroy(): boolean;
        [__private._cocos_core_animation_internal_symbols__BAKE_SKELETON_CURVE_SYMBOL](start: number, samples: number, frames: number): __private._cocos_core_animation_animation_clip__SkeletonAnimationBakeInfo;
        /**
         * Convert all untyped tracks into typed ones and delete the original.
         * @param refine How to decide the type on specified path.
         * @internal DO NOT USE THIS IN YOUR CODE.
         */
        upgradeUntypedTracks(refine: __private._cocos_core_animation_tracks_untyped_track__UntypedTrackRefine): void;
        /**
         * @internal Export for test.
         */
        [__private._cocos_core_animation_animation_clip__searchForRootBonePathSymbol](): string;
        /**
         * @zh 曲线可引用的所有时间轴。
         * @en Frame keys referenced by curves.
         * @deprecated Since V3.3. Please reference to the track/channel/curve mechanism introduced in V3.3.
         */
        get keys(): number[][];
        set keys(value: number[][]);
        /**
         * @zh 此动画包含的所有曲线。
         * @en Curves this animation contains.
         * @deprecated Since V3.3. Please reference to the track/channel/curve mechanism introduced in V3.3.
         */
        get curves(): AnimationClip._legacy.LegacyClipCurve[];
        set curves(value: AnimationClip._legacy.LegacyClipCurve[]);
        /**
         * @deprecated Since V3.3. Please reference to the track/channel/curve mechanism introduced in V3.3.
         */
        get commonTargets(): AnimationClip._legacy.LegacyCommonTarget[];
        set commonTargets(value: AnimationClip._legacy.LegacyCommonTarget[]);
        /**
         * @en
         * The animation's data.
         * @zh
         * 此动画的数据。
         * @deprecated Since V3.3. Please reference to the track/channel/curve mechanism introduced in V3.3.
         */
        get data(): Uint8Array | null;
        /**
         * @deprecated Since V3.3. Please reference to the track/channel/curve mechanism introduced in V3.3.
         */
        getPropertyCurves(): readonly AnimationClip._legacy.LegacyRuntimeCurve[];
        /**
         * @deprecated Since V3.3. Please reference to the track/channel/curve mechanism introduced in V3.3.
         */
        get eventGroups(): readonly __private._cocos_core_animation_animation_clip__IAnimationEventGroup[];
        /**
         * @zh 提交事件数据的修改。
         * 当你修改了 `this.events` 时，必须调用 `this.updateEventDatas()` 使修改生效。
         * @en
         * Commit event data update.
         * You should call this function after you changed the `events` data to take effect.
         * @deprecated Since V3.3. Please Assign to `this.events`.
         */
        updateEventDatas(): void;
        /**
         * @zh 返回本动画是否包含事件数据。
         * @en Returns if this animation contains event data.
         * @protected
         */
        hasEvents(): boolean;
        /**
         * Migrates legacy data into tracks.
         * NOTE: This method tend to be used as internal purpose or patch.
         * DO NOT use it in your code since it might be removed for the future at any time.
         * @internal Since V3.3. Please reference to the track/channel/curve mechanism introduced in V3.3.
         */
        syncLegacyData(): void;
        /**
         * @internal
         */
        get [embeddedPlayerCountTag](): number;
        /**
         * @internal
         */
        [getEmbeddedPlayersTag](): Iterable<EmbeddedPlayer>;
        /**
         * @internal
         */
        [addEmbeddedPlayerTag](embeddedPlayer: EmbeddedPlayer): void;
        /**
         * @internal
         */
        [removeEmbeddedPlayerTag](embeddedPlayer: EmbeddedPlayer): void;
        /**
         * @internal
         */
        [clearEmbeddedPlayersTag](): void;
    }
    export namespace AnimationClip {
        export interface IEvent {
            frame: number;
            func: string;
            params: string[];
        }
        export namespace _legacy {
            export class AnimationClipLegacyData {
                constructor(duration: number);
                get keys(): number[][];
                set keys(value: number[][]);
                get curves(): LegacyClipCurve[];
                set curves(value: LegacyClipCurve[]);
                get commonTargets(): LegacyCommonTarget[];
                set commonTargets(value: LegacyCommonTarget[]);
                /**
                 * 此动画的数据。
                 */
                get data(): Uint8Array | null;
                getPropertyCurves(): readonly LegacyRuntimeCurve[];
                toTracks(): animation.Track[];
                protected _createPropertyCurves(): void;
            }
            /**
             * Legacy curve uses time based bezier curve interpolation.
             * That's, interpolate time 'x'(time ratio between two frames, eg.[0, 1])
             * and then use the interpolated time to sample curve.
             * Now we need to compute the the end tangent of previous frame and the start tangent of the next frame.
             * @param timeBezierPoints Bezier points used for legacy time interpolation.
             * @param previousTime Time of the previous keyframe.
             * @param previousValue Value of the previous keyframe.
             * @param nextTime Time of the next keyframe.
             * @param nextValue Value of the next keyframe.
             */
            export function timeBezierToTangents(timeBezierPoints: BezierControlPoints, previousTime: number, previousKeyframe: RealKeyframeValue, nextTime: number, nextKeyframe: RealKeyframeValue): void;
            /**
             * 表示曲线值，曲线值可以是任意类型，但必须符合插值方式的要求。
             */
            export type LegacyCurveValue = any;
            /**
             * 表示曲线的目标对象。
             */
            export type LegacyCurveTarget = Record<string, any>;
            /**
             * 内置帧时间渐变方式名称。
             */
            export type LegacyEasingMethodName = keyof (typeof easing);
            /**
             * 帧时间渐变方式。可能为内置帧时间渐变方式的名称或贝塞尔控制点。
             */
            export type LegacyEasingMethod = LegacyEasingMethodName | BezierControlPoints;
            export type LegacyCompressedEasingMethods = Record<number, LegacyEasingMethod>;
            export type LegacyLerpFunction<T = any> = (from: T, to: T, t: number, dt: number) => T;
            export interface LegacyClipCurveData {
                /**
                 * 曲线使用的时间轴。
                 * @see {AnimationClip.keys}
                 */
                keys: number;
                /**
                 * 曲线值。曲线值的数量应和 `keys` 所引用时间轴的帧数相同。
                 */
                values: LegacyCurveValue[];
                /**
                 * 曲线任意两帧时间的渐变方式。仅当 `easingMethods === undefined` 时本字段才生效。
                 */
                easingMethod?: LegacyEasingMethod;
                /**
                 * 描述了每一帧时间到下一帧时间之间的渐变方式。
                 */
                easingMethods?: LegacyEasingMethod[] | LegacyCompressedEasingMethods;
                /**
                 * 是否进行插值。
                 * @default true
                 */
                interpolate?: boolean;
                /**
                 * For internal usage only.
                 */
                _arrayLength?: number;
            }
            export interface LegacyClipCurve {
                commonTarget?: number;
                modifiers: animation.TargetPath[];
                valueAdapter?: animation.IValueProxyFactory;
                data: LegacyClipCurveData;
            }
            export interface LegacyCommonTarget {
                modifiers: animation.TargetPath[];
                valueAdapter?: animation.IValueProxyFactory;
            }
            export type LegacyMaybeCompactCurve = Omit<LegacyClipCurve, "data"> & {
                data: Omit<LegacyClipCurveData, "values"> & {
                    values: any[] | CompactValueTypeArray;
                };
            };
            export type LegacyMaybeCompactKeys = Array<number[] | CompactValueTypeArray>;
            export type LegacyRuntimeCurve = Pick<LegacyClipCurve, "modifiers" | "valueAdapter" | "commonTarget"> & {
                /**
                 * 属性曲线。
                 */
                curve: AnimCurve;
                /**
                 * 曲线采样器。
                 */
                sampler: RatioSampler | null;
            };
            export interface LegacyObjectCurveData {
                [propertyName: string]: LegacyClipCurveData;
            }
            export interface LegacyComponentsCurveData {
                [componentName: string]: LegacyObjectCurveData;
            }
            export interface LegacyNodeCurveData {
                props?: LegacyObjectCurveData;
                comps?: LegacyComponentsCurveData;
            }
        }
        export type WrapMode = __private._cocos_core_animation_animation_clip__WrapMode_;
    }
    /**
     * @en
     * The AnimationState gives full control over animation playback process.
     * In most cases the Animation Component is sufficient and easier to use. Use the AnimationState if you need full control.
     * @zh
     * AnimationState 完全控制动画播放过程。<br/>
     * 大多数情况下 动画组件 是足够和易于使用的。如果您需要更多的动画控制接口，请使用 AnimationState。
     *
     */
    export class AnimationState extends __private._cocos_core_animation_playable__Playable {
        /**
         * @en The clip that is being played by this animation state.
         * @zh 此动画状态正在播放的剪辑。
         */
        get clip(): AnimationClip;
        /**
         * @en The name of the playing animation.
         * @zh 动画的名字。
         */
        get name(): string;
        get length(): number;
        /**
         * @en
         * Wrapping mode of the playing animation.
         * Notice : dynamic change wrapMode will reset time and repeatCount property
         * @zh
         * 动画循环方式。
         * 需要注意的是，动态修改 wrapMode 时，会重置 time 以及 repeatCount。
         * @default: WrapMode.Normal
         */
        get wrapMode(): __private._cocos_core_animation_types__WrapMode;
        set wrapMode(value: __private._cocos_core_animation_types__WrapMode);
        /**
         * @en The animation's iteration count property.
         *
         * A real number greater than or equal to zero (including positive infinity) representing the number of times
         * to repeat the animation node.
         *
         * Values less than zero and NaN values are treated as the value 1.0 for the purpose of timing model
         * calculations.
         *
         * @zh 迭代次数，指动画播放多少次后结束, normalize time。 如 2.5（2次半）。
         *
         * @default 1
         */
        get repeatCount(): number;
        set repeatCount(value: number);
        /**
         * @en The start delay which represents the number of seconds from an animation's start time to the start of
         * the active interval.
         * @zh 延迟多少秒播放。
         * @default 0
         */
        get delay(): number;
        set delay(value: number);
        /**
         * @en The iteration duration of this animation in seconds. (length)
         * @zh 单次动画的持续时间，秒。（动画长度）
         * @readOnly
         */
        duration: number;
        /**
         * @en
         * Gets or sets the playback range.
         * The `min` and `max` field of the range are measured in seconds.
         * While setting, the range object should be a valid range.
         * The actual playback range would be the inclusion of this field and [0, duration].
         * @zh
         * 获取或设置播放范围。
         * 范围的 `min`、`max` 字段都是以秒为单位的。
         * 设置时，应当指定一个有效的范围；实际的播放范围是该字段和 [0, 周期] 之间的交集。
         * 设置播放范围时将重置累计播放时间。
         */
        get playbackRange(): Readonly<{
            min: number;
            max: number;
        }>;
        set playbackRange(value: Readonly<{
            min: number;
            max: number;
        }>);
        /**
         * @en The animation's playback speed. 1 is normal playback speed.
         * @zh 播放速率。
         * @default: 1.0
         */
        get speed(): number;
        set speed(value: number);
        /**
         * @en The current accumulated time of this animation in seconds.
         * @zh 动画当前**累计播放**的时间，单位为秒。
         * @default 0
         */
        time: number;
        /**
         * @en Gets the time progress, in seconds.
         * @zh 获取动画的时间进度，单位为秒。
         */
        get current(): number;
        /**
         * @en Gets the playback ratio.
         * @zh 获取动画播放的比例时间。
         */
        get ratio(): number;
        /**
         * @en
         * The weight of this animation state.
         * @zh
         * 此动画状态的权重。
         */
        get weight(): number;
        set weight(value: number);
        frameRate: number;
        /**
         * @internal This field is only visible from within internal.
         */
        protected _targetNode: Node | null;
        /**
         * @internal This field is only visible from within internal.
         */
        protected _curveLoaded: boolean;
        /**
         * @internal For internal usage. Really hack...
         */
        protected _doNotCreateEval: boolean;
        constructor(clip: AnimationClip, name?: string);
        /**
         * This method is used for internal purpose only.
         */
        get curveLoaded(): boolean;
        initialize(root: Node, blendStateBuffer?: __private._cocos_3d_skeletal_animation_skeletal_animation_blending__BlendStateBuffer, mask?: AnimationMask): void;
        destroy(): void;
        /**
         * @deprecated Since V1.1.1, animation states were no longer defined as event targets.
         * To process animation events, use `Animation` instead.
         */
        emit(...args: any[]): void;
        /**
         * @deprecated Since V1.1.1, animation states were no longer defined as event targets.
         * To process animation events, use `Animation` instead.
         */
        on(type: string, callback: Function, target?: any): void | null;
        /**
         * @deprecated Since V1.1.1, animation states were no longer defined as event targets.
         * To process animation events, use `Animation` instead.
         */
        once(type: string, callback: Function, target?: any): void | null;
        /**
         * @deprecated Since V1.1.1, animation states were no longer defined as event targets.
         * To process animation events, use `Animation` instead.
         */
        off(type: string, callback: Function, target?: any): void;
        /**
         * @zh
         * 是否允许触发 `LastFrame` 事件。
         * 该方法仅用作内部用途。
         * @en
         * Whether `LastFrame` should be triggered.
         * @param allowed True if the last frame events may be triggered.
         * This method is only used for internal purpose only.
         */
        allowLastFrameEvent(allowed: boolean): void;
        /**
         * This method is used for internal purpose only.
         * @internal
         */
        _setEventTarget(target: any): void;
        setTime(time: number): void;
        update(delta: number): void;
        sample(): __private._cocos_core_animation_types__WrappedInfo;
        protected onPlay(): void;
        protected onStop(): void;
        protected onResume(): void;
        protected onPause(): void;
        /**
         * @internal
         */
        protected _sampleCurves(time: number): void;
    }
    /**
     * @en
     * Animation component governs a group of animation states to control playback of the states.
     * For convenient, it stores a group of animation clips.
     * Each of those clips would have an associated animation state uniquely created.
     * Animation component is eventful, it dispatch a serials playback status events.
     * See [[EventType]].
     * @zh
     * 动画组件管理一组动画状态，控制它们的播放。
     * 为了方便，动画组件还存储了一组动画剪辑。
     * 每个剪辑都会独自创建一个关联的动画状态对象。
     * 动画组件具有事件特性，它会派发一系列播放状态相关的事件。
     * 参考 [[EventType]]
     */
    export class Animation extends __private._cocos_core_animation_animation_component__Animation_base {
        /**
         * @en
         * Gets or sets clips this component governs.
         * When set, associated animation state of each existing clip will be stopped.
         * If the existing default clip is not in the set of new clips, default clip will be reset to null.
         * @zh
         * 获取或设置此组件管理的剪辑。
         * 设置时，已有剪辑关联的动画状态将被停止；若默认剪辑不在新的动画剪辑中，将被重置为空。
         */
        get clips(): (AnimationClip | null)[];
        set clips(value: (AnimationClip | null)[]);
        /**
         * @en
         * Gets or sets the default clip.
         * Two clips that both have same non-empty UUID are treat as equivalent.
         * @zh
         * 获取或设置默认剪辑。
         * 设置时，若指定的剪辑不在 `this.clips` 中则会被自动添加至 `this.clips`。
         * 具有相同的非空 UUID 的两个动画剪辑将被视为是相同的。
         * @see [[playOnLoad]]
         */
        get defaultClip(): AnimationClip | null;
        set defaultClip(value: AnimationClip | null);
        static EventType: typeof __private._cocos_core_animation_animation_state__EventType;
        /**
         * @en
         * Whether the default clip should get into playing when this components starts.
         * Note, this field takes no effect if `crossFade()` or `play()` has been called before this component starts.
         * @zh
         * 是否在组件开始运行时自动播放默认剪辑。
         * 注意，若在组件开始运行前调用了 `crossFade` 或 `play()`，此字段将不会生效。
         */
        playOnLoad: boolean;
        /**
         * @internal
         */
        protected _crossFade: __private._cocos_core_animation_cross_fade__CrossFade;
        /**
         * @internal
         */
        protected _nameToState: Record<string, AnimationState>;
        /**
         * @internal
         */
        protected _clips: (AnimationClip | null)[];
        /**
         * @internal
         */
        protected _defaultClip: AnimationClip | null;
        onLoad(): void;
        start(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        /**
         * @en
         * Switch to play specified animation state, without fading.
         * @zh
         * 立即切换到指定动画状态。
         * @param name The name of the animation to be played, if absent, the default clip will be played
         */
        play(name?: string): void;
        /**
         * @en
         * Smoothly switch to play specified animation state.
         * @zh
         * 平滑地切换到指定动画状态。
         * @param name The name of the animation to switch to
         * @param duration The duration of the cross fade, default value is 0.3s
         */
        crossFade(name: string, duration?: number): void;
        /**
         * @en
         * Pause all animation states and all switching.
         * @zh
         * 暂停所有动画状态，并暂停所有切换。
         */
        pause(): void;
        /**
         * @en
         * Resume all animation states and all switching.
         * @zh
         * 恢复所有动画状态，并恢复所有切换。
         */
        resume(): void;
        /**
         * @en
         * Stop all animation states and all switching.
         * @zh
         * 停止所有动画状态，并停止所有切换。
         */
        stop(): void;
        /**
         * @en
         * Get specified animation state.
         * @zh
         * 获取指定的动画状态。
         * @param name The name of the animation
         * @returns If no animation found, return null, otherwise the correspond animation state is returned
         */
        getState(name: string): AnimationState;
        /**
         * @en
         * Creates a state for specified clip.
         * If there is already a clip with same name, the existing animation state will be stopped and overridden.
         * @zh
         * 使用指定的动画剪辑创建一个动画状态。
         * 若指定名称的动画状态已存在，已存在的动画状态将先被设为停止并被覆盖。
         * @param clip The animation clip
         * @param name The animation state name, if absent, the default clip's name will be used
         * @returns The animation state created
         */
        createState(clip: AnimationClip, name?: string): AnimationState;
        /**
         * @en
         * Stops and removes specified clip.
         * @zh
         * 停止并移除指定的动画状态。
         * @param name The name of the animation state
         */
        removeState(name: string): void;
        /**
         * @zh
         * 添加一个动画剪辑到 `this.clips`中并以此剪辑创建动画状态。
         * @en
         * Adds an animation clip into this component and creates a animation state for this clip.
         * @param clip The animation clip
         * @param name The animation state name, if absent, the default clip's name will be used
         * @returns The created animation state
         */
        addClip(clip: AnimationClip, name?: string): AnimationState;
        /**
         * @en
         * Remove clip from the animation list. This will remove the clip and any animation states based on it.<br>
         * If there are animation states depend on the clip are playing or clip is defaultClip, it will not delete the clip.<br>
         * But if force is true, then will always remove the clip and any animation states based on it. If clip is defaultClip,
         * defaultClip will be reset to null
         * @zh
         * 从动画列表中移除指定的动画剪辑，<br/>
         * 如果依赖于 clip 的 AnimationState 正在播放或者 clip 是 defaultClip 的话，默认是不会删除 clip 的。<br/>
         * 但是如果 force 参数为 true，则会强制停止该动画，然后移除该动画剪辑和相关的动画。这时候如果 clip 是 defaultClip，defaultClip 将会被重置为 null。<br/>
         * @param force - If force is true, then will always remove the clip and any animation states based on it.
         */
        removeClip(clip: AnimationClip, force?: boolean): void;
        /**
         * @en
         * Register animation event callback.<bg>
         * The event arguments will provide the AnimationState which emit the event.<bg>
         * When play an animation, will auto register the event callback to the AnimationState,<bg>
         * and unregister the event callback from the AnimationState when animation stopped.
         * @zh
         * 注册动画事件回调。<bg>
         * 回调的事件里将会附上发送事件的 AnimationState。<bg>
         * 当播放一个动画时，会自动将事件注册到对应的 AnimationState 上，停止播放时会将事件从这个 AnimationState 上取消注册。
         * @param type The event type to listen to
         * @param callback The callback when event triggered
         * @param target The callee when invoke the callback, could be absent
         * @return The registered callback
         * @example
         * ```ts
         * onPlay: function (type, state) {
         *     // callback
         * }
         *
         * // register event to all animation
         * animation.on('play', this.onPlay, this);
         * ```
         */
        on<TFunction extends (...any: any[]) => void>(type: __private._cocos_core_animation_animation_state__EventType, callback: TFunction, thisArg?: any, once?: boolean): TFunction;
        once<TFunction extends (...any: any[]) => void>(type: __private._cocos_core_animation_animation_state__EventType, callback: TFunction, thisArg?: any): TFunction;
        /**
         * @en
         * Unregister animation event callback.
         * @zh
         * 取消注册动画事件回调。
         * @param {String} type The event type to unregister
         * @param {Function} callback The callback to unregister
         * @param {Object} target The callee of the callback, could be absent
         * @example
         * ```ts
         * // unregister event to all animation
         * animation.off('play', this.onPlay, this);
         * ```
         */
        off(type: __private._cocos_core_animation_animation_state__EventType, callback?: (...any: any[]) => void, thisArg?: any): void;
        /**
         * @internal
         */
        protected _createState(clip: AnimationClip, name?: string): AnimationState;
        /**
         * @internal
         */
        protected _doCreateState(clip: AnimationClip, name: string): AnimationState;
        /**
         * @internal This method only friends to skeletal animation component.
         */
        protected doPlayOrCrossFade(state: AnimationState, duration: number): void;
    }
    export namespace Animation {
        export type EventType = __private._cocos_core_animation_animation_component__EventType_;
    }
    export namespace animation {
        /**
         * @en
         * Represents variable's value.
         * @zh
         * 表示变量的值。
         */
        export type Value = number | string | boolean;
        /**
         * @en
         * Represents animation graph variable types.
         * @zh
         * 表示动画图变量的类型。
         */
        export enum VariableType {
            /**
             * @en
             * A floating.
             * @zh
             * 浮点数。
             */
            FLOAT = 0,
            /**
             * @en
             * A boolean.
             * @zh
             * 布尔值。
             */
            BOOLEAN = 1,
            /**
             * @en
             * A trigger.
             * @zh
             * 触发器。
             */
            TRIGGER = 2,
            /**
             * @en
             * An integer.
             * @zh
             * 整数。
             */
            INTEGER = 3
        }
        /**
         * @en
         * Value proxy factory for setting uniform on material target.
         * @zh
         * 用于设置材质目标上指定 Uniform 的曲线值代理工厂。
         */
        export class UniformProxyFactory implements IValueProxyFactory {
            /**
             * @en Pass index.
             * @zh Pass 索引。
             */
            passIndex: number;
            /**
             * @en Uniform name.
             * @zh Uniform 名称。
             */
            uniformName: string;
            /**
             * @en
             * Specify the aimed channel of the uniform.
             * Use this when you're aiming at a single channel of the uniform instead of who uniform.
             * For example, only green(1) channel of a color uniform.
             * @zh
             * 指定目标 Uniform 的通道。
             * 当你希望设置 Uniform 单独的通道而非整个 Uniform 时应该当使用此字段。
             * 例如，仅设置颜色 Uniform 的红色通道。
             */
            channelIndex: number | undefined;
            constructor(uniformName?: string, passIndex?: number);
            forTarget(target: Material): IValueProxy;
        }
        /**
         * @en
         * Value proxy factory for setting morph weights of specified sub-mesh on model component target.
         * @zh
         * 用于设置模型组件目标上指定子网格的指定形状的形变权重的曲线值代理工厂。
         */
        export class MorphWeightValueProxy implements IValueProxyFactory {
            /**
             * @en Sub mesh index.
             * @zh 子网格索引。
             */
            subMeshIndex: number;
            /**
             * @en Shape Index.
             * @zh 形状索引。
             */
            shapeIndex: number;
            forTarget(target: MeshRenderer): {
                set: (value: number) => void;
            };
        }
        /**
         * @en
         * Value proxy factory for setting morph weights of specified sub-mesh on model component target.
         * @zh
         * 用于设置模型组件目标上指定子网格形变权重的曲线值代理工厂。
         */
        export class MorphWeightsValueProxy implements IValueProxyFactory {
            /**
             * @en Sub-mesh index.
             * @zh 子网格索引。
             */
            subMeshIndex: number;
            forTarget(target: MeshRenderer): {
                set: (value: number[]) => void;
            };
        }
        /**
         * @en
         * Value proxy factory for setting morph weights of each sub-mesh on model component target.
         * @zh
         * 用于设置模型组件目标上所有子网格形变权重的曲线值代理工厂。
         */
        export class MorphWeightsAllValueProxy implements IValueProxyFactory {
            forTarget(target: MeshRenderer): {
                set: (value: number[]) => void;
            };
        }
        /**
         * @en
         * A track describes how to trace the target and how to animate it.
         * It's the basic unit of animation clip.
         * @zh
         * 轨道描述了动画目标的路径和动画的方式。它是动画剪辑的基础单元。
         */
        export abstract class Track {
            /**
             * @en Track path.
             * @zh 轨道路径。
             */
            get path(): Readonly<TrackPath>;
            set path(value: Readonly<TrackPath>);
            /**
             * @en Value proxy for the target.
             * @zh 目标的值代理。
             */
            get proxy(): IValueProxyFactory | undefined;
            set proxy(value: IValueProxyFactory | undefined);
            /**
             * @internal
             */
            get [__private._cocos_core_animation_tracks_track__trackBindingTag](): __private._cocos_core_animation_tracks_track__TrackBinding;
            /**
             * @en Channels on this track.
             * @zh 此轨道上的通道。
             * @returns Iterator to the channels.
             */
            channels(): Iterable<__private._cocos_core_animation_tracks_track__Channel>;
            /**
             * @en Time range of this track.
             * @zh 此轨道的时间范围。
             * @returns The time range.
             */
            range(): __private._cocos_core_animation_tracks_utils__Range;
            /**
             * @internal
             */
            abstract [__private._cocos_core_animation_define__createEvalSymbol](runtimeBinding: __private._cocos_core_animation_tracks_track__RuntimeBinding): __private._cocos_core_animation_tracks_track__TrackEval;
        }
        /**
         * @en Describes how to find the animation target.
         * @zh 描述怎样寻址动画目标。
         */
        export class TrackPath {
            /**
             * @en The length of the path.
             * @zh 此路径的段数。
             */
            get length(): number;
            /**
             * @en Appends a property path.
             * @zh 附加一段属性路径。
             * @param name The property's name.
             * @returns `this`
             */
            toProperty(name: string): this;
            /**
             * @en Appends an array element path.
             * @zh 附加一段数组元素路径。
             * @param index The element's index.
             * @returns `this`
             */
            toElement(index: number): this;
            /**
             * @en Appends a hierarchy path.
             * @zh 附加一段层级路径。
             * @param nodePath Path to the children.
             * @returns `this`
             */
            toHierarchy(nodePath: string): this;
            /**
             * @en Appends a component path.
             * @zh 附加一段组件路径。
             * @param constructor @en The constructor of the component. @zh 组件的构造函数。
             * @returns `this`
             */
            toComponent<T extends Component>(constructor: __private._types_globals__Constructor<T> | string): this;
            /**
             * @internal Reserved for backward compatibility. DO NOT USE IT IN YOUR CODE.
             */
            toCustomized(resolver: __private._cocos_core_animation_tracks_track__CustomizedTrackPathResolver): this;
            /**
             * @en Appends paths to this path.
             * @zh 附加指定路径到此路径后。
             * @param trackPaths Paths to append.
             * @returns `this`.
             */
            append(...trackPaths: TrackPath[]): this;
            /**
             * @zh 判断指定路径段是否是属性路径。
             * @en Decides if the specific path segment is property path.
             * @param index Index to the segment。
             * @returns The judgement result.
             */
            isPropertyAt(index: number): boolean;
            /**
             * @zh 将指定路径段视为属性路径，获取其描述的属性。
             * @en Treats the path segment as a property path. Obtains the property it describes.
             * @param index Index to the segment。
             * @returns The property.
             */
            parsePropertyAt(index: number): string;
            /**
             * @zh 判断指定路径段是否是数组元素路径。
             * @en Decides if the specific path segment is an array element path.
             * @param index Index to the segment。
             * @returns The judgement result.
             */
            isElementAt(index: number): boolean;
            /**
             * @zh 将指定路径段视为数组元素路径，获取其描述的数组元素。
             * @en Treats the path segment as an array element path. Obtains the element index it describes.
             * @param index Index to the segment。
             * @returns The element index.
             */
            parseElementAt(index: number): number;
            /**
             * @zh 判断指定路径段是否是层级路径。
             * @en Decides if the specific path segment is a hierarchy path.
             * @param index Index to the segment。
             * @returns The judgement result.
             */
            isHierarchyAt(index: number): boolean;
            /**
             * @zh 将指定路径段视为层级路径，获取其描述的层级路径。
             * @en Treats the path segment as a hierarchy path. Obtains the hierarchy path it describes.
             * @param index Index to the segment。
             * @returns The hierarchy path.
             */
            parseHierarchyAt(index: number): string;
            /**
             * @zh 判断指定路径段是否是组件路径。
             * @en Decides if the specific path segment is a component path.
             * @param index Index to the segment。
             * @returns The judgement result.
             */
            isComponentAt(index: number): boolean;
            /**
             * @zh 将指定路径段视为组件路径，获取其描述的组件路径。
             * @en Treats the path segment as a hierarchy path. Obtains the component path it describes.
             * @param index Index to the segment。
             * @returns The component path.
             */
            parseComponentAt(index: number): string;
            /**
             * @en Slices a interval of the path.
             * @zh 分割指定区段上的路径。
             * @param beginIndex Begin index to the segment. Default to 0.
             * @param endIndex End index to the segment. Default to the last segment.
             * @returns The new path.
             */
            slice(beginIndex?: number, endIndex?: number): TrackPath;
            /**
             * @internal
             */
            trace(object: unknown, beginIndex?: number, endIndex?: number): unknown;
            /**
             * @internal
             */
            [__private._cocos_core_animation_tracks_track__parseTrsPathTag](): {
                node: string;
                property: "position" | "scale" | "eulerAngles" | "rotation";
            } | null;
            /**
             * @internal
             */
            [__private._cocos_core_animation_tracks_track__normalizedFollowTag](root: unknown, beginIndex: number, endIndex: number): unknown;
        }
        /**
         * @en
         * A real track animates a scalar attribute of target.
         * @zh
         * 实数轨道描述目标上某个标量属性的动画。
         */
        export class RealTrack extends __private._cocos_core_animation_tracks_track__SingleChannelTrack<RealCurve> {
            /**
             * @internal
             */
            protected createCurve(): RealCurve;
        }
        /**
         * @en
         * A vector track animates a vector(in 2, 3, 4 dimension) attribute of target.
         * @zh
         * 向量轨道描述目标上某个（二、三、四维）向量属性的动画。
         */
        export class VectorTrack extends Track {
            constructor();
            /**
             * @en Gets or sets the count of components(dimension) available while evaluating of this track.
             * @zh 获取或设置此轨道在求值时有效的分量数（维度）。
             */
            get componentsCount(): 2 | 4 | 3;
            set componentsCount(value: 2 | 4 | 3);
            /**
             * @en The four channel of the track.
             * @zh 返回此轨道的四条通道。
             * @returns An readonly four length array in which
             * the element at n denotes the channel of n-th vector component.
             */
            channels(): [
                __private._cocos_core_animation_tracks_track__RealChannel,
                __private._cocos_core_animation_tracks_track__RealChannel,
                __private._cocos_core_animation_tracks_track__RealChannel,
                __private._cocos_core_animation_tracks_track__RealChannel
            ];
            /**
             * @internal
             */
            [__private._cocos_core_animation_define__createEvalSymbol](): __private._cocos_core_animation_tracks_vector_track__Vec2TrackEval | __private._cocos_core_animation_tracks_vector_track__Vec3TrackEval | __private._cocos_core_animation_tracks_vector_track__Vec4TrackEval;
        }
        /**
         * @en
         * A quaternion track animates a quaternion(rotation) attribute of target.
         * @zh
         * 四元数轨道描述目标上某个四元数（旋转）属性的动画。
         */
        export class QuatTrack extends __private._cocos_core_animation_tracks_track__SingleChannelTrack<QuatCurve> {
            /**
             * @internal
             */
            protected createCurve(): QuatCurve;
            /**
             * @internal
             */
            [__private._cocos_core_animation_define__createEvalSymbol](): __private._cocos_core_animation_tracks_quat_track__QuatTrackEval;
        }
        /**
         * @en
         * A color track animates a color attribute of target.
         * @zh
         * 颜色轨道描述目标上某个颜色属性的动画。
         */
        export class ColorTrack extends Track {
            constructor();
            /**
             * @en The four channel of the track.
             * @zh 返回此轨道的四条通道。
             * @returns An readonly four length array in which
             * the element at n denotes the channel of n-th(in order of RGBA) color component(in form of integer within 0-255).
             */
            channels(): [
                __private._cocos_core_animation_tracks_track__RealChannel,
                __private._cocos_core_animation_tracks_track__RealChannel,
                __private._cocos_core_animation_tracks_track__RealChannel,
                __private._cocos_core_animation_tracks_track__RealChannel
            ];
            /**
             * @internal
             */
            [__private._cocos_core_animation_define__createEvalSymbol](): __private._cocos_core_animation_tracks_color_track__ColorTrackEval;
        }
        /**
         * @en
         * A size track animates a size attribute of target.
         * @zh
         * 尺寸轨道描述目标上某个尺寸属性的动画。
         */
        export class SizeTrack extends Track {
            constructor();
            /**
             * @en The width channel and the height channel of the track.
             * @zh 返回此轨道的宽度通道和高度通道。
             * @returns An readonly array in which
             * the first element is the width channel and the second element is the height channel.
             */
            channels(): [
                __private._cocos_core_animation_tracks_track__RealChannel,
                __private._cocos_core_animation_tracks_track__RealChannel
            ];
            /**
             * @internal
             */
            [__private._cocos_core_animation_define__createEvalSymbol](): __private._cocos_core_animation_tracks_size_track__SizeTrackEval;
        }
        /**
         * @en
         * An object track animates an object of attribute of target.
         * @zh
         * 对象轨道描述目标上某个对象类型的属性的动画。
         */
        export class ObjectTrack<T> extends __private._cocos_core_animation_tracks_track__SingleChannelTrack<ObjectCurve<T>> {
            /**
             * @internal
             */
            protected createCurve(): ObjectCurve<T>;
        }
        /**
         * @deprecated Since V3.3, use [[TrackPath]] instead.
         */
        export function isPropertyPath(path: TargetPath): path is PropertyPath;
        /**
         * @deprecated Since V3.3, use [[TrackPath]] instead.
         */
        export function isCustomPath<T extends ICustomTargetPath>(path: TargetPath, constructor: __private._types_globals__Constructor<T>): path is T;
        /**
         * @deprecated Since V3.3, use [[TrackPath]] instead.
         */
        export type PropertyPath = string | number;
        /**
         * @deprecated Since V3.3, use [[TrackPath]] instead.
         */
        export interface ICustomTargetPath {
            /**
             * @en
             * Gets next target from current target.
             * If errors are encountered, `null` should be returned.
             * @zh
             * 从当前目标中获取下一个目标。
             * 若错误发生，应返回 `null`。
             * @param target
             */
            get(target: any): any;
        }
        /**
         * @deprecated Since V3.3, use [[TrackPath]] instead.
         */
        export type TargetPath = PropertyPath | ICustomTargetPath;
        /**
         * @deprecated Since V3.3, use [[TrackPath]] instead.
         */
        export class HierarchyPath implements ICustomTargetPath {
            path: string;
            constructor(path?: string);
            get(target: Node): Node | null;
        }
        /**
         * @deprecated Since V3.3, use [[TrackPath]] instead.
         */
        export class ComponentPath implements ICustomTargetPath {
            component: string;
            constructor(component?: string);
            get(target: Node): Component | null;
        }
        /**
         * @en
         * Value proxies are used to set curve value to target. They are "generalized assignment".
         * Every value proxy associates with a target object.
         * @zh
         * 曲线值代理用来设置曲线值到目标，是广义的赋值。
         * 每个曲线值代理都关联着一个目标对象。
         */
        export interface IValueProxy {
            /**
             * @en
             * Gets the value from the target.
             * This method is used for implementing component-wise animation in certain circumstance.
             * @zh
             * 从目标中获取值。某些情况下可能需要这个接口来实现分量动画。
             */
            get?: () => any;
            /**
             * @en
             * Sets a value.
             * @zh
             * 设置曲线值到目标对象上。
             */
            set: (value: any) => void;
        }
        export interface IValueProxyFactory {
            /**
             * @en
             * Returns a value proxy for specific target.
             * @zh
             * 返回指定目标的曲线值代理。
             * @param target The target acquiring the value proxy.
             */
            forTarget(target: any): IValueProxy;
        }
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        export const CubicSplineVec2Value: __private._cocos_core_animation_cubic_spline_value__CubicSplineValueConstructor<math.Vec2>;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        export type CubicSplineVec2Value = __private._cocos_core_animation_cubic_spline_value__ICubicSplineValue<math.Vec2>;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        export const CubicSplineVec3Value: __private._cocos_core_animation_cubic_spline_value__CubicSplineValueConstructor<math.Vec3>;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        export type CubicSplineVec3Value = __private._cocos_core_animation_cubic_spline_value__ICubicSplineValue<math.Vec3>;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        export const CubicSplineVec4Value: __private._cocos_core_animation_cubic_spline_value__CubicSplineValueConstructor<math.Vec4>;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        export type CubicSplineVec4Value = __private._cocos_core_animation_cubic_spline_value__ICubicSplineValue<math.Vec4>;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        export const CubicSplineQuatValue: __private._cocos_core_animation_cubic_spline_value__CubicSplineValueConstructor<math.Quat>;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        export class CubicSplineNumberValue implements __private._cocos_core_animation_cubic_spline_value__ICubicSplineValue<number> {
            dataPoint: number;
            inTangent: number;
            outTangent: number;
            constructor(dataPoint: number, inTangent: number, outTangent: number);
            lerp(to: CubicSplineNumberValue, t: number, dt: number): number;
            getNoLerp(): number;
        }
        /**
         * @en
         * An opacity type which denotes what the animation graph seems like outside the engine.
         * @zh
         * 一个非透明的类型，它是动画图在引擎外部的表示。
         */
        export interface AnimationGraphRunTime {
            /**
             * @internal
             */
            readonly __brand: "AnimationGraph";
        }
        /**
         * @en
         * The animation controller component applies an animation graph
         * to the node which it's attached to.
         * When the controller starts, the animation graph is instantiated.
         * Then you may set variables or query the running statuses of the animation graph instance.
         * @zh
         * 将动画图应用到动画控制器组件所挂载的节点上。
         * 当动画控制器开始运行时，动画图会被实例化。然后便可以设置动画图实例中的变量或者查询动画图的运行状况。
         */
        export class AnimationController extends Component {
            /**
             * @zh
             * 动画控制器所关联的动画图。
             * @en
             * The animation graph associated with the animation controller.
             */
            graph: AnimationGraphRunTime | null;
            __preload(): void;
            update(deltaTime: number): void;
            /**
             * @zh 获取动画图中的所有变量。
             * @en Gets all the variables in the animation graph.
             * @returns The iterator to the variables.
             * @example
             * ```ts
             * for (const [name, { type }] of animationController.getVariables()) {
             *   log(`Name: ${name}, Type: ${type}`);
             * }
             * ```
             */
            getVariables(): Iterable<readonly [
                string,
                Readonly<{
                    type: VariableType;
                }>
            ]>;
            /**
             * @zh 设置动画图实例中变量的值。
             * @en Sets the value of the variable in the animation graph instance.
             * @param name @en Variable's name. @zh 变量的名称。
             * @param value @en Variable's value. @zh 变量的值。
             * @example
             * ```ts
             * animationController.setValue('speed', 3.14);
             * animationController.setValue('crouching', true);
             * animationController.setValue('attack', true);
             * ```
             */
            setValue(name: string, value: Value): void;
            /**
             * @zh 获取动画图实例中变量的值。
             * @en Gets the value of the variable in the animation graph instance.
             * @param name @en Variable's name. @zh 变量的名称。
             * @returns @en Variable's value. @zh 变量的值。
             */
            getValue(name: string): Value | undefined;
            /**
             * @zh 获取动画图实例中当前状态的运行状况。
             * @en Gets the running status of the current state in the animation graph instance.
             * @param layer @en Index of the layer. @zh 层级索引。
             * @returns @en The running status of the current state.
             *          @zh 当前的状态运作状态对象。
             */
            getCurrentStateStatus(layer: number): Readonly<MotionStateStatus> | null;
            /**
             * @zh 获取动画图实例中当前状态上包含的所有动画剪辑的运行状况。
             * @en Gets the running status of all the animation clips added on the current state in the animation graph instance.
             * @param layer @en Index of the layer. @zh 层级索引。
             * @returns @en Iterable to the animation clip statuses on current state.
             *          @zh 到动画剪辑运作状态的迭代器。
             */
            getCurrentClipStatuses(layer: number): Iterable<Readonly<ClipStatus>>;
            /**
             * @zh 获取动画图实例中当前正在进行的过渡的运行状况。
             * @en Gets the running status of the transition currently in progress in the animation graph instance.
             * @param layer @en Index of the layer. @zh 层级索引。
             * @returns @en Current transition status. `null` is returned in case of no transition.
             *          @zh 当前正在进行的过渡，若没有进行任何过渡，则返回 `null`。
             */
            getCurrentTransition(layer: number): Readonly<TransitionStatus> | null;
            /**
             * @zh 获取动画图实例中下一个状态的运行状况。
             * @en Gets the running status of the next state in the animation graph instance.
             * @param layer @en Index of the layer. @zh 层级索引。
             * @returns @en The running status of the next state. `null` is returned in case of no transition.
             *          @zh 下一状态运作状态对象，若未在进行过渡，则返回 `null`。
             */
            getNextStateStatus(layer: number): Readonly<MotionStateStatus> | null;
            /**
             * @zh 获取动画图实例中下一个状态上添加的所有动画剪辑的运行状况。
             * @en Gets the running status of all the animation clips added on the next state in the animation graph instance.
             * @param layer @en Index of the layer. @zh 层级索引。
             * @returns @en Iterable to the animation clip statuses on next state. An empty iterable is returned in case of no transition.
             *          @zh 到下一状态上包含的动画剪辑运作状态的迭代器，若未在进行过渡，则返回一个空的迭代器。
             */
            getNextClipStatuses(layer: number): Iterable<Readonly<ClipStatus>>;
            /**
             * @zh 获取层级权重。
             * @en Gets the weight of specified layer.
             * @param layer @en Index of the layer. @zh 层级索引。
             */
            getLayerWeight(layer: number): number;
            /**
             * @zh 设置层级权重。
             * @en Sets the weight of specified layer.
             * @param layer @en Index of the layer. @zh 层级索引。
             */
            setLayerWeight(layer: number, weight: number): void;
        }
        /**
         * @en
         * Runtime clip status of a motion state.
         * @zh
         * 动作状态中包含的剪辑的运行状态。
         */
        export interface ClipStatus {
            /**
             * @en
             * The clip object.
             * @zh
             * 剪辑对象。
             */
            clip: AnimationClip;
            /**
             * @en
             * The clip's weight.
             * @zh
             * 剪辑的权重。
             */
            weight: number;
        }
        /**
         * @en
         * Runtime status of a transition.
         * @zh
         * 过渡的运行状态。
         */
        export interface TransitionStatus {
            /**
             * @en
             * The duration of the transition.
             * @zh
             * 过渡的周期。
             */
            duration: number;
            /**
             * @en
             * The progress of the transition.
             * @zh
             * 过渡的进度。
             */
            time: number;
        }
        /**
         * @en
         * Runtime status of a motion state.
         * @zh
         * 动作状态的运行状态。
         */
        export interface MotionStateStatus {
            /**
             * For testing.
             * TODO: remove it.
             * @internal
             */
            __DEBUG_ID__?: string;
            /**
             * @en
             * The normalized time of the state.
             * It would be the fraction part of `elapsed-time / duration` if elapsed time is non-negative,
             * and would be 1 plus the fraction part of `(elapsed-time / duration)` otherwise.
             * This is **NOT** the clip's progress if the state is not a clip motion or its wrap mode isn't loop.
             * @zh
             * 状态的规范化时间。
             * 如果流逝的时间是非负的，它就是 `流逝时间 / 周期` 的小数部分；否则，它是 `(流逝时间 / 周期)` 的小数部分加 1。
             * 它并不一定代表剪辑的进度，因为该状态可能并不是一个剪辑动作，或者它的循环模式并非循环。
             */
            progress: number;
        }
        /**
         * @en State machine component.
         * @zh 状态机组件。
         */
        export class StateMachineComponent {
            /**
             * @en
             * Called when a motion state right after it entered.
             * @zh
             * 在刚刚进入动作状态时调用。
             * @param controller The animation controller it within.
             * @param motionStateStatus The status of the motion.
             */
            onMotionStateEnter(controller: AnimationController, motionStateStatus: Readonly<MotionStateStatus>): void;
            /**
             * @en
             * Called when a motion state is going to be exited.
             * @zh
             * 在即将退出动作状态时调用。
             * @param controller The animation controller it within.
             * @param motionStateStatus The status of the motion.
             */
            onMotionStateExit(controller: AnimationController, motionStateStatus: Readonly<MotionStateStatus>): void;
            /**
             * @en
             * Called when a motion state updated except for the first and last frame.
             * @zh
             * 在动作状态更新时调用，但不会在第一次和最后一次时调用。
             * @param controller The animation controller it within.
             * @param motionStateStatus The status of the motion.
             */
            onMotionStateUpdate(controller: AnimationController, motionStateStatus: Readonly<MotionStateStatus>): void;
            /**
             * @en
             * Called when a state machine right after it entered.
             * @zh
             * 在刚刚进入状态机时调用。
             * @param controller The animation controller it within.
             */
            onStateMachineEnter(controller: AnimationController): void;
            /**
             * @en
             * Called when a state machine right after it entered.
             * @zh
             * 在即将退出状态机时调用。
             * @param controller The animation controller it within.
             */
            onStateMachineExit(controller: AnimationController): void;
        }
    }
    export interface ILerpable {
        /**
         * 在当前曲线值与目标曲线值之间插值。
         * @param to 目标曲线值。
         * @param t 插值比率。
         * @param dt 当前曲线值与目标曲线值的时间间隔，单位为秒。
         * @returns 插值结果。
         */
        lerp(to: any, t: number, dt: number): any;
        /**
         * 当直接使用曲线值作为采样结果时的结果值，它应该等同于插值比率为 0 时的插值结果。
         * @returns 插值比率为 0 时的插值结果。
         */
        getNoLerp?(): any;
    }
    export function bezier(C1: number, C2: number, C3: number, C4: number, t: number): number;
    export function bezierByTime(controlPoints: BezierControlPoints, x: number): number;
    export type BezierControlPoints = [
        number,
        number,
        number,
        number
    ];
    /**
     * @zh
     * 采样动画曲线。
     * @en
     * Samples an animation curve.
     * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
     * @param curve @zh 动画曲线。@en The curve.
     * @param sampler @zh 采样器。@en The sampler.
     * @param ratio @zh 采样比率。@en Sample ratio([0, 1]).
     */
    export function sampleAnimationCurve(curve: AnimCurve, sampler: RatioSampler, ratio: number): any;
    /**
     * @en
     * Compute a new ratio by curve type.
     * @zh
     * 根据曲线类型计算新的比例。
     * @param ratio - The origin ratio
     * @param type - If it's Array, then ratio will be computed with bezierByTime.
     * If it's string, then ratio will be computed with cc.easing function
     * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
     */
    export function computeRatioByType(ratio: number, type: AnimationClip._legacy.LegacyEasingMethod): number;
    /**
     * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
     */
    export class RatioSampler {
        ratios: number[];
        constructor(ratios: number[]);
        sample(ratio: number): number;
    }
    /**
     * @en
     * Animation curve.
     * @zh
     * 动画曲线。
     * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
     */
    export class AnimCurve {
        static Linear: null;
        static Bezier(controlPoints: number[]): BezierControlPoints;
        types?: Array<(AnimationClip._legacy.LegacyEasingMethod | null)>;
        type?: AnimationClip._legacy.LegacyEasingMethod | null;
        constructor(propertyCurveData: Omit<AnimationClip._legacy.LegacyClipCurveData, "keys">, duration: number);
        hasLerp(): boolean;
        valueAt(index: number): any;
        valueBetween(ratio: number, from: number, fromRatio: number, to: number, toRatio: number): any;
        empty(): boolean;
        /**
         * Returns if this curve only yields constants.
         */
        constant(): boolean;
    }
    export class EventInfo {
        events: any[];
        /**
         * @param func event function
         * @param params event params
         */
        add(func: string, params: any[]): void;
    }
    export class AnimationManager extends System {
        get blendState(): __private._cocos_3d_skeletal_animation_skeletal_animation_blending__LegacyBlendStateBuffer;
        static ID: string;
        addCrossFade(crossFade: __private._cocos_core_animation_cross_fade__CrossFade): void;
        removeCrossFade(crossFade: __private._cocos_core_animation_cross_fade__CrossFade): void;
        update(dt: number): void;
        destruct(): void;
        addAnimation(anim: AnimationState): void;
        removeAnimation(anim: AnimationState): void;
        pushDelayEvent(fn: (...args: any[]) => void, thisArg: any, args: any[]): void;
        addSockets(root: Node, sockets: Socket[]): void;
        removeSockets(root: Node, sockets: Socket[]): void;
    }
    /**
     * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
     */
    export function getPathFromRoot(target: Node | null, root: Node): string;
    /**
     * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
     */
    export function getWorldTransformUntilRoot(target: Node, root: Node, outMatrix: math.Mat4): math.Mat4;
    /**
     * @en
     * The audio clip asset.
     * @zh
     * 音频片段资源。
     */
    export class AudioClip extends Asset {
        static AudioType: typeof __private._pal_audio_type__AudioType;
        protected _duration: number;
        protected _loadMode: __private._pal_audio_type__AudioType;
        protected _meta: __private._cocos_audio_audio_clip__AudioMeta | null;
        destroy(): boolean;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        set _nativeAsset(meta: __private._cocos_audio_audio_clip__AudioMeta | null);
        get _nativeAsset(): __private._cocos_audio_audio_clip__AudioMeta | null;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        get _nativeDep(): {
            uuid: string;
            audioLoadMode: __private._pal_audio_type__AudioType;
            ext: string;
            __isNative__: boolean;
        };
        get loadMode(): __private._pal_audio_type__AudioType;
        validate(): boolean;
        getDuration(): number;
        /**
         * @deprecated since v3.1.0, please use AudioSource.prototype.state instead.
         */
        get state(): __private._pal_audio_type__AudioState;
        /**
         * @deprecated since v3.1.0, please use AudioSource.prototype.getCurrentTime() instead.
         */
        getCurrentTime(): number;
        /**
         * @deprecated since v3.1.0, please use AudioSource.prototype.getVolume() instead.
         */
        getVolume(): number;
        /**
         * @deprecated since v3.1.0, please use AudioSource.prototype.getLoop() instead.
         */
        getLoop(): boolean;
        /**
         * @deprecated since v3.1.0, please use AudioSource.prototype.setCurrentTime() instead.
         */
        setCurrentTime(time: number): void;
        /**
         * @deprecated since v3.1.0, please use AudioSource.prototype.setVolume() instead.
         */
        setVolume(volume: number): void;
        /**
         * @deprecated since v3.1.0, please use AudioSource.prototype.setLoop() instead.
         */
        setLoop(loop: boolean): void;
        /**
         * @deprecated since v3.1.0, please use AudioSource.prototype.play() instead.
         */
        play(): void;
        /**
         * @deprecated since v3.1.0, please use AudioSource.prototype.pause() instead.
         */
        pause(): void;
        /**
         * @deprecated since v3.1.0, please use AudioSource.prototype.stop() instead.
         */
        stop(): void;
        /**
         * @deprecated since v3.1.0, please use AudioSource.prototype.playOneShot() instead.
         */
        playOneShot(volume?: number): void;
    }
    /**
     * @en
     * A representation of a single audio source, <br>
     * contains basic functionalities like play, pause and stop.
     * @zh
     * 音频组件，代表单个音源，提供播放、暂停、停止等基本功能。
     */
    export class AudioSource extends Component {
        static get maxAudioChannel(): number;
        static AudioState: typeof __private._pal_audio_type__AudioState;
        static EventType: typeof __private._cocos_audio_audio_source__AudioSourceEventType;
        protected _clip: AudioClip | null;
        protected _player: __private._pal_audio__AudioPlayer | null;
        protected _loop: boolean;
        protected _playOnAwake: boolean;
        protected _volume: number;
        /**
         * @en
         * The default AudioClip to be played for this audio source.
         * @zh
         * 设定要播放的音频。
         */
        set clip(val: AudioClip | null);
        get clip(): AudioClip | null;
        /**
         * @en
         * Is looping enabled for this audio source?
         * @zh
         * 是否循环播放音频？
         */
        set loop(val: boolean);
        get loop(): boolean;
        /**
         * @en
         * Is the autoplay enabled? <br>
         * Note that for most platform autoplay will only start <br>
         * after a user gesture is received, according to the latest autoplay policy: <br>
         * https://www.chromium.org/audio-video/autoplay
         * @zh
         * 是否启用自动播放。 <br>
         * 请注意，根据最新的自动播放策略，现在对大多数平台，自动播放只会在第一次收到用户输入后生效。 <br>
         * 参考：https://www.chromium.org/audio-video/autoplay
         */
        set playOnAwake(val: boolean);
        get playOnAwake(): boolean;
        /**
         * @en
         * The volume of this audio source (0.0 to 1.0).<br>
         * Note: Volume control may be ineffective on some platforms.
         * @zh
         * 音频的音量（大小范围为 0.0 到 1.0）。<br>
         * 请注意，在某些平台上，音量控制可能不起效。<br>
         */
        set volume(val: number);
        get volume(): number;
        onLoad(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        /**
         * @en
         * Get PCM data from specified channel.
         * Currently it is only available in Native platform and Web Audio (including Web and ByteDance platforms).
         *
         * @zh
         * 通过指定的通道获取音频的 PCM data。
         * 目前仅在原生平台和 Web Audio（包括 Web 和 字节平台）中可用。
         *
         * @param channelIndex The channel index. 0 is left channel, 1 is right channel.
         * @returns A Promise to get the PCM data after audio is loaded.
         *
         * @example
         * ```ts
         * audioSource.getPCMData(0).then(dataView => {
         *   if (!dataView)  return;
         *   for (let i = 0; i < dataView.length; ++i) {
         *     console.log('data: ' + dataView.getData(i));
         *   }
         * });
         * ```
         */
        getPCMData(channelIndex: number): Promise<AudioPCMDataView | undefined>;
        /**
         * @en
         * Get the sample rate of audio.
         * Currently it is only available in Native platform and Web Audio (including Web and ByteDance platforms).
         *
         * @zh
         * 获取音频的采样率。
         * 目前仅在原生平台和 Web Audio（包括 Web 和 字节平台）中可用。
         *
         * @returns A Promise to get the sample rate after audio is loaded.
         */
        getSampleRate(): Promise<number>;
        /**
         * @en
         * Play the clip.<br>
         * Restart if already playing.<br>
         * Resume if paused.
         *
         * NOTE: On Web platforms, the Auto Play Policy bans auto playing audios at the first time, because the user gesture is required.
         * there are 2 ways to play audios at the first time:
         * - play audios in the callback of TOUCH_END or MOUSE_UP event
         * - play audios straightly, the engine will auto play audios at the next user gesture.
         *
         * @zh
         * 开始播放。<br>
         * 如果音频处于正在播放状态，将会重新开始播放音频。<br>
         * 如果音频处于暂停状态，则会继续播放音频。
         *
         * 注意:在 Web 平台，Auto Play Policy 禁止首次自动播放音频，因为需要发生用户交互之后才能播放音频。
         * 有两种方式实现音频首次自动播放：
         * - 在 TOUCH_END 或者 MOUSE_UP 的事件回调里播放音频。
         * - 直接播放音频，引擎会在下一次发生用户交互时自动播放。
         */
        play(): void;
        /**
         * @en
         * Pause the clip.
         * @zh
         * 暂停播放。
         */
        pause(): void;
        /**
         * @en
         * Stop the clip.
         * @zh
         * 停止播放。
         */
        stop(): void;
        /**
         * @en
         * Plays an AudioClip, and scales volume by volumeScale. The result volume is `audioSource.volume * volumeScale`. <br>
         * @zh
         * 以指定音量倍数播放一个音频一次。最终播放的音量为 `audioSource.volume * volumeScale`。 <br>
         * @param clip The audio clip to be played.
         * @param volumeScale volume scaling factor wrt. current value.
         */
        playOneShot(clip: AudioClip, volumeScale?: number): void;
        protected _syncStates(): void;
        /**
         * @en
         * Set current playback time, in seconds.
         * @zh
         * 以秒为单位设置当前播放时间。
         * @param num playback time to jump to.
         */
        set currentTime(num: number);
        /**
         * @en
         * Get the current playback time, in seconds.
         * @zh
         * 以秒为单位获取当前播放时间。
         */
        get currentTime(): number;
        /**
         * @en
         * Get the audio duration, in seconds.
         * @zh
         * 获取以秒为单位的音频总时长。
         */
        get duration(): number;
        /**
         * @en
         * Get current audio state.
         * @zh
         * 获取当前音频状态。
         */
        get state(): __private._pal_audio_type__AudioState;
        /**
         * @en
         * Is the audio currently playing?
         * @zh
         * 当前音频是否正在播放？
         */
        get playing(): boolean;
    }
    export class AudioPCMDataView {
        constructor(arrayBufferView: __private._pal_audio_type__AudioBufferView, normalizeFactor: number);
        constructor(arrayBuffer: ArrayBuffer, Ctor: __private._types_globals__Constructor<__private._pal_audio_type__AudioBufferView>, normalizeFactor: number);
        get length(): number;
        getData(offset: number): number;
    }
    export namespace renderer {
        export function createIA(device: gfx.Device, data: primitives.IGeometry): gfx.InputAssembler | null;
        export const addStage: (name: any) => void;
        export namespace scene {
            export enum CameraFOVAxis {
                VERTICAL = 0,
                HORIZONTAL = 1
            }
            export enum CameraProjection {
                ORTHO = 0,
                PERSPECTIVE = 1
            }
            export enum CameraAperture {
                F1_8 = 0,
                F2_0 = 1,
                F2_2 = 2,
                F2_5 = 3,
                F2_8 = 4,
                F3_2 = 5,
                F3_5 = 6,
                F4_0 = 7,
                F4_5 = 8,
                F5_0 = 9,
                F5_6 = 10,
                F6_3 = 11,
                F7_1 = 12,
                F8_0 = 13,
                F9_0 = 14,
                F10_0 = 15,
                F11_0 = 16,
                F13_0 = 17,
                F14_0 = 18,
                F16_0 = 19,
                F18_0 = 20,
                F20_0 = 21,
                F22_0 = 22
            }
            export enum CameraISO {
                ISO100 = 0,
                ISO200 = 1,
                ISO400 = 2,
                ISO800 = 3
            }
            export enum CameraShutter {
                D1 = 0,
                D2 = 1,
                D4 = 2,
                D8 = 3,
                D15 = 4,
                D30 = 5,
                D60 = 6,
                D125 = 7,
                D250 = 8,
                D500 = 9,
                D1000 = 10,
                D2000 = 11,
                D4000 = 12
            }
            export enum CameraType {
                DEFAULT = "Bad expression <-1>",
                LEFT_EYE = 0,
                RIGHT_EYE = 1,
                MAIN = 2
            }
            export enum TrackingType {
                NO_TRACKING = 0,
                POSITION_AND_ROTATION = 1,
                POSITION = 2,
                ROTATION = 3
            }
            export interface ICameraInfo {
                name: string;
                node: Node;
                projection: number;
                targetDisplay?: number;
                window?: __private._cocos_core_renderer_core_render_window__RenderWindow | null;
                priority: number;
                pipeline?: string;
                cameraType?: CameraType;
                trackingType?: TrackingType;
            }
            export const SKYBOX_FLAG: number;
            /**
             * @en The render camera representation in the render scene, it's managed by [[Camera]]
             * @zh 渲染场景中的相机对象，由项目层的 [[Camera]] 管理。
             */
            export class Camera {
                /**
                 * @en This exposure value corresponding to default standard camera exposure parameters.
                 * @zh 默认相机的曝光值。
                 */
                static get standardExposureValue(): number;
                /**
                 * @en The luminance unit scale used by area lights.
                 * @zh 默认局部光源使用的亮度单位缩放。
                 */
                static get standardLightMeterScale(): number;
                /**
                 * @en The name of the camera
                 * @zh 相机的名称
                 */
                get name(): string | null;
                /**
                 * @en The render scene to which the camera is attached
                 * @zh 相机所挂载的场景
                 */
                get scene(): RenderScene | null;
                /**
                 * @en The node of the camera which determines its transform in world space.
                 * @zh 相机绑定的节点，决定了它在世界空间的变换矩阵
                 */
                set node(val: Node);
                get node(): Node;
                /**
                 * @en The render window of the camera
                 * @zh 相机关联的渲染窗口
                 */
                set window(val: __private._cocos_core_renderer_core_render_window__RenderWindow);
                get window(): __private._cocos_core_renderer_core_render_window__RenderWindow;
                /**
                 * @en Whether the camera is enabled, a disabled camera won't be processed in the render pipeline.
                 * @zh 相机是否启用，未启用的相机不会被渲染
                 */
                set enabled(val: boolean);
                get enabled(): boolean;
                /**
                 * @en Visibility mask of the camera, declaring a set of node layers that will be visible to this camera.
                 * @zh 相机的可见性掩码，声明在当前相机中可见的节点层级集合。
                 */
                set visibility(vis: number);
                get visibility(): number;
                /**
                 * @en Render priority of the camera. Cameras with higher depth are rendered after cameras with lower depth.
                 * @zh 相机的渲染优先级，值越小越优先渲染。
                 */
                get priority(): number;
                set priority(val: number);
                /**
                 * @en The width of the camera's view size
                 * @zh 相机的视图宽度
                 */
                get width(): number;
                /**
                 * @en The height of the camera's view size
                 * @zh 相机的视图高度
                 */
                get height(): number;
                /**
                 * @en The world position of the camera
                 * @zh 相机的世界坐标
                 */
                set position(val: math.Vec3);
                get position(): math.Vec3;
                /**
                 * @en The forward vector of the camera's look direction
                 * @zh 指向相机观察方向的向量
                 */
                set forward(val: math.Vec3);
                get forward(): math.Vec3;
                /**
                 * @en Camera aperture, controls the exposure parameter.
                 * @zh 相机光圈，影响相机的曝光参数。
                 */
                set aperture(val: CameraAperture);
                get aperture(): CameraAperture;
                /**
                 * @en Camera aperture value.
                 * @zh 相机光圈值。
                 */
                get apertureValue(): number;
                /**
                 * @en Camera shutter, controls the exposure parameter.
                 * @zh 相机快门，影响相机的曝光参数。
                 */
                set shutter(val: CameraShutter);
                get shutter(): CameraShutter;
                /**
                 * @en Camera shutter value.
                 * @zh 相机快门值。
                 */
                get shutterValue(): number;
                /**
                 * @en Camera ISO, controls the exposure parameter.
                 * @zh 相机感光度，影响相机的曝光参数。
                 */
                set iso(val: CameraISO);
                get iso(): CameraISO;
                /**
                 * @en Camera ISO value.
                 * @zh 相机感光度值。
                 */
                get isoValue(): number;
                /**
                 * @en The calculated exposure of the camera
                 * @zh 相机的曝光参数
                 */
                get exposure(): number;
                /**
                 * @en Clearing flags of the camera, specifies which part of the framebuffer will be actually cleared every frame.
                 * @zh 相机的缓冲清除标志位，指定帧缓冲的哪部分要每帧清除。
                 */
                get clearFlag(): gfx.ClearFlags;
                set clearFlag(flag: gfx.ClearFlags);
                /**
                 * @en Clearing color of the camera.
                 * @zh 相机的颜色缓冲默认值。
                 */
                set clearColor(val: math.IVec4Like);
                get clearColor(): math.IVec4Like;
                /**
                 * @en Clearing depth of the camera.
                 * @zh 相机的深度缓冲默认值。
                 */
                get clearDepth(): number;
                set clearDepth(depth: number);
                /**
                 * @en Clearing stencil of the camera.
                 * @zh 相机的模板缓冲默认值。
                 */
                get clearStencil(): number;
                set clearStencil(stencil: number);
                /**
                 * @en The projection type of the camera.
                 * @zh 相机的投影类型。
                 */
                set projectionType(val: CameraProjection);
                get projectionType(): CameraProjection;
                /**
                 * @en The aspect ratio of the camera
                 * @zh 相机视图的长宽比
                 */
                get aspect(): number;
                /**
                 * @en The viewport height of the orthogonal type camera.
                 * @zh 正交相机的视角高度。
                 */
                set orthoHeight(val: number);
                get orthoHeight(): number;
                /**
                 * @en The axis on which the FOV would be fixed regardless of screen aspect changes.
                 * @zh 指定视角的固定轴向，在此轴上不会跟随屏幕长宽比例变化。
                 */
                set fovAxis(axis: CameraFOVAxis);
                get fovAxis(): CameraFOVAxis;
                /**
                 * @en Field of view of the camera.
                 * @zh 相机的视角大小。
                 */
                set fov(fov: number);
                get fov(): number;
                /**
                 * @en Near clipping distance of the camera, should be as large as possible within acceptable range.
                 * @zh 相机的近裁剪距离，应在可接受范围内尽量取最大。
                 */
                set nearClip(nearClip: number);
                get nearClip(): number;
                /**
                 * @en Far clipping distance of the camera, should be as small as possible within acceptable range.
                 * @zh 相机的远裁剪距离，应在可接受范围内尽量取最小。
                 */
                set farClip(farClip: number);
                get farClip(): number;
                /**
                 * @en The viewport rect of the camera, pre-rotated (i.e. always in identity/portrait mode) if possible.
                 * @zh 相机的视口矩形，如果设备允许的话，这个视口会永远保持竖屏状态，由渲染流程保障旋转的正确。
                 */
                get viewport(): math.Rect;
                set viewport(val: math.Rect);
                /**
                 * @en The view frustum of the camera
                 * @zh 相机的视锥体
                 */
                set frustum(val: geometry.Frustum);
                get frustum(): geometry.Frustum;
                /**
                 * @en The view matrix of the camera
                 * @zh 相机的视图矩阵
                 */
                get matView(): math.Mat4;
                /**
                 * @en The projection matrix of the camera
                 * @zh 相机的投影矩阵
                 */
                get matProj(): math.Mat4;
                /**
                 * @en The inverse of the projection matrix of the camera
                 * @zh 相机的逆投影矩阵
                 */
                get matProjInv(): math.Mat4;
                /**
                 * @en The view projection matrix of the camera
                 * @zh 相机的视图投影矩阵
                 */
                get matViewProj(): math.Mat4;
                /**
                 * @en The inverse of the view projection matrix of the camera
                 * @zh 相机的逆视图投影矩阵
                 */
                get matViewProjInv(): math.Mat4;
                /**
                 * @en Whether the camera is fixed size or matching the window size.
                 * @zh 相机是固定尺寸还是跟随屏幕尺寸
                 */
                isWindowSize: boolean;
                /**
                 * @en Scale of the internal buffer size,
                 * set to 1 to keep the same with the canvas size.
                 * @zh 相机内部缓冲尺寸的缩放值, 1 为与 canvas 尺寸相同。
                 */
                screenScale: number;
                constructor(device: gfx.Device);
                /**
                 * @en Initialize the camera, normally you shouldn't invoke this function, it's managed automatically.
                 * @zh 初始化相机，开发者通常不应该使用这个方法，初始化流程是自动管理的。
                 */
                initialize(info: ICameraInfo): void;
                /**
                 * @en Destroy the camera, you shouldn't invoke this function, it's managed by the render scene.
                 * @zh 销毁相机，开发者不应该使用这个方法，销毁流程是由 RenderScene 管理的。
                 */
                destroy(): void;
                /**
                 * @en Attach the camera to the given render scene so that it will be rendered in it.
                 * @zh 将相机添加到相关的渲染场景中，以便可以被渲染器渲染。
                 * @param scene @en The render scene @zh 渲染场景
                 */
                attachToScene(scene: RenderScene): void;
                /**
                 * @en Detach the camera from previously attached render scene. It will no longer be rendered.
                 * @zh 将相机从之前设置的渲染场景移除，之后将不会再被渲染。
                 */
                detachFromScene(): void;
                /**
                 * @en Resize the view size of the camera.
                 * @zh 重置相机视图尺寸
                 * @param width The width of the view size
                 * @param height The height of the view size
                 */
                resize(width: number, height: number): void;
                /**
                 * @en Set a fixed size for the camera view.
                 * @zh 设置固定相机视图尺寸
                 * @param width The width of the view size
                 * @param height The height of the view size
                 */
                setFixedSize(width: number, height: number): void;
                /**
                 * Editor specific gizmo camera logic
                 * @internal
                 */
                syncCameraEditor(camera: any): void;
                /**
                 * @en Update the camera's builtin matrixes
                 * @zh 更新相机的视图、投影等矩阵
                 * @param forceUpdate If force update, then dirty flag will be ignored
                 */
                update(forceUpdate?: boolean): void;
                get surfaceTransform(): gfx.SurfaceTransform;
                /**
                 * @en Set the viewport in oriented space (equal to the actual screen rotation)
                 * @zh 在目标朝向空间（实际屏幕朝向）内设置相机视口
                 */
                setViewportInOrientedSpace(val: math.Rect): void;
                /**
                 * @en create geometry renderer for this camera
                 * @zh 创建这个摄像机的几何体渲染器
                 */
                initGeometryRenderer(): void;
                /**
                 * @en get geometry renderer of this camera
                 * @zh 获取这个摄像机的几何体渲染器
                 * @returns @en return the geometry renderer @zh 返回几何体渲染器
                 */
                get geometryRenderer(): GeometryRenderer | null;
                get cameraType(): CameraType;
                set cameraType(type: CameraType);
                get trackingType(): TrackingType;
                set trackingType(type: TrackingType);
                /**
                 * @en Change the target render window to another one
                 * @zh 修改相机的目标渲染窗口
                 * @param window The target render window, could be null
                 */
                changeTargetWindow(window?: __private._cocos_core_renderer_core_render_window__RenderWindow | null): void;
                /**
                 * @en Detach camera from the render window
                 * @zh 将 camera 从渲染窗口移除
                 */
                detachCamera(): void;
                /**
                 * @en Transform a screen position (in oriented space) to a world space ray
                 * @zh 将一个屏幕空间（在实际朝向下）点转换到世界空间的射线
                 * @param out the resulting ray
                 * @param x the screen x of the position
                 * @param y the screen y of the position
                 * @returns the resulting ray
                 */
                screenPointToRay(out: geometry.Ray, x: number, y: number): geometry.Ray;
                /**
                 * @en Transform a screen position (in oriented space) to world space
                 * @zh 将一个屏幕空间（在实际朝向下）位置转换到世界空间
                 * @param out the resulting vector
                 * @param screenPos the screen position to be transformed
                 * @returns the resulting vector
                 */
                screenToWorld(out: math.Vec3, screenPos: math.Vec3): math.Vec3;
                /**
                 * @en Transform a world space position to screen space rendered by the camera
                 * @zh 将一个世界空间位置转换到相机渲染后的屏幕空间
                 * @param out the resulting vector
                 * @param worldPos the world position to be transformed
                 * @returns the resulting vector
                 */
                worldToScreen(out: math.Vec3, worldPos: math.Vec3 | Readonly<math.Vec3>): math.Vec3;
                /**
                 * @en Transform a world space matrix to screen space rendered by the camera
                 * @zh 将一个世界空间矩阵转换到相机渲染后的屏幕空间
                 * @param out the resulting matrix
                 * @param worldMatrix the world space matrix to be transformed
                 * @param width framebuffer width
                 * @param height framebuffer height
                 * @returns the resulting matrix
                 */
                worldMatrixToScreen(out: math.Mat4, worldMatrix: math.Mat4, width: number, height: number): math.Mat4;
                /**
                 * @en Set exposure with actual value.
                 * @zh 设置相机的曝光值
                 * @param ev100
                 */
                protected setExposure(ev100: any): void;
            }
            export enum ModelType {
                DEFAULT = 0,
                SKINNING = 1,
                BAKED_SKINNING = 2,
                BATCH_2D = 3,
                PARTICLE_BATCH = 4,
                LINE = 5
            }
            /**
             * @en A representation of a model instance
             * The base model class, which is the core component of [[MeshRenderer]],
             * adds its own Model to the rendered scene for rendering submissions when [[MeshRenderer]] is enabled.
             * This type of object represents a rendering instance in a scene, and it can contain multiple sub models,
             * each of which corresponds to a material. These sub models share the same location and form a complete object.
             * Each sub model references a sub mesh resource, which provides vertex and index buffers for rendering.
             * @zh 代表一个模型实例
             * 基础模型类，它是 [[MeshRenderer]] 的核心组成部分，在 [[MeshRenderer]] 启用时会将自己的 Model 添加到渲染场景中用于提交渲染。
             * 此类型对象代表一个场景中的渲染实例，它可以包含多个子模型，每个子模型对应一个材质。这些子模型共享同样的位置，组成一个完整的物体。
             * 每个子模型引用一个子网格资源，后者提供渲染所用的顶点与索引缓冲。
             */
            export class Model {
                /**
                 * @en Sub models of the current model
                 * @zh 获取所有子模型
                 */
                get subModels(): SubModel[];
                /**
                 * @en Whether the model is initialized
                 * @zh 是否初始化
                 */
                get inited(): boolean;
                /**
                 * @en The axis-aligned bounding box of the model in the world space
                 * @zh 获取世界空间包围盒
                 */
                get worldBounds(): geometry.AABB;
                /**
                 * @en The axis-aligned bounding box of the model in the model space
                 * @zh 获取模型空间包围盒
                 */
                get modelBounds(): geometry.AABB | null;
                /**
                 * @en The ubo buffer of the model
                 * @zh 获取模型的 ubo 缓冲
                 */
                get localBuffer(): gfx.Buffer | null;
                /**
                 * @en The world bound ubo buffer
                 * @zh 获取世界包围盒 ubo 缓冲
                 */
                get worldBoundBuffer(): gfx.Buffer | null;
                /**
                 * @en The time stamp of last update
                 * @zh 获取上次更新时间戳
                 */
                get updateStamp(): number;
                /**
                 * @en Model level shadow bias
                 * @zh 阴影偏移值
                 */
                get shadowBias(): number;
                set shadowBias(val: number);
                /**
                 * @en Model level shadow normal bias
                 * @zh 阴影法线偏移值
                 */
                get shadowNormalBias(): number;
                set shadowNormalBias(val: number);
                /**
                 * @en Whether the model should receive shadow
                 * @zh 是否接收阴影
                 */
                get receiveShadow(): boolean;
                set receiveShadow(val: boolean);
                /**
                 * @en Whether the model should cast shadow
                 * @zh 是否投射阴影
                 */
                get castShadow(): boolean;
                set castShadow(val: boolean);
                /**
                 * @en The node to which the model belongs
                 * @zh 模型所在的节点
                 */
                get node(): Node;
                set node(n: Node);
                /**
                 * @en Model's transform
                 * @zh 模型的变换
                 */
                get transform(): Node;
                set transform(n: Node);
                /**
                 * @en Model's visibility tag
                 * Model's visibility flags, it's different from [[Node.layer]],
                 * but it will also be compared with [[Camera.visibility]] during culling process.
                 * @zh 模型的可见性标志
                 * 模型的可见性标志与 [[Node.layer]] 不同，它会在剔除阶段与 [[Camera.visibility]] 进行比较
                 */
                get visFlags(): number;
                set visFlags(val: number);
                /**
                 * @en Whether the model is enabled in the render scene so that it will be rendered
                 * @zh 模型是否在渲染场景中启用并被渲染
                 */
                get enabled(): boolean;
                set enabled(val: boolean);
                /**
                 * @en Rendering priority in the transparent queue of model.
                 * @zh Model 在透明队列中的渲染排序优先级
                 */
                get priority(): number;
                set priority(val: number);
                /**
                 * @en The type of the model
                 * @zh 模型类型
                 */
                type: ModelType;
                /**
                 * @en The render scene to which the model belongs
                 * @zh 模型所在的场景
                 */
                scene: RenderScene | null;
                /**
                 * @en Whether dynamic batching is enabled for model
                 * @zh 是否动态合批
                 */
                isDynamicBatching: boolean;
                /**
                 * @en The world axis-aligned bounding box
                 * @zh 世界空间包围盒
                 */
                protected _worldBounds: geometry.AABB | null;
                /**
                 * @en The model axis-aligned bounding box
                 * @zh 模型空间包围盒
                 */
                protected _modelBounds: geometry.AABB | null;
                /**
                 * @en Sub models
                 * @zh 子模型
                 */
                protected _subModels: SubModel[];
                /**
                 * @en The node to which the model belongs
                 * @zh 模型所在的节点
                 */
                protected _node: Node;
                /**
                 * @en Model's transform
                 * @zh 子模型的变换
                 */
                protected _transform: Node;
                /**
                 * @en Current gfx device
                 * @zh 当前 GFX 设备
                 */
                protected _device: gfx.Device;
                /**
                 * @en Whether the model is initialized
                 * @zh 是否初始化过
                 */
                protected _inited: boolean;
                /**
                 * @en Descriptor set count
                 * @zh 描述符集合个数
                 */
                protected _descriptorSetCount: number;
                /**
                 * @en Time stamp for last update
                 * @zh 更新时间戳
                 */
                protected _updateStamp: number;
                /**
                 * @en Local ubo data dirty flag
                 * @zh 本地 ubo 数据是否修改过
                 */
                protected _localDataUpdated: boolean;
                /**
                 * @en Local ubo data
                 * @zh 本地 ubo 数据
                 */
                protected _localData: Float32Array;
                /**
                 * @en Local ubo buffer
                 * @zh 本地 ubo 缓冲
                 */
                protected _localBuffer: gfx.Buffer | null;
                /**
                 * @en World AABB buffer
                 * @zh 世界空间包围盒缓冲
                 */
                protected _worldBoundBuffer: gfx.Buffer | null;
                /**
                 * @en Whether the model should receive shadow
                 * @zh 是否接收阴影
                 */
                protected _receiveShadow: boolean;
                /**
                 * @en Whether the model should cast shadow
                 * @zh 是否投射阴影
                 */
                protected _castShadow: boolean;
                /**
                 * @en Shadow bias
                 * @zh 阴影偏移
                 */
                protected _shadowBias: number;
                /**
                 * @en Shadow normal bias
                 * @zh 阴影法线偏移
                 */
                protected _shadowNormalBias: number;
                /**
                 * @en Whether the model is enabled in the render scene so that it will be rendered
                 * @zh 模型是否在渲染场景中启用并被渲染
                 */
                protected _enabled: boolean;
                /**
                 * @en The visibility flags
                 * @zh 可见性标志位
                 */
                protected _visFlags: number;
                protected _priority: number;
                /**
                 * @internal
                 * @en native object
                 * @zh 原生对象
                 */
                /**
                 * @internal
                 * @en return native object
                 * @zh 返回原生对象
                 */
                /**
                 * @en Constructor to create an empty model
                 * @zh 创建一个空模型
                 */
                constructor();
                /**
                 * @en Initialize the model
                 * @zh 初始化模型
                 */
                initialize(): void;
                /**
                 * @en Destroy the model
                 * @zh 销毁模型
                 */
                destroy(): void;
                /**
                 * @en Attach the model to a [[renderer.RenderScene]]
                 * @zh 添加模型到渲染场景 [[renderer.RenderScene]] 中
                 * @param scene destination scene
                 */
                attachToScene(scene: RenderScene): void;
                /**
                 * @en Detach the model from its render scene
                 * @zh 移除场景中的模型
                 */
                detachFromScene(): void;
                /**
                 * @en Update the model's transform
                 * @zh 更新模型的变换
                 * @param stamp time stamp
                 */
                updateTransform(stamp: number): void;
                /**
                 * @en Update the model's world AABB
                 * @zh 更新模型的世界空间包围盒
                 */
                updateWorldBound(): void;
                /**
                 * @en Update the model's ubo
                 * @zh 更新模型的 ubo
                 * @param stamp time stamp
                 */
                updateUBOs(stamp: number): void;
                /**
                 * @en Create the model's AABB
                 * @zh 创建模型的包围盒
                 * @param minPos min position of the AABB
                 * @param maxPos max position of the AABB
                 */
                createBoundingShape(minPos?: math.Vec3, maxPos?: math.Vec3): void;
                /**
                 * @en Initialize a sub model with the sub mesh data and the material.
                 * @zh 用子网格数据和材质初始化一个子模型。
                 * @param idx sub model's index
                 * @param subMeshData sub mesh
                 * @param mat sub material
                 */
                initSubModel(idx: number, subMeshData: RenderingSubMesh, mat: Material): void;
                /**
                 * @en Set material for a given sub model
                 * @zh 为指定的子模型设置材质
                 * @param idx sub model's index
                 * @param subMesh sub mesh
                 */
                setSubModelMesh(idx: number, subMesh: RenderingSubMesh): void;
                /**
                 * @en Set a sub material
                 * @zh 设置一个子材质
                 * @param idx sub model's index
                 * @param mat sub material
                 */
                setSubModelMaterial(idx: number, mat: Material): void;
                /**
                 * @en Pipeline changed callback
                 * @zh 管线更新回调
                 */
                onGlobalPipelineStateChanged(): void;
                /**
                 * @en Shader macro changed callback
                 * @zh Shader 宏更新回调
                 */
                onMacroPatchesStateChanged(): void;
                onGeometryChanged(): void;
                /**
                 * @internal
                 * If the model has lighting map
                 * initialize lighting map info before model initializing
                 * because the lighting map will influence the shader
                 */
                initLightingmap(texture: Texture2D | null, uvParam: math.Vec4): void;
                /**
                 * @en Update the light map info
                 * @zh 更新光照贴图信息
                 * @param texture light map
                 * @param uvParam uv coordinate
                 */
                updateLightingmap(texture: Texture2D | null, uvParam: math.Vec4): void;
                /**
                 * @en Update the shadow bias
                 * @zh 更新阴影偏移
                 */
                updateLocalShadowBias(): void;
                /**
                 * @en Return shader's macro patches
                 * @zh 获取 shader 宏
                 * @param subModelIndex sub model's index
                 */
                getMacroPatches(subModelIndex: number): IMacroPatch[] | null;
                protected _updateAttributesAndBinding(subModelIndex: number): void;
                protected _updateInstancedAttributes(attributes: gfx.Attribute[], subModel: SubModel): void;
                protected _initLocalDescriptors(subModelIndex: number): void;
                protected _initWorldBoundDescriptors(subModelIndex: number): void;
                protected _updateLocalDescriptors(subModelIndex: number, descriptorSet: gfx.DescriptorSet): void;
                protected _updateWorldBoundDescriptors(subModelIndex: number, descriptorSet: gfx.DescriptorSet): void;
            }
            export interface IInstancedAttributeBlock {
                buffer: Uint8Array;
                views: __private._types_globals__TypedArray[];
                attributes: gfx.Attribute[];
            }
            /**
             * @en A sub part of the model, it describes how to render a specific sub mesh.
             * It contains geometry information in [[RenderingSubMesh]] and all sort of rendering configuration like shaders, macro patches, passes etc.
             * @zh 组成模型对象的子模型，它用来描述如何渲染模型的一个子网格。
             * 它包含 [[RenderingSubMesh]] 代表的几何网格信息和所有渲染需要的数据，比如着色器程序，着色器宏定义，渲染 pass，等。
             */
            export class SubModel {
                protected _device: gfx.Device | null;
                protected _passes: Pass[] | null;
                protected _shaders: gfx.Shader[] | null;
                protected _subMesh: RenderingSubMesh | null;
                protected _patches: IMacroPatch[] | null;
                protected _priority: pipeline.RenderPriority;
                protected _inputAssembler: gfx.InputAssembler | null;
                protected _descriptorSet: gfx.DescriptorSet | null;
                protected _worldBoundDescriptorSet: gfx.DescriptorSet | null;
                protected _planarInstanceShader: gfx.Shader | null;
                protected _planarShader: gfx.Shader | null;
                protected _reflectionTex: gfx.Texture | null;
                protected _reflectionSampler: gfx.Sampler | null;
                protected _instancedAttributeBlock: IInstancedAttributeBlock;
                protected _instancedWorldMatrixIndex: number;
                /**
                 * @en
                 * sub model's passes
                 * @zh
                 * 子模型的 passes
                 * @param passes @en The passes @zh 设置的 passes
                 */
                /**
                 * @en Render passes for the sub-model
                 * @zh 子模型的渲染 pass
                 */
                set passes(passes: Pass[]);
                get passes(): Pass[];
                /**
                 * @en Shaders for the sub-model, each shader corresponds to one of the [[passes]]
                 * @zh 子模型的着色器程序列表，每个着色器程序对应其中一个渲染 [[passes]]
                 */
                get shaders(): gfx.Shader[];
                /**
                 * @en The rendering sub mesh for the sub-model, each sub-model can only have one sub mesh.
                 * @zh 用于渲染的子网格对象，每个子模型只能包含一个子网格。
                 */
                set subMesh(subMesh: RenderingSubMesh);
                get subMesh(): RenderingSubMesh;
                /**
                 * @en The rendering priority of the sub-model
                 * @zh 子模型的渲染优先级
                 */
                set priority(val: pipeline.RenderPriority);
                get priority(): pipeline.RenderPriority;
                /**
                 * @en The low level input assembler which contains geometry data
                 * @zh 底层渲染用的输入汇集器，包含几何信息
                 */
                get inputAssembler(): gfx.InputAssembler;
                /**
                 * @en The descriptor set used for sub-model rendering
                 * @zh 底层渲染子模型用的描述符集组
                 */
                get descriptorSet(): gfx.DescriptorSet;
                /**
                 * @en The descriptor set for world bound
                 * @zh 用于存储世界包围盒的描述符集组
                 */
                get worldBoundDescriptorSet(): gfx.DescriptorSet | null;
                /**
                 * @en The macro patches for the shaders
                 * @zh 着色器程序所用的宏定义组合
                 */
                get patches(): IMacroPatch[] | null;
                /**
                 * @en The shader for rendering the planar shadow, instancing draw version.
                 * @zh 用于渲染平面阴影的着色器，适用于实例化渲染（instancing draw）
                 */
                get planarInstanceShader(): gfx.Shader | null;
                /**
                 * @en The shader for rendering the planar shadow.
                 * @zh 用于渲染平面阴影的着色器。
                 */
                get planarShader(): gfx.Shader | null;
                /**
                 * @en The instance attribute block, access by sub model
                 * @zh 硬件实例化属性，通过子模型访问
                 */
                get instancedAttributeBlock(): IInstancedAttributeBlock;
                /**
                 * @en Get or set instance matrix id, access by sub model
                 * @zh 获取或者设置硬件实例化中的矩阵索引，通过子模型访问
                 */
                set instancedWorldMatrixIndex(val: number);
                get instancedWorldMatrixIndex(): number;
                /**
                 * @en
                 * init sub model
                 * @zh
                 * 子模型初始化
                 * @param subMesh @en The sub mesh @zh 子网格资源
                 * @param passes @en The passes @zh 渲染的 passes
                 * @param patches @en The shader's macro @zh 着色器的宏定义
                 */
                initialize(subMesh: RenderingSubMesh, passes: Pass[], patches?: IMacroPatch[] | null): void;
                /**
                 * @en
                 * init planar shadow's shader
                 * @zh
                 * 平面阴影着色器初始化
                 */
                initPlanarShadowShader(): void;
                /**
                 * @en
                 * init planar shadow's instance shader
                 * @zh
                 * 平面阴影实例着色器初始化
                 */
                /**
                 * @internal
                 */
                initPlanarShadowInstanceShader(): void;
                /**
                 * @en
                 * destroy sub model
                 * @zh
                 * 销毁子模型
                 */
                destroy(): void;
                /**
                 * @en
                 * update sub model
                 * @zh
                 * 更新子模型
                 */
                update(): void;
                /**
                 * @en Pipeline changed callback
                 * @zh 管线更新回调
                 */
                onPipelineStateChanged(): void;
                /**
                 * @en Shader macro changed callback
                 * @zh Shader 宏更新回调
                 */
                onMacroPatchesStateChanged(patches: IMacroPatch[] | null): void;
                /**
                 * @en
                 * geometry changed callback
                 * @zh
                 * 几何数据改变后的回调
                 */
                onGeometryChanged(): void;
                /**
                 * @en
                 * get instanced attribute index
                 * @zh
                 * 获取硬件实例化相关索引
                 */
                /**
                 * @internal
                 */
                getInstancedAttributeIndex(name: string): number;
                /**
                 * @en
                 * update instancing related data, invoked by model
                 * @zh
                 * 更新硬件实例化相关数据，一般由model调用
                 */
                /**
                 * @internal
                 */
                updateInstancedWorldMatrix(mat: math.Mat4, idx: number): void;
                /**
                 * @en
                 * update instancing related data, invoked by model
                 * @zh
                 * 更新硬件实例化相关数据，一般由model调用
                 */
                /**
                 * @internal
                 */
                UpdateInstancedAttributes(attributes: gfx.Attribute[]): void;
                protected _flushPassInfo(): void;
            }
            /**
             * @en Ambient lighting representation in the render scene.
             * The initial data is setup in [[SceneGlobals.ambient]].
             * @zh 渲染场景中的环境光照设置。
             * 初始值是由 [[SceneGlobals.ambient]] 设置的。
             */
            export class Ambient {
                /**
                 * @en Default sun illuminance
                 * @zh 默认太阳亮度
                 */
                static SUN_ILLUM: number;
                /**
                 * @en Default sky illuminance
                 * @zh 默认天空亮度
                 */
                static SKY_ILLUM: number;
                /**
                 * @en Enable ambient
                 * @zh 是否开启环境光
                 */
                set enabled(val: boolean);
                get enabled(): boolean;
                /**
                 * @en Sky color
                 * @zh 天空颜色
                 */
                get skyColor(): math.Vec4;
                set skyColor(color: math.Vec4);
                /**
                 * @en Sky illuminance
                 * @zh 天空亮度
                 */
                get skyIllum(): number;
                set skyIllum(illum: number);
                /**
                 * @en Ground color
                 * @zh 地面颜色
                 */
                get groundAlbedo(): math.Vec4;
                set groundAlbedo(color: math.Vec4);
                protected _groundAlbedoHDR: math.Vec4;
                protected _skyColorHDR: math.Vec4;
                protected _skyIllumHDR: number;
                protected _groundAlbedoLDR: math.Vec4;
                protected _skyColorLDR: math.Vec4;
                protected _skyIllumLDR: number;
                protected _mipmapCount: number;
                protected _enabled: boolean;
                initialize(ambientInfo: AmbientInfo): void;
            }
            export const EnvironmentLightingType: {
                /**
                 * @zh
                 * 半球漫反射
                 * @en
                 * hemisphere diffuse
                 * @readonly
                 */
                HEMISPHERE_DIFFUSE: number;
                /**
                 * @zh
                 * 半球漫反射和环境反射
                 * @en
                 * hemisphere diffuse and Environment reflection
                 * @readonly
                 */
                AUTOGEN_HEMISPHERE_DIFFUSE_WITH_REFLECTION: number;
                /**
                 * @zh
                 * 漫反射卷积图和环境反射
                 * @en
                 * diffuse convolution map and environment reflection
                 * @readonly
                 */
                DIFFUSEMAP_WITH_REFLECTION: number;
            };
            /**
             * @en The skybox configuration of the render scene,
             * currently some rendering options like hdr and ibl lighting configuration is also here.
             * @zh 渲染场景的天空盒配置，目前一些渲染配置，比如 HDR 模式和环境光照配置也在 Skybox 中。
             */
            export class Skybox {
                /**
                 * @en The Model object of the skybox
                 * @zh 天空盒的 Model 对象
                 */
                get model(): Model | null;
                /**
                 * @en Whether activate skybox in the scene
                 * @zh 是否启用天空盒？
                 */
                get enabled(): boolean;
                set enabled(val: boolean);
                /**
                 * @en Whether HDR mode is enabled
                 * @zh 是否启用HDR？
                 */
                get useHDR(): boolean;
                set useHDR(val: boolean);
                /**
                 * @en Whether use image based lighting for PBR materials
                 * @zh 是否启用IBL？
                 */
                get useIBL(): boolean;
                set useIBL(val: boolean);
                /**
                 * @en Whether use diffuse convolution map lighting
                 * @zh 是否为IBL启用漫反射卷积图？
                 */
                get useDiffuseMap(): boolean;
                set useDiffuseMap(val: boolean);
                /**
                 * @en Whether enable RGBE data support in skybox shader
                 * @zh 是否需要开启 shader 内的 RGBE 数据支持？
                 */
                get isRGBE(): boolean;
                /**
                 * @en Whether to use offline baked convolutional maps
                 * @zh 是否使用离线烘焙的卷积图？
                 */
                get useConvolutionMap(): boolean;
                /**
                 * @en The texture cube used for the skybox
                 * @zh 使用的立方体贴图
                 */
                get envmap(): TextureCube | null;
                set envmap(val: TextureCube | null);
                /**
                 * @en The texture cube used diffuse convolution map
                 * @zh 使用的漫反射卷积图
                 */
                get diffuseMap(): TextureCube | null;
                set diffuseMap(val: TextureCube | null);
                get reflectionMap(): TextureCube | null;
                protected _envmapLDR: TextureCube | null;
                protected _envmapHDR: TextureCube | null;
                protected _diffuseMapLDR: TextureCube | null;
                protected _diffuseMapHDR: TextureCube | null;
                protected _globalDSManager: __private._cocos_core_pipeline_global_descriptor_set_manager__GlobalDSManager | null;
                protected _model: Model | null;
                protected _default: TextureCube | null;
                protected _enabled: boolean;
                protected _useIBL: boolean;
                protected _useHDR: boolean;
                protected _useDiffuseMap: boolean;
                protected _editableMaterial: MaterialInstance | null;
                protected _activated: boolean;
                protected _reflectionHDR: TextureCube | null;
                protected _reflectionLDR: TextureCube | null;
                protected _rotationAngle: number;
                initialize(skyboxInfo: SkyboxInfo): void;
                /**
                 * @en Set the environment maps for HDR and LDR mode
                 * @zh 为 HDR 和 LDR 模式设置环境贴图
                 * @param envmapHDR @en Environment map for HDR mode @zh HDR 模式下的环境贴图
                 * @param envmapLDR @en Environment map for LDR mode @zh LDR 模式下的环境贴图
                 */
                setEnvMaps(envmapHDR: TextureCube | null, envmapLDR: TextureCube | null): void;
                /**
                 * @en Set the diffuse maps
                 * @zh 设置环境光漫反射贴图
                 * @param diffuseMapHDR @en Diffuse map for HDR mode @zh HDR 模式下的漫反射贴图
                 * @param diffuseMapLDR  @en Diffuse map for LDR mode @zh LDR 模式下的漫反射贴图
                 */
                setDiffuseMaps(diffuseMapHDR: TextureCube | null, diffuseMapLDR: TextureCube | null): void;
                /**
                 * @en Set custom skybox material
                 * @zh 设置自定义的天空盒材质
                 * @param skyboxMat  @en Skybox material @zh 天空盒材质
                 */
                setSkyboxMaterial(skyboxMat: Material | null): void;
                /**
                 * @en Set the environment reflection convolution map
                 * @zh 设置环境反射卷积图
                 * @param reflectionHDR  @en Reflection convolution map for HDR mode @zh HDR 模式下的反射卷积图
                 * @param reflectionLDR  @en Reflection convolution map for LDR mode @zh LDR 模式下的反射卷积图
                 */
                setReflectionMaps(reflectionHDR: TextureCube | null, reflectionLDR: TextureCube | null): void;
                /**
                 * @en Set skybox rotation angle
                 * @zh 设置天空盒旋转角度
                 * @param angle  @en rotation angle @zh 旋转角度
                 */
                setRotationAngle(angle: number): void;
                getRotationAngle(): number;
                updateMaterialRenderInfo(): void;
                activate(): void;
                protected _updatePipeline(): void;
                protected _updateGlobalBinding(): void;
                protected _updateSubModes(): void;
            }
            /**
             * @zh 阴影贴图分辨率。
             * @en The shadow map size.
             * @static
             * @enum Shadows.ShadowSize
             */
            export const ShadowSize: {
                /**
                 * @zh 分辨率 256 * 256。
                 * @en shadow resolution 256 * 256.
                 * @readonly
                 */
                Low_256x256: number;
                /**
                 * @zh 分辨率 512 * 512。
                 * @en shadow resolution 512 * 512.
                 * @readonly
                 */
                Medium_512x512: number;
                /**
                 * @zh 分辨率 1024 * 1024。
                 * @en shadow resolution 1024 * 1024.
                 * @readonly
                 */
                High_1024x1024: number;
                /**
                 * @zh 分辨率 2048 * 2048。
                 * @en shadow resolution 2048 * 2048.
                 * @readonly
                 */
                Ultra_2048x2048: number;
            };
            /**
             * @zh 阴影类型。
             * @en The shadow type
             * @enum Shadows.ShadowType
             */
            export const ShadowType: {
                /**
                 * @zh 平面阴影。
                 * @en Planar shadow
                 * @property Planar
                 * @readonly
                 */
                Planar: number;
                /**
                 * @zh 阴影贴图。
                 * @en Shadow type
                 * @property ShadowMap
                 * @readonly
                 */
                ShadowMap: number;
            };
            /**
             * @zh pcf阴影等级。
             * @en The pcf type
             * @static
             * @enum Shadows.PCFType
             */
            export const PCFType: {
                /**
                 * @zh x1 次采样
                 * @en x1 times
                 * @readonly
                 */
                HARD: number;
                /**
                 * @zh x4 次采样
                 * @en x4 times
                 * @readonly
                 */
                SOFT: number;
                /**
                 * @zh x9 次采样
                 * @en x9 times
                 * @readonly
                 */
                SOFT_2X: number;
                /**
                 * @zh x16 次采样
                 * @en x16 times
                 * @readonly
                 */
                SOFT_4X: number;
            };
            /**
             * @zh 级联阴影贴图层级。
             * @en The CSM shadow level
             * @enum Shadows.CSMLevel
             */
            export const CSMLevel: {
                /**
                 * @zh 1 个层级
                 * @en level 1
                 * @readonly
                 */
                LEVEL_1: number;
                /**
                 * @zh 2 个层级
                 * @en level 2
                 * @readonly
                 */
                LEVEL_2: number;
                /**
                 * @zh 3 个层级
                 * @en level 3
                 * @readonly
                 */
                LEVEL_3: number;
                /**
                 * @zh 4 个层级
                 * @en level 4
                 * @readonly
                 */
                LEVEL_4: number;
            };
            /**
             * @zh 级联阴影性能优化模式。
             * @en The CSM performance optimization mode
             * @enum Shadows.CSMOptimizationMode
             */
            export const CSMOptimizationMode: {
                /**
                 * @zh 没有性能优化
                 * @en has no performance optimization
                 * @readonly
                 */
                NONE: number;
                /**
                 * @zh 剔除层与层之间重复物体
                 * @en Eliminate duplicate objects between layers
                 * @readonly
                 */
                RemoveDuplicates: number;
                /**
                 * @zh 取消稳抖
                 * @en Disable rotation fix
                 * @readonly
                 */
                DisableRotationFix: number;
            };
            /**
             * @en The global shadow's configuration of the render scene
             * @zh 渲染场景的全局阴影配置
             */
            export class Shadows {
                /**
                 * @en MAX_FAR. This is shadow camera max far.
                 * @zh 阴影相机的最远视距。
                 */
                static readonly MAX_FAR: number;
                /**
                 * @en EXPANSION_RATIO. This is shadow boundingBox Coefficient of expansion.
                 * @zh 阴影包围盒扩大系数。
                 */
                static readonly COEFFICIENT_OF_EXPANSION: number;
                /**
                 * @en Whether activate planar shadow.
                 * @zh 是否启用平面阴影？
                 */
                get enabled(): boolean;
                set enabled(val: boolean);
                /**
                 * @en Shadow type.
                 * @zh 阴影类型。
                 */
                get type(): number;
                set type(val: number);
                /**
                 * @en The normal of the plane which receives shadow.
                 * @zh 阴影接收平面的法线。
                 */
                get normal(): math.Vec3;
                set normal(val: math.Vec3);
                /**
                 * @en The distance from coordinate origin to the receiving plane.
                 * @zh 阴影接收平面与原点的距离。
                 */
                get distance(): number;
                set distance(val: number);
                /**
                 * @en Shadow color.
                 * @zh 阴影颜色。
                 */
                get shadowColor(): math.Color;
                set shadowColor(color: math.Color);
                /**
                 * @en get or set shadow camera orthoSize.
                 * @zh 获取或者设置阴影纹理大小。
                 */
                get size(): math.Vec2;
                set size(val: math.Vec2);
                /**
                 * @en shadow Map size has been modified.
                 * @zh 阴影贴图大小是否被修改。
                 */
                get shadowMapDirty(): boolean;
                set shadowMapDirty(val: boolean);
                /**
                 * @en The transform matrix of the light source
                 * @zh 光源的变换矩阵
                 */
                get matLight(): math.Mat4;
                get material(): Material;
                get instancingMaterial(): Material;
                /**
                 * @en The bounding sphere of the shadow map.
                 * @zh 用于计算固定区域阴影 Shadow map 的场景包围球.
                 */
                fixedSphere: geometry.Sphere;
                /**
                 * @en get or set shadow max received.
                 * @zh 阴影接收的最大灯光数量。
                 */
                maxReceived: number;
                protected _matLight: math.Mat4;
                protected _material: Material | null;
                protected _instancingMaterial: Material | null;
                protected _enabled: boolean;
                protected _type: number;
                protected _distance: number;
                protected _normal: math.Vec3;
                protected _shadowColor: math.Color;
                protected _size: math.Vec2;
                protected _shadowMapDirty: boolean;
                /**
                 * @en Get the shader for the planar shadow with macro patches
                 * @zh 通过指定宏获取平面阴影的 Shader 对象
                 * @param patches The macro patches for the shader
                 * @returns The shader for the planar shadow
                 */
                getPlanarShader(patches: IMacroPatch[] | null): gfx.Shader | null;
                /**
                 * @en Get the shader which support instancing draw for the planar shadow with macro patches
                 * @zh 通过指定宏获取支持实例化渲染的平面阴影的 Shader 对象
                 * @param patches The macro patches for the shader
                 * @returns The shader for the planar shadow
                 */
                getPlanarInstanceShader(patches: IMacroPatch[] | null): gfx.Shader | null;
                initialize(shadowsInfo: ShadowsInfo): void;
                activate(): void;
                protected _updatePlanarInfo(): void;
                destroy(): void;
            }
            /**
             * @zh
             * 全局雾类型。
             * @en
             * The global fog type
             * @static
             * @enum FogInfo.FogType
             */
            export const FogType: {
                /**
                 * @zh
                 * 线性雾。
                 * @en
                 * Linear fog
                 * @readonly
                 */
                LINEAR: number;
                /**
                 * @zh
                 * 指数雾。
                 * @en
                 * Exponential fog
                 * @readonly
                 */
                EXP: number;
                /**
                 * @zh
                 * 指数平方雾。
                 * @en
                 * Exponential square fog
                 * @readonly
                 */
                EXP_SQUARED: number;
                /**
                 * @zh
                 * 层叠雾。
                 * @en
                 * Layered fog
                 * @readonly
                 */
                LAYERED: number;
            };
            /**
             * @en The fog representation in the render scene.
             * @zh 渲染场景中的全局雾效配置
             */
            export class Fog {
                /**
                 * @zh 是否启用全局雾效
                 * @en Enable global fog
                 */
                set enabled(val: boolean);
                get enabled(): boolean;
                /**
                 * @zh 是否启用精确雾效(像素雾)计算
                 * @en Enable accurate fog (pixel fog)
                 */
                set accurate(val: boolean);
                get accurate(): boolean;
                /**
                 * @zh 全局雾颜色
                 * @en Global fog color
                 */
                set fogColor(val: math.Color);
                get fogColor(): math.Color;
                /**
                 * @zh 当前雾化类型。
                 * @en The current global fog type.
                 * @returns {FogType}
                 * Returns the current global fog type
                 * - -1:Disable global Fog
                 * - 0:Linear fog
                 * - 1:Exponential fog
                 * - 2:Exponential square fog
                 * - 3:Layered fog
                 */
                get type(): number;
                set type(val: number);
                /**
                 * @zh 全局雾浓度
                 * @en Global fog density
                 */
                get fogDensity(): number;
                set fogDensity(val: number);
                /**
                 * @zh 雾效起始位置，只适用于线性雾
                 * @en Global fog start position, only for linear fog
                 */
                get fogStart(): number;
                set fogStart(val: number);
                /**
                 * @zh 雾效结束位置，只适用于线性雾
                 * @en Global fog end position, only for linear fog
                 */
                get fogEnd(): number;
                set fogEnd(val: number);
                /**
                 * @zh 雾效衰减
                 * @en Global fog attenuation
                 */
                get fogAtten(): number;
                set fogAtten(val: number);
                /**
                 * @zh 雾效顶部范围，只适用于层级雾
                 * @en Global fog top range, only for layered fog
                 */
                get fogTop(): number;
                set fogTop(val: number);
                /**
                 * @zh 雾效范围，只适用于层级雾
                 * @en Global fog range, only for layered fog
                 */
                get fogRange(): number;
                set fogRange(val: number);
                get colorArray(): Readonly<math.Vec4>;
                protected _fogColor: math.Color;
                protected _colorArray: math.Vec4;
                protected _enabled: boolean;
                protected _accurate: boolean;
                protected _type: number;
                protected _fogDensity: number;
                protected _fogStart: number;
                protected _fogEnd: number;
                protected _fogAtten: number;
                protected _fogTop: number;
                protected _fogRange: number;
                protected _activated: boolean;
                initialize(fogInfo: FogInfo): void;
                activate(): void;
                protected _updatePipeline(): void;
            }
            /**
             * @en The octree culling configuration of the render scene
             * @zh 渲染场景的八叉树剔除配置
             */
            export class Octree {
                /**
                 * @en Whether octree culling is enabled in the render scene
                 * @zh 是否开启八叉树加速剔除
                 */
                set enabled(val: boolean);
                get enabled(): boolean;
                /**
                 * @en Minimum position of the scene's bounding box
                 * @zh 场景包围盒最小值
                 */
                get minPos(): math.Vec3;
                set minPos(val: math.Vec3);
                /**
                 * @en Maximum position of the scene's bounding box
                 * @zh 场景包围盒最大值
                 */
                get maxPos(): math.Vec3;
                set maxPos(val: math.Vec3);
                /**
                 * @en The depth of the octree
                 * @zh 八叉树深度
                 */
                get depth(): number;
                set depth(val: number);
                protected _enabled: boolean;
                protected _minPos: math.Vec3;
                protected _maxPos: math.Vec3;
                protected _depth: number;
                initialize(octreeInfo: OctreeInfo): void;
            }
            export function ColorTemperatureToRGB(rgb: math.Vec3, kelvin: number): void;
            /**
             * @en The light type enumeration.
             * @zh 光源类型枚举。
             */
            export enum LightType {
                DIRECTIONAL = 0,
                SPHERE = 1,
                SPOT = 2,
                UNKNOWN = 3
            }
            export const nt2lm: (size: number) => number;
            /**
             * @en The abstract light class of the render scene
             * @zh 渲染场景中的光源基类
             */
            export class Light {
                /**
                 * @en Whether it's a baked light source, baked light will be ignored in real time lighting pass
                 * @zh 是否是烘焙光源，烘焙光源会在实时光照计算中被忽略
                 */
                get baked(): boolean;
                set baked(val: boolean);
                /**
                 * @en The color of the light
                 * @zh 光源的颜色
                 */
                set color(color: math.Vec3);
                get color(): math.Vec3;
                /**
                 * @en Whether to use color temperature
                 * @zh 是否使用光源的色温
                 */
                set useColorTemperature(enable: boolean);
                get useColorTemperature(): boolean;
                /**
                 * @en The color temperature of the light
                 * @zh 光源的色温
                 */
                set colorTemperature(val: number);
                get colorTemperature(): number;
                /**
                 * @en The float RGB value of the color temperature, each channel is from 0 to 1
                 * @zh 色温的浮点数颜色值，每个通道都是从 0 到 1
                 */
                get colorTemperatureRGB(): math.Vec3;
                set node(n: Node | null);
                /**
                 * @en The node which owns the light source
                 * @zh 光源归属的节点
                 */
                get node(): Node | null;
                /**
                 * @en The type of the light source, e.g. directional light, spot light, etc
                 * @zh 光源的类型，比如方向光、聚光灯等
                 */
                get type(): LightType;
                /**
                 * @en The name of the light source
                 * @zh 光源的名字
                 */
                get name(): string | null;
                set name(n: string | null);
                /**
                 * @en The render scene which owns the current light
                 * @zh 光源所属的渲染场景
                 */
                get scene(): RenderScene | null;
                protected _baked: boolean;
                protected _color: math.Vec3;
                protected _colorTemp: number;
                protected _colorTempRGB: math.Vec3;
                protected _scene: RenderScene | null;
                protected _node: Node | null;
                protected _name: string | null;
                protected _useColorTemperature: boolean;
                protected _type: LightType;
                initialize(): void;
                /**
                 * @en Attach the light to a render scene
                 * @zh 将光源挂载到渲染场景上
                 * @param scene @en The render scene @zh 渲染场景
                 */
                attachToScene(scene: RenderScene): void;
                /**
                 * @en Detach the light from the render scene
                 * @zh 将光源从渲染场景上移除
                 */
                detachFromScene(): void;
                destroy(): void;
                update(): void;
            }
            /**
             * @en The directional light representation in the render scene, it acts as the main light source in a scene.
             * As main light, only one directional light can be created in a scene, it can generate realtime shadows with configuration.
             * @zh 渲染场景中的方向光抽象，这是场景中的主光源。作为主光源，每个场景只能有一个方向光，它也包含阴影配置，用来生成实时阴影。
             */
            export class DirectionalLight extends Light {
                protected _dir: math.Vec3;
                protected _illuminanceHDR: number;
                protected _illuminanceLDR: number;
                protected _shadowEnabled: boolean;
                protected _shadowPcf: number;
                protected _shadowBias: number;
                protected _shadowNormalBias: number;
                protected _shadowSaturation: number;
                protected _shadowDistance: number;
                protected _shadowInvisibleOcclusionRange: number;
                protected _csmLevel: number;
                protected _csmNeedUpdate: boolean;
                protected _csmLayerLambda: number;
                protected _csmOptimizationMode: number;
                protected _shadowFixedArea: boolean;
                protected _shadowNear: number;
                protected _shadowFar: number;
                protected _shadowOrthoSize: number;
                /**
                 * @en The direction vector of the light
                 * @zh 光源的方向
                 */
                set direction(dir: math.Vec3);
                get direction(): math.Vec3;
                /**
                 * @en The illuminance of the light in Lux(lx)
                 * @zh 光源的辐照度，单位是 Lux(lx)
                 */
                get illuminance(): number;
                set illuminance(value: number);
                /**
                 * @en The illuminance of the light in HDR mode
                 * @zh HDR 模式下光源的辐照度
                 */
                get illuminanceHDR(): number;
                set illuminanceHDR(value: number);
                /**
                 * @en The illuminance of the light in LDR mode
                 * @zh LDR 模式下光源的辐照度
                 */
                get illuminanceLDR(): number;
                set illuminanceLDR(value: number);
                /**
                 * @en Whether activate shadow
                 * @zh 是否启用阴影？
                 */
                get shadowEnabled(): boolean;
                set shadowEnabled(val: boolean);
                /**
                 * @en get or set shadow pcf.
                 * @zh 获取或者设置阴影pcf等级。
                 */
                get shadowPcf(): number;
                set shadowPcf(val: number);
                /**
                 * @en get or set shadow map sampler offset
                 * @zh 获取或者设置阴影纹理偏移值
                 */
                get shadowBias(): number;
                set shadowBias(val: number);
                /**
                 * @en get or set normal bias.
                 * @zh 设置或者获取法线偏移。
                 */
                get shadowNormalBias(): number;
                set shadowNormalBias(val: number);
                /**
                 * @en Shadow color saturation
                 * @zh 阴影颜色饱和度
                 */
                get shadowSaturation(): number;
                set shadowSaturation(val: number);
                /**
                 * @en get or set shadow camera far
                 * @zh 获取或者设置潜在阴影产生的范围
                 */
                get shadowDistance(): number;
                set shadowDistance(val: number);
                /**
                 * @en get or set shadow camera far
                 * @zh 获取或者设置潜在阴影产生的范围
                 */
                get shadowInvisibleOcclusionRange(): number;
                set shadowInvisibleOcclusionRange(val: number);
                /**
                 * @en get or set shadow CSM level
                 * @zh 获取或者设置级联阴影层数
                 */
                get csmLevel(): number;
                set csmLevel(val: number);
                /**
                 * @en is CSM need update
                 * @zh 获取或者设置级联阴影是否需要更新
                 */
                get csmNeedUpdate(): boolean;
                set csmNeedUpdate(val: boolean);
                /**
                 * @en get or set shadow CSM level ratio
                 * @zh 获取或者设置级联阴影层数系数
                 */
                get csmLayerLambda(): number;
                set csmLayerLambda(val: number);
                /**
                 * @en get or set shadow CSM performance optimization mode
                 * @zh 获取或者设置级联阴影性能优化模式
                 */
                get csmOptimizationMode(): number;
                set csmOptimizationMode(val: number);
                /**
                 * @en get or set fixed area shadow
                 * @zh 是否是固定区域阴影
                 */
                get shadowFixedArea(): boolean;
                set shadowFixedArea(val: boolean);
                /**
                 * @en The near clip plane of the shadow camera
                 * @zh 获取或者设置阴影相机近裁剪面
                 */
                get shadowNear(): number;
                set shadowNear(val: number);
                /**
                 * @en The far clip plane of the shadow camera
                 * @zh 获取或者设置阴影相机远裁剪面
                 */
                get shadowFar(): number;
                set shadowFar(val: number);
                /**
                 * @en get or set shadow camera orthoSize
                 * @zh 获取或者设置阴影相机正交大小
                 */
                get shadowOrthoSize(): number;
                set shadowOrthoSize(val: number);
                constructor();
                initialize(): void;
                /**
                 * @en Update the direction
                 * @zh 更新方向
                 */
                update(): void;
            }
            /**
             * @en The sphere light representation in the render scene, it will light up a spherical area in the scene.
             * It doesn't support shadow generation currently.
             * @zh 渲染场景中的球面光抽象，可以照亮场景中的一个球形区域，目前还不支持生成阴影。
             */
            export class SphereLight extends Light {
                /**
                 * @en The world position of the light source
                 * @zh 光源中心点的世界坐标
                 */
                get position(): math.Vec3;
                /**
                 * @en The size of the light source
                 * @zh 球面光源的尺寸
                 */
                set size(size: number);
                get size(): number;
                /**
                 * @en The lighting range of the light source
                 * @zh 球面光源的光照范围
                 */
                set range(range: number);
                get range(): number;
                /**
                 * @en The luminance of the light source
                 * @zh 光源的亮度
                 */
                get luminance(): number;
                set luminance(value: number);
                /**
                 * @en The luminance of the light source in HDR mode
                 * @zh HDR 模式下光源的亮度
                 */
                get luminanceHDR(): number;
                set luminanceHDR(value: number);
                /**
                 * @en The luminance of the light source in LDR mode
                 * @zh LDR 模式下光源的亮度
                 */
                set luminanceLDR(value: number);
                /**
                 * @en The AABB bounding box of the lighting area
                 * @zh 受光源影响范围的 AABB 包围盒
                 */
                get aabb(): geometry.AABB;
                protected _needUpdate: boolean;
                protected _size: number;
                protected _range: number;
                protected _luminanceHDR: number;
                protected _luminanceLDR: number;
                protected _pos: math.Vec3;
                protected _aabb: geometry.AABB;
                constructor();
                initialize(): void;
                /**
                 * @en Update the lighting area
                 * @zh 更新光源影响范围
                 */
                update(): void;
            }
            /**
             * @en The spot light representation in the render scene, it will light up a cone area in the direction of the light, it supports shadow generation.
             * @zh 渲染场景中的聚光灯抽象，可以照亮光源方向上的一个锥形区域，支持生成阴影。
             */
            export class SpotLight extends Light {
                protected _dir: math.Vec3;
                protected _range: number;
                protected _spotAngle: number;
                protected _pos: math.Vec3;
                protected _aabb: geometry.AABB;
                protected _frustum: geometry.Frustum;
                /**
                 * @en User-specified full-angle radians.
                 * @zh 用户指定的全角弧度。
                 */
                protected _angle: number;
                protected _needUpdate: boolean;
                protected _size: number;
                protected _luminanceHDR: number;
                protected _luminanceLDR: number;
                protected _shadowEnabled: boolean;
                protected _shadowPcf: number;
                protected _shadowBias: number;
                protected _shadowNormalBias: number;
                /**
                 * @en The world position of the light source
                 * @zh 光源的世界坐标
                 */
                get position(): math.Vec3;
                /**
                 * @en The size of the spot light source
                 * @zh 聚光灯的光源尺寸
                 */
                set size(size: number);
                get size(): number;
                /**
                 * @en The lighting range of the spot light
                 * @zh 聚光灯的光照范围
                 */
                set range(range: number);
                get range(): number;
                /**
                 * @en The luminance of the light source
                 * @zh 光源的亮度
                 */
                get luminance(): number;
                set luminance(value: number);
                /**
                 * @en The luminance of the light source in HDR mode
                 * @zh HDR 模式下光源的亮度
                 */
                get luminanceHDR(): number;
                set luminanceHDR(value: number);
                /**
                 * @en The luminance of the light source in LDR mode
                 * @zh LDR 模式下光源的亮度
                 */
                get luminanceLDR(): number;
                set luminanceLDR(value: number);
                /**
                 * @en The direction of the spot light
                 * @zh 聚光灯的照明方向
                 */
                get direction(): math.Vec3;
                /**
                 * @en The setter will take the value as the cone angle,
                 * but the getter will give you the cosine value of the half cone angle: `cos(angle / 2)`.
                 * As the in-consistence is not acceptable for a property, please do not use it.
                 * @zh 赋值时这个属性会把输入值当做聚光灯光照区域的锥角，但是获取时返回的是 cos(angle / 2)。
                 * 由于这种不一致性，请不要使用这个属性。
                 * @internal
                 */
                get spotAngle(): number;
                set spotAngle(val: number);
                /**
                 * @en The cone angle of the lighting area
                 * @zh 聚光灯锥角
                 */
                get angle(): number;
                get aabb(): geometry.AABB;
                /**
                 * @en The frustum of the lighting area
                 * @zh 受光源影响范围的截椎体
                 */
                get frustum(): geometry.Frustum;
                /**
                 * @en Whether shadow casting is enabled
                 * @zh 是否启用阴影？
                 */
                get shadowEnabled(): boolean;
                set shadowEnabled(val: boolean);
                /**
                 * @en The pcf level of the shadow generation.
                 * @zh 获取或者设置阴影 pcf 等级。
                 */
                get shadowPcf(): number;
                set shadowPcf(val: number);
                /**
                 * @en The depth offset of shadow to avoid moire pattern artifacts
                 * @zh 阴影的深度偏移, 可以减弱跨像素导致的条纹状失真
                 */
                get shadowBias(): number;
                set shadowBias(val: number);
                /**
                 * @en The normal bias of the shadow map.
                 * @zh 设置或者获取法线偏移。
                 */
                get shadowNormalBias(): number;
                set shadowNormalBias(val: number);
                constructor();
                initialize(): void;
                update(): void;
            }
        }
        export enum RenderQueue {
            OPAQUE = 0,
            TRANSPARENT = 1,
            OVERLAY = 2
        }
        export enum PassStage {
            DEFAULT = 1,
            FORWARD = 2,
            SHADOWCAST = 4
        }
        /**
         * @en Gets the default values for the given type of uniform
         * @zh 根据指定的 Uniform 类型来获取默认值
         * @param type The type of the uniform
         */
        export function getDefaultFromType(type: gfx.Type): readonly number[] | string;
        export function getStringFromType(type: gfx.Type): string;
        /**
         * @en Override the preprocess macros
         * @zh 覆写预处理宏
         * @param target Target preprocess macros to be overridden
         * @param source Preprocess macros used for override
         */
        export function overrideMacros(target: MacroRecord, source: MacroRecord): boolean;
        export const genHandle: (binding: number, type: gfx.Type, count: number, offset?: number) => number;
        export const getTypeFromHandle: (handle: number) => number;
        export const getBindingFromHandle: (handle: number) => number;
        export const getCountFromHandle: (handle: number) => number;
        export const getOffsetFromHandle: (handle: number) => number;
        export const customizeType: (handle: number, type: gfx.Type) => number;
        /**
         * @en Vector type uniforms
         * @zh 向量类型 uniform
         */
        export type MaterialProperty = number | math.Vec2 | math.Vec3 | math.Vec4 | math.Color | math.Mat3 | math.Mat4 | math.Quat;
        export const type2reader: {
            0: (a: Float32Array, v: number, idx?: number) => void;
            5: (a: Int32Array, v: number, idx?: number) => number;
            6: (a: Int32Array, v: math.IVec2Like, idx?: number) => math.IVec2Like;
            7: (a: Int32Array, v: math.IVec3Like, idx?: number) => math.IVec3Like;
            8: (a: Int32Array, v: math.IVec4Like, idx?: number) => math.IVec4Like;
            13: (a: Float32Array, v: number, idx?: number) => number;
            14: (a: Float32Array, v: math.IVec2Like, idx?: number) => math.IVec2Like;
            15: (a: Float32Array, v: math.IVec3Like, idx?: number) => math.IVec3Like;
            16: (a: Float32Array, v: math.IVec4Like, idx?: number) => math.IVec4Like;
            21: (a: Float32Array, v: math.IMat3Like, idx?: number) => math.IMat3Like;
            25: (a: Float32Array, v: math.IMat4Like, idx?: number) => math.IMat4Like;
        };
        export const type2writer: {
            0: (a: Float32Array, v: number, idx?: number) => void;
            5: (a: Int32Array, v: number, idx?: number) => number;
            6: (a: Int32Array, v: math.IVec2Like, idx?: number) => Int32Array;
            7: (a: Int32Array, v: math.IVec3Like, idx?: number) => Int32Array;
            8: (a: Int32Array, v: math.IVec4Like, idx?: number) => Int32Array;
            13: (a: Float32Array, v: number, idx?: number) => number;
            14: (a: Float32Array, v: math.IVec2Like, idx?: number) => Float32Array;
            15: (a: Float32Array, v: math.IVec3Like, idx?: number) => Float32Array;
            16: (a: Float32Array, v: math.IVec4Like, idx?: number) => Float32Array;
            21: (a: Float32Array, v: math.IMat3Like, idx?: number) => Float32Array;
            25: (a: Float32Array, v: math.IMat4Like, idx?: number) => Float32Array;
        };
        /**
         * @en Combination of preprocess macros
         * @zh 预处理宏组合
         */
        export type MacroRecord = Record<string, number | boolean | string>;
        export interface IPassInfoFull extends EffectAsset.IPassInfo {
            passIndex: number;
            defines: MacroRecord;
            stateOverrides?: PassOverrides;
        }
        export type PassOverrides = __private._types_globals__RecursivePartial<EffectAsset.IPassStates>;
        export interface IMacroPatch {
            name: string;
            value: boolean | number | string;
        }
        export enum BatchingSchemes {
            NONE = 0,
            INSTANCING = 1,
            VB_MERGING = 2
        }
        /**
         * @en Render pass, store actual resources for the rendering process
         * @zh 渲染 pass，储存实际描述绘制过程的各项资源。
         */
        export class Pass {
            /**
             * @en Get the type of member in uniform buffer object with the handle
             * @zh 根据 handle 获取 uniform 的具体类型。
             */
            static getTypeFromHandle: (handle: number) => number;
            /**
             * @en Get the binding with handle
             * @zh 根据 handle 获取 binding。
             */
            static getBindingFromHandle: (handle: number) => number;
            /**
             * @en Get the array length with handle
             * @zh 根据 handle 获取数组长度。
             */
            static getCountFromHandle: (handle: number) => number;
            protected static getOffsetFromHandle: (handle: number) => number;
            /**
             * @en Fill a pass represented by the given pass handle with the given override info
             * @param hPass The pass handle point to the pass
             * @param info The pass override info
             */
            static fillPipelineInfo(pass: Pass, info: PassOverrides): void;
            /**
             * @en Get pass hash value by [[renderer.Pass]] hash information.
             * @zh 根据 [[renderer.Pass]] 的哈希信息获取哈希值。
             *
             * @param hPass Handle of the pass info used to compute hash value.
             */
            static getPassHash(pass: Pass): number;
            protected _rootBuffer: gfx.Buffer | null;
            protected _buffers: gfx.Buffer[];
            protected _descriptorSet: gfx.DescriptorSet;
            protected _pipelineLayout: gfx.PipelineLayout;
            protected _passIndex: number;
            protected _propertyIndex: number;
            protected _programName: string;
            protected _dynamics: __private._cocos_core_renderer_core_pass__IPassDynamics;
            protected _propertyHandleMap: Record<string, number>;
            protected _rootBlock: ArrayBuffer | null;
            protected _blocksInt: Int32Array[];
            protected _blocks: Float32Array[];
            protected _shaderInfo: IProgramInfo;
            protected _defines: MacroRecord;
            protected _properties: Record<string, EffectAsset.IPropertyInfo>;
            protected _shader: gfx.Shader | null;
            protected _bs: gfx.BlendState;
            protected _dss: gfx.DepthStencilState;
            protected _rs: gfx.RasterizerState;
            protected _priority: pipeline.RenderPriority;
            protected _stage: pipeline.RenderPassStage;
            protected _phase: number;
            protected _primitive: gfx.PrimitiveMode;
            protected _batchingScheme: BatchingSchemes;
            protected _dynamicStates: gfx.DynamicStateFlagBit;
            protected _instancedBuffers: Record<number, InstancedBuffer>;
            protected _batchedBuffers: Record<number, __private._cocos_core_pipeline_batched_buffer__BatchedBuffer>;
            protected _hash: number;
            protected _root: Root;
            protected _device: gfx.Device;
            protected _rootBufferDirty: boolean;
            constructor(root: Root);
            /**
             * @en Initialize the pass with given pass info, shader will be compiled in the init process
             * @zh 根据指定参数初始化当前 pass，shader 会在这一阶段就尝试编译。
             */
            initialize(info: IPassInfoFull): void;
            /**
             * @en Get the handle of a UBO member, or specific channels of it.
             * @zh 获取指定 UBO 成员，或其更具体分量的读写句柄。默认以成员自身的类型为目标读写类型（即读写时必须传入与成员类型相同的变量）。
             * @param name Name of the target UBO member.
             * @param offset Channel offset into the member.
             * @param targetType Target type of the handle, i.e. the type of data when read/write to it.
             * @example
             * ```
             * import { Vec3, gfx } from 'cc';
             * // say 'pbrParams' is a uniform vec4
             * const hParams = pass.getHandle('pbrParams'); // get the default handle
             * pass.setUniform(hAlbedo, new Vec3(1, 0, 0)); // wrong! pbrParams.w is NaN now
             *
             * // say 'albedoScale' is a uniform vec4, and we only want to modify the w component in the form of a single float
             * const hThreshold = pass.getHandle('albedoScale', 3, gfx.Type.FLOAT);
             * pass.setUniform(hThreshold, 0.5); // now, albedoScale.w = 0.5
             * ```
             */
            getHandle(name: string, offset?: number, targetType?: gfx.Type): number;
            /**
             * @en Gets the uniform binding with its name
             * @zh 获取指定 uniform 的 binding。
             * @param name The name of target uniform
             */
            getBinding(name: string): number;
            /**
             * @en Sets a vector type uniform value, if a uniform requires frequent update, please use this method.
             * @zh 设置指定普通向量类 uniform 的值，如果需要频繁更新请尽量使用此接口。
             * @param handle The handle for the target uniform
             * @param value New value
             */
            setUniform(handle: number, value: MaterialProperty): void;
            /**
             * @en Gets a uniform's value.
             * @zh 获取指定普通向量类 uniform 的值。
             * @param handle The handle for the target uniform
             * @param out The output property to store the result
             */
            getUniform<T extends MaterialProperty>(handle: number, out: T): T;
            /**
             * @en Sets an array type uniform value, if a uniform requires frequent update, please use this method.
             * @zh 设置指定数组类 uniform 的值，如果需要频繁更新请尽量使用此接口。
             * @param handle The handle for the target uniform
             * @param value New value
             */
            setUniformArray(handle: number, value: MaterialProperty[]): void;
            /**
             * @en Bind a GFX [[gfx.Texture]] the the given uniform binding
             * @zh 绑定实际 GFX [[gfx.Texture]] 到指定 binding。
             * @param binding The binding for target uniform of texture type
             * @param value Target texture
             */
            bindTexture(binding: number, value: gfx.Texture, index?: number): void;
            /**
             * @en Bind a GFX [[gfx.Sampler]] the the given uniform binding
             * @zh 绑定实际 GFX [[gfx.Sampler]] 到指定 binding。
             * @param binding The binding for target uniform of sampler type
             * @param value Target sampler
             */
            bindSampler(binding: number, value: gfx.Sampler, index?: number): void;
            /**
             * @en Sets the dynamic pipeline state property at runtime
             * @zh 设置运行时 pass 内可动态更新的管线状态属性。
             * @param state Target dynamic state
             * @param value Target value
             */
            setDynamicState(state: gfx.DynamicStateFlagBit, value: number): void;
            /**
             * @en Override all pipeline states with the given pass override info.
             * @zh 重载当前所有管线状态。
             * @param original The original pass info
             * @param value The override pipeline state info
             */
            overridePipelineStates(original: EffectAsset.IPassInfo, overrides: PassOverrides): void;
            _setRootBufferDirty(val: boolean): void;
            /**
             * @en Update the current uniforms data.
             * @zh 更新当前 Uniform 数据。
             */
            update(): void;
            getInstancedBuffer(extraKey?: number): InstancedBuffer;
            getBatchedBuffer(extraKey?: number): __private._cocos_core_pipeline_batched_buffer__BatchedBuffer;
            /**
             * @en Destroy the current pass.
             * @zh 销毁当前 pass。
             */
            destroy(): void;
            /**
             * @en Resets the value of the given uniform by name to the default value in [[EffectAsset]].
             * This method does not support array type uniform.
             * @zh 重置指定（非数组） Uniform 为 [[EffectAsset]] 默认值。
             */
            resetUniform(name: string): void;
            /**
             * @en Resets the value of the given texture by name to the default value in [[EffectAsset]].
             * @zh 重置指定贴图为 [[EffectAsset]] 默认值。
             */
            resetTexture(name: string, index?: number): void;
            /**
             * @en Resets all uniform buffer objects to the default values in [[EffectAsset]]
             * @zh 重置所有 UBO 为默认值。
             */
            resetUBOs(): void;
            /**
             * @en Resets all textures and samplers to the default values in [[EffectAsset]]
             * @zh 重置所有 texture 和 sampler 为初始默认值。
             */
            resetTextures(): void;
            /**
             * @en Try to compile the shader and retrieve related resources references.
             * @zh 尝试编译 shader 并获取相关资源引用。
             */
            tryCompile(): boolean;
            /**
             * @en Gets the shader variant of the current pass and given macro patches
             * @zh 结合指定的编译宏组合获取当前 Pass 的 Shader Variant
             * @param patches The macro patches
             */
            getShaderVariant(patches?: IMacroPatch[] | null): gfx.Shader | null;
            /**
             * @private
             */
            beginChangeStatesSilently(): void;
            /**
             * @private
             */
            endChangeStatesSilently(): void;
            protected _doInit(info: IPassInfoFull, copyDefines?: boolean): void;
            protected _syncBatchingScheme(): void;
            get root(): Root;
            get device(): gfx.Device;
            get shaderInfo(): IProgramInfo;
            get localSetLayout(): gfx.DescriptorSetLayout;
            get program(): string;
            get properties(): Record<string, EffectAsset.IPropertyInfo>;
            get defines(): Record<string, string | number | boolean>;
            get passIndex(): number;
            get propertyIndex(): number;
            get dynamics(): __private._cocos_core_renderer_core_pass__IPassDynamics;
            get blocks(): Float32Array[];
            get blocksInt(): Int32Array[];
            get rootBufferDirty(): boolean;
            get priority(): pipeline.RenderPriority;
            get primitive(): gfx.PrimitiveMode;
            get stage(): pipeline.RenderPassStage;
            get phase(): number;
            get rasterizerState(): gfx.RasterizerState;
            get depthStencilState(): gfx.DepthStencilState;
            get blendState(): gfx.BlendState;
            get dynamicStates(): gfx.DynamicStateFlags;
            get batchingScheme(): BatchingSchemes;
            get descriptorSet(): gfx.DescriptorSet;
            get hash(): number;
            get pipelineLayout(): gfx.PipelineLayout;
        }
        export namespace Pass {
            export type getTypeFromHandle = typeof Pass.getTypeFromHandle;
            export type getBindingFromHandle = typeof Pass.getBindingFromHandle;
            export type fillPipelineInfo = typeof Pass.fillPipelineInfo;
            export type getPassHash = typeof Pass.getPassHash;
            export type getCountFromHandle = typeof Pass.getCountFromHandle;
        }
        export function getDeviceShaderVersion(device: gfx.Device): "glsl1" | "glsl3" | "glsl4";
        export interface ITemplateInfo {
            gfxAttributes: gfx.Attribute[];
            shaderInfo: gfx.ShaderInfo;
            blockSizes: number[];
            setLayouts: gfx.DescriptorSetLayout[];
            pipelineLayout: gfx.PipelineLayout;
            handleMap: Record<string, number>;
            bindings: gfx.DescriptorSetLayoutBinding[];
            samplerStartBinding: number;
        }
        export interface IProgramInfo extends EffectAsset.IShaderInfo {
            effectName: string;
            defines: __private._cocos_core_renderer_core_program_lib__IDefineRecord[];
            constantMacros: string;
            uber: boolean;
        }
        export const programLib: __private._cocos_core_renderer_core_program_lib__ProgramLib;
        export function nearestPOT(num: number): number;
        export interface ITextureBuffer {
            texture: gfx.Texture;
            size: number;
            start: number;
            end: number;
        }
        export interface ITextureBufferHandle {
            chunkIdx: number;
            start: number;
            end: number;
            texture: gfx.Texture;
        }
        export interface ITextureBufferPoolInfo {
            format: gfx.Format;
            inOrderFree?: boolean;
            alignment?: number;
            roundUpFn?: (size: number, formatSize: number) => number;
        }
        export class TextureBufferPool {
            constructor(device: gfx.Device);
            initialize(info: ITextureBufferPoolInfo): void;
            destroy(): void;
            alloc(size: number, chunkIdx?: number): ITextureBufferHandle;
            free(handle: ITextureBufferHandle): void;
            createChunk(length: number): number;
            update(handle: ITextureBufferHandle, buffer: ArrayBuffer): void;
        }
        export interface IMaterialInstanceInfo {
            parent: Material;
            owner?: Renderer;
            subModelIdx?: number;
        }
        /**
         * @zh
         * 材质实例，当有材质修改需求时，根据材质资源创建的，可任意定制的实例。
         */
        export class MaterialInstance extends Material {
            get parent(): Material;
            get owner(): Renderer | null;
            protected _passes: PassInstance[];
            constructor(info: IMaterialInstanceInfo);
            recompileShaders(overrides: MacroRecord, passIdx?: number): void;
            overridePipelineStates(overrides: PassOverrides, passIdx?: number): void;
            destroy(): boolean;
            onPassStateChange(dontNotify: boolean): void;
            protected _createPasses(): PassInstance[];
        }
        /**
         * @en A pass instance defines an variant version of the [[renderer.Pass]]
         * @zh 表示 [[renderer.Pass]] 的一种特殊实例
         */
        export class PassInstance extends Pass {
            /**
             * @en The parent pass
             * @zh 相关联的原始 Pass
             */
            get parent(): Pass;
            constructor(parent: Pass, owner: MaterialInstance);
            /**
             * @en Override pipeline states with the given pass override info.
             * This won't affect the original pass
             * @zh 重载当前 Pass 的管线状态。这不会影响原始 Pass
             * @param original The original pass info
             * @param value The override pipeline state info
             */
            overridePipelineStates(original: EffectAsset.IPassInfo, overrides: PassOverrides): void;
            tryCompile(defineOverrides?: MacroRecord): boolean;
            /**
             * @en Prepare to change states of the pass and do not notify the material to rebuild the pipeline state object
             * @zh 开始静默修改 Pass 相关状态，不会通知材质去重新构建管线状态对象。
             */
            beginChangeStatesSilently(): void;
            /**
             * @en End the silent states changing process, all state changes will be notified.
             * @zh 结束静默状态修改，所有修改将会开始通知材质。
             */
            endChangeStatesSilently(): void;
            protected _syncBatchingScheme(): void;
            protected _onStateChange(): void;
        }
        export enum PoolType {
            NODE = 0,
            PASS = 1,
            AABB = 2,
            RENDER2D = 3
        }
        export const NULL_HANDLE: __private._cocos_core_renderer_core_memory_pools__IHandle<any>;
        export type Render2dHandle = __private._cocos_core_renderer_core_memory_pools__IHandle<PoolType.RENDER2D>;
        export enum Render2dView {
            POSITION = 0,
            UV = 3,
            COLOR = 5,
            COUNT = 9
        }
        export const Render2dPool: __private._cocos_core_renderer_core_memory_pools__BufferPool<PoolType.RENDER2D, typeof Render2dView>;
        export type NodeHandle = __private._cocos_core_renderer_core_memory_pools__IHandle<PoolType.NODE>;
        export enum NodeView {
            DIRTY_FLAG = 0,
            LAYER = 1,
            WORLD_SCALE = 2,
            WORLD_POSITION = 5,
            WORLD_ROTATION = 8,
            WORLD_MATRIX = 12,
            LOCAL_SCALE = 28,
            LOCAL_POSITION = 31,
            LOCAL_ROTATION = 34,
            COUNT = 38
        }
        export const NodePool: __private._cocos_core_renderer_core_memory_pools__BufferPool<PoolType.NODE, typeof NodeView>;
        export type PassHandle = __private._cocos_core_renderer_core_memory_pools__IHandle<PoolType.PASS>;
        export enum PassView {
            PRIORITY = 0,
            STAGE = 1,
            PHASE = 2,
            PRIMITIVE = 3,
            BATCHING_SCHEME = 4,
            DYNAMIC_STATE = 5,
            HASH = 6,
            COUNT = 7
        }
        export const PassPool: __private._cocos_core_renderer_core_memory_pools__BufferPool<PoolType.PASS, typeof PassView>;
        export type AABBHandle = __private._cocos_core_renderer_core_memory_pools__IHandle<PoolType.AABB>;
        export enum AABBView {
            CENTER = 0,
            HALFEXTENTS = 3,
            COUNT = 6
        }
        export const AABBPool: __private._cocos_core_renderer_core_memory_pools__BufferPool<PoolType.AABB, typeof AABBView>;
        export interface IRenderSceneInfo {
            name: string;
        }
        export interface ISceneNodeInfo {
            name: string;
            isStatic?: boolean;
        }
        /**
         * @en The result of one raycast operation
         * @zh 一次射线检测的结果
         */
        export interface IRaycastResult {
            node: Node;
            distance: number;
        }
        /**
         * @en The render scene which is created by the [[Root]] and provides all basic render scene elements for the render process.
         * It manages:
         * 1. [[Camera]]s
         * 2. [[Light]]s
         * 3. Renderable objects: [[renderer.Model]]s and `DrawBatchs`
         * @zh 渲染场景，由 [[Root]] 创建，并提供用于渲染流程的所有场景基础元素。它管理：
         * 1. [[Camera]]s：相机
         * 2. [[Light]]s：光源
         * 3. 渲染元素：[[renderer.Model]]s 和 `DrawBatchs`
         */
        export class RenderScene {
            /**
             * @en The root manager of the renderer
             * @zh 基础渲染管理器
             */
            get root(): Root;
            /**
             * @en The name of the render scene
             * @zh 渲染场景的名称
             */
            get name(): string;
            /**
             * @en All cameras of the render scene
             * @zh 渲染场景管理的所有相机
             */
            get cameras(): scene.Camera[];
            /**
             * @en The main directional light source of the render scene
             * @zh 渲染场景管理的主方向光源
             */
            get mainLight(): scene.DirectionalLight | null;
            /**
             * @en All sphere light sources of the render scene
             * @zh 渲染场景管理的所有球面光源
             */
            get sphereLights(): scene.SphereLight[];
            /**
             * @en All spot light sources of the render scene
             * @zh 渲染场景管理的所有聚光灯光源
             */
            get spotLights(): scene.SpotLight[];
            /**
             * @en All active models of the render scene
             * @zh 渲染场景管理的所有模型
             */
            get models(): scene.Model[];
            /**
             * @en All active 2d draw batches of the render scene
             * @zh 渲染场景管理的所有 2D 渲染批次对象
             */
            get batches(): __private._cocos_2d_renderer_draw_batch__DrawBatch2D[];
            /**
             * Register the creation function of the render scene to root.
             * @internal
             */
            static registerCreateFunc(root: Root): void;
            constructor(root: Root);
            /**
             * @en Initialize the render scene
             * @zh 初始化渲染场景
             * @returns Successful
             */
            initialize(info: IRenderSceneInfo): boolean;
            /**
             * @en The update process of the render scene, it updates all rendering related data for the lights and the models.
             * @zh 渲染场景的更新流程，会更新所有光源和模型的渲染相关数据。
             * @param stamp The update time stamp
             * @returns void
             */
            update(stamp: number): void;
            /**
             * @en Destroy the render scene, dangerous, please do not invoke manually.
             * @zh 销毁渲染场景，请不要手动销毁，会造成未知行为。
             */
            destroy(): void;
            /**
             * @en Attach a camera to the render scene
             * @zh 向渲染场景挂载一个相机
             */
            addCamera(cam: scene.Camera): void;
            /**
             * @en Detach a camera to the render scene
             * @zh 从渲染场景移除一个相机
             */
            removeCamera(camera: scene.Camera): void;
            /**
             * @en Detach all cameras to the render scene
             * @zh 从渲染场景移除所有相机
             */
            removeCameras(): void;
            /**
             * @en Sets the main light source for the render scene
             * @zh 给渲染场景设置主光源
             * @param dl The main directional light source
             */
            setMainLight(dl: scene.DirectionalLight | null): void;
            /**
             * @en Remove the main light source from the render scene
             * @zh 从渲染场景移除主光源
             * @param dl The main directional light source, if it's not the actual main light, nothing happens.
             */
            unsetMainLight(dl: scene.DirectionalLight): void;
            /**
             * @en Add a directional light source, only one directional light is active and act as the main light source.
             * @zh 增加一个方向光源，场景中只会有一个方向光是起效的，并且会作为主光源。
             * @param dl The directional light.
             */
            addDirectionalLight(dl: scene.DirectionalLight): void;
            /**
             * @en Remove a directional light source.
             * @zh 删除一个方向光源。
             * @param dl The directional light.
             */
            removeDirectionalLight(dl: scene.DirectionalLight): void;
            /**
             * @en Add a sphere light source.
             * @zh 增加一个球面光源。
             * @param pl The sphere light.
             */
            addSphereLight(pl: scene.SphereLight): void;
            /**
             * @en Remove a sphere light source.
             * @zh 删除一个球面光源。
             * @param pl The sphere light.
             */
            removeSphereLight(pl: scene.SphereLight): void;
            /**
             * @en Add a spot light source.
             * @zh 增加一个聚光灯光源。
             * @param sl The spot light.
             */
            addSpotLight(sl: scene.SpotLight): void;
            /**
             * @en Remove a spot light source.
             * @zh 删除一个聚光灯光源。
             * @param sl The spot light.
             */
            removeSpotLight(sl: scene.SpotLight): void;
            /**
             * @en Remove all sphere light sources.
             * @zh 删除所有球面光源。
             */
            removeSphereLights(): void;
            /**
             * @en Remove all spot light sources.
             * @zh 删除所有聚光灯光源。
             */
            removeSpotLights(): void;
            /**
             * @en Add a model, all models attached to the render scene will be submitted for rendering.
             * @zh 增加一个模型，渲染场景上挂载的所有模型都会被提交渲染。
             * @param m The model.
             */
            addModel(m: scene.Model): void;
            /**
             * @en Remove a model, model removed will no longer be submitted for rendering.
             * @zh 删除一个模型，移除的模型将不再被提交渲染。
             * @param m The model.
             */
            removeModel(model: scene.Model): void;
            /**
             * @en Remove all models.
             * @zh 删除所有模型。
             */
            removeModels(): void;
            /**
             * @en Add a draw batch of 2d objects, all draw batches attached to the render scene will be submitted for rendering.
             * @zh 增加一个 2D 渲染批次，渲染场景上挂载的所有 2D 渲染批次都会被提交渲染。
             * @param batch The draw batch.
             * @internal
             * @deprecated since v3.6.0, this is an engine private interface that will be removed in the future.
             */
            addBatch(batch: __private._cocos_2d_renderer_draw_batch__DrawBatch2D): void;
            /**
             * @en Remove a draw batch of 2d objects, draw batch removed will no longer be submitted for rendering.
             * @zh 删除一个 2D 渲染批次，移除的 2D 渲染批次将不再被提交渲染。
             * @param batch The draw batch.
             * @internal
             * @deprecated since v3.6.0, this is an engine private interface that will be removed in the future.
             */
            removeBatch(batch: __private._cocos_2d_renderer_draw_batch__DrawBatch2D): void;
            /**
             * @en Remove all 2d draw batches.
             * @zh 删除所有 2D 渲染批次。
             * @internal
             * @deprecated since v3.6.0, this is an engine private interface that will be removed in the future.
             */
            removeBatches(): void;
            /**
             * @en Notify all models that the global pipeline state have been updated so that they can update their render data and states.
             * @zh 通知所有模型全局管线状态已更新，需要更新自身状态。
             */
            onGlobalPipelineStateChanged(): void;
            /**
             * @en Generate a new model id.
             * @zh 生成一个新的模型 ID
             * @returns The model id
             */
            generateModelId(): number;
        }
        export const CameraVisFlags: {};
        export const VisibilityFlags: {};
    }
    /**
     * @en
     * The main namespace of Cocos2d-JS, all engine core classes, functions, properties and constants are defined in this namespace.
     * @zh
     * Cocos 引擎的主要命名空间，引擎代码中所有的类，函数，属性和常量都在这个命名空间中定义。
     * @deprecated
     */
    export const cclegacy: Record<string, any> & {
        _global: typeof globalThis;
    };
    export type Constructor<T = unknown> = __private._types_globals__Constructor<T>;
    export namespace math {
        export namespace bits {
            /**
             * @en Returns -1, 0, +1 depending on sign of x.
             * @zh 根据x的符号返回 -1，0，+1。
             */
            export function sign(v: number): number;
            /**
             * @en Computes absolute value of integer.
             * @zh 计算整数的绝对值。
             */
            export function abs(v: number): number;
            /**
             * @en Computes minimum of integers x and y.
             * @zh 计算整数x和y中的最小值。
             */
            export function min(x: number, y: number): number;
            /**
             * @en Computes maximum of integers x and y.
             * @zh 计算整数x和y中的最大值。
             */
            export function max(x: number, y: number): number;
            /**
             * @en Checks if a number is a power of two.
             * @zh 检查一个数字是否是2的幂。
             */
            export function isPow2(v: number): boolean;
            /**
             * @en Computes log base 2 of v.
             * @zh 计算以 2 为底的 v 的对数。
             */
            export function log2(v: number): number;
            /**
             * @en Computes log base 10 of v.
             * @zh 计算以 10 为底的 v 的对数。
             */
            export function log10(v: number): 0 | 1 | 4 | 3 | 2 | 9 | 8 | 7 | 6 | 5;
            /**
             * @en Counts number of bits.
             * @zh 计算传入数字二进制表示中 1 的数量。
             */
            export function popCount(v: number): number;
            /**
             * @en Counts number of trailing zeros.
             * @zh 计算传入数字二进制表示尾随零的数量。
             */
            export function countTrailingZeros(v: number): number;
            /**
             * @en Rounds to next power of 2.
             * @zh 计算大于等于v的最小的二的整数次幂的数字。
             */
            export function nextPow2(v: number): number;
            /**
             * @en Rounds down to previous power of 2.
             * @zh 计算小于等于v的最小的二的整数次幂的数字。
             */
            export function prevPow2(v: number): number;
            /**
             * @en Computes parity of word.
             * @zh 奇偶校验。
             */
            export function parity(v: number): number;
            /**
             * @en Reverse bits in a 32 bit word.
             * @zh 翻转 32 位二进制数字。
             */
            export function reverse(v: number): number;
            /**
             * @en Interleave bits of 2 coordinates with 16 bits. Useful for fast quadtree codes.
             * @zh 将两个 16 位数字按位交错编码。有利于在快速四叉树中使用。
             */
            export function interleave2(x: number, y: number): number;
            /**
             * @en Extracts the nth interleaved component.
             * @zh 提取第 n 个交错分量。
             */
            export function deinterleave2(v: number, n: number): number;
            /**
             * @en Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes.
             * @zh 将三个数字按位交错编码，每个数字占十位。有利于在八叉树中使用。
             */
            export function interleave3(x: number, y: number, z: number): number;
            /**
             * @en Extracts nth interleaved component of a 3-tuple.
             * @zh 提取三个数字中的第n个交错分量。
             */
            export function deinterleave3(v: number, n: number): number;
            /**
             * @en Compute the lexicographically next bit permutation
             * @zh 计算下一组字典序的比特排列
             */
            export function nextCombination(v: number): number;
            /**
             * Bit twiddling hacks for JavaScript.
             *
             * Author: Mikola Lysenko
             *
             * Ported from Stanford bit twiddling hack library:
             *    http://graphics.stanford.edu/~seander/bithacks.html
             */
            /**
             * @en
             * Number of bits in an integer
             * @zh
             * 整型类型的 bit 数
             */
            export const INT_BITS = 32;
            /**
             * @en
             * The maximal signed integer number
             * @zh
             * 最大有符号整型数
             */
            export const INT_MAX = 2147483647;
            /**
             * @en
             * The minimal signed integer number
             * @zh
             * 最小有符号整型数
             */
            export const INT_MIN: number;
        }
        /**
         * @en Representation of 2D vectors and points.
         * @zh 二维向量。
         */
        export class Vec2 extends ValueType {
            static ZERO: Readonly<Vec2>;
            static ONE: Readonly<Vec2>;
            static NEG_ONE: Readonly<Vec2>;
            static UNIT_X: Readonly<Vec2>;
            static UNIT_Y: Readonly<Vec2>;
            /**
             * @en Obtains a clone of the given vector object
             * @zh 获得指定向量的拷贝
             */
            static clone<Out extends IVec2Like>(a: Out): Vec2;
            /**
             * @en Copy the target vector and save the results to out vector object
             * @zh 复制目标向量
             */
            static copy<Out extends IVec2Like>(out: Out, a: Out): Out;
            /**
             * @en Sets the out vector with the given x and y values
             * @zh 设置向量值
             */
            static set<Out extends IVec2Like>(out: Out, x: number, y: number): Out;
            /**
             * @en Element-wise vector addition and save the results to out vector object
             * @zh 逐元素向量加法
             */
            static add<Out extends IVec2Like>(out: Out, a: Out, b: Out): Out;
            /**
             * @en Element-wise vector subtraction and save the results to out vector object
             * @zh 逐元素向量减法
             */
            static subtract<Out extends IVec2Like>(out: Out, a: Out, b: Out): Out;
            /**
             * @en Element-wise vector multiplication and save the results to out vector object
             * @zh 逐元素向量乘法
             */
            static multiply<Out extends IVec2Like>(out: Out, a: Out, b: Out): Out;
            /**
             * @en Element-wise vector division and save the results to out vector object
             * @zh 逐元素向量除法
             */
            static divide<Out extends IVec2Like>(out: Out, a: Out, b: Out): Out;
            /**
             * @en Rounds up by elements of the vector and save the results to out vector object
             * @zh 逐元素向量向上取整
             */
            static ceil<Out extends IVec2Like>(out: Out, a: Out): Out;
            /**
             * @en Element-wise rounds down of the current vector and save the results to the out vector
             * @zh 逐元素向量向下取整
             */
            static floor<Out extends IVec2Like>(out: Out, a: Out): Out;
            /**
             * @en Calculates element-wise minimum values and save to the out vector
             * @zh 逐元素向量最小值
             */
            static min<Out extends IVec2Like>(out: Out, a: Out, b: Out): Out;
            /**
             * @en Calculates element-wise maximum values and save to the out vector
             * @zh 逐元素向量最大值
             */
            static max<Out extends IVec2Like>(out: Out, a: Out, b: Out): Out;
            /**
             * @en Calculates element-wise round results and save to the out vector
             * @zh 逐元素向量四舍五入取整
             */
            static round<Out extends IVec2Like>(out: Out, a: Out): Out;
            /**
             * @en Vector scalar multiplication and save the results to out vector object
             * @zh 向量标量乘法
             */
            static multiplyScalar<Out extends IVec2Like>(out: Out, a: Out, b: number): Out;
            /**
             * @en Element-wise multiplication and addition with the equation: a + b * scale
             * @zh 逐元素向量乘加: A + B * scale
             */
            static scaleAndAdd<Out extends IVec2Like>(out: Out, a: Out, b: Out, scale: number): Out;
            /**
             * @en Calculates the euclidean distance of two vectors
             * @zh 求两向量的欧氏距离
             */
            static distance<Out extends IVec2Like>(a: Out, b: Out): number;
            /**
             * @en Calculates the squared euclidean distance of two vectors
             * @zh 求两向量的欧氏距离平方
             */
            static squaredDistance<Out extends IVec2Like>(a: Out, b: Out): number;
            /**
             * @en Calculates the length of the vector
             * @zh 求向量长度
             */
            static len<Out extends IVec2Like>(a: Out): number;
            /**
             * @en Calculates the squared length of the vector
             * @zh 求向量长度平方
             */
            static lengthSqr<Out extends IVec2Like>(a: Out): number;
            /**
             * @en Sets each element to its negative value
             * @zh 逐元素向量取负
             */
            static negate<Out extends IVec2Like>(out: Out, a: Out): Out;
            /**
             * @en Sets each element to its inverse value, zero value will become Infinity
             * @zh 逐元素向量取倒数，接近 0 时返回 Infinity
             */
            static inverse<Out extends IVec2Like>(out: Out, a: Out): Out;
            /**
             * @en Sets each element to its inverse value, zero value will remain zero
             * @zh 逐元素向量取倒数，接近 0 时返回 0
             */
            static inverseSafe<Out extends IVec2Like>(out: Out, a: Out): Out;
            /**
             * @en Sets the normalized vector to the out vector
             * @zh 归一化向量
             */
            static normalize<Out extends IVec2Like, Vec2Like extends IVec2Like>(out: Out, a: Vec2Like): Out;
            /**
             * @en Calculates the dot product of the vector
             * @zh 向量点积（数量积）
             */
            static dot<Out extends IVec2Like>(a: Out, b: Out): number;
            /**
             * @en Calculates the cross product of the vector
             * @zh 向量叉积（向量积），注意二维向量的叉积为与 Z 轴平行的三维向量
             * @override (a:Vec2, b:Vec2) => number
             * @override [deprecated] (out:Vec3, a:Vec2, b:Vec2) => Vec3
             */
            static cross(a: IVec2Like, b: IVec2Like): number;
            /**
             * @deprecated Consider use another overrides please.
             */
            static cross<Out extends IVec2Like>(out: Vec3, a: Out, b: Out): Vec3;
            /**
             * @en Calculates the linear interpolation between two vectors with a given ratio
             * @zh 逐元素向量线性插值： A + t * (B - A)
             */
            static lerp<Out extends IVec2Like>(out: Out, a: Out, b: Out, t: number): Out;
            /**
             * @en Generates a uniformly distributed random vector points from center to the surface of the unit sphere
             * @zh 生成一个在单位圆上均匀分布的随机向量
             * @param scale vector length
             */
            static random<Out extends IVec2Like>(out: Out, scale?: number): Out;
            /**
             * @en Vector and third order matrix multiplication, will complete the vector with a third value as one
             * @zh 向量与三维矩阵乘法，默认向量第三位为 1。
             */
            static transformMat3<Out extends IVec2Like, MatLike extends IMat3Like>(out: Out, a: Out, m: IMat3Like): Out;
            /**
             * @en Vector and third order matrix multiplication, will complete the vector with a third and a fourth element as one
             * @zh 向量与四维矩阵乘法，默认向量第三位为 0，第四位为 1。
             */
            static transformMat4<Out extends IVec2Like, MatLike extends IMat4Like>(out: Out, a: Out, m: IMat4Like): Out;
            /**
             * @en Gets the string representation of the given vector
             * @zh 返回向量的字符串表示
             */
            static str<Out extends IVec2Like>(a: Out): string;
            /**
             * @en Converts the given vector to an array
             * @zh 向量转数组
             * @param ofs Array Start Offset
             */
            static toArray<Out extends __private._types_globals__IWritableArrayLike<number>>(out: Out, v: IVec2Like, ofs?: number): Out;
            /**
             * @en Converts the given array to a vector
             * @zh 数组转向量
             * @param ofs Array Start Offset
             */
            static fromArray<Out extends IVec2Like>(out: Out, arr: __private._types_globals__IWritableArrayLike<number>, ofs?: number): Out;
            /**
             * @en Check the equality of the two given vectors
             * @zh 向量等价判断
             */
            static strictEquals<Out extends IVec2Like>(a: Out, b: Out): boolean;
            /**
             * @en Check whether the two given vectors are approximately equivalent
             * @zh 排除浮点数误差的向量近似等价判断
             */
            static equals<Out extends IVec2Like>(a: Out, b: Out, epsilon?: number): boolean;
            /**
             * @en Calculates the radian angle between two vectors
             * @zh 求两向量夹角弧度
             */
            static angle<Out extends IVec2Like>(a: Out, b: Out): number;
            /**
             * @en x component.
             * @zh x 分量。
             */
            x: number;
            /**
             * @en y component.
             * @zh y 分量。
             */
            y: number;
            constructor(other: Vec2);
            constructor(x?: number, y?: number);
            /**
             * @en clone a Vec2 value
             * @zh 克隆当前向量。
             */
            clone(): Vec2;
            /**
             * @en Set the current vector value with the given vector.
             * @zh 设置当前向量使其与指定向量相等。
             * @param other Specified vector
             * @return `this`
             */
            set(other: Vec2): Vec2;
            /**
             * @en Set the value of each component of the current vector.
             * @zh 设置当前向量的具体分量值。
             * @param x x value
             * @param y y value
             * @return `this`
             */
            set(x?: number, y?: number): Vec2;
            /**
             * @en Check whether the vector approximately equals another one.
             * @zh 判断当前向量是否在误差范围内与指定向量相等。
             * @param other Specified vector
             * @param epsilon The error allowed. It`s should be a non-negative number.
             * @return Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
             */
            equals(other: Vec2, epsilon?: number): boolean;
            /**
             * @en Check whether the vector approximately equals another one.
             * @zh 判断当前向量是否在误差范围内与指定分量的向量相等。
             * @param x The x value of specified vector
             * @param y The y value of specified vector
             * @param epsilon The error allowed. It`s should be a non-negative number.
             * @return Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
             */
            equals2f(x: number, y: number, epsilon?: number): boolean;
            /**
             * @en Check whether the current vector strictly equals another Vec2.
             * @zh 判断当前向量是否与指定向量相等。
             * @param other specified vector
             * @return Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
             */
            strictEquals(other: Vec2): boolean;
            /**
             * @en Check whether the current vector strictly equals another Vec2.
             * @zh 判断当前向量是否与指定分量的向量相等。
             * @param x The x value of specified vector
             * @param y The y value of specified vector
             * @return Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
             */
            strictEquals2f(x: number, y: number): boolean;
            /**
             * @en Transform to string with vector information.
             * @zh 返回当前向量的字符串表示。
             * @returns The string with vector information
             */
            toString(): string;
            /**
             * @en Calculate linear interpolation result between this vector and another one with given ratio.
             * @zh 根据指定的插值比率，从当前向量到目标向量之间做插值。
             * @param to Target vector
             * @param ratio The interpolation coefficient.The range is [0,1].
             */
            lerp(to: Vec2, ratio: number): this;
            /**
             * @en Clamp the vector between minInclusive and maxInclusive.
             * @zh 设置当前向量的值，使其各个分量都处于指定的范围内。
             * @param minInclusive Minimum value allowed
             * @param maxInclusive Maximum value allowed
             * @return `this`
             */
            clampf(minInclusive: Vec2, maxInclusive: Vec2): this;
            /**
             * @en Adds the current vector with another one and return this
             * @zh 向量加法。将当前向量与指定向量的相加
             * @param other specified vector
             */
            add(other: Vec2): this;
            /**
             * @en Adds the current vector with another one and return this
             * @zh 向量加法。将当前向量与指定分量的向量相加
             * @param x The x value of specified vector
             * @param y The y value of specified vector
             */
            add2f(x: number, y: number): this;
            /**
             * @en Subtracts one vector from this, and returns this.
             * @zh 向量减法。将当前向量减去指定向量
             * @param other specified vector
             */
            subtract(other: Vec2): this;
            /**
             * @en Subtracts one vector from this, and returns this.
             * @zh 向量减法。将当前向量减去指定分量的向量
             * @param x The x value of specified vector
             * @param y The y value of specified vector
             */
            subtract2f(x: number, y: number): this;
            /**
             * @en Multiplies the current vector with a number, and returns this.
             * @zh 向量数乘。将当前向量数乘指定标量
             * @param scalar scalar number
             */
            multiplyScalar(scalar: number): this;
            /**
             * @en Multiplies the current vector with another one and return this
             * @zh 向量乘法。将当前向量乘以与指定向量的结果赋值给当前向量。
             * @param other specified vector
             */
            multiply(other: Vec2): this;
            /**
             * @en Multiplies the current vector with another one and return this
             * @zh 向量乘法。将当前向量与指定分量的向量相乘的结果赋值给当前向量。
             * @param x The x value of specified vector
             * @param y The y value of specified vector
             */
            multiply2f(x: number, y: number): this;
            /**
             * @en Element-wisely divides this vector with another one, and return this.
             * @zh 向量逐元素相除。将当前向量与指定分量的向量相除的结果赋值给当前向量。
             * @param other specified vector
             */
            divide(other: Vec2): this;
            /**
             * @en Element-wisely divides this vector with another one, and return this.
             * @zh 向量逐元素相除。将当前向量与指定分量的向量相除的结果赋值给当前向量。
             * @param x The x value of specified vector
             * @param y The y value of specified vector
             */
            divide2f(x: number, y: number): this;
            /**
             * @en Sets each component of this vector with its negative value
             * @zh 将当前向量的各个分量取反
             */
            negative(): this;
            /**
             * @en Calculates the dot product with another vector
             * @zh 向量点乘。
             * @param other specified vector
             * @return The result of calculates the dot product with another vector
             */
            dot(other: Vec2): number;
            /**
             * @en Calculates the cross product with another vector.
             * @zh 向量叉乘。
             * @param other specified vector
             * @return `out`
             */
            cross(other: Vec2): number;
            /**
             * @en Returns the length of this vector.
             * @zh 计算向量的长度（模）。
             * @return Length of vector
             */
            length(): number;
            /**
             * @en Returns the squared length of this vector.
             * @zh 计算向量长度（模）的平方。
             * @return the squared length of this vector
             */
            lengthSqr(): number;
            /**
             * @en Normalize the current vector.
             * @zh 将当前向量归一化。
             */
            normalize(): this;
            /**
             * @en Calculates radian angle between two vectors
             * @zh 获取当前向量和指定向量之间的角度。
             * @param other specified vector
             * @return The angle between the current vector and the specified vector (in radians); if there are zero vectors in the current vector and the specified vector, 0 is returned.
             */
            angle(other: Vec2): number;
            /**
             * @en Get angle in radian between this and vector with direction.
             * @zh 获取当前向量和指定向量之间的有符号角度。<br/>
             * 有符号角度的取值范围为 (-180, 180]，当前向量可以通过逆时针旋转有符号角度与指定向量同向。<br/>
             * @param other specified vector
             * @return The signed angle between the current vector and the specified vector (in radians); if there is a zero vector in the current vector and the specified vector, 0 is returned.
             */
            signAngle(other: Vec2): number;
            /**
             * @en Rotates the current vector by an angle in radian value
             * @zh 将当前向量的旋转
             * @param radians radius of rotation
             */
            rotate(radians: number): this;
            /**
             * @en Projects the current vector on another one
             * @zh 计算当前向量在指定向量上的投影向量。
             * @param other specified vector
             */
            project(other: Vec2): this;
            /**
             * @en Transforms the vec2 with a mat4. 3rd vector component is implicitly '0', 4th vector component is implicitly '1'
             * @zh 将当前向量视为 z 分量为 0、w 分量为 1 的四维向量，<br/>
             * 应用四维矩阵变换到当前矩阵<br/>
             * @param matrix matrix to transform with
             */
            transformMat4(matrix: Mat4): this;
        }
        export function v2(other: Vec2): Vec2;
        export function v2(x?: number, y?: number): Vec2;
        /**
         * @en Representation of 3D vectors and points.
         * @zh 三维向量。
         */
        export class Vec3 extends ValueType {
            static UNIT_X: Readonly<Vec3>;
            static UNIT_Y: Readonly<Vec3>;
            static UNIT_Z: Readonly<Vec3>;
            static RIGHT: Readonly<Vec3>;
            static UP: Readonly<Vec3>;
            static FORWARD: Readonly<Vec3>;
            static ZERO: Readonly<Vec3>;
            static ONE: Readonly<Vec3>;
            static NEG_ONE: Readonly<Vec3>;
            /**
             * @en return a Vec3 object with x = 0, y = 0, z = 0.
             * @zh 将目标赋值为零向量
             */
            static zero<Out extends IVec3Like>(out: Out): Out;
            /**
             * @en Obtains a clone of the given vector object
             * @zh 获得指定向量的拷贝
             */
            static clone<Out extends IVec3Like>(a: Out): Vec3;
            /**
             * @en Copy the target vector and save the results to out vector object
             * @zh 复制目标向量
             */
            static copy<Out extends IVec3Like, Vec3Like extends IVec3Like>(out: Out, a: Vec3Like): Out;
            /**
             * @en Sets the out vector with the given x, y and z values
             * @zh 设置向量值
             */
            static set<Out extends IVec3Like>(out: Out, x: number, y: number, z: number): Out;
            /**
             * @en Element-wise vector addition and save the results to out vector object
             * @zh 逐元素向量加法
             */
            static add<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
            /**
             * @en Element-wise vector subtraction and save the results to out vector object
             * @zh 逐元素向量减法
             */
            static subtract<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
            /**
             * @en Element-wise vector multiplication and save the results to out vector object
             * @zh 逐元素向量乘法 (分量积)
             */
            static multiply<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
            /**
             * @en Element-wise vector division and save the results to out vector object
             * @zh 逐元素向量除法
             */
            static divide<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
            /**
             * @en Rounds up by elements of the vector and save the results to out vector object
             * @zh 逐元素向量向上取整
             */
            static ceil<Out extends IVec3Like>(out: Out, a: IVec3Like): Out;
            /**
             * @en Element-wise rounds down of the current vector and save the results to the out vector
             * @zh 逐元素向量向下取整
             */
            static floor<Out extends IVec3Like>(out: Out, a: IVec3Like): Out;
            /**
             * @en Calculates element-wise minimum values and save to the out vector
             * @zh 逐元素向量最小值
             */
            static min<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
            /**
             * @en Calculates element-wise maximum values and save to the out vector
             * @zh 逐元素向量最大值
             */
            static max<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
            /**
             * @en Calculates element-wise round results and save to the out vector
             * @zh 逐元素向量四舍五入取整
             */
            static round<Out extends IVec3Like>(out: Out, a: IVec3Like): Out;
            /**
             * @en Vector scalar multiplication and save the results to out vector object
             * @zh 向量标量乘法
             */
            static multiplyScalar<Out extends IVec3Like, Vec3Like extends IVec3Like>(out: Out, a: Vec3Like, b: number): Out;
            /**
             * @en Element-wise multiplication and addition with the equation: a + b * scale
             * @zh 逐元素向量乘加: A + B * scale
             */
            static scaleAndAdd<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like, scale: number): Out;
            /**
             * @en Calculates the euclidean distance of two vectors
             * @zh 求两向量的欧氏距离
             */
            static distance(a: IVec3Like, b: IVec3Like): number;
            /**
             * @en Calculates the squared euclidean distance of two vectors
             * @zh 求两向量的欧氏距离平方
             */
            static squaredDistance(a: IVec3Like, b: IVec3Like): number;
            /**
             * @en Calculates the length of the vector
             * @zh 求向量长度
             */
            static len(a: IVec3Like): number;
            /**
             * @en Calculates the squared length of the vector
             * @zh 求向量长度平方
             */
            static lengthSqr(a: IVec3Like): number;
            /**
             * @en Sets each element to its negative value
             * @zh 逐元素向量取负
             */
            static negate<Out extends IVec3Like>(out: Out, a: IVec3Like): Out;
            /**
             * @en Sets each element to its inverse value, zero value will become Infinity
             * @zh 逐元素向量取倒数，接近 0 时返回 Infinity
             */
            static invert<Out extends IVec3Like>(out: Out, a: IVec3Like): Out;
            /**
             * @en Sets each element to its inverse value, zero value will remain zero
             * @zh 逐元素向量取倒数，接近 0 时返回 0
             */
            static invertSafe<Out extends IVec3Like>(out: Out, a: IVec3Like): Out;
            /**
             * @en Sets the normalized vector to the out vector
             * @zh 归一化向量
             */
            static normalize<Out extends IVec3Like>(out: Out, a: IVec3Like): Out;
            /**
             * @en Calculates the dot product of the vector
             * @zh 向量点积（数量积）
             */
            static dot<Out extends IVec3Like>(a: Out, b: IVec3Like): number;
            /**
             * @en Calculates the cross product of the vector
             * @zh 向量叉积（向量积）
             */
            static cross<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
            /**
             * @en Calculates the linear interpolation between two vectors with a given ratio
             * @zh 逐元素向量线性插值： A + t * (B - A)
             */
            static lerp<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like, t: number): Out;
            /**
             * @en Generates a uniformly distributed random vector points from center to the surface of the unit sphere
             * @zh 生成一个在单位球体上均匀分布的随机向量
             * @param scale vector length
             */
            static random<Out extends IVec3Like>(out: Out, scale?: number): Out;
            /**
             * @en Vector and fourth order matrix multiplication, will complete the vector with a fourth value as one
             * @zh 向量与四维矩阵乘法，默认向量第四位为 1。
             */
            static transformMat4<Out extends IVec3Like>(out: Out, a: IVec3Like, m: IMat4Like): Out;
            /**
             * @en Vector and fourth order matrix multiplication, will complete the vector with a fourth element as one
             * @zh 向量与四维矩阵乘法，默认向量第四位为 0。
             */
            static transformMat4Normal<Out extends IVec3Like>(out: Out, a: IVec3Like, m: IMat4Like): Out;
            /**
             * @en Vector and third order matrix multiplication
             * @zh 向量与三维矩阵乘法
             */
            static transformMat3<Out extends IVec3Like>(out: Out, a: IVec3Like, m: IMat3Like): Out;
            /**
             * @en Affine transformation vector
             * @zh 向量仿射变换
             */
            static transformAffine<Out extends IVec3Like>(out: Out, v: IVec3Like, m: IMat4Like): Out;
            /**
             * @en Vector quaternion multiplication
             * @zh 向量四元数乘法
             */
            static transformQuat<Out extends IVec3Like>(out: Out, a: IVec3Like, q: IQuatLike): Out;
            /**
             * @en Transforms the current vector with given scale, rotation and translation in order
             * @zh 以缩放 -> 旋转 -> 平移顺序变换向量
             */
            static transformRTS<Out extends IVec3Like>(out: Out, a: IVec3Like, r: IQuatLike, t: IVec3Like, s: IVec3Like): Out;
            /**
             * @en Transforms the current vector with given scale, rotation and translation in reverse order
             * @zh 以平移 -> 旋转 -> 缩放顺序逆变换向量
             */
            static transformInverseRTS<Out extends IVec3Like>(out: Out, a: IVec3Like, r: IQuatLike, t: IVec3Like, s: IVec3Like): Out;
            /**
             * @en Rotates the vector with specified angle around X axis
             * @zh 绕 X 轴旋转向量指定弧度
             * @param v rotation vector
             * @param o center of rotation
             * @param a radius of rotation
             */
            static rotateX<Out extends IVec3Like>(out: Out, v: IVec3Like, o: IVec3Like, a: number): Out;
            /**
             * @en Rotates the vector with specified angle around Y axis
             * @zh 绕 Y 轴旋转向量指定弧度
             * @param v rotation vector
             * @param o center of rotation
             * @param a radius of rotation
             */
            static rotateY<Out extends IVec3Like>(out: Out, v: IVec3Like, o: IVec3Like, a: number): Out;
            /**
             * @en Rotates the vector with specified angle around Z axis
             * @zh 绕 Z 轴旋转向量指定弧度
             * @param v rotation vector
             * @param o center of rotation
             * @param a radius of rotation
             */
            static rotateZ<Out extends IVec3Like>(out: Out, v: IVec3Like, o: IVec3Like, a: number): Out;
            /**
             * @en Converts the given vector to an array
             * @zh 向量转数组
             * @param ofs Array Start Offset
             */
            static toArray<Out extends __private._types_globals__IWritableArrayLike<number>>(out: Out, v: IVec3Like, ofs?: number): Out;
            /**
             * @en Converts the given array to a vector
             * @zh 数组转向量
             * @param ofs Array Start Offset
             */
            static fromArray<Out extends IVec3Like>(out: Out, arr: __private._types_globals__IWritableArrayLike<number>, ofs?: number): Out;
            /**
             * @en Check the equality of the two given vectors
             * @zh 向量等价判断
             */
            static strictEquals(a: IVec3Like, b: IVec3Like): boolean;
            /**
             * @en Check whether the two given vectors are approximately equivalent
             * @zh 排除浮点数误差的向量近似等价判断
             */
            static equals(a: IVec3Like, b: IVec3Like, epsilon?: number): boolean;
            /**
             * @en Calculates the radian angle between two vectors
             * @zh 求两向量夹角弧度
             */
            static angle(a: IVec3Like, b: IVec3Like): number;
            /**
             * @en Calculates the projection vector on the specified plane
             * @zh 计算向量在指定平面上的投影
             * @param a projection vector
             * @param n the normal line of specified plane
             */
            static projectOnPlane<Out extends IVec3Like>(out: Out, a: IVec3Like, n: IVec3Like): Out;
            /**
             * @en Calculates the projection on the specified vector
             * @zh 计算向量在指定向量上的投影
             * @param a projection vector
             * @param n target vector
             */
            static project<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
            /**
             * @en x component.
             * @zh x 分量。
             */
            x: number;
            /**
             * @en y component.
             * @zh y 分量。
             */
            y: number;
            /**
             * @en z component.
             * @zh z 分量。
             */
            z: number;
            constructor(v: Vec3);
            constructor(x?: number, y?: number, z?: number);
            /**
             * @en clone a Vec3 value
             * @zh 克隆当前向量。
             */
            clone(): Vec3;
            /**
             * @en Set the current vector value with the given vector.
             * @zh 设置当前向量使其与指定向量相等。
             * @param other Specified vector
             * @returns `this`
             */
            set(other: Vec3): Vec3;
            /**
             * @en Set the value of each component of the current vector.
             * @zh 设置当前向量的具体分量值。
             * @param x x value
             * @param y y value
             * @param z z value
             * @returns `this`
             */
            set(x?: number, y?: number, z?: number): Vec3;
            /**
             * @en Check whether the vector approximately equals another one.
             * @zh 判断当前向量是否在误差范围内与指定向量相等。
             * @param other Specified vector
             * @param epsilon The error allowed. It`s should be a non-negative number.
             * @returns Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
             */
            equals(other: Vec3, epsilon?: number): boolean;
            /**
             * @en Check whether the vector approximately equals another one.
             * @zh 判断当前向量是否在误差范围内与指定分量的向量相等。
             * @param x The x value of specified vector
             * @param y The y value of specified vector
             * @param z The z value of specified vector
             * @param epsilon The error allowed. It`s should be a non-negative number.
             * @returns Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
             */
            equals3f(x: number, y: number, z: number, epsilon?: number): boolean;
            /**
             * @en Check whether the current vector strictly equals another Vec3.
             * @zh 判断当前向量是否与指定向量相等。
             * @param other specified vector
             * @returns Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
             */
            strictEquals(other: Vec3): boolean;
            /**
             * @en Check whether the current vector strictly equals another Vec3.
             * @zh 判断当前向量是否与指定分量的向量相等。
             * @param x The x value of specified vector
             * @param y The y value of specified vector
             * @param z The z value of specified vector
             * @returns Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
             */
            strictEquals3f(x: number, y: number, z: number): boolean;
            /**
             * @en Transform to string with vector information.
             * @zh 返回当前向量的字符串表示。
             * @returns The string with vector information
             */
            toString(): string;
            /**
             * @en Calculate linear interpolation result between this vector and another one with given ratio.
             * @zh 根据指定的插值比率，从当前向量到目标向量之间做插值。
             * @param to Target vector
             * @param ratio The interpolation coefficient.The range is [0,1].
             */
            lerp(to: Vec3, ratio: number): this;
            /**
             * @en Adds the current vector with another one and return this
             * @zh 向量加法。将当前向量与指定向量的相加
             * @param other specified vector
             */
            add(other: Vec3): this;
            /**
             * @en Adds the current vector with another one and return this
             * @zh 向量加法。将当前向量与指定分量的向量相加
             * @param x The x value of specified vector
             * @param y The y value of specified vector
             * @param z The z value of specified vector
             */
            add3f(x: number, y: number, z: number): this;
            /**
             * @en Subtracts one vector from this, and returns this.
             * @zh 向量减法。将当前向量减去指定向量的结果。
             * @param other specified vector
             */
            subtract(other: Vec3): this;
            /**
             * @en Subtracts one vector from this, and returns this.
             * @zh 向量减法。将当前向量减去指定分量的向量
             * @param x The x value of specified vector
             * @param y The y value of specified vector
             * @param z The z value of specified vector
             */
            subtract3f(x: number, y: number, z: number): this;
            /**
             * @en Multiplies the current vector with a number, and returns this.
             * @zh 向量数乘。将当前向量数乘指定标量
             * @param scalar scalar number
             */
            multiplyScalar(scalar: number): this;
            /**
             * @en Multiplies the current vector with another one and return this
             * @zh 向量乘法。将当前向量乘以与指定向量的结果赋值给当前向量。
             * @param other specified vector
             */
            multiply(other: Vec3): this;
            /**
             * @en Multiplies the current vector with another one and return this
             * @zh 向量乘法。将当前向量与指定分量的向量相乘的结果赋值给当前向量。
             * @param x The x value of specified vector
             * @param y The y value of specified vector
             * @param z The z value of specified vector
             */
            multiply3f(x: number, y: number, z: number): this;
            /**
             * @en Element-wisely divides this vector with another one, and return this.
             * @zh 向量逐元素相除。将当前向量与指定分量的向量相除的结果赋值给当前向量。
             * @param other specified vector
             */
            divide(other: Vec3): this;
            /**
             * @en Element-wisely divides this vector with another one, and return this.
             * @zh 向量逐元素相除。将当前向量与指定分量的向量相除的结果赋值给当前向量。
             * @param x The x value of specified vector
             * @param y The y value of specified vector
             * @param z The z value of specified vector
             */
            divide3f(x: number, y: number, z: number): this;
            /**
             * @en Sets each component of this vector with its negative value
             * @zh 将当前向量的各个分量取反
             */
            negative(): this;
            /**
             * @en Clamp the vector between minInclusive and maxInclusive.
             * @zh 设置当前向量的值，使其各个分量都处于指定的范围内。
             * @param minInclusive Minimum value allowed
             * @param maxInclusive Maximum value allowed
             * @returns `this`
             */
            clampf(minInclusive: Vec3, maxInclusive: Vec3): this;
            /**
             * @en Calculates the dot product with another vector
             * @zh 向量点乘。
             * @param other specified vector
             * @returns The result of calculates the dot product with another vector
             */
            dot(other: Vec3): number;
            /**
             * @en Calculates the cross product with another vector.
             * @zh 向量叉乘。将当前向量左叉乘指定向量
             * @param other specified vector
             */
            cross(other: Vec3): this;
            /**
             * @en Returns the length of this vector.
             * @zh 计算向量的长度（模）。
             * @returns Length of vector
             */
            length(): number;
            /**
             * @en Returns the squared length of this vector.
             * @zh 计算向量长度（模）的平方。
             * @returns the squared length of this vector
             */
            lengthSqr(): number;
            /**
             * @en Normalize the current vector.
             * @zh 将当前向量归一化
             */
            normalize(): this;
            /**
             * @en Transforms the vec3 with a mat4. 4th vector component is implicitly '1'
             * @zh 将当前向量视为 w 分量为 1 的四维向量，应用四维矩阵变换到当前矩阵
             * @param matrix matrix to transform with
             */
            transformMat4(matrix: Mat4): this;
        }
        export function v3(other: Vec3): Vec3;
        export function v3(x?: number, y?: number, z?: number): Vec3;
        /**
         * @en Representation of four-dimensional vectors.
         * @zh 四维向量。
         */
        export class Vec4 extends ValueType {
            static ZERO: Readonly<Vec4>;
            static ONE: Readonly<Vec4>;
            static NEG_ONE: Readonly<Vec4>;
            /**
             * @en Obtains a clone of the given vector object
             * @zh 获得指定向量的拷贝
             */
            static clone<Out extends IVec4Like>(a: Out): Vec4;
            /**
             * @en Copy the target vector and save the results to out vector object
             * @zh 复制目标向量
             */
            static copy<Out extends IVec4Like>(out: Out, a: Out): Out;
            /**
             * @en Sets the out vector with the given x, y, z and w values
             * @zh 设置向量值
             */
            static set<Out extends IVec4Like>(out: Out, x: number, y: number, z: number, w: number): Out;
            /**
             * @en Element-wise vector addition and save the results to out vector object
             * @zh 逐元素向量加法
             */
            static add<Out extends IVec4Like>(out: Out, a: Out, b: Out): Out;
            /**
             * @en Element-wise vector subtraction and save the results to out vector object
             * @zh 逐元素向量减法
             */
            static subtract<Out extends IVec4Like>(out: Out, a: Out, b: Out): Out;
            /**
             * @en Element-wise vector multiplication and save the results to out vector object
             * @zh 逐元素向量乘法
             */
            static multiply<Out extends IVec4Like>(out: Out, a: Out, b: Out): Out;
            /**
             * @en Element-wise vector division and save the results to out vector object
             * @zh 逐元素向量除法
             */
            static divide<Out extends IVec4Like>(out: Out, a: Out, b: Out): Out;
            /**
             * @en Rounds up by elements of the vector and save the results to out vector object
             * @zh 逐元素向量向上取整
             */
            static ceil<Out extends IVec4Like>(out: Out, a: Out): Out;
            /**
             * @en Element-wise rounds down of the current vector and save the results to the out vector
             * @zh 逐元素向量向下取整
             */
            static floor<Out extends IVec4Like>(out: Out, a: Out): Out;
            /**
             * @en Calculates the minimum values by elements of the vector and save the results to the out vector
             * @zh 逐元素向量最小值
             */
            static min<Out extends IVec4Like>(out: Out, a: Out, b: Out): Out;
            /**
             * @en Calculates the maximum values by elements of the vector and save the results to the out vector
             * @zh 逐元素向量最大值
             */
            static max<Out extends IVec4Like>(out: Out, a: Out, b: Out): Out;
            /**
             * @en Calculates element-wise round results and save to the out vector
             * @zh 逐元素向量四舍五入取整
             */
            static round<Out extends IVec4Like>(out: Out, a: Out): Out;
            /**
             * @en Vector scalar multiplication and save the results to out vector object
             * @zh 向量标量乘法
             */
            static multiplyScalar<Out extends IVec4Like>(out: Out, a: Out, b: number): Out;
            /**
             * @en Element-wise multiplication and addition with the equation: a + b * scale
             * @zh 逐元素向量乘加: A + B * scale
             */
            static scaleAndAdd<Out extends IVec4Like>(out: Out, a: Out, b: Out, scale: number): Out;
            /**
             * @en Calculates the euclidean distance of two vectors
             * @zh 求两向量的欧氏距离
             */
            static distance<Out extends IVec4Like>(a: Out, b: Out): number;
            /**
             * @en Calculates the squared euclidean distance of two vectors
             * @zh 求两向量的欧氏距离平方
             */
            static squaredDistance<Out extends IVec4Like>(a: Out, b: Out): number;
            /**
             * @en Calculates the length of the vector
             * @zh 求向量长度
             */
            static len<Out extends IVec4Like>(a: Out): number;
            /**
             * @en Calculates the squared length of the vector
             * @zh 求向量长度平方
             */
            static lengthSqr<Out extends IVec4Like>(a: Out): number;
            /**
             * @en Sets each element to its negative value
             * @zh 逐元素向量取负
             */
            static negate<Out extends IVec4Like>(out: Out, a: Out): Out;
            /**
             * @en Sets each element to its inverse value, zero value will become Infinity
             * @zh 逐元素向量取倒数，接近 0 时返回 Infinity
             */
            static inverse<Out extends IVec4Like>(out: Out, a: Out): Out;
            /**
             * @en Sets each element to its inverse value, zero value will remain zero
             * @zh 逐元素向量取倒数，接近 0 时返回 0
             */
            static inverseSafe<Out extends IVec4Like>(out: Out, a: Out): Out;
            /**
             * @en Sets the normalized vector to the out vector
             * @zh 归一化向量
             */
            static normalize<Out extends IVec4Like>(out: Out, a: Out): Out;
            /**
             * @en Calculates the dot product of the vector
             * @zh 向量点积（数量积）
             */
            static dot<Out extends IVec4Like>(a: Out, b: Out): number;
            /**
             * @en Calculates the linear interpolation between two vectors with a given ratio
             * @zh 逐元素向量线性插值： A + t * (B - A)
             */
            static lerp<Out extends IVec4Like>(out: Out, a: Out, b: Out, t: number): Out;
            /**
             * @en Generates a uniformly distributed random vector points from center to the surface of the unit sphere
             * @zh 生成一个在单位球体上均匀分布的随机向量
             * @param scale vector length
             */
            static random<Out extends IVec4Like>(out: Out, scale?: number): Out;
            /**
             * @en Vector and fourth order matrix multiplication
             * @zh 向量与四维矩阵乘法
             */
            static transformMat4<Out extends IVec4Like, MatLike extends IMat4Like>(out: Out, a: Out, m: MatLike): Out;
            /**
             * @en Transform the vector with the given affine transformation
             * @zh 向量仿射变换
             */
            static transformAffine<Out extends IVec4Like, VecLike extends IVec4Like, MatLike extends IMat4Like>(out: Out, v: VecLike, m: MatLike): Out;
            /**
             * @en Vector quaternion multiplication
             * @zh 向量四元数乘法
             */
            static transformQuat<Out extends IVec4Like, QuatLike extends IQuatLike>(out: Out, a: Out, q: QuatLike): Out;
            /**
             * @en Converts the given vector to an array
             * @zh 向量转数组
             * @param ofs Array Start Offset
             */
            static toArray<Out extends __private._types_globals__IWritableArrayLike<number>>(out: Out, v: IVec4Like, ofs?: number): Out;
            /**
             * @en Converts the given array to a vector
             * @zh 数组转向量
             * @param ofs Array Start Offset
             */
            static fromArray<Out extends IVec4Like>(out: Out, arr: __private._types_globals__IWritableArrayLike<number>, ofs?: number): Out;
            /**
             * @en Check the equality of the two given vectors
             * @zh 向量等价判断
             */
            static strictEquals<Out extends IVec4Like>(a: Out, b: Out): boolean;
            /**
             * @en Check whether the two given vectors are approximately equivalent
             * @zh 排除浮点数误差的向量近似等价判断
             */
            static equals<Out extends IVec4Like>(a: Out, b: Out, epsilon?: number): boolean;
            /**
             * @en x component.
             * @zh x 分量。
             */
            x: number;
            /**
             * @en y component.
             * @zh y 分量。
             */
            y: number;
            /**
             * @en z component.
             * @zh z 分量。
             */
            z: number;
            /**
             * @en w component.
             * @zh w 分量。
             */
            w: number;
            constructor(other: Vec4);
            constructor(x?: number, y?: number, z?: number, w?: number);
            /**
             * @en clone the current Vec4 value.
             * @zh 克隆当前向量。
             */
            clone(): Vec4;
            /**
             * @en Set the current vector value with the given vector.
             * @zh 设置当前向量使其与指定向量相等。
             * @param other Specified vector
             * @returns `this`
             */
            set(other: Vec4): Vec4;
            /**
             * @en Set the value of each component of the current vector.
             * @zh 设置当前向量的具体分量值。
             * @param x x value
             * @param y y value
             * @param z z value
             * @param w w value
             * @returns `this`
             */
            set(x?: number, y?: number, z?: number, w?: number): Vec4;
            /**
             * @en Check whether the vector approximately equals another one.
             * @zh 判断当前向量是否在误差范围内与指定向量相等。
             * @param other Specified vector
             * @param epsilon The error allowed. It`s should be a non-negative number.
             * @returns Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
             */
            equals(other: Vec4, epsilon?: number): boolean;
            /**
             * @en Check whether the vector approximately equals another one.
             * @zh 判断当前向量是否在误差范围内与指定分量的向量相等。
             * @param x The x value of specified vector
             * @param y The y value of specified vector
             * @param z The z value of specified vector
             * @param w The w value of specified vector
             * @param epsilon The error allowed. It`s should be a non-negative number.
             * @returns Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
             */
            equals4f(x: number, y: number, z: number, w: number, epsilon?: number): boolean;
            /**
             * @en Check whether the current vector strictly equals another Vec4.
             * @zh 判断当前向量是否与指定向量相等。
             * @param other specified vector
             * @returns Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
             */
            strictEquals(other: Vec4): boolean;
            /**
             * @en Check whether the current vector strictly equals another Vec4.
             * @zh 判断当前向量是否与指定分量的向量相等。
             * @param x The x value of specified vector
             * @param y The y value of specified vector
             * @param z The z value of specified vector
             * @param w The w value of specified vector
             * @returns Returns `true` when the components of both vectors are equal within the specified range of error; otherwise it returns `false`.
             */
            strictEquals4f(x: number, y: number, z: number, w: number): boolean;
            /**
             * @en Calculate linear interpolation result between this vector and another one with given ratio.
             * @zh 根据指定的插值比率，从当前向量到目标向量之间做插值。
             * @param to Target vector
             * @param ratio The interpolation coefficient.The range is [0,1].
             */
            lerp(to: Vec4, ratio: number): this;
            /**
             * @en Return the information of the vector in string
             * @zh 返回当前向量的字符串表示。
             * @returns The string with vector information
             */
            toString(): string;
            /**
             * @en Clamp the vector between minInclusive and maxInclusive.
             * @zh 设置当前向量的值，使其各个分量都处于指定的范围内。
             * @param minInclusive Minimum value allowed
             * @param maxInclusive Maximum value allowed
             * @returns `this`
             */
            clampf(minInclusive: Vec4, maxInclusive: Vec4): this;
            /**
             * @en Adds the current vector with another one and return this
             * @zh 向量加法。将当前向量与指定向量的相加
             * @param other specified vector
             */
            add(other: Vec4): this;
            /**
             * @en Adds the current vector with another one and return this
             * @zh 向量加法。将当前向量与指定分量的向量相加
             * @param x The x value of specified vector
             * @param y The y value of specified vector
             * @param z The z value of specified vector
             * @param w The w value of specified vector
             */
            add4f(x: number, y: number, z: number, w: number): this;
            /**
             * @en Subtracts one vector from this, and returns this.
             * @zh 向量减法。将当前向量减去指定向量
             * @param other specified vector
             */
            subtract(other: Vec4): this;
            /**
             * @en Subtracts one vector from this, and returns this.
             * @zh 向量减法。将当前向量减去指定分量的向量
             * @param x The x value of specified vector
             * @param y The y value of specified vector
             * @param z The z value of specified vector
             * @param w The w value of specified vector
             */
            subtract4f(x: number, y: number, z: number, w: number): this;
            /**
             * @en Multiplies the current vector with a number, and returns this.
             * @zh 向量数乘。将当前向量数乘指定标量
             * @param scalar scalar number
             */
            multiplyScalar(scalar: number): this;
            /**
             * @en Multiplies the current vector with another one and return this
             * @zh 向量乘法。将当前向量乘以指定向量
             * @param other specified vector
             */
            multiply(other: Vec4): this;
            /**
             * @en Multiplies the current vector with another one and return this
             * @zh 向量乘法。将当前向量与指定分量的向量相乘的结果赋值给当前向量。
             * @param x The x value of specified vector
             * @param y The y value of specified vector
             * @param z The z value of specified vector
             * @param w The w value of specified vector
             */
            multiply4f(x: number, y: number, z: number, w: number): this;
            /**
             * @en Element-wisely divides this vector with another one, and return this.
             * @zh 向量逐元素相除。将当前向量与指定分量的向量相除的结果赋值给当前向量。
             * @param other specified vector
             */
            divide(other: Vec4): this;
            /**
             * @en Element-wisely divides this vector with another one, and return this.
             * @zh 向量逐元素相除。将当前向量与指定分量的向量相除的结果赋值给当前向量。
             * @param x The x value of specified vector
             * @param y The y value of specified vector
             * @param z The z value of specified vector
             * @param w The w value of specified vector
             */
            divide4f(x: number, y: number, z: number, w: number): this;
            /**
             * @en Sets each component of this vector with its negative value
             * @zh 将当前向量的各个分量取反
             */
            negative(): this;
            /**
             * @en Calculates the dot product with another vector
             * @zh 向量点乘。
             * @param other specified vector
             * @returns 当前向量与指定向量点乘的结果。
             */
            dot(vector: Vec4): number;
            /**
             * @en Calculates the cross product with another vector.
             * @zh 向量叉乘。视当前向量和指定向量为三维向量（舍弃 w 分量），将当前向量左叉乘指定向量
             * @param other specified vector
             */
            cross(vector: Vec4): this;
            /**
             * @en Returns the length of this vector.
             * @zh 计算向量的长度（模）。
             * @returns Length of vector
             */
            length(): number;
            /**
             * @en Returns the squared length of this vector.
             * @zh 计算向量长度（模）的平方。
             * @returns the squared length of this vector
             */
            lengthSqr(): number;
            /**
             * @en Normalize the current vector.
             * @zh 将当前向量归一化
             */
            normalize(): this;
            /**
             * @en Transforms the vec4 with a mat4
             * @zh 应用四维矩阵变换到当前矩阵
             * @param matrix matrix to transform with
             */
            transformMat4(matrix: Mat4): this;
        }
        export function v4(other: Vec4): Vec4;
        export function v4(x?: number, y?: number, z?: number, w?: number): Vec4;
        /**
         * @en quaternion
         * @zh 四元数
         */
        export class Quat extends ValueType {
            static IDENTITY: Readonly<Quat>;
            /**
             * @en Obtain a copy of the given quaternion
             * @zh 获得指定四元数的拷贝
             */
            static clone<Out extends IQuatLike>(a: Out): Quat;
            /**
             * @en Copy the given quaternion to the out quaternion
             * @zh 复制目标四元数
             */
            static copy<Out extends IQuatLike, QuatLike extends IQuatLike>(out: Out, a: QuatLike): Out;
            /**
             * @en Sets the out quaternion with values of each component
             * @zh 设置四元数值
             */
            static set<Out extends IQuatLike>(out: Out, x: number, y: number, z: number, w: number): Out;
            /**
             * @en Sets the out quaternion to an identity quaternion
             * @zh 将目标赋值为单位四元数
             */
            static identity<Out extends IQuatLike>(out: Out): Out;
            /**
             * @en Sets the out quaternion with the shortest path orientation between two vectors, considering both vectors normalized
             * @zh 设置四元数为两向量间的最短路径旋转，默认两向量都已归一化
             */
            static rotationTo<Out extends IQuatLike, VecLike extends IVec3Like>(out: Out, a: VecLike, b: VecLike): Out;
            /**
             * @en Gets the rotation axis and the arc of rotation from the quaternion
             * @zh 获取四元数的旋转轴和旋转弧度
             * @param outAxis output axis
             * @param q input quaternion
             * @return radius of rotation
             */
            static getAxisAngle<Out extends IQuatLike, VecLike extends IVec3Like>(outAxis: VecLike, q: Out): number;
            /**
             * @en Quaternion multiplication and save the results to out quaternion
             * @zh 四元数乘法
             */
            static multiply<Out extends IQuatLike, QuatLike_1 extends IQuatLike, QuatLike_2 extends IQuatLike>(out: Out, a: QuatLike_1, b: QuatLike_2): Out;
            /**
             * @en Quaternion scalar multiplication and save the results to out quaternion
             * @zh 四元数标量乘法
             */
            static multiplyScalar<Out extends IQuatLike>(out: Out, a: Out, b: number): Out;
            /**
             * @en Quaternion multiplication and addition: A + B * scale
             * @zh 四元数乘加：A + B * scale
             */
            static scaleAndAdd<Out extends IQuatLike>(out: Out, a: Out, b: Out, scale: number): Out;
            /**
             * @en Sets the out quaternion to represent a radian rotation around x axis
             * @zh 绕 X 轴旋转指定四元数
             * @param rad radius of rotation
             */
            static rotateX<Out extends IQuatLike>(out: Out, a: Out, rad: number): Out;
            /**
             * @en Sets the out quaternion to represent a radian rotation around y axis
             * @zh 绕 Y 轴旋转指定四元数
             * @param rad radius of rotation
             */
            static rotateY<Out extends IQuatLike>(out: Out, a: Out, rad: number): Out;
            /**
             * @en Sets the out quaternion to represent a radian rotation around z axis
             * @zh 绕 Z 轴旋转指定四元数
             * @param rad radius of rotation
             */
            static rotateZ<Out extends IQuatLike>(out: Out, a: Out, rad: number): Out;
            /**
             * @en Sets the out quaternion to represent a radian rotation around a given rotation axis in world space
             * @zh 绕世界空间下指定轴旋转四元数
             * @param axis axis of rotation, normalized by default
             * @param rad radius of rotation
             */
            static rotateAround<Out extends IQuatLike, VecLike extends IVec3Like>(out: Out, rot: Out, axis: VecLike, rad: number): Out;
            /**
             * @en Sets the out quaternion to represent a radian rotation around a given rotation axis in local space
             * @zh 绕本地空间下指定轴旋转四元数
             * @param axis axis of rotation
             * @param rad radius of rotation
             */
            static rotateAroundLocal<Out extends IQuatLike, VecLike extends IVec3Like>(out: Out, rot: Out, axis: VecLike, rad: number): Out;
            /**
             * @en Calculates the w component with xyz components, considering the given quaternion normalized
             * @zh 根据 xyz 分量计算 w 分量，默认已归一化
             */
            static calculateW<Out extends IQuatLike>(out: Out, a: Out): Out;
            /**
             * @en Quaternion dot product (scalar product)
             * @zh 四元数点积（数量积）
             */
            static dot<Out extends IQuatLike>(a: Out, b: Out): number;
            /**
             * @en Element by element linear interpolation: A + t * (B - A)
             * @zh 逐元素线性插值： A + t * (B - A)
             */
            static lerp<Out extends IQuatLike>(out: Out, a: Out, b: Out, t: number): Out;
            /**
             * @en Spherical quaternion interpolation
             * @zh 四元数球面插值
             */
            static slerp<Out extends IQuatLike, QuatLike_1 extends IQuatLike, QuatLike_2 extends IQuatLike>(out: Out, a: QuatLike_1, b: QuatLike_2, t: number): Out;
            /**
             * @en Spherical quaternion interpolation with two control points
             * @zh 带两个控制点的四元数球面插值
             */
            static sqlerp<Out extends IQuatLike>(out: Out, a: Out, b: Out, c: Out, d: Out, t: number): Out;
            /**
             * @en Sets the inverse of the given quaternion to out quaternion
             * @zh 四元数求逆
             */
            static invert<Out extends IQuatLike, QuatLike extends IQuatLike>(out: Out, a: QuatLike): Out;
            /**
             * @en Conjugating a quaternion, it's equivalent to the inverse of the unit quaternion, but more efficient
             * @zh 求共轭四元数，对单位四元数与求逆等价，但更高效
             */
            static conjugate<Out extends IQuatLike>(out: Out, a: Out): Out;
            /**
             * @en Calculates the length of the quaternion
             * @zh 求四元数长度
             */
            static len<Out extends IQuatLike>(a: Out): number;
            /**
             * @en Calculates the squared length of the quaternion
             * @zh 求四元数长度平方
             */
            static lengthSqr<Out extends IQuatLike>(a: Out): number;
            /**
             * @en Normalize the given quaternion
             * @zh 归一化四元数
             */
            static normalize<Out extends IQuatLike>(out: Out, a: Out): Out;
            /**
             * @en Calculated the quaternion represents the given coordinates, considering all given vectors are normalized and mutually perpendicular
             * @zh 根据本地坐标轴朝向计算四元数，默认三向量都已归一化且相互垂直
             */
            static fromAxes<Out extends IQuatLike, VecLike extends IVec3Like>(out: Out, xAxis: VecLike, yAxis: VecLike, zAxis: VecLike): Out;
            /**
             * @en Calculates the quaternion with the up direction and the direction of the viewport
             * @zh 根据视口的前方向和上方向计算四元数
             * @param view The view direction, it`s must be normalized.
             * @param up The view up direction, it`s must be normalized, default value is (0, 1, 0).
             */
            static fromViewUp<Out extends IQuatLike, VecLike extends IVec3Like>(out: Out, view: VecLike, up?: Vec3): Out;
            /**
             * @en Calculates the quaternion from a given rotary shaft and a radian rotation around it.
             * @zh 根据旋转轴和旋转弧度计算四元数
             */
            static fromAxisAngle<Out extends IQuatLike, VecLike extends IVec3Like>(out: Out, axis: VecLike, rad: number): Out;
            /**
             * @en Calculates the quaternion with the three-dimensional transform matrix, considering no scale included in the matrix
             * @zh 根据三维矩阵信息计算四元数，默认输入矩阵不含有缩放信息
             */
            static fromMat3<Out extends IQuatLike>(out: Out, m: Mat3): Out;
            /**
             * @en Calculates the quaternion with Euler angles, the rotation order is YZX
             * @zh 根据欧拉角信息计算四元数，旋转顺序为 YZX
             */
            static fromEuler<Out extends IQuatLike>(out: Out, x: number, y: number, z: number): Out;
            /**
             * @en Calculates the quaternion with given 2D angle (0, 0, z).
             * @zh 根据 2D 角度（0, 0, z）计算四元数
             *
             * @param out Output quaternion
             * @param z Angle to rotate around Z axis in degrees.
             */
            static fromAngleZ<Out extends IQuatLike>(out: Out, z: number): Out;
            /**
             * @en This returns the X-axis vector of the quaternion
             * @zh 返回定义此四元数的坐标系 X 轴向量
             */
            static toAxisX(out: IVec3Like, q: IQuatLike): IVec3Like;
            /**
             * @en This returns the Y-axis vector of the quaternion
             * @zh 返回定义此四元数的坐标系 Y 轴向量
             */
            static toAxisY(out: IVec3Like, q: IQuatLike): IVec3Like;
            /**
             * @en This returns the Z-axis vector of the quaternion
             * @zh 返回定义此四元数的坐标系 Z 轴向量
             */
            static toAxisZ(out: IVec3Like, q: IQuatLike): IVec3Like;
            /**
             * @en Converts the quaternion to angles, result angle x, y in the range of [-180, 180], z in the range of [-90, 90] interval, the rotation order is YZX
             * @zh 根据四元数计算欧拉角，返回角度 x, y 在 [-180, 180] 区间内, z 默认在 [-90, 90] 区间内，旋转顺序为 YZX
             * @param outerZ change z value range to [-180, -90] U [90, 180]
             */
            static toEuler(out: IVec3Like, q: IQuatLike, outerZ?: boolean): IVec3Like;
            /**
             * @en Converts quaternion to an array
             * @zh 四元数转数组
             * @param ofs Array Start Offset
             */
            static toArray<Out extends __private._types_globals__IWritableArrayLike<number>>(out: Out, q: IQuatLike, ofs?: number): Out;
            /**
             * @en Array to a quaternion
             * @zh 数组转四元数
             * @param ofs Array Start Offset
             */
            static fromArray(out: IQuatLike, arr: __private._types_globals__IWritableArrayLike<number>, ofs?: number): IQuatLike;
            /**
             * @en Check whether two quaternions are equal
             * @zh 四元数等价判断
             */
            static strictEquals(a: IQuatLike, b: IQuatLike): boolean;
            /**
             * @en Check whether two quaternions are approximately equal
             * @zh 排除浮点数误差的四元数近似等价判断
             */
            static equals(a: IQuatLike, b: IQuatLike, epsilon?: number): boolean;
            /**
             * @en x component.
             * @zh x 分量。
             */
            x: number;
            /**
             * @en y component.
             * @zh y 分量。
             */
            y: number;
            /**
             * @en z component.
             * @zh z 分量。
             */
            z: number;
            /**
             * @en w component.
             * @zh w 分量。
             */
            w: number;
            constructor(other: Quat);
            constructor(x?: number, y?: number, z?: number, w?: number);
            /**
             * @en clone the current Quat
             * @zh 克隆当前四元数。
             */
            clone(): Quat;
            /**
             * @en Set values with another quaternion
             * @zh 设置当前四元数使其与指定四元数相等。
             * @param other Specified quaternion
             * @returns `this`
             */
            set(other: Quat): Quat;
            /**
             * @en Set the value of each component of the current quaternion
             * @zh 设置当前四元数指定元素值。
             * @returns `this`
             */
            set(x?: number, y?: number, z?: number, w?: number): Quat;
            /**
             * @en Check whether the quaternion approximately equals another one
             * @zh 判断当前四元数是否在误差范围内与指定向量相等。
             * @param other Comparative quaternion
             * @param epsilon The error allowed. It`s should be a non-negative number.
             * @returns Returns `true' when the components of the two quaternions are equal within the specified error range; otherwise, returns `false'.
             */
            equals(other: Quat, epsilon?: number): boolean;
            /**
             * @en Check whether the current quaternion strictly equals other quaternion
             * @zh 判断当前四元数是否与指定四元数相等。
             * @param other Comparative quaternion
             * @returns Returns `true' when the components of the two quaternions are equal within the specified error range; otherwise, returns `false'.
             */
            strictEquals(other: Quat): boolean;
            /**
             * @en Convert quaternion to Euler angles
             * @zh 将当前四元数转化为欧拉角（x-y-z）并赋值给出口向量。
             * @param out the output vector
             */
            getEulerAngles(out: Vec3): IVec3Like;
            /**
             * @en Calculate the linear interpolation result between this quaternion and another one with given ratio
             * @zh 根据指定的插值比率，从当前四元数到目标四元数之间做线性插值。
             * @param to The target quaternion
             * @param ratio The interpolation coefficient. The range is [0,1].
             */
            lerp(to: Quat, ratio: number): this;
            /**
             * @en Calculates the spherical interpolation result between this quaternion and another one with the given ratio
             * @zh 根据指定的插值比率，从当前四元数到目标四元数之间做球面插值。
             * @param to The target quaternion
             * @param ratio The interpolation coefficient. The range is [0,1].
             */
            slerp(to: Quat, ratio: number): this;
            /**
             * @en Calculates the length of the quaternion
             * @zh 求四元数长度
             */
            length(): number;
            /**
             * @en Calculates the squared length of the quaternion
             * @zh 求四元数长度平方
             */
            lengthSqr(): number;
        }
        export function quat(other: Quat): Quat;
        export function quat(x?: number, y?: number, z?: number, w?: number): Quat;
        /**
         * @en Mathematical 3x3 matrix.
         * @zh 表示三维（3x3）矩阵。
         */
        export class Mat3 extends ValueType {
            static IDENTITY: Readonly<Mat3>;
            /**
             * @en Clone a matrix and save the results to out matrix
             * @zh 获得指定矩阵的拷贝
             */
            static clone<Out extends IMat3Like>(a: Out): Mat3;
            /**
             * @en Copy content of a matrix into another and save the results to out matrix
             * @zh 复制目标矩阵
             */
            static copy<Out extends IMat3Like>(out: Out, a: Out): Out;
            /**
             * @en Sets the elements of a matrix with the given values and save the results to out matrix
             * @zh 设置矩阵值
             */
            static set<Out extends IMat3Like>(out: Out, m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number): Out;
            /**
             * @en Reset the out matrix to an identity matrix
             * @zh 将目标赋值为单位矩阵
             */
            static identity<Out extends IMat3Like>(out: Out): Out;
            /**
             * @en Transposes a matrix and save the results to out matrix
             * @zh 转置矩阵
             */
            static transpose<Out extends IMat3Like>(out: Out, a: Out): Out;
            /**
             * @en Inverts a matrix. When matrix is not invertible the matrix will be set to zeros.
             * @zh 矩阵求逆，注意，在矩阵不可逆时，会返回一个全为 0 的矩阵。
             */
            static invert<Out extends IMat3Like>(out: Out, a: Out): Out;
            /**
             * @en Calculates the determinant of a matrix
             * @zh 矩阵行列式
             */
            static determinant<Out extends IMat3Like>(a: Out): number;
            /**
             * @en Multiply two matrices explicitly and save the results to out matrix
             * @zh 矩阵乘法
             */
            static multiply<Out extends IMat3Like>(out: Out, a: Out, b: Out): Out;
            /**
             * @en Take the first third order of the fourth order matrix and multiply by the third order matrix
             * @zh 取四阶矩阵的前三阶，与三阶矩阵相乘
             */
            static multiplyMat4<Out extends IMat3Like>(out: Out, a: Out, b: IMat4Like): Out;
            /**
             * @en Multiply a matrix with a translation vector given by a translation offset.
             * @zh 在给定矩阵变换基础上加入变换
             */
            static transform<Out extends IMat3Like, VecLike extends IVec3Like>(out: Out, a: Out, v: VecLike): Out;
            /**
             * @en Multiply a matrix with a scale matrix given by a scale vector and save the results to out matrix
             * @zh 在给定矩阵变换基础上加入新缩放变换
             */
            static scale<Out extends IMat3Like, VecLike extends IVec3Like>(out: Out, a: Out, v: VecLike): Out;
            /**
             * @en Rotates the transform by the given angle and save the results into the out matrix
             * @zh 在给定矩阵变换基础上加入新旋转变换
             * @param rad radius of rotation
             */
            static rotate<Out extends IMat3Like>(out: Out, a: Out, rad: number): Out;
            /**
             * @en Copies the first third order matrix of a fourth order matrix to the out third order matrix
             * @zh 取四阶矩阵的前三阶
             */
            static fromMat4<Out extends IMat3Like>(out: Out, a: IMat4Like): Out;
            /**
             * @en Sets a third order matrix with view direction and up direction. Then save the results to out matrix
             * @zh 根据视口前方向和上方向计算矩阵
             * @param view The view direction, it`s must be normalized.
             * @param up The view up direction, it`s must be normalized, default value is (0, 1, 0).
             */
            static fromViewUp<Out extends IMat3Like, VecLike extends IVec3Like>(out: Out, view: VecLike, up?: Vec3): Out;
            /**
             * @en Sets the given matrix with a translation vector and save the results to out matrix
             * @zh 计算位移矩阵
             */
            static fromTranslation<Out extends IMat3Like, VecLike extends IVec2Like>(out: Out, v: VecLike): Out;
            /**
             * @en Sets the given matrix with a scale vector and save the results to out matrix
             * @zh 计算缩放矩阵
             */
            static fromScaling<Out extends IMat3Like, VecLike extends IVec2Like>(out: Out, v: VecLike): Out;
            /**
             * @en Sets the given matrix with a given angle and save the results to out matrix
             * @zh 计算旋转矩阵
             */
            static fromRotation<Out extends IMat3Like>(out: Out, rad: number): Out;
            /**
             * @en Sets the given matrix with the given quaternion and save the results to out matrix
             * @zh 根据四元数旋转信息计算矩阵
             */
            static fromQuat<Out extends IMat3Like>(out: Out, q: IQuatLike): Out;
            /**
             * @en Calculates the upper-left 3x3 matrix of a 4x4 matrix's inverse transpose
             * @zh 计算指定四维矩阵的逆转置三维矩阵
             */
            static inverseTransposeMat4<Out extends IMat3Like>(out: Out, a: IMat4Like): Out | null;
            /**
             * @en Transform a matrix object to a flat array
             * @zh 矩阵转数组
             * @param ofs Array Start Offset
             */
            static toArray<Out extends __private._types_globals__IWritableArrayLike<number>>(out: Out, m: IMat3Like, ofs?: number): Out;
            /**
             * @en Generates or sets a matrix with a flat array
             * @zh 数组转矩阵
             * @param ofs Array Start Offset
             */
            static fromArray<Out extends IMat3Like>(out: Out, arr: __private._types_globals__IWritableArrayLike<number>, ofs?: number): Out;
            /**
             * @en Adds two matrices and save the results to out matrix
             * @zh 逐元素矩阵加法
             */
            static add<Out extends IMat3Like>(out: Out, a: Out, b: Out): Out;
            /**
             * @en Subtracts matrix b from matrix a and save the results to out matrix
             * @zh 逐元素矩阵减法
             */
            static subtract<Out extends IMat3Like>(out: Out, a: Out, b: Out): Out;
            /**
             * @en Multiply each element of a matrix by a scalar number and save the results to out matrix
             * @zh 矩阵标量乘法
             */
            static multiplyScalar<Out extends IMat3Like>(out: Out, a: Out, b: number): Out;
            /**
             * @en Adds two matrices after multiplying each element of the second operand by a scalar number. And save the results to out matrix.
             * @zh 逐元素矩阵标量乘加: A + B * scale
             */
            static multiplyScalarAndAdd<Out extends IMat3Like>(out: Out, a: Out, b: Out, scale: number): Out;
            /**
             * @en Returns whether the specified matrices are equal.
             * @zh 矩阵等价判断
             */
            static strictEquals<Out extends IMat3Like>(a: Out, b: Out): boolean;
            /**
             * @en Returns whether the specified matrices are approximately equal.
             * @zh 排除浮点数误差的矩阵近似等价判断
             */
            static equals<Out extends IMat3Like>(a: Out, b: Out, epsilon?: number): boolean;
            /**
             * @en Value at column 0 row 0 of the matrix.
             * @zh 矩阵第 0 列第 0 行的元素。
             */
            m00: number;
            /**
             * @en Value at column 0 row 1 of the matrix.
             * @zh 矩阵第 0 列第 1 行的元素。
             */
            m01: number;
            /**
             * @en Value at column 0 row 2 of the matrix.
             * @zh 矩阵第 0 列第 2 行的元素。
             */
            m02: number;
            /**
             * @en Value at column 1 row 0 of the matrix.
             * @zh 矩阵第 1 列第 0 行的元素。
             */
            m03: number;
            /**
             * @en Value at column 1 row 1 of the matrix.
             * @zh 矩阵第 1 列第 1 行的元素。
             */
            m04: number;
            /**
             * @en Value at column 1 row 2 of the matrix.
             * @zh 矩阵第 1 列第 2 行的元素。
             */
            m05: number;
            /**
             * @en Value at column 2 row 0 of the matrix.
             * @zh 矩阵第 2 列第 0 行的元素。
             */
            m06: number;
            /**
             * @en Value at column 2 row 1 of the matrix.
             * @zh 矩阵第 2 列第 1 行的元素。
             */
            m07: number;
            /**
             * @en Value at column 2 row 2 of the matrix.
             * @zh 矩阵第 2 列第 2 行的元素。
             */
            m08: number;
            constructor(other: Mat3);
            constructor(m00?: number, m01?: number, m02?: number, m03?: number, m04?: number, m05?: number, m06?: number, m07?: number, m08?: number);
            /**
             * @en Clone a new matrix from the current matrix.
             * @zh 克隆当前矩阵。
             */
            clone(): Mat3;
            /**
             * @en Sets the matrix with another one's value.
             * @zh 设置当前矩阵使其与指定矩阵相等。
             * @param other Specified matrix
             * @return this
             */
            set(other: Mat3): Mat3;
            /**
             * @en Set the matrix with values of all elements
             * @zh 设置当前矩阵指定元素值。
             * @return this
             */
            set(m00?: number, m01?: number, m02?: number, m03?: number, m04?: number, m05?: number, m06?: number, m07?: number, m08?: number): Mat3;
            /**
             * @en Returns whether the specified matrices are approximately equal.
             * @zh 判断当前矩阵是否在误差范围内与指定矩阵相等。
             * @param other Comparative matrix
             * @param epsilon The error allowed. It`s should be a non-negative number.
             * @return Returns `true' when the elements of both matrices are equal; otherwise returns `false'.
             */
            equals(other: Mat3, epsilon?: number): boolean;
            /**
             * @en Returns whether the specified matrices are equal.
             * @zh 判断当前矩阵是否与指定矩阵相等。
             * @param other Comparative matrix
             * @return Returns `true' when the elements of both matrices are equal; otherwise returns `false'.
             */
            strictEquals(other: Mat3): boolean;
            /**
             * @en Returns a string representation of a matrix.
             * @zh 返回当前矩阵的字符串表示。
             * @return The string representation of this matrix
             */
            toString(): string;
            /**
             * @en set the current matrix to an identity matrix.
             * @zh 将当前矩阵设为单位矩阵。
             * @return `this`
             */
            identity(): this;
            /**
             * @en Transposes the current matrix.
             * @zh 计算当前矩阵的转置矩阵。
             */
            transpose(): this;
            /**
             * @en Inverts the current matrix. When matrix is not invertible the matrix will be set to zeros.
             * @zh 计算当前矩阵的逆矩阵。注意，在矩阵不可逆时，会返回一个全为 0 的矩阵。
             */
            invert(): this;
            /**
             * @en Calculates the determinant of the current matrix.
             * @zh 计算当前矩阵的行列式。
             * @return 当前矩阵的行列式。
             */
            determinant(): number;
            /**
             * @en Adds the current matrix and another matrix to the current matrix.
             * @zh 矩阵加法。将当前矩阵与指定矩阵的相加，结果返回给当前矩阵。
             * @param mat the second operand
             */
            add(mat: Mat3): this;
            /**
             * @en Subtracts another matrix from the current matrix.
             * @zh 计算矩阵减法。将当前矩阵减去指定矩阵的结果赋值给当前矩阵。
             * @param mat the second operand
             */
            subtract(mat: Mat3): this;
            /**
             * @en Multiply the current matrix with another matrix.
             * @zh 矩阵乘法。将当前矩阵左乘指定矩阵的结果赋值给当前矩阵。
             * @param mat the second operand
             */
            multiply(mat: Mat3): this;
            /**
             * @en Multiply each element of the current matrix by a scalar number.
             * @zh 矩阵数乘。将当前矩阵与指定标量的数乘结果赋值给当前矩阵。
             * @param scalar amount to scale the matrix's elements by
             */
            multiplyScalar(scalar: number): this;
            /**
             * @en Multiply the current matrix with a scale matrix given by a scale vector.
             * @zh 将当前矩阵左乘缩放矩阵的结果赋值给当前矩阵，缩放矩阵由各个轴的缩放给出。
             * @param vec vector to scale by
             */
            scale(vec: Vec3): this;
            /**
             * @en Rotates the current matrix by the given angle.
             * @zh 将当前矩阵左乘旋转矩阵的结果赋值给当前矩阵，旋转矩阵由旋转轴和旋转角度给出。
             * @param rad radius of rotation
             */
            rotate(rad: number): this;
            /**
             * @en Resets the current matrix from the given quaternion.
             * @zh 重置当前矩阵的值，使其表示指定四元数表示的旋转变换。
             * @param q The quaternion.
             * @returns this
             */
            fromQuat(q: Quat): this;
        }
        /**
         * @en Mathematical 4x4 matrix.
         * @zh 表示四维（4x4）矩阵。
         */
        export class Mat4 extends ValueType {
            static IDENTITY: Readonly<Mat4>;
            /**
             * @en Clone a matrix and save the results to out matrix
             * @zh 获得指定矩阵的拷贝
             */
            static clone(a: IMat4Like): Mat4;
            /**
             * @en Copy a matrix into the out matrix
             * @zh 复制目标矩阵
             */
            static copy<Out extends IMat4Like>(out: Out, a: Out): Out;
            /**
             * @en Sets a matrix with the given values and save the results to out matrix
             * @zh 设置矩阵值
             */
            static set<Out extends IMat4Like>(out: Out, m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): Out;
            /**
             * @en return an identity matrix.
             * @zh 将目标赋值为单位矩阵
             */
            static identity<Out extends IMat4Like>(out: Out): Out;
            /**
             * @en Transposes a matrix and save the results to out matrix
             * @zh 转置矩阵
             */
            static transpose<Out extends IMat4Like>(out: Out, a: Out): Out;
            /**
             * @en Inverts a matrix. When matrix is not invertible the matrix will be set to zeros.
             * @zh 矩阵求逆，注意，在矩阵不可逆时，会返回一个全为 0 的矩阵。
             */
            static invert<Out extends IMat4Like>(out: Out, a: Out): Out;
            /**
             * @en Calculates the determinant of a matrix
             * @zh 矩阵行列式
             */
            static determinant<InType extends IMat4Like>(a: InType): number;
            /**
             * @en Multiply two matrices and save the results to out matrix
             * @zh 矩阵乘法
             */
            static multiply<Out extends IMat4Like>(out: Out, a: Out, b: Out): Out;
            /**
             * @en Transform a matrix with the given vector and save results to the out matrix
             * @zh 在给定矩阵变换基础上加入变换
             */
            static transform<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, a: Out, v: VecLike): Out;
            /**
             * @en Transform a matrix with the given translation vector and save results to the out matrix
             * @zh 在给定矩阵变换基础上加入新位移变换
             */
            static translate<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, a: Out, v: VecLike): Out;
            /**
             * @en Multiply a matrix with a scale matrix given by a scale vector and save the results into the out matrix
             * @zh 在给定矩阵变换基础上加入新缩放变换
             */
            static scale<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, a: Out, v: VecLike): Out;
            /**
             * @en Rotates the transform by the given angle and save the results into the out matrix
             * @zh 在给定矩阵变换基础上加入新旋转变换
             * @param rad Angle of rotation (in radians)
             * @param axis axis of rotation
             */
            static rotate<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, a: Out, rad: number, axis: VecLike): Out | null;
            /**
             * @en Transform a matrix with a given angle around X axis and save the results to the out matrix
             * @zh 在给定矩阵变换基础上加入绕 X 轴的旋转变换
             * @param rad Angle of rotation (in radians)
             */
            static rotateX<Out extends IMat4Like>(out: Out, a: Out, rad: number): Out;
            /**
             * @en Transform a matrix with a given angle around Y axis and save the results to the out matrix
             * @zh 在给定矩阵变换基础上加入绕 Y 轴的旋转变换
             * @param rad Angle of rotation (in radians)
             */
            static rotateY<Out extends IMat4Like>(out: Out, a: Out, rad: number): Out;
            /**
             * @en Transform a matrix with a given angle around Z axis and save the results to the out matrix
             * @zh 在给定矩阵变换基础上加入绕 Z 轴的旋转变换
             * @param rad Angle of rotation (in radians)
             */
            static rotateZ<Out extends IMat4Like>(out: Out, a: Out, rad: number): Out;
            /**
             * @en Sets the out matrix with a translation vector
             * @zh 计算位移矩阵
             */
            static fromTranslation<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, v: VecLike): Out;
            /**
             * @en Sets the out matrix with a scale vector
             * @zh 计算缩放矩阵
             */
            static fromScaling<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, v: VecLike): Out;
            /**
             * @en Sets the out matrix with rotation angle
             * @zh 计算旋转矩阵
             */
            static fromRotation<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, rad: number, axis: VecLike): Out | null;
            /**
             * @en Calculates the matrix representing a rotation around the X axis
             * @zh 计算绕 X 轴的旋转矩阵
             */
            static fromXRotation<Out extends IMat4Like>(out: Out, rad: number): Out;
            /**
             * @en Calculates the matrix representing a rotation around the Y axis
             * @zh 计算绕 Y 轴的旋转矩阵
             */
            static fromYRotation<Out extends IMat4Like>(out: Out, rad: number): Out;
            /**
             * @en Calculates the matrix representing a rotation around the Z axis
             * @zh 计算绕 Z 轴的旋转矩阵
             */
            static fromZRotation<Out extends IMat4Like>(out: Out, rad: number): Out;
            /**
             * @en Calculates the transform representing the combination of a rotation and a translation
             * @zh 根据旋转和位移信息计算矩阵
             */
            static fromRT<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, q: Quat, v: VecLike): Out;
            /**
             * @en Extracts the translation from the matrix, assuming it's composed in order of scale, rotation, translation
             * @zh 提取矩阵的位移信息, 默认矩阵中的变换以 S->R->T 的顺序应用
             */
            static getTranslation<InType extends IMat4Like, VecLike extends IVec3Like>(out: VecLike, mat: InType): VecLike;
            /**
             * @en Extracts the scale vector from the matrix, assuming it's composed in order of scale, rotation, translation
             * @zh 提取矩阵的缩放信息, 默认矩阵中的变换以 S->R->T 的顺序应用
             */
            static getScaling<InType extends IMat4Like, VecLike extends IVec3Like>(out: VecLike, mat: InType): VecLike;
            /**
             * @en Extracts the rotation from the matrix, assuming it's composed in order of scale, rotation, translation
             * @zh 提取矩阵的旋转信息, 默认输入矩阵不含有缩放信息，如考虑缩放应使用 `toRTS` 函数。
             */
            static getRotation<InType extends IMat4Like>(out: Quat, mat: InType): Quat;
            /**
             * @en Extracts the scale, rotation and translation from the matrix, assuming it's composed in order of scale, rotation, translation
             * @zh 提取旋转、位移、缩放信息， 默认矩阵中的变换以 S->R->T 的顺序应用
             */
            static toRTS<InType extends IMat4Like, VecLike extends IVec3Like>(m: InType, q: Quat, v: VecLike, s: VecLike): void;
            /**
             * @en Compose a matrix from scale, rotation and translation, applied in order.
             * @zh 根据旋转、位移、缩放信息计算矩阵，以 S->R->T 的顺序应用
             */
            static fromRTS<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, q: Quat, v: VecLike, s: VecLike): Out;
            /**
             * @en Compose a matrix from scale, rotation and translation, applied in order, from a given origin
             * @zh 根据指定的旋转、位移、缩放及变换中心信息计算矩阵，以 S->R->T 的顺序应用
             * @param q Rotation quaternion
             * @param v Translation vector
             * @param s Scaling vector
             * @param o transformation Center
             */
            static fromRTSOrigin<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, q: Quat, v: VecLike, s: VecLike, o: VecLike): Out;
            /**
             * @en Sets the out matrix with the given quaternion
             * @zh 根据指定的旋转信息计算矩阵
             */
            static fromQuat<Out extends IMat4Like>(out: Out, q: Quat): Out;
            /**
             * @en Calculates the matrix representing the given frustum
             * @zh 根据指定的视锥体信息计算矩阵
             * @param left The X coordinate of the left side of the near projection plane in view space.
             * @param right The X coordinate of the right side of the near projection plane in view space.
             * @param bottom The Y coordinate of the bottom side of the near projection plane in view space.
             * @param top The Y coordinate of the top side of the near projection plane in view space.
             * @param near Z distance to the near plane from the origin in view space.
             * @param far Z distance to the far plane from the origin in view space.
             */
            static frustum<Out extends IMat4Like>(out: Out, left: number, right: number, bottom: number, top: number, near: number, far: number): Out;
            /**
             * @en Calculates perspective projection matrix
             * @zh 计算透视投影矩阵
             * @param fovy Vertical field-of-view in degrees.
             * @param aspect Aspect ratio
             * @param near Near depth clipping plane value.
             * @param far Far depth clipping plane value.
             */
            static perspective<Out extends IMat4Like>(out: Out, fov: number, aspect: number, near: number, far: number, isFOVY?: boolean, minClipZ?: number, projectionSignY?: number, orientation?: number): Out;
            /**
             * @en Calculates orthogonal projection matrix
             * @zh 计算正交投影矩阵
             * @param left Left-side x-coordinate.
             * @param right Right-side x-coordinate.
             * @param bottom Bottom y-coordinate.
             * @param top Top y-coordinate.
             * @param near Near depth clipping plane value.
             * @param far Far depth clipping plane value.
             */
            static ortho<Out extends IMat4Like>(out: Out, left: number, right: number, bottom: number, top: number, near: number, far: number, minClipZ?: number, projectionSignY?: number, orientation?: number): Out;
            /**
             * @en
             * Calculates the matrix with the view point information, given by eye position, target center and the up vector.
             * Note that center to eye vector can't be zero or parallel to the up vector
             * @zh
             * 根据视点计算矩阵，注意 `eye - center` 不能为零向量或与 `up` 向量平行
             * @param eye The source point.
             * @param center The target point.
             * @param up The vector describing the up direction.
             */
            static lookAt<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, eye: VecLike, center: VecLike, up: VecLike): Out;
            /**
             * @en Calculates the inverse transpose of a matrix and save the results to out matrix
             * @zh 计算逆转置矩阵
             */
            static inverseTranspose<Out extends IMat4Like>(out: Out, a: Out): Out | null;
            /**
             * @en Transform a matrix object to a flat array
             * @zh 矩阵转数组
             * @param ofs Array Start Offset
             */
            static toArray<Out extends __private._types_globals__IWritableArrayLike<number>>(out: Out, m: IMat4Like, ofs?: number): Out;
            /**
             * @en Generates or sets a matrix with a flat array
             * @zh 数组转矩阵
             * @param ofs Array Start Offset
             */
            static fromArray<Out extends IMat4Like>(out: Out, arr: __private._types_globals__IWritableArrayLike<number>, ofs?: number): Out;
            /**
             * @en Adds two matrices and save the results to out matrix
             * @zh 逐元素矩阵加法
             */
            static add<Out extends IMat4Like>(out: Out, a: Out, b: Out): Out;
            /**
             * @en Subtracts matrix b from matrix a and save the results to out matrix
             * @zh 逐元素矩阵减法
             */
            static subtract<Out extends IMat4Like>(out: Out, a: Out, b: Out): Out;
            /**
             * @en Multiply each element of a matrix by a scalar number and save the results to out matrix
             * @zh 矩阵标量乘法
             */
            static multiplyScalar<Out extends IMat4Like>(out: Out, a: Out, b: number): Out;
            /**
             * @en Adds two matrices after multiplying each element of the second operand by a scalar number. And save the results to out matrix.
             * @zh 逐元素矩阵标量乘加: A + B * scale
             */
            static multiplyScalarAndAdd<Out extends IMat4Like>(out: Out, a: Out, b: Out, scale: number): Out;
            /**
             * @en Returns whether the specified matrices are equal.
             * @zh 矩阵等价判断
             */
            static strictEquals<InType extends IMat4Like>(a: InType, b: InType): boolean;
            /**
             * @en Returns whether the specified matrices are approximately equal.
             * @zh 排除浮点数误差的矩阵近似等价判断
             */
            static equals<InType extends IMat4Like>(a: InType, b: InType, epsilon?: number): boolean;
            /**
             * @en Value at column 0 row 0 of the matrix.
             * @zh 矩阵第 0 列第 0 行的元素。
             */
            m00: number;
            /**
             * @en Value at column 0 row 1 of the matrix.
             * @zh 矩阵第 0 列第 1 行的元素。
             */
            m01: number;
            /**
             * @en Value at column 0 row 2 of the matrix.
             * @zh 矩阵第 0 列第 2 行的元素。
             */
            m02: number;
            /**
             * @en Value at column 0 row 3 of the matrix.
             * @zh 矩阵第 0 列第 3 行的元素。
             */
            m03: number;
            /**
             * @en Value at column 1 row 0 of the matrix.
             * @zh 矩阵第 1 列第 0 行的元素。
             */
            m04: number;
            /**
             * @en Value at column 1 row 1 of the matrix.
             * @zh 矩阵第 1 列第 1 行的元素。
             */
            m05: number;
            /**
             * @en Value at column 1 row 2 of the matrix.
             * @zh 矩阵第 1 列第 2 行的元素。
             */
            m06: number;
            /**
             * @en Value at column 1 row 3 of the matrix.
             * @zh 矩阵第 1 列第 3 行的元素。
             */
            m07: number;
            /**
             * @en Value at column 2 row 0 of the matrix.
             * @zh 矩阵第 2 列第 0 行的元素。
             */
            m08: number;
            /**
             * @en Value at column 2 row 1 of the matrix.
             * @zh 矩阵第 2 列第 1 行的元素。
             */
            m09: number;
            /**
             * @en Value at column 2 row 2 of the matrix.
             * @zh 矩阵第 2 列第 2 行的元素。
             */
            m10: number;
            /**
             * @en Value at column 2 row 3 of the matrix.
             * @zh 矩阵第 2 列第 3 行的元素。
             */
            m11: number;
            /**
             * @en Value at column 3 row 0 of the matrix.
             * @zh 矩阵第 3 列第 0 行的元素。
             */
            m12: number;
            /**
             * @en Value at column 3 row 1 of the matrix.
             * @zh 矩阵第 3 列第 1 行的元素。
             */
            m13: number;
            /**
             * @en Value at column 3 row 2 of the matrix.
             * @zh 矩阵第 3 列第 2 行的元素。
             */
            m14: number;
            /**
             * @en Value at column 3 row 3 of the matrix.
             * @zh 矩阵第 3 列第 3 行的元素。
             */
            m15: number;
            constructor(other: Mat4);
            constructor(m00?: number, m01?: number, m02?: number, m03?: number, m04?: number, m05?: number, m06?: number, m07?: number, m08?: number, m09?: number, m10?: number, m11?: number, m12?: number, m13?: number, m14?: number, m15?: number);
            /**
             * @en Clone a new matrix from the current matrix.
             * @zh 克隆当前矩阵。
             */
            clone(): Mat4;
            /**
             * @en Sets the matrix with another one's value.
             * @zh 设置当前矩阵使其与指定矩阵相等。
             * @param other Specified matrix.
             * @return this
             */
            set(other: Mat4): Mat4;
            /**
             * @en Set the matrix with values of all elements
             * @zh 设置当前矩阵指定元素值。
             * @return this
             */
            set(m00?: number, m01?: number, m02?: number, m03?: number, m04?: number, m05?: number, m06?: number, m07?: number, m08?: number, m09?: number, m10?: number, m11?: number, m12?: number, m13?: number, m14?: number, m15?: number): Mat4;
            /**
             * @en Returns whether the specified matrices are approximately equal.
             * @zh 判断当前矩阵是否在误差范围内与指定矩阵相等。
             * @param other Comparative matrix
             * @param epsilon The error allowed. It`s should be a non-negative number.
             * @return Returns `true' when the elements of both matrices are equal; otherwise returns `false'.
             */
            equals(other: Mat4, epsilon?: number): boolean;
            /**
             * @en Returns whether the specified matrices are equal.
             * @zh 判断当前矩阵是否与指定矩阵相等。
             * @param other Comparative matrix
             * @return Returns `true' when the elements of both matrices are equal; otherwise returns `false'.
             */
            strictEquals(other: Mat4): boolean;
            /**
             * @en Returns a string representation of a matrix.
             * @zh 返回当前矩阵的字符串表示。
             * @return 当前矩阵的字符串表示。
             */
            toString(): string;
            /**
             * @en set the current matrix to an identity matrix.
             * @zh 将当前矩阵设为单位矩阵。
             * @return `this`
             */
            identity(): this;
            /**
             * @en set the current matrix to an zero matrix.
             * @zh 将当前矩阵设为 0矩阵。
             * @return `this`
             */
            zero(): this;
            /**
             * @en Transposes the current matrix.
             * @zh 计算当前矩阵的转置矩阵。
             */
            transpose(): this;
            /**
             * @en Inverts the current matrix. When matrix is not invertible the matrix will be set to zeros.
             * @zh 计算当前矩阵的逆矩阵。注意，在矩阵不可逆时，会返回一个全为 0 的矩阵。
             */
            invert(): this;
            /**
             * @en Calculates the determinant of the current matrix.
             * @zh 计算当前矩阵的行列式。
             * @return 当前矩阵的行列式。
             */
            determinant(): number;
            /**
             * @en Adds the current matrix and another matrix to the current matrix.
             * @zh 矩阵加法。将当前矩阵与指定矩阵的相加，结果返回给当前矩阵。
             * @param mat the second operand
             */
            add(mat: Mat4): this;
            /**
             * @en Subtracts another matrix from the current matrix.
             * @zh 计算矩阵减法。将当前矩阵减去指定矩阵的结果赋值给当前矩阵。
             * @param mat the second operand
             */
            subtract(mat: Mat4): this;
            /**
             * @en Multiply the current matrix with another matrix.
             * @zh 矩阵乘法。将当前矩阵左乘指定矩阵的结果赋值给当前矩阵。
             * @param mat the second operand
             */
            multiply(mat: Mat4): this;
            /**
             * @en Multiply each element of the current matrix by a scalar number.
             * @zh 矩阵数乘。将当前矩阵与指定标量的数乘结果赋值给当前矩阵。
             * @param scalar amount to scale the matrix's elements by
             */
            multiplyScalar(scalar: number): this;
            /**
             * @en Translate the current matrix by the given vector
             * @zh 将当前矩阵左乘位移矩阵的结果赋值给当前矩阵，位移矩阵由各个轴的位移给出。
             * @param vec vector to translate by
             */
            translate(vec: Vec3): this;
            /**
             * @en Multiply the current matrix with a scale vector.
             * @zh 将当前矩阵左乘缩放矩阵的结果赋值给当前矩阵，缩放矩阵由各个轴的缩放给出。
             * @param vec vector to scale by
             */
            scale(vec: Vec3): this;
            /**
             * @en Rotates the current matrix by the given angle around the given axis
             * @zh 将当前矩阵左乘旋转矩阵的结果赋值给当前矩阵，旋转矩阵由旋转轴和旋转角度给出。
             * @param rad Angle of rotation (in radians)
             * @param axis Axis of rotation
             */
            rotate(rad: number, axis: Vec3): this | null;
            /**
             * @en Returns the translation vector component of a transformation matrix.
             * @zh 从当前矩阵中计算出位移变换的部分，并以各个轴上位移的形式赋值给出口向量。
             * @param out Vector to receive translation component.
             */
            getTranslation(out: Vec3): Vec3;
            /**
             * @en Returns the scale factor component of a transformation matrix
             * @zh 从当前矩阵中计算出缩放变换的部分，并以各个轴上缩放的形式赋值给出口向量。
             * @param out Vector to receive scale component
             */
            getScale(out: Vec3): Vec3;
            /**
             * @en Returns the rotation factor component of a transformation matrix
             * @zh 从当前矩阵中计算出旋转变换的部分，并以四元数的形式赋值给出口四元数。
             * @param out Vector to receive rotation component
             */
            getRotation(out: Quat): Quat;
            /**
             * @en Resets the matrix values by the given rotation quaternion, translation vector and scale vector
             * @zh 重置当前矩阵的值，使其表示指定的旋转、缩放、位移依次组合的变换。
             * @param q Rotation quaternion
             * @param v Translation vector
             * @param s Scaling vector
             * @return `this`
             */
            fromRTS(q: Quat, v: Vec3, s: Vec3): this;
            /**
             * @en Resets the current matrix from the given quaternion.
             * @zh 重置当前矩阵的值，使其表示指定四元数表示的旋转变换。
             * @param q Rotation quaternion
             * @return `this`
             */
            fromQuat(q: Quat): this;
        }
        export function mat4(other: Mat4): Mat4;
        export function mat4(m00?: number, m01?: number, m02?: number, m03?: number, m10?: number, m11?: number, m12?: number, m13?: number, m20?: number, m21?: number, m22?: number, m23?: number, m30?: number, m31?: number, m32?: number, m33?: number): Mat4;
        /**
         * @en `AffineTransform` class represent an affine transform matrix. It's composed basically by translation, rotation, scale transformations.
         * @zh 二维仿射变换矩阵，描述了平移、缩放和缩放。
         */
        export class AffineTransform {
            /**
             * @en Create an identity transformation matrix.
             * @zh 创建单位二维仿射变换矩阵，它不进行任何变换。
             */
            static identity(): AffineTransform;
            /**
             * @en Clone an `AffineTransform` object from the specified transform.
             * @zh 克隆指定的二维仿射变换矩阵。
             * @param affineTransform Specified `AffineTransform` objects
             */
            static clone(affineTransform: AffineTransform): AffineTransform;
            /**
             * @en Concatenate a transform matrix to another. The results are reflected in the out `AffineTransform`.
             * @zh 将两个矩阵相乘的结果赋值给出口矩阵。
             * @param out Out object to store the concat result
             * @param t1 The first transform object.
             * @param t2 The transform object to concatenate.
             */
            static concat(out: AffineTransform, t1: AffineTransform, t2: AffineTransform): void;
            /**
             * @en Get the invert transform of an `AffineTransform` object.
             * @zh 将矩阵求逆的结果赋值给出口矩阵。
             * @param out Out object to store the invert result
             * @param t the input `AffineTransform` object
             */
            static invert(out: AffineTransform, t: AffineTransform): void;
            /**
             * @en Get an `AffineTransform` object from a given matrix 4x4.
             * @zh 将四维矩阵转换为二维仿射变换矩阵并赋值给出口矩阵。
             * @param out The output matrix to store the result
             * @param mat transform matrix.
             */
            static fromMat4(out: AffineTransform, mat: Mat4): void;
            /**
             * @en Apply the `AffineTransform` on a 2D vector.
             * @zh 应用二维仿射变换矩阵到二维向量上，并将结果赋值给出口向量。
             * @param out The output vector to store the result
             * @param point Vector to apply transform.
             * @param t transform matrix.
             */
            static transformVec2(out: Vec2, point: Vec2, t: AffineTransform): any;
            /**
             * @en Apply the `AffineTransform` on a 2D vector.
             * @zh 应用二维仿射变换矩阵到二维向量上，并将结果赋值给出口向量。
             * @param out The output vector to store the result
             * @param x x to apply transform.
             * @param y y to apply transform.
             * @param t transform matrix.
             */
            static transformVec2(out: Vec2, x: number, y: number, t: AffineTransform): any;
            /**
             * @en Apply the `AffineTransform` on a size.
             * @zh 应用二维仿射变换矩阵到二维尺寸上，并将结果赋值给出口尺寸。
             * @param out The output size to store the result
             * @param size The size to apply transform.
             * @param t transform matrix.
             */
            static transformSize(out: Size, size: Size, t: AffineTransform): void;
            /**
             * @en Apply the `AffineTransform` on a rect.
             * @zh 应用二维仿射变换矩阵到矩形上，并将结果赋值给出口矩形。
             * @param out The output rect object to store the result
             * @param rect The rect object to apply transform.
             * @param t transform matrix.
             */
            static transformRect(out: Rect, rect: Rect, t: AffineTransform): void;
            /**
             * @en Apply the `AffineTransform` on a rect, and turns to an Oriented Bounding Box.
             * This function does not allocate any memory, you should create the output vectors by yourself and manage their memory.
             * @zh 应用二维仿射变换矩阵到矩形上, 并转换为有向包围盒。
             * 这个函数不创建任何内存，你需要先创建包围盒的四个 Vector 对象用来存储结果，并作为前四个参数传入函数。
             * @param out_bl Output vector for storing the bottom left corner coordinates of the Obb object
             * @param out_tl Output vector for storing the top left corner coordinates of the Obb object
             * @param out_tr Output vector for storing the top right corner coordinates of the Obb object
             * @param out_br Output vector for storing the bottom right corner coordinates of the Obb object
             * @param rect The rect object to apply transform.
             * @param anAffineTransform transform matrix.
             */
            static transformObb(out_bl: Vec2, out_tl: Vec2, out_tr: Vec2, out_br: Vec2, rect: Rect, anAffineTransform: AffineTransform): void;
            a: number;
            b: number;
            c: number;
            d: number;
            tx: number;
            ty: number;
            /**
             * @en constructor an `AffineTransform` object.
             * @zh 构造二维放射变换矩阵。
             * @param a a
             * @param b b
             * @param c c
             * @param d d
             * @param tx tx
             * @param ty ty
             */
            constructor(a?: number, b?: number, c?: number, d?: number, tx?: number, ty?: number);
        }
        /**
         * @en Two dimensional size type representing the width and height.
         * @zh 二维尺寸。
         */
        export class Size extends ValueType {
            static ZERO: Readonly<Size>;
            static ONE: Readonly<Size>;
            /**
             * @en Calculate the interpolation result between this size and another one with given ratio
             * @zh 根据指定的插值比率，从当前尺寸到目标尺寸之间做插值。
             * @param out Output Size.
             * @param from Original Size.
             * @param to Target Size.
             * @param ratio The interpolation coefficient.The range is [0,1].
             * @returns A vector consisting of linear interpolation of the width and height of the current size to the width and height of the target size at a specified interpolation ratio, respectively.
             */
            static lerp<Out extends ISizeLike>(out: Out, from: Out, to: Out, ratio: number): Out;
            set x(val: number);
            get x(): number;
            set y(val: number);
            get y(): number;
            width: number;
            height: number;
            /**
             * @en Constructor a size from another one.
             * @zh 构造与指定尺寸相等的尺寸。
             * @param other Specified Size.
             */
            constructor(other: Size);
            /**
             * @en Constructor a size with specified values.
             * @zh 构造具有指定宽度和高度的尺寸。
             * @param width width of the Size, default value is 0.
             * @param height height of the Size, default value is 0.
             */
            constructor(width?: number, height?: number);
            /**
             * @en clone the current `Size`.
             * @zh 克隆当前尺寸。
             */
            clone(): Size;
            /**
             * @en Set values with another `Size`.
             * @zh 设置当前尺寸使其与指定的尺寸相等。
             * @param other Specified Size.
             * @returns `this`
             */
            set(other: Size): any;
            /**
             * @en Set the value of each component of the current `Size`.
             * @zh 设置当前尺寸的具体参数。
             * @param width Specified width
             * @param height Specified height
             * @returns `this`
             */
            set(width?: number, height?: number): any;
            /**
             * @en Check whether the current `Size` equals another one.
             * @zh 判断当前尺寸是否与指定尺寸的相等。
             * @param other Specified Size
             * @returns Returns `true' when both dimensions are equal in width and height; otherwise returns `false'.
             */
            equals(other: Size): boolean;
            /**
             * @en Calculate the interpolation result between this size and another one with given ratio
             * @zh 根据指定的插值比率，从当前尺寸到目标尺寸之间做插值。
             * @param to Target Size.
             * @param ratio The interpolation coefficient.The range is [0,1].
             */
            lerp(to: Size, ratio: number): this;
            /**
             * @en Return the information of the current size in string
             * @zh 返回当前尺寸的字符串表示。
             * @returns The information of the current size in string
             */
            toString(): string;
        }
        /**
         * @en Constructs a `Size` object.
         * @zh 等价于 `new Size(other)`。
         * @param other Specified Size.
         * @returns `new Size(other)`
         */
        export function size(other: Size): Size;
        /**
         * @en Constructs a `Size` object.
         * @zh 等价于 `new Size(x, y)`。
         * @param width Specified width
         * @param height Specified height
         * @returns `new Size(w, h)`
         */
        export function size(width?: number, height?: number): Size;
        /**
         * @en
         * A 2D rectangle defined by x, y position and width, height.
         * @zh
         * 轴对齐矩形。
         * 矩形内的所有点都大于等于矩形的最小点 (xMin, yMin) 并且小于等于矩形的最大点 (xMax, yMax)。
         * 矩形的宽度定义为 xMax - xMin；高度定义为 yMax - yMin。
         */
        export class Rect extends ValueType {
            /**
             * @en Creates a rectangle from two coordinate values.
             * @zh 由任意两个点创建一个矩形，目标矩形即是这两个点各向 x、y 轴作线所得到的矩形。
             * @param v1 Specified point 1.
             * @param v2 Specified point 2.
             * @returns Target rectangle.
             */
            static fromMinMax<Out extends IRectLike, VecLike extends IVec2Like>(out: Out, v1: VecLike, v2: VecLike): Out;
            /**
             * @en Calculate the interpolation result between this rect and another one with given ratio
             * @zh 根据指定的插值比率，从当前矩形到目标矩形之间做插值。
             * @param out Output rect.
             * @param from Original rect.
             * @param to Target rect.
             * @param ratio The interpolation coefficient.The range is [0,1].
             */
            static lerp<Out extends IRectLike>(out: Out, from: Out, to: Out, ratio: number): Out;
            /**
             * @en Returns the overlapping portion of 2 rectangles.
             * @zh 计算当前矩形与指定矩形重叠部分的矩形，将其赋值给出口矩形。
             * @param out Output Rect.
             * @param one One of the specify Rect.
             * @param other Another of the specify Rect.
             */
            static intersection<Out extends IRectLike>(out: Out, one: Out, other: Out): Out;
            /**
             * @en Returns the smallest rectangle that contains the current rect and the given rect.
             * @zh 创建同时包含当前矩形和指定矩形的最小矩形，将其赋值给出口矩形。
             * @param out Output Rect.
             * @param one One of the specify Rect.
             * @param other Another of the specify Rect.
             */
            static union<Out extends IRectLike>(out: Out, one: Out, other: Out): Out;
            /**
             * @en The minimum x value.
             * @zh 获取或设置矩形在 x 轴上的最小值。
             */
            get xMin(): number;
            set xMin(value: number);
            /**
             * @en The minimum y value.
             * @zh 获取或设置矩形在 y 轴上的最小值。
             */
            get yMin(): number;
            set yMin(value: number);
            /**
             * @en The maximum x value.
             * @zh 获取或设置矩形在 x 轴上的最大值。
             */
            get xMax(): number;
            set xMax(value: number);
            /**
             * @en The maximum y value.
             * @zh 获取或设置矩形在 y 轴上的最大值。
             */
            get yMax(): number;
            set yMax(value: number);
            /**
             * @en The position of the center of the rectangle.
             * @zh 获取或设置矩形中心点的坐标。
             */
            get center(): Vec2;
            set center(value: Vec2);
            /**
             * @en Returns a new [[Vec2]] object representing the position of the rectangle
             * @zh 获取或设置矩形的 x 和 y 坐标。
             */
            get origin(): Vec2;
            set origin(value: Vec2);
            /**
             * @en Returns a new [[Size]] object represents the width and height of the rectangle
             * @zh 获取或设置矩形的尺寸。
             */
            get size(): Size;
            set size(value: Size);
            set z(val: number);
            get z(): number;
            set w(val: number);
            get w(): number;
            /**
             * @en The minimum x value.
             * @zh 矩形最小点的 x 坐标。
             */
            x: number;
            /**
             * @en The minimum y value.
             * @zh 矩形最小点的 y 坐标。
             */
            y: number;
            /**
             * @en The width of the Rect.
             * @zh 矩形的宽度。
             */
            width: number;
            /**
             * @en The height of the Rect.
             * @zh 矩形的高度。
             */
            height: number;
            /**
             * @en Constructs a Rect from another one.
             * @zh 构造与指定矩形相等的矩形。
             * @param other Specified Rect.
             */
            constructor(other: Rect);
            /**
             * @en Constructs a Rect with specified values.
             * @zh 构造具有指定的最小值和尺寸的矩形。
             * @param x The minimum X coordinate of the rectangle.
             * @param y The minimum Y coordinate of the rectangle.
             * @param width The width of the rectangle, measured from the X position.
             * @param height The height of the rectangle, measured from the Y position.
             */
            constructor(x?: number, y?: number, width?: number, height?: number);
            /**
             * @en clone the current Rect.
             * @zh 克隆当前矩形。
             */
            clone(): Rect;
            /**
             * @en Set values with another Rect.
             * @zh 设置当前矩形使其与指定矩形相等。
             * @param other Specified Rect.
             * @returns `this`
             */
            set(other: Rect): any;
            /**
             * @en Set the value of each component of the current Rect.
             * @zh 设置当前矩形使其与指定参数的矩形相等。
             * @param x The x parameter of the specified rectangle
             * @param y The y parameter of the specified rectangle
             * @param width The width parameter of the specified rectangle
             * @param height The height parameter of the specified rectangle
             * @returns `this`
             */
            set(x?: number, y?: number, width?: number, height?: number): any;
            /**
             * @en Check whether the current Rect equals another one.
             * @zh 判断当前矩形是否与指定矩形相等。
             * @param other Specified rectangles.
             * @returns Returns `true' when the minimum and maximum values of both rectangles are equal, respectively; otherwise, returns `false'.
             */
            equals(other: Rect): boolean;
            /**
             * @en Calculate the interpolation result between this Rect and another one with given ratio.
             * @zh 根据指定的插值比率，从当前矩形到目标矩形之间做插值。
             * @param to Target Rect.
             * @param ratio The interpolation coefficient.The range is [0,1].
             */
            lerp(to: Rect, ratio: number): this;
            /**
             * @en Return the information of the current rect in string
             * @zh 返回当前矩形的字符串表示。
             * @returns The information of the current rect in string
             */
            toString(): string;
            /**
             * @en Check whether the current rectangle intersects with the given one.
             * @zh 判断当前矩形是否与指定矩形相交。
             * @param other Specified rectangles.
             * @returns If intersected, return `true', otherwise return `false'.
             */
            intersects(other: Rect): boolean;
            /**
             * @en Check whether the current rect contains the given point.
             * @zh 判断当前矩形是否包含指定的点。
             * @param point Specified point.
             * @returns The specified point is included in the rectangle and returns `true', otherwise it returns `false'.
             */
            contains(point: Vec2): boolean;
            /**
             * @en Returns true if the other rect entirely inside this rectangle.
             * @zh 判断当前矩形是否包含指定矩形。
             * @param other Specified rectangles.
             * @returns Returns `true' if all the points of the specified rectangle are included in the current rectangle, `false' otherwise.
             */
            containsRect(other: Rect): boolean;
            /**
             * @en Apply matrix4 to the rect.
             * @zh
             * 应用矩阵变换到当前矩形：
             * 应用矩阵变换到当前矩形的最小点得到新的最小点，
             * 将当前矩形的尺寸视为二维向量应用矩阵变换得到新的尺寸；
             * 并将如此构成的新矩形。
             * @param matrix The matrix4
             */
            transformMat4(mat: Mat4): this;
            /**
             * @en
             * Applies a matrix transformation to the current rectangle and outputs the result to the four vertices.
             * @zh
             * 应用矩阵变换到当前矩形，并将结果输出到四个顶点上。
             *
             * @param mat The mat4 to apply
             * @param out_lb The left bottom point
             * @param out_lt The left top point
             * @param out_rb The right bottom point
             * @param out_rt The right top point
             */
            transformMat4ToPoints(mat: Mat4, out_lb: Vec2, out_lt: Vec2, out_rt: Vec2, out_rb: Vec2): void;
        }
        /**
         * @en The convenient method to create a new Rect.
         * @zh 构造与指定矩形相等的矩形。等价于 `new Rect(rect)`。
         * @param rect Specified Rect.
         * @returns `new Rect(rect)`
         */
        export function rect(rect: Rect): Rect;
        /**
         * @en The convenient method to create a new Rect.
         * @zh 构造具有指定的最小值和尺寸的矩形，等价于`new Rect(x, y, width, height)`。
         * @param x The minimum X coordinate of the rectangle.
         * @param y The minimum Y coordinate of the rectangle.
         * @param width The width of the rectangle, measured from the X position.
         * @param height The height of the rectangle, measured from the Y position.
         * @returns `new Rect(x, y, width, height)`
         */
        export function rect(x?: number, y?: number, width?: number, height?: number): Rect;
        /**
         * @en Representation of RGBA colors.<br/>
         * Each color component is an integer value with a range from 0 to 255.<br/>
         * @zh 通过 Red、Green、Blue 颜色通道表示颜色，并通过 Alpha 通道表示不透明度。<br/>
         * 每个通道都为取值范围 [0, 255] 的整数。<br/>
         */
        export class Color extends ValueType {
            static WHITE: Readonly<Color>;
            static GRAY: Readonly<Color>;
            static BLACK: Readonly<Color>;
            static TRANSPARENT: Readonly<Color>;
            static RED: Readonly<Color>;
            static GREEN: Readonly<Color>;
            static BLUE: Readonly<Color>;
            static CYAN: Readonly<Color>;
            static MAGENTA: Readonly<Color>;
            static YELLOW: Readonly<Color>;
            /**
             * @en Copy content of a color into another and save the results to out color.
             * @zh 获得指定颜色的拷贝
             */
            static clone<Out extends IColorLike>(a: Out): Color;
            /**
             * @en Clone a color and save the results to out color.
             * @zh 复制目标颜色
             */
            static copy<Out extends IColorLike>(out: Out, a: Out): Out;
            /**
             * @en Set the components of a color to the given values and save the results to out color.
             * @zh 设置颜色值
             */
            static set<Out extends IColorLike>(out: Out, r: number, g: number, b: number, a: number): Out;
            /**
             * @en Convert 8bit color to Vec4
             * @zh 将当前颜色转换为到 Vec4
             * @returns Vec4 as float color value
             * @example
             * ```
             * const color = Color.YELLOW;
             * color.toVec4();
             * ```
             */
            static toVec4(color: Color, out?: Vec4): Vec4;
            /**
             * @en Set 8bit Color from Vec4
             * @zh 使用 Vec4 设置 8 bit 颜色
             * @returns 8 Bit srgb value
             * @example
             * ```
             * color.fromVec4(new Vec4(1,1,1,1));
             * ```
             */
            static fromVec4(value: Vec4, out?: Color): Color;
            /**
             * @en Converts the hexadecimal formal color into rgb formal and save the results to out color.
             * @zh 从十六进制颜色字符串中读入颜色到 out 中
             */
            static fromHEX<Out extends IColorLike>(out: Out, hexString: string): Out;
            /**
             * @en Add two colors by components. And save the results to out color.
             * @zh 逐通道颜色加法
             */
            static add<Out extends IColorLike>(out: Out, a: Out, b: Out): Out;
            /**
             * @en Subtract each components of color b from each components of color a. And save the results to out color.
             * @zh 逐通道颜色减法
             */
            static subtract<Out extends IColorLike>(out: Out, a: Out, b: Out): Out;
            /**
             * @en Multiply each components of two colors. And save the results to out color.
             * @zh 逐通道颜色乘法
             */
            static multiply<Out extends IColorLike>(out: Out, a: Out, b: Out): Out;
            /**
             * @en Divide each components of color a by each components of color b. And save the results to out color.
             * @zh 逐通道颜色除法
             */
            static divide<Out extends IColorLike>(out: Out, a: Out, b: Out): Out;
            /**
             * @en Multiply all channels in a color with the given scale factor, and save the results to out color.
             * @zh 全通道统一缩放颜色
             */
            static scale<Out extends IColorLike>(out: Out, a: Out, b: number): Out;
            /**
             * @en Performs a linear interpolation between two colors.
             * @zh 逐通道颜色线性插值：A + t * (B - A)
             */
            static lerp<Out extends IColorLike>(out: Out, from: Out, to: Out, ratio: number): Out;
            /**
             * @en Convert a color object to a RGBA array, and save the results to out color.
             * @zh 颜色转数组
             * @param ofs Array Start Offset
             */
            static toArray<Out extends __private._types_globals__IWritableArrayLike<number>>(out: Out, a: IColorLike, ofs?: number): Out;
            /**
             * @en Sets the given color with RGBA values in an array, and save the results to out color.
             * @zh 数组转颜色
             * @param ofs Array Start Offset
             */
            static fromArray<Out extends IColorLike>(arr: __private._types_globals__IWritableArrayLike<number>, out: Out, ofs?: number): Out;
            /**
             * @en Check whether the two given colors are identical
             * @zh 颜色等价判断
             */
            static strictEquals<Out extends IColorLike>(a: Out, b: Out): boolean;
            /**
             * @en Check whether the two given colors are approximately equivalent. Difference of each channel is smaller that the epsilon.
             * @zh 排除浮点数误差的颜色近似等价判断
             */
            static equals<Out extends IColorLike>(a: Out, b: Out, epsilon?: number): boolean;
            /**
             * @en Convert the given color to a hex color value. And save the results to out color.
             * @zh 获取指定颜色的整型数据表示
             */
            static hex<Out extends IColorLike>(a: Out): number;
            /**
             * @en Get or set red channel value.
             * @zh 获取或设置当前颜色的 Red 通道。
             */
            get r(): number;
            set r(red: number);
            /**
             * @en Get or set green channel value.
             * @zh 获取或设置当前颜色的 Green 通道。
             */
            get g(): number;
            set g(green: number);
            /**
             * @en Get or set blue channel value.
             * @zh 获取或设置当前颜色的 Blue 通道。
             */
            get b(): number;
            set b(blue: number);
            /** @en Get or set alpha channel value.
             * @zh 获取或设置当前颜色的透明度通道。
             */
            get a(): number;
            set a(alpha: number);
            get x(): number;
            set x(value: number);
            get y(): number;
            set y(value: number);
            get z(): number;
            set z(value: number);
            get w(): number;
            set w(value: number);
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _val: number;
            /**
             * @en Construct a same color from the given color
             * @zh 构造与指定颜色相等的颜色。
             * @param other Specified color
             */
            constructor(other: Color);
            /**
             * @en Construct a color form the hex color string
             * @zh 用十六进制颜色字符串中构造颜色。
             * @param hexString Hexadecimal color string.
             */
            constructor(hexString: string);
            /**
             * @en Construct a color
             * @zh 构造具有指定通道的颜色。
             * @param r red component of the color, default value is 0.
             * @param g green component of the color, default value is 0.
             * @param b blue component of the color, default value is 0.
             * @param a alpha component of the color, default value is 255.
             */
            constructor(r?: number, g?: number, b?: number, a?: number);
            /**
             * @en Clone a new color from the current color.
             * @zh 克隆当前颜色。
             */
            clone(): Color;
            /**
             * @en Check whether the current color is identical with the given color
             * @zh 判断当前颜色是否与指定颜色相等。
             * @param other Specified color
             * @returns Returns `true` when all channels of both colours are equal; otherwise returns `false`.
             */
            equals(other: Color): boolean;
            /**
             * @en Calculate linear interpolation result between this color and another one with given ratio。
             * @zh 根据指定的插值比率，从当前颜色到目标颜色之间做插值。
             * @param to Target color
             * @param ratio The interpolation coefficient.The range is [0,1].
             */
            lerp(to: Color, ratio: number): this;
            /**
             * @en Convert to string with color informations
             * @zh 返回当前颜色的字符串表示。
             * @returns A string representation of the current color.
             */
            toString(): string;
            /**
             * @en Convert color to css format.
             * @zh 将当前颜色转换为 CSS 格式。
             * @param opt "rgba", "rgb", "#rgb" or "#rrggbb".
             * @returns CSS format for the current color.
             * @example
             * ```ts
             * let color = cc.Color.BLACK;
             * color.toCSS();          // "rgba(0,0,0,1.00)";
             * color.toCSS("rgba");    // "rgba(0,0,0,1.00)";
             * color.toCSS("rgb");     // "rgba(0,0,0)";
             * color.toCSS("#rgb");    // "#000";
             * color.toCSS("#rrggbb"); // "#000000";
             * ```
             */
            toCSS(opt?: ("rgba" | "rgb" | "#rrggbb" | "#rrggbbaa")): string;
            /**
             * @en Read hex string and store color data into the current color object, the hex string must be formatted as rgba or rgb.
             * @zh 从十六进制颜色字符串中读入当前颜色。<br/>
             * 十六进制颜色字符串应该以可选的 "#" 开头，紧跟最多 8 个代表十六进制数字的字符；<br/>
             * 每两个连续字符代表的数值依次作为 Red、Green、Blue 和 Alpha 通道；<br/>
             * 缺省的颜色通道将视为 0；缺省的透明通道将视为 255。<br/>
             * @param hexString the hex string
             * @returns `this`
             */
            fromHEX(hexString: string): this;
            /**
             * @en convert Color to HEX color string.
             * @zh 转换当前颜色为十六进制颜色字符串。
             * @param fmt "#rrggbb" or "#rrggbbaa".
             * - `'#rrggbbaa'` obtains the hexadecimal value of the Red, Green, Blue, Alpha channels (**two**, high complement 0) and connects them sequentially.
             * - `'#rrggbb'` is similar to `'#rrggbbaa'` but does not include the Alpha channel.
             * @returns the Hex color string
             * @example
             * ```
             * const color = new Color(255, 14, 0, 255);
             * color.toHEX("#rgb");      // "f00";
             * color.toHEX("#rrggbbaa"); // "ff0e00ff"
             * color.toHEX("#rrggbb");   // "ff0e00"
             * ```
             */
            toHEX(fmt?: "#rgb" | "#rrggbb" | "#rrggbbaa"): string;
            /**
             * @en Convert to rgb value.
             * @zh 将当前颜色转换为 RGB 整数值。
             * @returns RGB integer value. Starting from the lowest valid bit, each 8 bits is the value of the Red, Green, and Blue channels respectively.
             * @example
             * ```
             * const color = Color.YELLOW;
             * color.toRGBValue();
             * ```
             */
            toRGBValue(): number;
            /**
             * @en Read HSV model color and convert to RGB color.
             * @zh 从 HSV 颜色中读入当前颜色。
             * @param h H value。
             * @param s S value。
             * @param v V value。
             * @returns `this`
             * @example
             * ```
             * const color = Color.YELLOW;
             * color.fromHSV(0, 0, 1); // Color {r: 255, g: 255, b: 255, a: 255};
             * ```
             */
            fromHSV(h: number, s: number, v: number): this;
            /**
             * @en Transform to HSV model color.
             * @zh 转换当前颜色为 HSV 颜色。
             * @returns HSV format color
             * @example
             * ```
             * import { Color } from 'cc';
             * const color = Color.YELLOW;
             * color.toHSV(); // {h: 0.1533864541832669, s: 0.9843137254901961, v: 1}
             * ```
             */
            toHSV(): {
                h: number;
                s: number;
                v: number;
            };
            /**
             * @en Set the color.
             * @zh 设置当前颜色使其与指定颜色相等。
             * @param other The specified color.
             * @overload
             * @param [r=0] red component of the color, the range is [0-255]
             * @param [g=0] green component of the color
             * @param [b=0] blue component of the color
             * @param [a=255] alpha component of the color
             * @returns Current color.
             */
            set(other: Color): Color;
            set(r?: number, g?: number, b?: number, a?: number): Color;
            /**
             * @en Multiplies the current color by the specified color.
             * @zh 将当前颜色乘以与指定颜色
             * @param other The specified color.
             */
            multiply(other: Color): this;
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _set_r_unsafe(red: any): this;
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _set_g_unsafe(green: any): this;
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _set_b_unsafe(blue: any): this;
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _set_a_unsafe(alpha: any): this;
        }
        export function color(other: Color | string): Color;
        export function color(r?: number, g?: number, b?: number, a?: number): Color;
        /**
         * @en Tests whether or not the arguments have approximately the same value, within an absolute<br/>
         * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less<br/>
         * than or equal to 1.0, and a relative tolerance is used for larger values)
         * @zh 在glMatrix的绝对或相对容差范围内，测试参数是否具有近似相同的值。<br/>
         * EPSILON(小于等于1.0的值采用绝对公差，大于1.0的值采用相对公差)
         * @param a The first number to test.
         * @param b The second number to test.
         * @return True if the numbers are approximately equal, false otherwise.
         */
        export function equals(a: number, b: number): boolean;
        /**
         * @en Tests whether or not the arguments have approximately the same value by given maxDiff<br/>
         * @zh 通过给定的最大差异，测试参数是否具有近似相同的值。
         * @param a The first number to test.
         * @param b The second number to test.
         * @param maxDiff Maximum difference.
         * @return True if the numbers are approximately equal, false otherwise.
         */
        export function approx(a: number, b: number, maxDiff: number): boolean;
        /**
         * @en Clamps a value between a minimum float and maximum float value.<br/>
         * @zh 返回最小浮点数和最大浮点数之间的一个数值。可以使用 clamp 函数将不断变化的数值限制在范围内。
         * @param val
         * @param min
         * @param max
         */
        export function clamp(val: number, min: number, max: number): number;
        /**
         * @en Clamps a value between 0 and 1.<br/>
         * @zh 将值限制在0和1之间。
         * @param val
         */
        export function clamp01(val: number): number;
        /**
         * @param from
         * @param to
         * @param ratio - The interpolation coefficient.
         */
        export function lerp(from: number, to: number, ratio: number): number;
        /**
         * @en Convert Degree To Radian<br/>
         * @zh 把角度换算成弧度。
         * @param {Number} a Angle in Degrees
         */
        export function toRadian(a: number): number;
        /**
         * @en Convert Radian To Degree<br/>
         * @zh 把弧度换算成角度。
         * @param {Number} a Angle in Radian
         */
        export function toDegree(a: number): number;
        /**
         * @en Returns a floating-point random number between min (inclusive) and max (exclusive).<br/>
         * @zh 返回最小(包含)和最大(不包含)之间的浮点随机数。
         * @method randomRange
         * @param min
         * @param max
         * @return The random number.
         */
        export function randomRange(min: number, max: number): number;
        /**
         * @en Returns a random integer between min (inclusive) and max (exclusive).<br/>
         * @zh 返回最小(包含)和最大(不包含)之间的随机整数。
         * @param min
         * @param max
         * @return The random integer.
         */
        export function randomRangeInt(min: number, max: number): number;
        /**
         * @en
         * Linear congruence generator using Hull-Dobell Theorem.
         * @zh
         * 使用 Hull-Dobell 算法的线性同余生成器构造伪随机数
         *
         * @param seed The random seed.
         * @return The pseudo random.
         */
        export function pseudoRandom(seed: number): number;
        /**
         * @en
         * Returns a floating-point pseudo-random number between min (inclusive) and max (exclusive).
         * @zh
         * 返回一个在范围内的浮点伪随机数，注意，不包含边界值
         *
         * @param seed
         * @param min
         * @param max
         * @return The random number.
         */
        export function pseudoRandomRange(seed: number, min: number, max: number): number;
        /**
         * @en Returns a pseudo-random integer between min (inclusive) and max (exclusive).<br/>
         * @zh 返回最小(包含)和最大(不包含)之间的浮点伪随机数。
         * @param seed
         * @param min
         * @param max
         * @return The random integer.
         */
        export function pseudoRandomRangeInt(seed: number, min: number, max: number): number;
        /**
         * @en
         * Returns the next power of two for the value.<br/>
         * @zh
         * 返回下一个最接近的 2 的幂
         *
         * @param val
         * @return The the next power of two.
         */
        export function nextPow2(val: number): number;
        /**
         * @en Returns float remainder for t / length.<br/>
         * @zh 返回t / length的浮点余数。
         * @param t Time start at 0.
         * @param length Time of one cycle.
         * @return The Time wrapped in the first cycle.
         */
        export function repeat(t: number, length: number): number;
        /**
         * @en
         * Returns time wrapped in ping-pong mode.
         * @zh
         * 返回乒乓模式下的相对时间
         *
         * @param t Time start at 0.
         * @param length Time of one cycle.
         * @return The time wrapped in the first cycle.
         */
        export function pingPong(t: number, length: number): number;
        /**
         * @en Returns ratio of a value within a given range.<br/>
         * @zh 返回给定范围内的值的比率。
         * @param from Start value.
         * @param to End value.
         * @param value Given value.
         * @return The ratio between [from, to].
         */
        export function inverseLerp(from: number, to: number, value: number): number;
        /**
         * @en Compare the absolute values of all components and the component with the largest absolute value will be returned.
         * @zh 对所有分量的绝对值进行比较大小，返回绝对值最大的分量。
         * @param v vec3 like value
         * @returns max absolute component
         */
        export function absMaxComponent(v: IVec3Like): number;
        /**
         * @en Compare the absolute value of two values and return the value with the largest absolute value
         * @zh 对 a b 的绝对值进行比较大小，返回绝对值最大的值。
         * @param a number
         * @param b number
         */
        export function absMax(a: number, b: number): number;
        /**
         * @en
         * Make the attributes of the specified class available to be enumerated
         * @zh
         * 使指定类的特定属性可被枚举
         * @param prototype Inherit the prototype chain of the ValueType class
         * @param attrs List of attributes that need to be enumerated
         */
        export function enumerableProps(prototype: ValueType, attrs: string[]): void;
        export const EPSILON = 0.000001;
        /**
         * @method random
         */
        export const random: () => number;
        export interface IColorLike {
            r: number;
            g: number;
            b: number;
            a: number;
            _val: number;
        }
        export interface IMat3Like {
            m00: number;
            m01: number;
            m02: number;
            m03: number;
            m04: number;
            m05: number;
            m06: number;
            m07: number;
            m08: number;
        }
        export interface IMat4Like {
            m00: number;
            m01: number;
            m02: number;
            m03: number;
            m04: number;
            m05: number;
            m06: number;
            m07: number;
            m08: number;
            m09: number;
            m10: number;
            m11: number;
            m12: number;
            m13: number;
            m14: number;
            m15: number;
        }
        export interface IQuatLike {
            x: number;
            y: number;
            z: number;
            w: number;
        }
        export interface IRectLike {
            x: number;
            y: number;
            width: number;
            height: number;
        }
        export interface ISizeLike {
            width: number;
            height: number;
        }
        export interface IVec2Like {
            x: number;
            y: number;
        }
        export interface IVec3Like {
            x: number;
            y: number;
            z: number;
        }
        export interface IVec4Like {
            x: number;
            y: number;
            z: number;
            w: number;
        }
        export type FloatArray = Float64Array | Float32Array;
        export type IVec2 = IVec2Like | Readonly<IVec2Like>;
        export type IVec3 = IVec3Like | Readonly<IVec3Like>;
        export type IVec4 = IVec4Like | Readonly<IVec4Like>;
        export type IMat3 = IMat3Like | Readonly<IMat3Like>;
        export type IMat4 = IMat4Like | Readonly<IMat4Like>;
        export type IRect = IRectLike | Readonly<IRectLike>;
        export type IQuat = IQuatLike | Readonly<IQuatLike>;
        export type IColor = IColorLike | Readonly<IColorLike>;
        export const MATH_FLOAT_ARRAY: Float32ArrayConstructor | Float64ArrayConstructor;
        export class MathBase extends ValueType {
            static createFloatArray(size: number): Float32Array | Float64Array;
            /**
             * @en Get the internal array data.
             * @zh 获取内部 array 数据。
             */
            get array(): FloatArray;
            protected _array: FloatArray;
        }
    }
    export namespace memop {
        /**
         * @en Typed object pool.
         * It's a traditional design, you can get elements out of the pool or recycle elements by putting back into the pool.
         * @zh 支持类型的对象池。这是一个传统设计的对象池，你可以从对象池中取出对象或是放回不再需要对象来复用。
         * @see [[RecyclePool]]
         */
        export class Pool<T> extends __private._cocos_core_memop_scalable_container__ScalableContainer {
            /**
             * @en Constructor with the allocator of elements and initial pool size
             * @zh 使用元素的构造器和初始大小的构造函数
             * @param ctor The allocator of elements in pool, it's invoked directly without `new`
             * @param elementsPerBatch Initial pool size, this size will also be the incremental size when the pool is overloaded
             * @param dtor The finalizer of element, it's invoked when this container is destroyed or shrunk
             */
            constructor(ctor: () => T, elementsPerBatch: number, dtor?: (obj: T) => void);
            /**
             * @en Take an object out of the object pool.
             * @zh 从对象池中取出一个对象。
             * @return An object ready for use. This function always return an object.
             */
            alloc(): T;
            /**
             * @en Put an object back into the object pool.
             * @zh 将一个对象放回对象池中。
             * @param obj The object to be put back into the pool
             */
            free(obj: T): void;
            /**
             * @en Put multiple objects back into the object pool.
             * @zh 将一组对象放回对象池中。
             * @param objs An array of objects to be put back into the pool
             */
            freeArray(objs: T[]): void;
            tryShrink(): void;
            /**
             * @en Destroy all elements and clear the pool.
             * @zh 释放对象池中所有资源并清空缓存池。
             */
            destroy(): void;
        }
        /**
         * @en Recyclable object pool. It's designed to be entirely reused each time.
         * There is no put and get method, each time you get the [[data]], you can use all elements as new.
         * You shouldn't simultaneously use the same RecyclePool in more than two overlapped logic.
         * Its size can be automatically incremented or manually resized.
         * @zh 循环对象池。这种池子被设计为每次使用都完整复用。
         * 它没有回收和提取的函数，通过获取 [[data]] 可以获取池子中所有元素，全部都应该被当做新对象来使用。
         * 开发者不应该在相互交叉的不同逻辑中同时使用同一个循环对象池。
         * 池子尺寸可以在池子满时自动扩充，也可以手动调整。
         * @see [[Pool]]
         */
        export class RecyclePool<T = any> extends __private._cocos_core_memop_scalable_container__ScalableContainer {
            /**
             * @en Constructor with the allocator of elements and initial pool size, all elements will be pre-allocated.
             * @zh 使用元素的构造器和初始大小的构造函数，所有元素都会被预创建。
             * @param fn The allocator of elements in pool, it's invoked directly without `new`
             * @param size Initial pool size
             * @param dtor The finalizer of element, it's invoked when this container is destroyed or shrunk
             */
            constructor(fn: () => T, size: number, dtor?: (obj: T) => void);
            /**
             * @en The length of the object pool.
             * @zh 对象池大小。
             */
            get length(): number;
            /**
             * @en The underlying array of all pool elements.
             * @zh 实际对象池数组。
             */
            get data(): T[];
            /**
             * @en Resets the object pool. Only changes the length to 0
             * @zh 清空对象池。目前仅仅会设置尺寸为 0
             */
            reset(): void;
            /**
             * @en Resize the object poo, and fills with new created elements.
             * @zh 设置对象池大小，并填充新的元素。
             * @param size The new size of the pool
             */
            resize(size: number): void;
            /**
             * @en Expand the object pool, the size will be increment to current size times two, and fills with new created elements.
             * @zh 扩充对象池容量，会自动扩充尺寸到两倍，并填充新的元素。
             * @param idx
             */
            add(): T;
            destroy(): void;
            tryShrink(): void;
            /**
             * @en Remove an element of the object pool. This will also decrease size of the pool
             * @zh 移除对象池中的一个元素，同时会减小池子尺寸。
             * @param idx The index of the element to be removed
             */
            removeAt(idx: number): void;
        }
        /**
         * @en
         * Cached array is a data structure for objects cache, it's designed for persistent data.
         * Its content array length will keep grow.
         * @zh
         * 适用于对象缓存的数组类型封装，一般用于不易被移除的常驻数据。
         * 它的内部数组长度会持续增长，不会减少。
         */
        export class CachedArray<T> extends __private._cocos_core_memop_scalable_container__ScalableContainer {
            /**
             * @en
             * The array which stores actual content
             * @zh
             * 实际存储数据内容的数组
             */
            array: T[];
            /**
             * @en
             * The actual count of data object
             * @zh
             * 实际数据内容数量
             */
            length: number;
            /**
             * @param length Initial length
             * @param compareFn Comparison function for sorting
             */
            constructor(length: number, compareFn?: (a: T, b: T) => number);
            /**
             * @en
             * Push an element to the end of the array
             * @zh
             * 向数组末尾添加一个元素
             * @param item The item to be added
             */
            push(item: T): void;
            /**
             * @en
             * Pop the last element in the array. The [[length]] will reduce, but the internal array will keep its size.
             * @zh
             * 弹出数组最后一个元素，CachedArray 的 [[length]] 会减少，但是内部数组的实际长度不变
             * @return The last element.
             */
            pop(): T | undefined;
            /**
             * @en
             * Get the element at the specified index of the array
             * @zh
             * 得到数组中指定位置的元素
             * @param idx The index of the requested element
             * @return The element at given index
             */
            get(idx: number): T | undefined;
            /**
             * @en
             * Clear the cache. The [[length]] will be set to 0, but the internal array will keep its size.
             * @zh
             * 清空数组所有元素。[[length]] 会被设为 0，但内部数组的实际长度不变
             */
            clear(): void;
            /**
             * @en
             * Clear the cache. The [[length]] will be set to 0, and clear the internal array.
             * @zh
             * 清空数组所有元素。[[length]] 会被设为 0，并且清空内部数组
             */
            destroy(): void;
            tryShrink(): void;
            /**
             * @en
             * Sort the existing elements in cache
             * @zh
             * 排序所有现有元素
             */
            sort(): void;
            /**
             * @en
             * Add all elements of a given array to the end of the current array
             * @zh
             * 添加一个指定数组中的所有元素到当前数组末尾
             * @param array The given array to be appended
             */
            concat(array: T[]): void;
            /**
             * @en Delete the element at the specified location and move the last element to that location.
             * @zh 删除指定位置的元素并将最后一个元素移动至该位置。
             * @param idx The index of the element to be deleted
             */
            fastRemove(idx: number): void;
            /**
             * @en Returns the first index at which a given element can be found in the array.
             * @zh 返回在数组中可以找到一个给定元素的第一个索引。
             * @param val The element
             */
            indexOf(val: T): number;
        }
    }
    export namespace geometry {
        /**
         * 几何工具模块
         * @module geometry
         */
        /**
         * @en
         * The enum type of basic geometry.
         * @zh
         * 形状的类型值。
         */
        export const enums: {
            SHAPE_RAY: number;
            SHAPE_LINE: number;
            SHAPE_SPHERE: number;
            SHAPE_AABB: number;
            SHAPE_OBB: number;
            SHAPE_PLANE: number;
            SHAPE_TRIANGLE: number;
            SHAPE_FRUSTUM: number;
            SHAPE_FRUSTUM_ACCURATE: number;
            SHAPE_CAPSULE: number;
            SHAPE_SPLINE: number;
        };
        export namespace distance {
            /**
             * @en
             * the distance between a point and a plane
             * @zh
             * 计算点和平面之间的距离。
             * @param {Vec3} point @en Target point @zh 目标点。
             * @param {Plane} plane @en Target plane @zh 目标平面。
             * @return @en The distance in between @zh 距离。
             */
            export function point_plane(point: math.Vec3, plane_: Plane): number;
            /**
             * @en
             * the closest point on plane to a given point
             * @zh
             * 计算平面上最接近给定点的点。
             * @param out @en The closest point, as a result @zh 最近点。
             * @param point @en The given point @zh 给定点。
             * @param plane @en Target plane @zh 平面。
             * @return @en The closest point, same as out @zh 最近点。
             */
            export function pt_point_plane(out: math.Vec3, point: math.Vec3, plane_: Plane): math.Vec3;
            /**
             * @en
             * the closest point on aabb to a given point
             * @zh
             * 计算 aabb 上最接近给定点的点。
             * @param {Vec3} out @en The closest point, as a result @zh 最近点。
             * @param {Vec3} point @en The given point @zh 给定点。
             * @param {AABB} aabb @en Target aabb to calculate @zh 轴对齐包围盒。
             * @return {Vec3} @en The closest point, same as out @zh 最近点。
             */
            export function pt_point_aabb(out: math.Vec3, point: math.Vec3, aabb_: AABB): math.Vec3;
            /**
             * @en
             * the closest point on obb to a given point
             * @zh
             * 计算 obb 上最接近给定点的点。
             * @param {Vec3} out @en The closest point, as a result @zh 最近点。
             * @param {Vec3} point @en The given point @zh 给定点。
             * @param {OBB} obb @en Target obb to calculate @zh 方向包围盒。
             * @return {Vec3} @en The closest point, same as out @zh 最近点。
             */
            export function pt_point_obb(out: math.Vec3, point: math.Vec3, obb_: OBB): math.Vec3;
            /**
             * @en
             * Calculate the nearest point on the line, which is from A to B, to the given point
             * @zh
             * 计算给定点距离线段上最近的一点。线段从A到B。
             * @param out @en The closest point, as a result @zh 最近点
             * @param point @en The given point @zh 给定点
             * @param linePointA @en Point A on the line @zh 线上的某点 A
             * @param linePointB @en Point B on the line @zh 线上的某点 B
             */
            export function pt_point_line(out: math.Vec3, point: math.Vec3, linePointA: math.Vec3, linePointB: math.Vec3): void;
        }
        /**
         * @en
         * Algorithm of intersect detect for basic geometry.
         * @zh
         * 基础几何的相交性检测算法。
         */
        export const intersect: {
            raySphere: (ray: Ray, sphere: Sphere) => number;
            rayAABB: (ray: Ray, aabb: AABB) => number;
            rayOBB: (ray: Ray, obb: OBB) => number;
            rayPlane: (ray: Ray, plane: Plane) => number;
            rayTriangle: (ray: Ray, triangle: Triangle, doubleSided?: boolean) => number;
            rayCapsule: (ray: Ray, capsule: Capsule) => number;
            raySubMesh: (ray: Ray, submesh: RenderingSubMesh, options?: IRaySubMeshOptions) => number;
            rayMesh: (ray: Ray, mesh: Mesh, options?: IRayMeshOptions) => number;
            rayModel: (r: Ray, model: renderer.scene.Model, options?: IRayModelOptions) => number;
            lineSphere: typeof __private._cocos_core_geometry_intersect__lineSphere;
            lineAABB: typeof __private._cocos_core_geometry_intersect__lineAABB;
            lineOBB: typeof __private._cocos_core_geometry_intersect__lineOBB;
            linePlane: (line: Line, plane: Plane) => number;
            lineTriangle: (line: Line, triangle: Triangle, outPt?: math.Vec3) => number;
            sphereWithSphere: (sphere0: Sphere, sphere1: Sphere) => boolean;
            sphereAABB: (sphere: Sphere, aabb: AABB) => boolean;
            sphereOBB: (sphere: Sphere, obb: OBB) => boolean;
            spherePlane: (sphere: Sphere, plane: Plane) => number;
            sphereFrustum: (sphere: Sphere, frustum: Frustum) => number;
            sphereFrustumAccurate: (sphere: Sphere, frustum: Frustum) => number;
            sphereCapsule: (sphere: Sphere, capsule: Capsule) => boolean;
            aabbWithAABB: (aabb1: AABB, aabb2: AABB) => boolean;
            aabbWithOBB: (aabb: AABB, obb: OBB) => number;
            aabbPlane: (aabb: AABB, plane: Plane) => number;
            aabbFrustum: (aabb: AABB, frustum: Readonly<Frustum>) => number;
            aabbFrustumAccurate: (aabb: AABB, frustum: Frustum) => number;
            obbWithOBB: (obb1: OBB, obb2: OBB) => number;
            obbPlane: (obb: OBB, plane: Plane) => number;
            obbFrustum: (obb: OBB, frustum: Frustum) => number;
            obbFrustumAccurate: (obb: OBB, frustum: Frustum) => number;
            obbPoint: (obb: OBB, point: math.Vec3) => boolean;
            obbCapsule: (obb: OBB, capsule: Capsule) => boolean | 0 | 1;
            aabbFrustumCompletelyInside: (aabb: AABB, frustum: Readonly<Frustum>) => number;
            capsuleWithCapsule: (capsuleA: Capsule, capsuleB: Capsule) => boolean;
            /**
             * @en Check intersection between two geometries, it accept all basic geometry types in [[geometry]] module.
             * @zh 两个几何体的相交性检测，可填入 [[geometry]] 模块中的基础几何形状。
             * @param g1 @en The first geometry. @zh 第一个几何体。
             * @param g2 @en The second geometry. @zh 第二个几何体。
             * @param outPt @en A 3d point to store the intersection point result, only part of the geometries support this.
             *              @zh 可选，用于保存相交点的输出对象。（注：仅部分形状的检测带有这个返回值）
             */
            resolve(g1: any, g2: any, outPt?: null): number;
        };
        /**
         * @en
         * Basic Geometry: Line.
         * @zh
         * 基础几何 line。
         */
        export class Line {
            /**
             * @en
             * create a new line
             * @zh
             * 创建一个新的 line。
             * @param sx @en Start position x @zh 起点的 x 坐标。
             * @param sy @en Start position y @zh 起点的 y 坐标。
             * @param sz @en Start position z @zh 起点的 z 坐标。
             * @param ex @en End position x @zh 终点的 x 坐标。
             * @param ey @en End position y @zh 终点的 y 坐标。
             * @param ez @en End position z @zh 终点的 z 坐标。
             * @return
             */
            static create(sx: number, sy: number, sz: number, ex: number, ey: number, ez: number): Line;
            /**
             * @en
             * Creates a new Line initialized with values from an existing Line
             * @zh
             * 克隆一个新的 line。
             * @param a @en The line to clone from @zh 克隆的来源 Line 对象。
             * @return @en The new line cloned @zh 克隆出的新 Line 对象
             */
            static clone(a: Line): Line;
            /**
             * @en
             * Copy the values from one Line to another
             * @zh
             * 复制一个线的值到另一个。
             * @param out @en The output line to store the copied data @zh 用来存储拷贝数据的 Line 对象
             * @param a @en The line to copy from @zh 从这个 Line 对象拷贝信息。
             * @return @en The out object @zh 会直接返回传入的 out 对象
             */
            static copy(out: Line, a: Line): Line;
            /**
             * @en
             * create a line from two points
             * @zh
             * 用两个点创建一个线。
             * @param out @en The output line @zh 接受新数据的 Line 对象
             * @param start @en The start point @zh 起点
             * @param end @en The end point @zh 终点
             * @return @en The out object @zh 会直接返回传入的 out 对象
             */
            static fromPoints(out: Line, start: math.Vec3, end: math.Vec3): Line;
            /**
             * @en
             * Set the components of a Vec3 to the given values
             * @zh
             * 将给定线的属性设置为给定值。
             * @param out @en The output line to set properties to @zh 接受新数据的 Line 对象
             * @param sx @en Start position x @zh 起点到 x 坐标
             * @param sy @en Start position y @zh 起点到 y 坐标
             * @param sz @en Start position z @zh 起点到 z 坐标
             * @param ex @en End position x @zh 终点到 x 坐标
             * @param ey @en End position y @zh 终点到 y 坐标
             * @param ez @en End position z @zh 终点到 z 坐标
             * @return @en The out object @zh 会直接返回传入的 out 对象
             */
            static set(out: Line, sx: number, sy: number, sz: number, ex: number, ey: number, ez: number): Line;
            /**
             * @en Calculate the length of the given line
             * @zh 计算线的长度。
             * @param a @en The line @zh 用于计算长度的线段
             * @return @en The length of the given line @zh 线段的长度
             */
            static len(a: Line): number;
            /**
             * @en Start point
             * @zh 起点。
             */
            s: math.Vec3;
            /**
             * @en End point
             * @zh 终点。
             */
            e: math.Vec3;
            /**
             * @en Gets the type of the shape.
             * @zh 获取形状的类型。
             */
            get type(): number;
            /**
             * @en Constructor of the line
             * @zh 构造一条线。
             * @param sx @en Start position x @zh 起点的 x 坐标
             * @param sy @en Start position y @zh 起点的 y 坐标
             * @param sz @en Start position z @zh 起点的 z 坐标
             * @param ex @en End position x @zh 终点的 x 坐标
             * @param ey @en End position y @zh 终点的 y 坐标
             * @param ez @en End position z @zh 终点的 z 坐标
             */
            constructor(sx?: number, sy?: number, sz?: number, ex?: number, ey?: number, ez?: number);
            /**
             * @en Calculate the length of the line
             * @zh 计算线的长度。
             * @return @en The length @zh 线段的长度
             */
            length(): number;
        }
        /**
         * @en
         * Basic Geometry: Plane.
         * @zh
         * 基础几何 Plane。
         */
        export class Plane {
            /**
             * @en
             * create a new plane
             * @zh
             * 创建一个新的 plane。
             * @param nx @en The x component of normal vector. @zh 法向分量的 x 部分。
             * @param ny @en The y component of normal vector. @zh 法向分量的 y 部分。
             * @param nz @en The z component of normal vector. @zh 法向分量的 z 部分。
             * @param d  @en The distance between normal vector and the origin. @zh 与原点的距离。
             * @return
             */
            static create(nx: number, ny: number, nz: number, d: number): Plane;
            /**
             * @en
             * clone a new plane
             * @zh
             * 克隆一个新的 plane。
             * @param p @en The Plane object to be cloned from. @zh 克隆的来源。
             * @return @en Cloned objects @zh 克隆出的对象。
             */
            static clone(p: Plane): Plane;
            /**
             * @en
             * copy the values from one plane to another
             * @zh
             * 复制一个平面的值到另一个。
             * @param out @en The object to be operated on. @zh 接受操作的对象。
             * @param p @en The source of replication. @zh 复制的来源。
             * @return @en The object to be operated on. @zh 接受操作的对象。
             */
            static copy(out: Plane, p: Plane): Plane;
            /**
             * @en
             * create a plane from three points
             * @zh
             * 用三个点创建一个平面。
             * @param out @en The object to be operated on. @zh 接受操作的对象。
             * @param a @en Point a. @zh 点 a。
             * @param b @en Point b. @zh 点 b。
             * @param c @en Point c. @zh 点 c。
             * @return out @en The object to be operated on. @zh 接受操作的对象。
             */
            static fromPoints(out: Plane, a: math.Vec3, b: math.Vec3, c: math.Vec3): Plane;
            /**
             * @en
             * Set the components of a plane to the given values
             * @zh
             * 将给定平面的属性设置为给定值。
             * @param out @en The object to be operated on. @zh 接受操作的对象。
             * @param nx @en The x component of normal vector. @zh 法向分量的 x 部分。
             * @param ny @en The y component of normal vector. @zh 法向分量的 y 部分。
             * @param nz @en The z component of normal vector. @zh 法向分量的 z 部分。
             * @param d  @en The distance between normal vector and the origin. @zh 与原点的距离。
             * @return out @en The object to be operated on. @zh 接受操作的对象。
             */
            static set(out: Plane, nx: number, ny: number, nz: number, d: number): Plane;
            /**
             * @en
             * create plane from normal and point
             * @zh
             * 用一条法线和一个点创建平面。
             * @param out @en The object to be operated on. @zh 接受操作的对象。
             * @param normal @en Normal of the plane. @zh 平面的法线。
             * @param point @en A point in the plane. @zh 平面上的一点。
             * @return out @en The object to be operated on. @zh 接受操作的对象。
             */
            static fromNormalAndPoint(out: Plane, normal: math.Vec3, point: math.Vec3): Plane;
            /**
             * @en
             * normalize a plane
             * @zh
             * 归一化一个平面。
             * @param out @en The object to be operated on. @zh 接受操作的对象。
             * @param a @en Source data for the operation. @zh 操作的源数据。
             * @return out @en The object to be operated on. @zh 接受操作的对象。
             */
            static normalize(out: Plane, a: Plane): Plane;
            /**
             * @en
             * The normal of the plane.
             * @zh
             * 法线向量。
             */
            n: math.Vec3;
            /**
             * @en
             * The distance from the origin to the plane.
             * @zh
             * 原点到平面的距离。
             */
            d: number;
            /**
             * @en
             * Gets the type of the shape.
             * @zh
             * 获取形状的类型。
             */
            get type(): number;
            set x(val: number);
            get x(): number;
            set y(val: number);
            get y(): number;
            set z(val: number);
            get z(): number;
            set w(val: number);
            get w(): number;
            protected readonly _type: number;
            /**
             * @en
             * Construct a plane.
             * @zh
             * 构造一个平面。
             * @param nx @en The x component of normal vector. @zh 法向分量的 x 部分。
             * @param ny @en The y component of normal vector. @zh 法向分量的 y 部分。
             * @param nz @en The z component of normal vector. @zh 法向分量的 z 部分。
             * @param d @en The distance between normal vector and the origin. @zh 与原点的距离。
             */
            constructor(nx?: number, ny?: number, nz?: number, d?: number);
            /**
             * @en
             * transform this plane.
             * @zh
             * 变换一个平面。
             * @param mat
             */
            transform(mat: math.Mat4): void;
        }
        /**
         * @en
         * Basic Geometry: ray.
         * @zh
         * 基础几何 射线。
         */
        export class Ray {
            /**
             * @en
             * create a new ray
             * @zh
             * 创建一条射线。
             * @param {number} ox @en x component of start point @zh 起点的 x 部分。
             * @param {number} oy @en y component of start point @zh 起点的 y 部分。
             * @param {number} oz @en z component of start point @zh 起点的 z 部分。
             * @param {number} dx @en Point in the x direction @zh 方向的 x 部分。
             * @param {number} dy @en Point in the y direction @zh 方向的 y 部分。
             * @param {number} dz @en Point in the z direction @zh 方向的 z 部分。
             * @return {Ray} @en Ray object @zh 射线。
             */
            static create(ox?: number, oy?: number, oz?: number, dx?: number, dy?: number, dz?: number): Ray;
            /**
             * @en
             * Creates a new ray initialized with values from an existing ray
             * @zh
             * 从一条射线克隆出一条新的射线。
             * @param {Ray} a @en The Ray object to be cloned from @zh 克隆的目标。
             * @return {Ray} @en Clone new ray object @zh 克隆出的新对象。
             */
            static clone(a: Ray): Ray;
            /**
             * @en
             * Copy the values from one ray to another
             * @zh
             * 将从一个 ray 的值复制到另一个 ray。
             * @param {Ray} out @en The ray object to be modified @zh 接受操作的 ray。
             * @param {Ray} a @en The copied ray object @zh 被复制的 ray。
             * @return {Ray} @en Ray object @zh out 接受操作的 ray。
             */
            static copy(out: Ray, a: Ray): Ray;
            /**
             * @en
             * create a ray from two points
             * @zh
             * 用两个点创建一条射线。
             * @param {Ray} out @en The ray object to be modified @zh 接受操作的射线。
             * @param {Vec3} origin @en Starting point of the ray @zh 射线的起点。
             * @param {Vec3} target @en point on the ray @zh 射线上的一点。
             * @return {Ray} @en Ray object @zh out 接受操作的射线。
             */
            static fromPoints(out: Ray, origin: math.Vec3, target: math.Vec3): Ray;
            /**
             * @en
             * Set the components of a ray to the given values
             * @zh
             * 将给定射线的属性设置为给定的值。
             * @param {Ray} out @en The ray object to be modified @zh 接受操作的射线。
             * @param {number} ox @en x component of start point @zh 起点的 x 部分。
             * @param {number} oy @en y component of start point @zh 起点的 y 部分。
             * @param {number} oz @en z component of start point @zh 起点的 z 部分。
             * @param {number} dx @en Point in the x direction @zh 方向的 x 部分。
             * @param {number} dy @en Point in the y direction @zh 方向的 y 部分。
             * @param {number} dz @en Point in the z direction @zh 方向的 z 部分。
             * @return {Ray} @en Ray object @zh out 接受操作的射线。
             */
            static set(out: Ray, ox: number, oy: number, oz: number, dx: number, dy: number, dz: number): Ray;
            /**
             * @en
             * The origin of the ray.
             * @zh
             * 起点。
             */
            o: math.Vec3;
            /**
             * @en
             * The direction of the ray.
             * @zh
             * 方向。
             */
            d: math.Vec3;
            /**
             * @en
             * Gets the type of the shape.
             * @zh
             * 获取形状的类型。
             */
            get type(): number;
            protected readonly _type: number;
            /**
             * @en
             * Construct a ray;
             * @zh
             * 构造一条射线。
             * @param {number} ox @en x component of start point @zh 起点的 x 部分。
             * @param {number} oy @en y component of start point @zh 起点的 y 部分。
             * @param {number} oz @en z component of start point @zh 起点的 z 部分。
             * @param {number} dx @en Point in the x direction @zh 方向的 x 部分。
             * @param {number} dy @en Point in the y direction @zh 方向的 y 部分。
             * @param {number} dz @en Point in the z direction @zh 方向的 z 部分。
             */
            constructor(ox?: number, oy?: number, oz?: number, dx?: number, dy?: number, dz?: number);
            /**
             * @en
             * Compute a point with the distance between the origin.
             * @zh
             * 根据给定距离计算出射线上的一点。
             * @param out @en Another point on the ray @zh 射线上的另一点。
             * @param distance @en Given distance @zh 给定距离。
             */
            computeHit(out: math.IVec3Like, distance: number): void;
        }
        /**
         * @en
         * Basic Geometry: Triangle.
         * @zh
         * 基础几何 三角形。
         */
        export class Triangle {
            /**
             * @en
             * create a new triangle
             * @zh
             * 创建一个新的 triangle。
             * @param {number} ax @en x component of point a @zh a 点的 x 部分。
             * @param {number} ay @en y component of point a @zh a 点的 y 部分。
             * @param {number} az @en z component of point a @zh a 点的 z 部分。
             * @param {number} bx @en x component of point b @zh b 点的 x 部分。
             * @param {number} by @en y component of point b @zh b 点的 y 部分。
             * @param {number} bz @en z component of point b @zh b 点的 z 部分。
             * @param {number} cx @en x component of point c @zh c 点的 x 部分。
             * @param {number} cy @en y component of point c @zh c 点的 y 部分。
             * @param {number} cz @en z component of point c @zh c 点的 z 部分。
             * @return {Triangle} @en A new triangle. @zh 一个新的 triangle。
             */
            static create(ax?: number, ay?: number, az?: number, bx?: number, by?: number, bz?: number, cx?: number, cy?: number, cz?: number): Triangle;
            /**
             * @en
             * clone a new triangle
             * @zh
             * 克隆一个新的 triangle。
             * @param {Triangle} @en Triangle object to be cloned from. @zh t 克隆的目标。
             * @return {Triangle} @en A new cloned Triangle object. @zh 克隆出的新对象。
             */
            static clone(t: Triangle): Triangle;
            /**
             * @en
             * copy the values from one triangle to another
             * @zh
             * 将一个 triangle 的值复制到另一个 triangle。
             * @param {Triangle} out @en Target Triangle object to be copied to. @zh 接受操作的 triangle。
             * @param {Triangle} t @en A Triangle object to be copied from. @zh 被复制的 triangle。
             * @return {Triangle}  @en The same as out. @zh out 接受操作的 triangle。
             */
            static copy(out: Triangle, t: Triangle): Triangle;
            /**
             * @en
             * Create a triangle from three points
             * @zh
             * 用三个点创建一个 triangle。
             * @param {Triangle} out @en The Triangle object to be modified. @zh 接受操作的 triangle。
             * @param {Vec3} a @en The point value to set out.a. @zh a 点。
             * @param {Vec3} b @en The point value to set out.b. @zh b 点。
             * @param {Vec3} c @en The point value to set out.c. @zh c 点。
             * @return {Triangle} @en The same as out. @zh 接受操作的 triangle。
             */
            static fromPoints(out: Triangle, a: math.Vec3, b: math.Vec3, c: math.Vec3): Triangle;
            /**
             * @en
             * Set the components of a triangle to the given values
             * @zh
             * 将给定三角形的属性设置为给定值。
             * @param {Triangle} out @en The Triangle object to be set. @zh 被修改的三角形。
             * @param {number} ax @en The value to set out.a.x. @zh a 点的 x 部分。
             * @param {number} ay @en The value to set out.a.y. @zh a 点的 y 部分。
             * @param {number} az @en The value to set out.a.z. @zh a 点的 z 部分。
             * @param {number} bx @en The value to set out.b.x. @zh b 点的 x 部分。
             * @param {number} by @en The value to set out.b.y. @zh b 点的 y 部分。
             * @param {number} bz @en The value to set out.b.z. @zh b 点的 z 部分。
             * @param {number} cx @en The value to set out.c.x. @zh c 点的 x 部分。
             * @param {number} cy @en The value to set out.c.y. @zh c 点的 y 部分。
             * @param {number} cz @en The value to set out.c.z. @zh c 点的 z 部分。
             * @return {Triangle} @en The same as out. @zh 传入的 out 对象。
             * @function
             */
            static set(out: Triangle, ax: number, ay: number, az: number, bx: number, by: number, bz: number, cx: number, cy: number, cz: number): Triangle;
            /**
             * @en
             * Point a.
             * @zh
             * 点 a。
             */
            a: math.Vec3;
            /**
             * @en
             * Point b.
             * @zh
             * 点 b。
             */
            b: math.Vec3;
            /**
             * @en
             * Point c.
             * @zh
             * 点 c。
             */
            c: math.Vec3;
            /**
             * @en
             * Gets the type of the shape.
             * @zh
             * 获取形状的类型。
             */
            get type(): number;
            protected readonly _type: number;
            /**
             * @en
             * Construct a triangle.
             * @zh
             * 构造一个三角形。
             * @param {number} ax @en x component of point a. @zh a 点的 x 部分。
             * @param {number} ay @en y component of point a. @zh a 点的 y 部分。
             * @param {number} az @en z component of point a. @zh a 点的 z 部分。
             * @param {number} bx @en x component of point b. @zh b 点的 x 部分。
             * @param {number} by @en y component of point b. @zh b 点的 y 部分。
             * @param {number} bz @en z component of point b. @zh b 点的 z 部分。
             * @param {number} cx @en x component of point c. @zh c 点的 x 部分。
             * @param {number} cy @en y component of point c. @zh c 点的 y 部分。
             * @param {number} cz @en z component of point c. @zh c 点的 z 部分。
             */
            constructor(ax?: number, ay?: number, az?: number, bx?: number, by?: number, bz?: number, cx?: number, cy?: number, cz?: number);
        }
        /**
         * @en
         * Basic Geometry: Sphere.
         * @zh
         * 基础几何 轴对齐球。
         */
        export class Sphere {
            /**
             * @en
             * create a new sphere
             * @zh
             * 创建一个新的 sphere 实例。
             * @param cx @en X-Coordinate of center point relative to the origin.  @zh 中心点的相对于原点的 X 坐标。
             * @param cy @en Y-Coordinate of center point relative to the origin.  @zh 中心点的相对于原点的 Y 坐标。
             * @param cz @en Z-Coordinate of center point relative to the origin.  @zh 中心点的相对于原点的 Z 坐标。
             * @param r @en Radius of the sphere. @zh 球体的半径
             * @return @en return a new sphere. @zh 返回一个 sphere。
             */
            static create(cx: number, cy: number, cz: number, r: number): Sphere;
            /**
             * @en
             * clone a new sphere
             * @zh
             * 克隆一个新的 sphere 实例。
             * @param p @en The sphere object to clone from. @zh 克隆的目标。
             * @return @en The sphere object to clone to. @zh 克隆出的示例。
             */
            static clone(p: Sphere): Sphere;
            /**
             * @en
             * copy the values from one sphere to another
             * @zh
             * 将从一个 sphere 的值复制到另一个 sphere。
             * @param out @en The sphere object to copy to. @zh 接受操作的 sphere。
             * @param a @en The sphere object to copy from. @zh 被复制的 sphere。
             * @return @en The sphere object to copy to. @zh 接受操作的 sphere。
             */
            static copy(out: Sphere, p: Sphere): Sphere;
            /**
             * @en
             * create a new bounding sphere from two corner points
             * @zh
             * 从两个点创建一个新的 sphere。
             * @param out - @en Sphere created from points. @zh 接受操作的 sphere。
             * @param minPos - @en Lower point of the sphere. @zh sphere 的较小点。
             * @param maxPos - @en Upper point of the sphere. @zh sphere 的较大点。
             * @returns @en The output sphere object to save the created sphere data. @zh 接受操作的 sphere。
             */
            static fromPoints(out: Sphere, minPos: math.Vec3, maxPos: math.Vec3): Sphere;
            /**
             * @en
             * Set the components of a sphere to the given values
             * @zh
             * 将球体的属性设置为给定的值。
             * @param out @en The sphere to set properties to. @zh 接受操作的 sphere。
             * @param cx @en X-Coordinate of center point relative to the origin.  @zh 中心点的相对于原点的 X 坐标。
             * @param cy @en Y-Coordinate of center point relative to the origin.  @zh 中心点的相对于原点的 Y 坐标。
             * @param cz @en Z-Coordinate of center point relative to the origin.  @zh 中心点的相对于原点的 Z 坐标。
             * @param r @en Radius of the sphere. @zh 半径。
             * @return @en Sphere which the properties will be set to. @zh 接受操作的 sphere。
             * @function
             */
            static set(out: Sphere, cx: number, cy: number, cz: number, r: number): Sphere;
            /**
             * @en
             * The center of this sphere.
             * @zh
             * 本地坐标的中心点。
             */
            protected _center: math.Vec3;
            get center(): math.Vec3;
            set center(val: math.Vec3);
            /**
             * @en
             * The radius of this sphere.
             * @zh
             * 半径。
             */
            get radius(): number;
            set radius(val: number);
            /**
             * @en
             * Gets the type of the shape.
             * @zh
             * 获取形状的类型。
             */
            get type(): number;
            protected readonly _type: number;
            /**
             * @en
             * Construct a sphere.
             * @zh
             * 构造一个球。
             * @param cx @en The X-Coordinate of the sphere. @zh 该球的世界坐标的 X 坐标。
             * @param cy @en The Y-Coordinate of the sphere. @zh 该球的世界坐标的 Y 坐标。
             * @param cz @en The Z-Coordinate of the sphere. @zh 该球的世界坐标的 Z 坐标。
             * @param r @en The radius. @zh 半径。
             */
            constructor(cx?: number, cy?: number, cz?: number, r?: number);
            destroy(): void;
            /**
             * @en
             * Get a clone.
             * @zh
             * 获得克隆。
             */
            clone(): Sphere;
            /**
             * @en
             * Copy a sphere.
             * @zh
             * 拷贝对象。
             * @param a @en The sphere to copy from. @zh 拷贝的目标。
             */
            copy(a: Sphere): Sphere;
            /**
             * @en
             * Get the bounding points of this shape
             * @zh
             * 获取此形状的边界点。
             * @param minPos @en The point with maximum coordinates of the sphere. @zh 最小点。
             * @param maxPos @en The point with minimum coordinates of the sphere. @zh 最大点。
             */
            getBoundary(minPos: math.Vec3, maxPos: math.Vec3): void;
            /**
             * @en
             * Transform this shape
             * @zh
             * 将 out 根据这个 sphere 的数据进行变换。
             * @param m @en The transform matrix. @zh 变换的矩阵。
             * @param pos @en The position. @zh 变换的位置部分。
             * @param rot @en The rotation. @zh 变换的旋转部分。
             * @param scale @en The scale. @zh 变换的缩放部分。
             * @param out @en The sphere which the transform will be applied to. @zh 变换的目标。
             */
            transform(m: math.Mat4, pos: math.Vec3, rot: math.Quat, scale: math.Vec3, out: Sphere): void;
            /**
             * @en
             * Translate and rotate this sphere.
             * @zh
             * 将 out 根据这个 sphere 的数据进行变换。
             * @param m @en The transform matrix. @zh 变换的矩阵。
             * @param rot @en The rotation. @zh 变换的旋转部分。
             * @param out @en The sphere which the transform will be applied to. @zh 变换的目标。
             */
            translateAndRotate(m: math.Mat4, rot: math.Quat, out: Sphere): void;
            /**
             * @en
             * Scaling this sphere.
             * @zh
             * 将 out 根据这个 sphere 的数据进行缩放。
             * @param scale @en The scale. @zh 缩放值。
             * @param out @en The sphere which the scale will be applied to. @zh 缩放的目标。
             */
            setScale(scale: math.Vec3, out: Sphere): void;
            /**
             * @en The point to be merged.
             * @zh 球跟点合并
             * @param point @en The point to be merged. @zh 点
             */
            mergePoint(point: math.Vec3): void;
            /**
             * @en The sphere and points to be merged.
             * @zh 球跟一系列点合并
             * @param points @en The point to be merged. @zh 一系列点
             */
            mergePoints(points: math.Vec3[]): void;
            /**
             * @en The axis-aligned bounding box to be merged.
             * @zh 球跟立方体合并
             * @param a @en Cube. @zh 立方体
             */
            mergeAABB(a: AABB): void;
        }
        /**
         * @en
         * Basic Geometry: Axis-aligned bounding box, using center and half extents structure.
         * @zh
         * 基础几何  轴对齐包围盒，使用中心点和半长宽高的结构。
         */
        export class AABB {
            /**
             * @en
             * create a new AABB
             * @zh
             * 创建一个新的 AABB 实例。
             * @param px @zh AABB 的原点的 X 坐标。@en The x coordinate of the origin of the AABB.
             * @param py @zh AABB 的原点的 Y 坐标。@en The y coordinate of the origin of the AABB.
             * @param pz @zh AABB 的原点的 Z 坐标。 @en The z coordinate of the origin of the AABB.
             * @param hw @zh AABB 宽度的一半。 @en Half the width of the AABB.
             * @param hh @zh AABB 高度的一半。@en Half the height of the AABB.
             * @param hl @zh AABB 长度的一半。@en Half the length of the AABB.
             * @returns @zh 返回新创建的 AABB 实例。 @en A new instance of AABB.
             */
            static create(px?: number, py?: number, pz?: number, hw?: number, hh?: number, hl?: number): AABB;
            /**
             * @en
             * clone a new AABB
             * @zh
             * 克隆一个 AABB。
             * @param a @zh 克隆的目标。 @en Target object.
             * @returns @zh 克隆出的 AABB。@en The new AABB.
             */
            static clone(a: AABB | Readonly<AABB>): AABB;
            /**
             * @en
             * copy the values from one AABB to another
             * @zh
             * 将从一个 AABB 的值复制到另一个 AABB。
             * @param out @zh 接受操作的 AABB。 @en The output AABB, copy destination.
             * @param a @zh 被复制的 AABB。 @en Source object of copy operation.
             * @returns @zh 接受操作的 AABB。 @en The reference of the first parameter `dst`, the new AABB.
             */
            static copy(out: AABB, a: AABB | Readonly<AABB>): AABB;
            /**
             * @en
             * Construct a new AABB from two corner points
             * @zh
             * 从两个点创建一个新的 AABB。
             * @param out @zh 接受操作的 AABB。 @en The output AABB
             * @param minPos @zh AABB 的最小点。 @en Minimum point of the axis-aligned 3d bounding box.
             * @param maxPos @zh AABB 的最大点。 @en Maximum point of the axis-aligned 3d bounding box.
             * @returns @zh out 接受操作的 AABB。 @en The new AABB
             */
            static fromPoints(out: AABB, minPos: math.IVec3, maxPos: math.IVec3): AABB;
            /**
             * @en
             * Set the components of a AABB to the given values
             * @zh
             * 将 AABB 的属性设置为给定的值。
             * @param @zh out 接受操作的 AABB。 @en The output AABB to set.
             * @param px @zh - AABB 的原点的 X 坐标。 @en The x coordinate of the origin of the AABB.
             * @param py @zh - AABB 的原点的 Y 坐标。 @en The y coordinate of the origin of the AABB.
             * @param pz @zh - AABB 的原点的 Z 坐标。 @en The z coordinate of the origin of the AABB.
             * @param hw @zh - AABB 宽度的一半。 @en Half the width of the AABB.
             * @param hh @zh - AABB 高度的一半。 @en Half the height of the AABB.
             * @param hl @zh - AABB 长度度的一半。 @en Half the length of the AABB.
             * @returns @zh out 接受操作的 AABB。 @en The reference fo the first parameter `out`.
             */
            static set(out: AABB, px: number, py: number, pz: number, hw: number, hh: number, hl: number): AABB;
            /**
             * @en
             * Merge two AABB into one.
             * @zh
             * 合并两个 AABB 到 out。
             * @param out @zh 接受操作的 AABB。 @en The output AABB to storge merge result.
             * @param a @zh 输入的 AABB。 @en The first AABB to be merged.
             * @param b @zh 输入的 AABB。 @en The second AABB to be merged.
             * @returns @zh out 接受操作的 AABB。 @en The reference of the first parameter `out`.
             */
            static merge(out: AABB, a: AABB | Readonly<AABB>, b: AABB | Readonly<AABB>): AABB;
            /**
             * @en
             * Convert AABB to sphere.
             * @zh
             * 包围盒转包围球
             * @param out @zh 接受操作的 sphere。 @en The output sphere.
             * @param a @zh 输入的 AABB。 @en The input AABB.
             * @returns @zh out 接受的 Sphere @en The reference of the first parameter `out`.
             */
            static toBoundingSphere(out: Sphere, a: AABB | Readonly<AABB>): Sphere;
            /**
             * @en
             * Transform this AABB.
             * @zh
             * 变换一个 AABB 到 out 中。
             * @param out @zh 接受操作的 AABB。 @en The output AABB.
             * @param a @zh 输入的源 AABB。 @en The input AABB.
             * @param matrix @zh 矩阵。 @en The transformation matrix.
             * @returns @zh {AABB} out 接受操作的 AABB。 @en The reference of the first parameter `out`.
             */
            static transform(out: AABB, a: AABB | Readonly<AABB>, matrix: math.Mat4 | Readonly<math.Mat4>): AABB;
            /**
             * @en
             * The origin point of the AABB
             * @zh
             * 本地坐标的中心点。
             */
            center: math.Vec3;
            /**
             * @en
             * Half the size of the AABB
             * @zh
             * 长宽高的一半。
             */
            halfExtents: math.Vec3;
            /**
             * @en
             * Gets the type of the shape.
             * @zh
             * 获取形状的类型。
             */
            get type(): number;
            protected readonly _type: number;
            constructor(px?: number, py?: number, pz?: number, hw?: number, hh?: number, hl?: number);
            /**
             * @en
             * Get the bounding points of this shape
             * @zh
             * 获取 AABB 的最小点和最大点。
             * @param minPos @zh 最小点。 @en Minimum position of the axis-aligned 3d bounding box.
             * @param maxPos @zh 最大点。 @en Maximum position of the axis-aligned 3d bounding box.
             */
            getBoundary(minPos: math.IVec3Like, maxPos: math.IVec3Like): void;
            /**
             * @en
             * Transform this shape
             * @zh
             * 将 out 根据这个 AABB 的数据进行变换。
             * @param m @zh 变换的矩阵。 @en The transform matrix.
             * @param pos @zh 变换的位置部分。 @en 3d-vector translation.
             * @param rot @zh 变换的旋转部分。 @en Quaternion rotation .
             * @param scale @zh 变换的缩放部分。 @en 3d-vector scale.
             * @param out @zh 变换的目标。 @en The output AABB.
             */
            transform(m: math.Mat4, pos: math.Vec3 | null, rot: math.Quat | null, scale: math.Vec3 | null, out: AABB): void;
            /**
             * @en
             * Clones the AABB
             * @zh
             * 获得克隆。
             * @returns @zh {AABB} @en A copy of the object.
             */
            clone(): AABB;
            /**
             * @en
             * Copy the input to the receiver object.
             * @zh
             * 拷贝对象。
             * @param a @zh 拷贝的目标。 @en Copy target
             * @returns @zh This object @en The reference of this.
             */
            copy(a: AABB | Readonly<AABB>): AABB;
            /**
             * @en AABB and point merge.
             * @zh AABB包围盒合并一个顶点。
             * @param point @zh - 某一个位置的顶点。 @en A point in 3d space.
             */
            mergePoint(point: math.IVec3): void;
            /**
             * @en AABB and points merge.
             * @zh AABB包围盒合并一系列顶点。
             * @param points @zh - 某一个位置的顶点。 @en A list of points in 3d space.
             */
            mergePoints(points: math.IVec3[]): void;
            /**
             * @en AABB and frustum merge.
             * @zh Frustum 合并到 AABB。
             * @param frustum @zh 输入的 Frustum。 @en The frustum object.
             */
            mergeFrustum(frustum: Frustum | Readonly<Frustum>): void;
        }
        /**
         * @en
         * Basic Geometry: directional bounding box.
         * @zh
         * 基础几何  方向包围盒。
         */
        export class OBB {
            /**
             * @en
             * create a new obb
             * @zh
             * 创建一个新的 obb 实例。
             * @param cx @zh 形状的相对于原点的 X 坐标。 @en The x coordinate of origin.
             * @param cy @zh 形状的相对于原点的 Y 坐标。 @en The y coordinate of origin.
             * @param cz @zh 形状的相对于原点的 Z 坐标。 @en The z coordinate of origin.
             * @param hw @zh - obb 宽度的一半。 @en Half the width of the OBB.
             * @param hh @zh - obb 高度的一半。 @en Half the height of the OBB.
             * @param hl @zh - obb 长度的一半。 @en Half the length of the OBB.
             * @param ox_1 @zh 方向矩阵参数。 @en The x component of the one axis of the OBB.
             * @param ox_2 @zh 方向矩阵参数。 @en The x component of the second axis of the OBB.
             * @param ox_3 @zh 方向矩阵参数。 @en The x component of the third axis of the OBB.
             * @param oy_1 @zh 方向矩阵参数。 @en The y component of the one axis of the OBB.
             * @param oy_2 @zh 方向矩阵参数。 @en The y component of the second axis of the OBB.
             * @param oy_3 @zh 方向矩阵参数。 @en The y component of the third axis of the OBB.
             * @param oz_1 @zh 方向矩阵参数。 @en The z component of the one axis of the OBB.
             * @param oz_2 @zh 方向矩阵参数。 @en The z component of the second axis of the OBB.
             * @param oz_3 @zh 方向矩阵参数。 @en The z component of the third axis of the OBB.
             * @return @zh 返回一个 obb。 @en A new OBB.
             */
            static create(cx: number, cy: number, cz: number, hw: number, hh: number, hl: number, ox_1: number, ox_2: number, ox_3: number, oy_1: number, oy_2: number, oy_3: number, oz_1: number, oz_2: number, oz_3: number): OBB;
            /**
             * @en
             * clone a new obb
             * @zh
             * 克隆一个 obb。
             * @param a @zh 克隆的目标。 @en The input OBB.
             * @returns @zh The new OBB.  @en 克隆出的新对象。
             */
            static clone(a: OBB): OBB;
            /**
             * @en
             * copy the values from one obb to another
             * @zh
             * 将从一个 obb 的值复制到另一个 obb。
             * @param  out @zh 接受操作的 obb。 @en The output OBB.
             * @param  a @zh 被复制的 obb。 @en The input OBB.
             * @returns  @zh out 接受操作的 obb。 @en The reference of the first parameter `out`.
             */
            static copy(out: OBB, a: OBB): OBB;
            /**
             * @en
             * create a new obb from two corner points
             * @zh
             * 用两个点创建一个新的 obb。
             * @param out @zh - 接受操作的 obb。 @en The output OBB.
             * @param minPos @zh - obb 的最小点。 @en The minimum position of the AABB.
             * @param maxPos @zh - obb 的最大点。 @en The maximum position of the AABB.
             * @returns @zh {OBB} out 接受操作的 obb。 @en The reference of the first parameter `out`.
             */
            static fromPoints(out: OBB, minPos: math.Vec3, maxPos: math.Vec3): OBB;
            /**
             * @en
             * Set the components of a obb to the given values
             * @zh
             * 将给定 obb 的属性设置为给定的值。
             * @param out @zh 目标 OBB @en The output OBB.
             * @param cx @zh 形状的相对于原点的 X 坐标。 @en The x coordinate of origin.
             * @param cy @zh 形状的相对于原点的 Y 坐标。 @en The y coordinate of origin.
             * @param cz @zh 形状的相对于原点的 Z 坐标。 @en The z coordinate of origin.
             * @param hw @zh - obb 宽度的一半。 @en Half the width of the OBB.
             * @param hh @zh - obb 高度的一半。 @en Half the height of the OBB.
             * @param hl @zh - obb 长度的一半。 @en Half the length of the OBB.
             * @param ox_1 @zh 方向矩阵参数。 @en The x component of the one axis of the OBB.
             * @param ox_2 @zh 方向矩阵参数。 @en The x component of the second axis of the OBB.
             * @param ox_3 @zh 方向矩阵参数。 @en The x component of the third axis of the OBB.
             * @param oy_1 @zh 方向矩阵参数。 @en The y component of the one axis of the OBB.
             * @param oy_2 @zh 方向矩阵参数。 @en The y component of the second axis of the OBB.
             * @param oy_3 @zh 方向矩阵参数。 @en The y component of the third axis of the OBB.
             * @param oz_1 @zh 方向矩阵参数。 @en The z component of the one axis of the OBB.
             * @param oz_2 @zh 方向矩阵参数。 @en The z component of the second axis of the OBB.
             * @param oz_3 @zh 方向矩阵参数。 @en The z component of the third axis of the OBB.
             * @returns @zh out 接受操作的 OBB @en The reference of the first parameter `out`.
             */
            static set(out: OBB, cx: number, cy: number, cz: number, hw: number, hh: number, hl: number, ox_1: number, ox_2: number, ox_3: number, oy_1: number, oy_2: number, oy_3: number, oz_1: number, oz_2: number, oz_3: number): OBB;
            /**
             * @en
             * Center point of the OBB.
             * @zh
             * 本地坐标的中心点。
             */
            center: math.Vec3;
            /**
             * @en
             * Half the distance across the OBB in each local axis.
             * @zh
             * 长宽高的一半。
             */
            halfExtents: math.Vec3;
            /**
             * @en
             * Orientation matrix.
             * @zh
             * 方向矩阵。
             */
            orientation: math.Mat3;
            /**
             * @en
             * Gets the type of the shape.
             * @zh
             * 获取形状的类型。
             */
            get type(): number;
            protected readonly _type: number;
            constructor(cx?: number, cy?: number, cz?: number, hw?: number, hh?: number, hl?: number, ox_1?: number, ox_2?: number, ox_3?: number, oy_1?: number, oy_2?: number, oy_3?: number, oz_1?: number, oz_2?: number, oz_3?: number);
            /**
             * @en
             * Get the bounding points of this shape
             * @zh
             * 获取 obb 的最小点和最大点。
             * @param minPos @zh 最小点。 @en The out minimum position of the OBB.
             * @param maxPos @zh 最大点。 @en The out maximum position of the OBB.
             */
            getBoundary(minPos: math.Vec3, maxPos: math.Vec3): void;
            /**
             * @en
             * Transform this shape
             * @zh
             * 将 out 根据这个 obb 的数据进行变换。
             * @param m @zh 变换的矩阵。 @en The transform matrix
             * @param pos @zh 变换的位置部分。 @en 3d-vector translation.
             * @param rot @zh 变换的旋转部分。 @en Quaternion rotation.
             * @param scale @zh 变换的缩放部分。 @en 3d-vector scale.
             * @param out @zh 变换的目标。 @en The output OBB.
             */
            transform(m: math.Mat4, pos: math.Vec3, rot: math.Quat, scale: math.Vec3, out: OBB): void;
            /**
             * @en
             * Transform by matrix and rotation.
             * @zh
             * 将 out 根据这个 obb 的数据进行变换。
             * @param m @zh 变换的矩阵。 @en The transform matrix.
             * @param rot @zh 变换的旋转部分。 @en Quaternion rotation.
             * @param out @zh 变换的目标。 @en The output OBB.
             */
            translateAndRotate(m: math.Mat4, rot: math.Quat, out: OBB): void;
            /**
             * @en
             * Scale OBB by a 3d-vector.
             * @zh
             *  将 out 根据这个 obb 的数据进行缩放。
             * @param scale @zh 缩放值。 @en 3d-vector scale.
             * @param out @zh 缩放的目标。 @en The output OBB.
             */
            setScale(scale: math.Vec3, out: OBB): void;
        }
        /**
         * @en
         * Basic Geometry: capsule.
         * @zh
         * 基础几何，胶囊体。
         */
        export class Capsule {
            /**
             * @en
             * Gets the type of the shape.
             * @zh
             * 获取形状的类型。
             */
            get type(): number;
            protected readonly _type: number;
            /**
             * @en
             * Capsule sphere radius.
             * @zh
             * 胶囊体球部半径。
             */
            radius: number;
            /**
             * @en
             * The distance between the center point of the capsule and the center of the sphere.
             * @zh
             * 胶囊体中心点和球部圆心的距离。
             */
            halfHeight: number;
            /**
             * @en
             * Local orientation of capsule [0,1,2] => [x,y,z].
             * @zh
             * 胶囊体的本地朝向，映射关系 [0,1,2] => [x,y,z]。
             */
            axis: number;
            /**
             * @en
             * The origin of the capsule.
             * @zh
             * 胶囊体的原点。
             */
            readonly center: math.Vec3;
            /**
             * @en
             * The rotation of the capsule.
             * @zh
             * 胶囊体的旋转。
             */
            readonly rotation: math.Quat;
            /**
             * @internal
             * cache, local center of ellipse
             **/
            readonly ellipseCenter0: math.Vec3;
            /**
             * @internal
             */
            readonly ellipseCenter1: math.Vec3;
            constructor(radius?: number, halfHeight?: number, axis?: number);
            /**
             * @en
             * Transform this capsule.
             * @zh
             * 变换此胶囊体。
             */
            transform(m: math.Mat4, pos: math.IVec3Like, rot: math.IQuatLike, scale: math.IVec3Like, out: Capsule): void;
            updateCache(): void;
            updateLocalCenter(): void;
        }
        /**
         * @en
         * Basic Geometry: frustum.
         * @zh
         * 基础几何 截头锥体。
         */
        export class Frustum {
            /**
             * @en
             * Create an orthogonal frustum.
             * @zh
             * 创建一个正交视锥体。
             * @param out @en The result orthogonal frustum. @zh 输出的正交视锥体。
             * @param width @en The width of the frustum. @zh 正交视锥体的宽度。
             * @param height @en The height of the frustum. @zh 正交视锥体的高度。
             * @param near @en The near plane of the frustum. @zh 正交视锥体的近平面值。
             * @param far @en The far plane of the frustum. @zh 正交视锥体的远平面值。
             * @param transform @en The transform matrix of the frustum. @zh 正交视锥体的变换矩阵。
             * @return @en The out object @zh 返回正交视锥体.
             */
            static createOrtho: (out: Frustum, width: number, height: number, near: number, far: number, transform: math.Mat4) => void;
            /**
             * @en Create a frustum from an AABB box.
             * @zh 从 AABB 包围盒中创建一个视锥体。
             * @param out @en The result frustum @zh 输出的视锥体对象。
             * @param aabb @en The AABB bounding box of the frustum @zh AABB 包围盒。
             * @return @en The out object @zh 返回视锥体.
             */
            static createFromAABB(out: Frustum, aabb: AABB | Readonly<AABB>): Frustum;
            /**
             * @en Calculate the splitted frustum.
             * @zh 创建一个新的截锥体。
             * @param out @en The output frustum @zh 输出的新截锥体
             * @param camera @en The camera of the frustum @zh 相机参数
             * @param m @en The transform matrix @zh 变换矩阵
             * @param start @en The split start position @zh 分割开始位置
             * @param end @en The split end position @zh 分割末尾位置
             * @return @en The out object @zh 返回新截锥体.
             */
            static split(out: Frustum, camera: renderer.scene.Camera, m: math.Mat4, start: number, end: number): Frustum;
            /**
             * @en
             * Create a new frustum.
             * @zh
             * 创建一个新的截锥体。
             * @return @en An empty frustum. @zh 一个空截椎体
             */
            static create(): Frustum;
            /**
             * @en
             * Clone a frustum.
             * @zh
             * 克隆一个截锥体。
             * @param f @en The frustum to clone from @zh 用于克隆的截锥体
             * @return @en The cloned frustum @zh 克隆出的新截锥体
             */
            static clone(f: Frustum): Frustum;
            /**
             * @en
             * Copy the values from one frustum to another.
             * @zh
             * 从一个视锥体拷贝到另一个视锥体。
             * @param out @en The result frustum @zh 用于存储拷贝数据的截锥体
             * @param f @en The frustum to copy from @zh 用于克隆的截锥体
             * @return @en The out object @zh 传入的 out 对象
             */
            static copy(out: Frustum, f: Readonly<Frustum>): Frustum;
            /**
             * @en
             * Set whether to use accurate intersection testing function on this frustum.
             * @zh
             * 设置是否在此截锥体上使用精确的相交测试函数。
             */
            set accurate(b: boolean);
            /**
             * @en
             * Gets the type of the shape.
             * @zh
             * 获取形状的类型。
             * @readonly
             */
            get type(): number;
            planes: Plane[];
            vertices: math.Vec3[];
            protected _type: number;
            constructor();
            /**
             * @en
             * Update the frustum information according to the given transform matrix.
             * Note that the resulting planes are not normalized under normal mode.
             * @zh
             * 根据给定的变换矩阵更新截锥体信息，注意得到的平面不是在标准模式下归一化的。
             * @param m @en The view-projection matrix @zh 视图投影矩阵
             * @param inv @en The inverse view-projection matrix @zh 视图投影逆矩阵
             */
            update(m: math.Mat4, inv: math.Mat4): void;
            /**
             * @en
             * Transform this frustum.
             * @zh
             * 变换此视锥体。
             * @param mat @en The transform matrix @zh 变换矩阵
             */
            transform(mat: math.Mat4): void;
            /**
             * @en Initialize the frustum
             * @zh 初始化视锥体
             */
            zero(): void;
            /**
             * @en Update all six planes of the frustum
             * @zh 更新视锥体的所有面数据
             */
            updatePlanes(): void;
        }
        /**
         * @en
         * A key frame in the curve.
         * @zh
         * 曲线中的一个关键帧。
         */
        export class Keyframe {
            /**
             * @en Current frame time.
             * @zh 当前帧时间。
             */
            time: number;
            /**
             * @en Current frame value.
             * @zh 当前帧的值。
             */
            value: number;
            /**
             * @en In tangent value.
             * @zh 左切线。
             */
            inTangent: number;
            /**
             * @en Out tangent value.
             * @zh 右切线。
             */
            outTangent: number;
        }
        /**
         * @en
         * Describe a curve in which three times Hermite interpolation is used for each adjacent key frame.
         * @zh
         * 描述一条曲线，其中每个相邻关键帧采用三次hermite插值计算。
         */
        export class AnimationCurve {
            /**
             * For internal usage only.
             * @internal
             */
            get _internalCurve(): RealCurve;
            /**
             * @en
             * The key frame of the curve.
             * @zh
             * 曲线的关键帧。
             */
            get keyFrames(): Keyframe[];
            set keyFrames(value: Keyframe[]);
            /**
             * @en
             * Loop mode [[AnimationClip.WrapMode]] when the sampling time exceeds the left end.
             * @zh
             * 当采样时间超出左端时采用的循环模式[[AnimationClip.WrapMode]]。
             */
            get preWrapMode(): __private._cocos_core_animation_types__WrapModeMask;
            set preWrapMode(value: __private._cocos_core_animation_types__WrapModeMask);
            /**
             * @en
             * Cycle mode [[AnimationClip.WrapMode]] when the sampling time exceeds the right end.
             * @zh
             * 当采样时间超出右端时采用的循环模式[[AnimationClip.WrapMode]]。
             */
            get postWrapMode(): __private._cocos_core_animation_types__WrapModeMask;
            set postWrapMode(value: __private._cocos_core_animation_types__WrapModeMask);
            /**
             * @en Construct a curve with key frames
             * @zh 通过关键帧构造一条曲线。
             * @param keyFrames @zh 关键帧 @en Key frames
             */
            constructor(keyFrames?: Keyframe[] | null | RealCurve);
            /**
             * @en
             * Add a keyframe.
             * @zh
             * 添加一个关键帧。
             * @param keyFrame @en A keyframe. @zh 关键帧。
             */
            addKey(keyFrame: Keyframe | null): void;
            /**
             * @ignore
             * @param time
             */
            evaluate_slow(time: number): number;
            /**
             * @en
             * Calculate the curve interpolation at a given point in time.
             * @zh
             * 计算给定时间点的曲线插值。
             * @param time @en The time. @zh 时间。
             */
            evaluate(time: number): number;
            /**
             * @ignore
             * @param optKey
             * @param leftIndex
             * @param rightIndex
             */
            calcOptimizedKey(optKey: __private._cocos_core_geometry_curve__OptimizedKey, leftIndex: number, rightIndex: number): void;
        }
        export enum SplineMode {
            /**
             * Broken line:
             * Each knot is connected with a straight line from the beginning to the end to form a curve. At least two knots.
             */
            LINEAR = 0,
            /**
             * Piecewise Bezier curve:
             * Every four knots form a curve. Total knots number must be a multiple of 4.
             * Each curve passes only the first and fourth knots, and does not pass through the middle two control knots.
             *
             * If you need a whole continuous curve:
             * (1) Suppose the four knots of the previous curve are A, B, C, D
             * (2) The four knots of the next curve must be D, E, F, G
             * (3) C and E need to be symmetrical about D
             */
            BEZIER = 1,
            /**
             * Catmull Rom curve:
             * All knots(including start & end knots) form a whole continuous curve. At least two knots.
             * The whole curve passes through all knots.
             */
            CATMULL_ROM = 2
        }
        /**
         * @en
         * Basic Geometry: Spline.
         * @zh
         * 基础几何 Spline
         */
        export class Spline {
            static create(mode: SplineMode, knots?: math.Vec3[]): Spline;
            static clone(s: Spline): Spline;
            static copy(out: Spline, s: Spline): Spline;
            get type(): number;
            get mode(): SplineMode;
            get knots(): Readonly<math.Vec3[]>;
            setModeAndKnots(mode: SplineMode, knots: math.Vec3[]): void;
            clearKnots(): void;
            getKnotCount(): number;
            addKnot(knot: math.Vec3): void;
            insertKnot(index: number, knot: math.Vec3): void;
            removeKnot(index: number): void;
            setKnot(index: number, knot: math.Vec3): void;
            getKnot(index: number): Readonly<math.Vec3>;
            getPoint(t: number, index?: number): math.Vec3;
            getPoints(num: number, index?: number): math.Vec3[];
        }
        /**
         * @en
         * The raycast mode.
         * @zh
         * 射线检测模式。
         */
        export enum ERaycastMode {
            /**
             * @en
             * Detect and record all data.
             * @zh
             * 检测并记录所有的数据。
             */
            ALL = 0,
            /**
             * @en
             * Detect all, but record only the most recent data.
             * @zh
             * 检测所有，但只记录最近的数据。
             */
            CLOSEST = 1,
            /**
             * @en
             * Once the test is successful, the test is stopped and the data is recorded only once.
             * @zh
             * 一旦检测成功就停止检测，只会记录一次数据。
             */
            ANY = 2
        }
        /**
         * @en
         * The storage structure of the raycast results.
         * @zh
         * 射线检测结果的存储结构。
         */
        export interface IRaySubMeshResult {
            /**
             * @en
             * The distance between the hit point and the ray.
             * @zh
             * 击中点和射线的距离。
             */
            distance: number;
            /**
             * @en
             * The index of the triangle vertex 0。
             * @zh
             * 三角形顶点0的索引。
             */
            vertexIndex0: number;
            /**
             * @en
             * The index of the triangle vertex 1。
             * @zh
             * 三角形顶点1的索引
             */
            vertexIndex1: number;
            /**
             * @en
             * The index of the triangle vertex 2。
             * @zh
             * 三角形顶点2的索引
             */
            vertexIndex2: number;
        }
        /**
         * @en
         * The optional param structure of the `raySubMesh`.
         * @zh
         * `raySubMesh`的可选参数结构。
         */
        export interface IRaySubMeshOptions {
            /**
             * @en
             * The raycast mode，`ANY` by default.
             * @zh
             * 射线检测模式：[0, 1, 2]=>[`ALL`, `CLOSEST`, `ANY`]
             */
            mode: ERaycastMode;
            /**
             * @en
             * The maximum distance of the raycast, `Infinity` by default.
             * @zh
             * 射线检测的最大距离，默认为`Infinity`。
             */
            distance: number;
            /**
             * @en
             * An array used to store the results of a ray detection.
             * @zh
             * 用于存储射线检测结果的数组。
             */
            result?: IRaySubMeshResult[];
            /**
             * @en
             * Whether to detect the double-sided or not，`false` by default.
             * @zh
             * 是否检测双面，默认为`false`。
             */
            doubleSided?: boolean;
        }
        /**
         * @en
         * The optional param structure of the `rayMesh`.
         * @zh
         * `rayMesh`的可选参数结构。
         */
        export interface IRayMeshOptions extends IRaySubMeshOptions {
            /**
             * @en
             * The index of the sub mesh.
             * @zh
             * 子网格的索引。
             */
            subIndices?: number[];
        }
        /**
         * @en
         * The optional param structure of the `rayModel`.
         * @zh
         * `rayModel`的可选参数结构。
         */
        export type IRayModelOptions = IRayMeshOptions;
        /**
         * @en
         * Alias of [[geometry.Line]]
         * @zh
         * [[geometry.Line]] 别名类
         *
         * @deprecated Since v3.0, please use Line instead
         */
        export class line extends Line {
            constructor();
        }
        /**
         * @en
         * Alias of [[geometry.Plane]]
         *
         * @zh
         * [[geometry.Plane]] 别名类
         *
         * @deprecated Since v3.0, please use Plane instead
         */
        export class plane extends Plane {
            constructor();
        }
        /**
         * @en
         * Alias of [[geometry.Ray]]
         * @zh
         * [[geometry.Ray]] 别名类
         * @deprecated Since v3.0, please use Ray instead
         */
        export class ray extends Ray {
            constructor();
        }
        /**
         * @en
         * Alias of [[geometry.Triangle]]
         *
         * @zh
         * [[geometry.Triangle]] 别名类
         * @deprecated Since v3.0, please use Triangle instead
         */
        export class triangle extends Triangle {
            constructor();
        }
        /**
         * @en
         * Alias of [[geometry.Sphere]]
         *
         * @zh
         * [[geometry.Sphere]] 别名类
         * @deprecated Since v3.0, please use Sphere instead
         */
        export class sphere extends Sphere {
            constructor();
        }
        /**
         * @en
         * Alias of [[geometry.AABB]]
         *
         * @zh
         * [[geometry.AABB]] 别名类
         * @deprecated Since v3.0, please use AABB instead
         */
        export class aabb extends AABB {
            constructor();
        }
        /**
         * @en
         * Alias of [[geometry.OBB]]
         *
         * @zh
         * [[geometry.OBB]] 别名类
         * @deprecated Since v3.0, please use OBB instead
         */
        export class obb extends OBB {
            constructor();
        }
        /**
         * @en
         * Alias of [[geometry.Capsule]]
         *
         * @zh
         * [[geometry.Capsule]] 别名类
         * @deprecated Since v3.0, please use Capsule instead
         */
        export class capsule extends Capsule {
            constructor();
        }
        /**
         * @en
         * Alias of [[geometry.Frustum]]
         *
         * @zh
         * [[geometry.Frustum]] 别名类
         * @deprecated Since v3.0, please use Frustum instead
         */
        export class frustum extends Frustum {
            constructor();
        }
    }
    export namespace gfx {
        /**
         * @en GFX sampler.
         * @zh GFX 采样器。
         */
        export class Sampler extends GFXObject {
            get info(): Readonly<SamplerInfo>;
            get hash(): number;
            protected _info: SamplerInfo;
            protected _hash: number;
            constructor(info: Readonly<SamplerInfo>, hash: number);
            static computeHash(info: Readonly<SamplerInfo>): Filter;
            static unpackFromHash(hash: number): SamplerInfo;
        }
        export class SamplerInfo {
            minFilter: Filter;
            magFilter: Filter;
            mipFilter: Filter;
            addressU: Address;
            addressV: Address;
            addressW: Address;
            maxAnisotropy: number;
            cmpFunc: ComparisonFunc;
            constructor(minFilter?: Filter, magFilter?: Filter, mipFilter?: Filter, addressU?: Address, addressV?: Address, addressW?: Address, maxAnisotropy?: number, cmpFunc?: ComparisonFunc);
            copy(info: Readonly<SamplerInfo>): this;
        }
        /**
         * @en Get the memory size of the specified type.
         * @zh 得到 GFX 数据类型的大小。
         * @param type The target type.
         */
        export function GetTypeSize(type: Type): number;
        /**
         * @en GFX descriptor sets.
         * @zh GFX 描述符集组。
         */
        export abstract class DescriptorSet extends GFXObject {
            get layout(): DescriptorSetLayout;
            protected _layout: DescriptorSetLayout | null;
            protected _buffers: Buffer[];
            protected _textures: Texture[];
            protected _samplers: Sampler[];
            protected _isDirty: boolean;
            constructor();
            abstract initialize(info: Readonly<DescriptorSetInfo>): void;
            abstract destroy(): void;
            abstract update(): void;
            /**
             * @en Bind buffer to the specified descriptor.
             * @zh 在指定的描述符位置上绑定缓冲。
             * @param binding The target binding.
             * @param buffer The buffer to be bound.
             */
            bindBuffer(binding: number, buffer: Buffer, index?: number): void;
            /**
             * @en Bind sampler to the specified descriptor.
             * @zh 在指定的描述符位置上绑定采样器。
             * @param binding The target binding.
             * @param sampler The sampler to be bound.
             */
            bindSampler(binding: number, sampler: Sampler, index?: number): void;
            /**
             * @en Bind texture to the specified descriptor.
             * @zh 在指定的描述符位置上绑定纹理。
             * @param binding The target binding.
             * @param texture The texture to be bound.
             */
            bindTexture(binding: number, texture: Texture, index?: number): void;
            /**
             * @en Get buffer from the specified binding location.
             * @zh 获取当前指定绑定位置上的缓冲。
             * @param binding The target binding.
             */
            getBuffer(binding: number, index?: number): Buffer;
            /**
             * @en Get sampler from the specified binding location.
             * @zh 获取当前指定绑定位置上的采样器。
             * @param binding The target binding.
             */
            getSampler(binding: number, index?: number): Sampler;
            /**
             * @en Get texture from the specified binding location.
             * @zh 获取当前指定绑定位置上的贴图。
             * @param binding The target binding.
             */
            getTexture(binding: number, index?: number): Texture;
        }
        /**
         * @en GFX buffer.
         * @zh GFX 缓冲。
         */
        export abstract class Buffer extends GFXObject {
            /**
             * @en Usage type of the buffer.
             * @zh 缓冲使用方式。
             */
            get usage(): BufferUsage;
            /**
             * @en Memory usage of the buffer.
             * @zh 缓冲的内存使用方式。
             */
            get memUsage(): MemoryUsage;
            /**
             * @en Size of the buffer.
             * @zh 缓冲大小。
             */
            get size(): number;
            /**
             * @en Stride of the buffer.
             * @zh 缓冲步长。
             */
            get stride(): number;
            /**
             * @en Count of the buffer wrt. stride.
             * @zh 缓冲条目数量。
             */
            get count(): number;
            get flags(): BufferFlags;
            protected _usage: BufferUsage;
            protected _memUsage: MemoryUsage;
            protected _size: number;
            protected _stride: number;
            protected _count: number;
            protected _flags: BufferFlags;
            protected _isBufferView: boolean;
            constructor();
            abstract initialize(info: Readonly<BufferInfo> | Readonly<BufferViewInfo>): void;
            abstract destroy(): void;
            /**
             * @en Resize the buffer.
             * @zh 重置缓冲大小。
             * @param size The new buffer size.
             */
            abstract resize(size: number): void;
            /**
             * @en Update the buffer data.
             * @zh 更新缓冲内容。
             * @param buffer The new buffer data.
             * @param size Size in bytes to be updated.
             */
            abstract update(buffer: Readonly<BufferSource>, size?: number): void;
        }
        /**
         * @en GFX command buffer.
         * @zh GFX 命令缓冲。
         */
        export abstract class CommandBuffer extends GFXObject {
            /**
             * @en Type of the command buffer.
             * @zh 命令缓冲类型。
             */
            get type(): CommandBufferType;
            /**
             * @en Type of the command buffer.
             * @zh 命令缓冲类型。
             */
            get queue(): Queue;
            /**
             * @en Number of draw calls currently recorded.
             * @zh 绘制调用次数。
             */
            get numDrawCalls(): number;
            /**
             * @en Number of instances currently recorded.
             * @zh 绘制 Instance 数量。
             */
            get numInstances(): number;
            /**
             * @en Number of triangles currently recorded.
             * @zh 绘制三角形数量。
             */
            get numTris(): number;
            protected _queue: Queue | null;
            protected _type: CommandBufferType;
            protected _numDrawCalls: number;
            protected _numInstances: number;
            protected _numTris: number;
            constructor();
            abstract initialize(info: Readonly<CommandBufferInfo>): void;
            abstract destroy(): void;
            /**
             * @en Begin recording commands.
             * @zh 开始记录命令。
             * @param renderPass [Secondary Command Buffer Only] The render pass the subsequent commands will be executed in
             * @param subpass [Secondary Command Buffer Only] The subpass the subsequent commands will be executed in
             * @param frameBuffer [Secondary Command Buffer Only, Optional] The framebuffer to be used in the subpass
             */
            abstract begin(renderPass?: RenderPass, subpass?: number, frameBuffer?: Framebuffer): void;
            /**
             * @en End recording commands.
             * @zh 结束记录命令。
             */
            abstract end(): void;
            /**
             * @en Begin render pass.
             * @zh 开始 RenderPass。
             * @param framebuffer The frame buffer used.
             * @param renderArea The target render area.
             * @param clearFlag The clear flags.
             * @param clearColors The clearing colors.
             * @param clearDepth The clearing depth.
             * @param clearStencil The clearing stencil.
             */
            abstract beginRenderPass(renderPass: RenderPass, framebuffer: Framebuffer, renderArea: Readonly<Rect>, clearColors: Readonly<Color[]>, clearDepth: number, clearStencil: number): void;
            /**
             * @en End render pass.
             * @zh 结束 RenderPass。
             */
            abstract endRenderPass(): void;
            /**
             * @en Bind pipeline state.
             * @zh 绑定 GFX 管线状态。
             * @param pipelineState The pipeline state to be bound.
             */
            abstract bindPipelineState(pipelineState: PipelineState): void;
            /**
             * @en Bind a descriptor set. Note that the corresponding PiplieneState has to be bound first
             * before calling this function, or the dynamic offset specified may be invalidated.
             * @zh 绑定 GFX 描述符集。注意在调用此函数前，必须先绑定对应的 PipelineState，否则 dynamic offset 可能无效。
             * @param set The target descriptor set index.
             * @param descriptorSet The descriptor set to be bound.
             * @param dynamicOffsets The offset numbers for dynamic bindings.
             */
            abstract bindDescriptorSet(set: number, descriptorSet: DescriptorSet, dynamicOffsets?: Readonly<number[]>): void;
            /**
             * @en Bind input assembler.
             * @zh 绑定 GFX 输入汇集器。
             * @param inputAssembler The input assembler to be bound.
             */
            abstract bindInputAssembler(inputAssembler: InputAssembler): void;
            /**
             * @en Set viewport.
             * @zh 设置视口。
             * @param viewport The new viewport.
             */
            abstract setViewport(viewport: Readonly<Viewport>): void;
            /**
             * @en Set scissor range.
             * @zh 设置剪裁区域。
             * @param scissor The new scissor range.
             */
            abstract setScissor(scissor: Readonly<Rect>): void;
            /**
             * @en Set line width.
             * @zh 设置线宽。
             * @param lineWidth The new line width.
             */
            abstract setLineWidth(lineWidth: number): void;
            /**
             * @en Set depth bias.
             * @zh 设置深度偏移。
             * @param depthBiasConstantFactor The new depth bias factor.
             * @param depthBiasClamp The new depth bias clamp threshold.
             * @param depthBiasSlopeFactor  The new depth bias slope factor.
             */
            abstract setDepthBias(depthBiasConstantFactor: number, depthBiasClamp: number, depthBiasSlopeFactor: number): void;
            /**
             * @en Set blend constants.
             * @zh 设置混合因子。
             * @param blendConstants The new blend constants.
             */
            abstract setBlendConstants(blendConstants: Readonly<Color>): void;
            /**
             * @en Set depth bound.
             * @zh 设置深度边界。
             * @param minDepthBounds The new minimum depth bound.
             * @param maxDepthBounds The new maximum depth bound.
             */
            abstract setDepthBound(minDepthBounds: number, maxDepthBounds: number): void;
            /**
             * @en Set stencil write mask.
             * @zh 设置模板写掩码。
             * @param face The effective triangle face.
             * @param writeMask The new stencil write mask.
             */
            abstract setStencilWriteMask(face: StencilFace, writeMask: number): void;
            /**
             * @en Set stencil compare mask.
             * @zh 设置模板比较掩码。
             * @param face The effective triangle face.
             * @param reference The new stencil reference constant.
             * @param compareMask The new stencil read mask.
             */
            abstract setStencilCompareMask(face: StencilFace, reference: number, compareMask: number): void;
            /**
             * @en Draw the specified primitives.
             * @zh 绘制。
             * @param infoOrAssembler The draw call information.
             */
            abstract draw(infoOrAssembler: Readonly<DrawInfo> | Readonly<InputAssembler>): void;
            /**
             * @en Update buffer.
             * @zh 更新缓冲。
             * @param buffer The buffer to be updated.
             * @param data The source data.
             * @param size Size in bytes to be updated.
             */
            abstract updateBuffer(buffer: Buffer, data: Readonly<ArrayBuffer>, size?: number): void;
            /**
             * @en Copy buffer to texture.
             * @zh 拷贝缓冲到纹理。
             * @param srcBuff The buffer to be copied.
             * @param dstTex The texture to copy to.
             * @param dstLayout The target texture layout.
             * @param regions The region descriptions.
             */
            abstract copyBuffersToTexture(buffers: Readonly<ArrayBufferView[]>, texture: Texture, regions: Readonly<BufferTextureCopy[]>): void;
            /**
             * @en Execute specified command buffers.
             * @zh 执行一组命令缓冲。
             * @param cmdBuffs The command buffers to be executed.
             * @param count The number of command buffers to be executed.
             */
            abstract execute(cmdBuffs: Readonly<CommandBuffer[]>, count: number): void;
            /**
             * @en Insert pipeline memory barriers.
             * @zh 插入管线内存屏障。
             * @param barrier The global memory barrier to apply.
             * @param textureBarriers The texture memory barriers to apply.
             */
            abstract pipelineBarrier(barrier: Readonly<GeneralBarrier> | null, bufferBarriers?: Readonly<__private._cocos_core_gfx_base_states_buffer_barrier__BufferBarrier[]>, buffers?: Readonly<Buffer[]>, textureBarriers?: Readonly<TextureBarrier[]>, textures?: Readonly<Texture[]>): void;
        }
        export function IsPowerOf2(x: number): boolean;
        /**
         * @en Get memory size of the specified fomat.
         * @zh 获取指定格式对应的内存大小。
         * @param format The target format.
         * @param width The target width.
         * @param height The target height.
         * @param depth The target depth.
         */
        export function FormatSize(format: Format, width: number, height: number, depth: number): number;
        /**
         * @en Get memory size of the specified surface.
         * @zh GFX 格式表面内存大小。
         * @param format The target format.
         * @param width The target width.
         * @param height The target height.
         * @param depth The target depth.
         * @param mips The target mip levels.
         */
        export function FormatSurfaceSize(format: Format, width: number, height: number, depth: number, mips: number): number;
        export function getTypedArrayConstructor(info: FormatInfo): __private._types_globals__TypedArrayConstructor;
        export function formatAlignment(format: Format): FormatAlignment;
        export function alignTo(size: number, alignment: number): number;
        /**
         * ========================= !DO NOT CHANGE THE FOLLOWING SECTION MANUALLY! =========================
         * The following section is auto-generated from native/cocos/renderer/core/gfx/GFXDef-common.h
         * by the script native/tools/gfx-define-generator/generate.js.
         * Changes to these public interfaces should be made there first and synced back.
         * ========================= !DO NOT CHANGE THE FOLLOWING SECTION MANUALLY! =========================
         */
        /**
         * @en Graphics object type
         * @zh 图形API对象的类型
         */
        export enum ObjectType {
            UNKNOWN = 0,
            SWAPCHAIN = 1,
            BUFFER = 2,
            TEXTURE = 3,
            RENDER_PASS = 4,
            FRAMEBUFFER = 5,
            SAMPLER = 6,
            SHADER = 7,
            DESCRIPTOR_SET_LAYOUT = 8,
            PIPELINE_LAYOUT = 9,
            PIPELINE_STATE = 10,
            DESCRIPTOR_SET = 11,
            INPUT_ASSEMBLER = 12,
            COMMAND_BUFFER = 13,
            QUEUE = 14,
            QUERY_POOL = 15,
            GLOBAL_BARRIER = 16,
            TEXTURE_BARRIER = 17,
            BUFFER_BARRIER = 18,
            COUNT = 19
        }
        export enum Status {
            UNREADY = 0,
            FAILED = 1,
            SUCCESS = 2
        }
        export enum API {
            UNKNOWN = 0,
            GLES2 = 1,
            GLES3 = 2,
            METAL = 3,
            VULKAN = 4,
            NVN = 5,
            WEBGL = 6,
            WEBGL2 = 7,
            WEBGPU = 8
        }
        export enum SurfaceTransform {
            IDENTITY = 0,
            ROTATE_90 = 1,
            ROTATE_180 = 2,
            ROTATE_270 = 3
        }
        export enum Feature {
            ELEMENT_INDEX_UINT = 0,
            INSTANCED_ARRAYS = 1,
            MULTIPLE_RENDER_TARGETS = 2,
            BLEND_MINMAX = 3,
            COMPUTE_SHADER = 4,
            INPUT_ATTACHMENT_BENEFIT = 5,
            COUNT = 6
        }
        export enum Format {
            UNKNOWN = 0,
            A8 = 1,
            L8 = 2,
            LA8 = 3,
            R8 = 4,
            R8SN = 5,
            R8UI = 6,
            R8I = 7,
            R16F = 8,
            R16UI = 9,
            R16I = 10,
            R32F = 11,
            R32UI = 12,
            R32I = 13,
            RG8 = 14,
            RG8SN = 15,
            RG8UI = 16,
            RG8I = 17,
            RG16F = 18,
            RG16UI = 19,
            RG16I = 20,
            RG32F = 21,
            RG32UI = 22,
            RG32I = 23,
            RGB8 = 24,
            SRGB8 = 25,
            RGB8SN = 26,
            RGB8UI = 27,
            RGB8I = 28,
            RGB16F = 29,
            RGB16UI = 30,
            RGB16I = 31,
            RGB32F = 32,
            RGB32UI = 33,
            RGB32I = 34,
            RGBA8 = 35,
            BGRA8 = 36,
            SRGB8_A8 = 37,
            RGBA8SN = 38,
            RGBA8UI = 39,
            RGBA8I = 40,
            RGBA16F = 41,
            RGBA16UI = 42,
            RGBA16I = 43,
            RGBA32F = 44,
            RGBA32UI = 45,
            RGBA32I = 46,
            R5G6B5 = 47,
            R11G11B10F = 48,
            RGB5A1 = 49,
            RGBA4 = 50,
            RGB10A2 = 51,
            RGB10A2UI = 52,
            RGB9E5 = 53,
            DEPTH = 54,
            DEPTH_STENCIL = 55,
            BC1 = 56,
            BC1_ALPHA = 57,
            BC1_SRGB = 58,
            BC1_SRGB_ALPHA = 59,
            BC2 = 60,
            BC2_SRGB = 61,
            BC3 = 62,
            BC3_SRGB = 63,
            BC4 = 64,
            BC4_SNORM = 65,
            BC5 = 66,
            BC5_SNORM = 67,
            BC6H_UF16 = 68,
            BC6H_SF16 = 69,
            BC7 = 70,
            BC7_SRGB = 71,
            ETC_RGB8 = 72,
            ETC2_RGB8 = 73,
            ETC2_SRGB8 = 74,
            ETC2_RGB8_A1 = 75,
            ETC2_SRGB8_A1 = 76,
            ETC2_RGBA8 = 77,
            ETC2_SRGB8_A8 = 78,
            EAC_R11 = 79,
            EAC_R11SN = 80,
            EAC_RG11 = 81,
            EAC_RG11SN = 82,
            PVRTC_RGB2 = 83,
            PVRTC_RGBA2 = 84,
            PVRTC_RGB4 = 85,
            PVRTC_RGBA4 = 86,
            PVRTC2_2BPP = 87,
            PVRTC2_4BPP = 88,
            ASTC_RGBA_4X4 = 89,
            ASTC_RGBA_5X4 = 90,
            ASTC_RGBA_5X5 = 91,
            ASTC_RGBA_6X5 = 92,
            ASTC_RGBA_6X6 = 93,
            ASTC_RGBA_8X5 = 94,
            ASTC_RGBA_8X6 = 95,
            ASTC_RGBA_8X8 = 96,
            ASTC_RGBA_10X5 = 97,
            ASTC_RGBA_10X6 = 98,
            ASTC_RGBA_10X8 = 99,
            ASTC_RGBA_10X10 = 100,
            ASTC_RGBA_12X10 = 101,
            ASTC_RGBA_12X12 = 102,
            ASTC_SRGBA_4X4 = 103,
            ASTC_SRGBA_5X4 = 104,
            ASTC_SRGBA_5X5 = 105,
            ASTC_SRGBA_6X5 = 106,
            ASTC_SRGBA_6X6 = 107,
            ASTC_SRGBA_8X5 = 108,
            ASTC_SRGBA_8X6 = 109,
            ASTC_SRGBA_8X8 = 110,
            ASTC_SRGBA_10X5 = 111,
            ASTC_SRGBA_10X6 = 112,
            ASTC_SRGBA_10X8 = 113,
            ASTC_SRGBA_10X10 = 114,
            ASTC_SRGBA_12X10 = 115,
            ASTC_SRGBA_12X12 = 116,
            COUNT = 117
        }
        export enum FormatType {
            NONE = 0,
            UNORM = 1,
            SNORM = 2,
            UINT = 3,
            INT = 4,
            UFLOAT = 5,
            FLOAT = 6
        }
        export enum Type {
            UNKNOWN = 0,
            BOOL = 1,
            BOOL2 = 2,
            BOOL3 = 3,
            BOOL4 = 4,
            INT = 5,
            INT2 = 6,
            INT3 = 7,
            INT4 = 8,
            UINT = 9,
            UINT2 = 10,
            UINT3 = 11,
            UINT4 = 12,
            FLOAT = 13,
            FLOAT2 = 14,
            FLOAT3 = 15,
            FLOAT4 = 16,
            MAT2 = 17,
            MAT2X3 = 18,
            MAT2X4 = 19,
            MAT3X2 = 20,
            MAT3 = 21,
            MAT3X4 = 22,
            MAT4X2 = 23,
            MAT4X3 = 24,
            MAT4 = 25,
            SAMPLER1D = 26,
            SAMPLER1D_ARRAY = 27,
            SAMPLER2D = 28,
            SAMPLER2D_ARRAY = 29,
            SAMPLER3D = 30,
            SAMPLER_CUBE = 31,
            SAMPLER = 32,
            TEXTURE1D = 33,
            TEXTURE1D_ARRAY = 34,
            TEXTURE2D = 35,
            TEXTURE2D_ARRAY = 36,
            TEXTURE3D = 37,
            TEXTURE_CUBE = 38,
            IMAGE1D = 39,
            IMAGE1D_ARRAY = 40,
            IMAGE2D = 41,
            IMAGE2D_ARRAY = 42,
            IMAGE3D = 43,
            IMAGE_CUBE = 44,
            SUBPASS_INPUT = 45,
            COUNT = 46
        }
        export enum BufferUsageBit {
            NONE = 0,
            TRANSFER_SRC = 1,
            TRANSFER_DST = 2,
            INDEX = 4,
            VERTEX = 8,
            UNIFORM = 16,
            STORAGE = 32,
            INDIRECT = 64
        }
        export enum BufferFlagBit {
            NONE = 0
        }
        export enum MemoryAccessBit {
            NONE = 0,
            READ_ONLY = 1,
            WRITE_ONLY = 2,
            READ_WRITE = 3
        }
        export enum MemoryUsageBit {
            NONE = 0,
            DEVICE = 1,
            HOST = 2
        }
        export enum TextureType {
            TEX1D = 0,
            TEX2D = 1,
            TEX3D = 2,
            CUBE = 3,
            TEX1D_ARRAY = 4,
            TEX2D_ARRAY = 5
        }
        export enum TextureUsageBit {
            NONE = 0,
            TRANSFER_SRC = 1,
            TRANSFER_DST = 2,
            SAMPLED = 4,
            STORAGE = 8,
            COLOR_ATTACHMENT = 16,
            DEPTH_STENCIL_ATTACHMENT = 32,
            INPUT_ATTACHMENT = 64
        }
        export enum TextureFlagBit {
            NONE = 0,
            GEN_MIPMAP = 1,
            GENERAL_LAYOUT = 2
        }
        export enum FormatFeatureBit {
            NONE = 0,
            RENDER_TARGET = 1,
            SAMPLED_TEXTURE = 2,
            LINEAR_FILTER = 4,
            STORAGE_TEXTURE = 8,
            VERTEX_ATTRIBUTE = 16
        }
        export enum SampleCount {
            ONE = 0,
            MULTIPLE_PERFORMANCE = 1,
            MULTIPLE_BALANCE = 2,
            MULTIPLE_QUALITY = 3
        }
        export enum VsyncMode {
            OFF = 0,
            ON = 1,
            RELAXED = 2,
            MAILBOX = 3,
            HALF = 4
        }
        export enum Filter {
            NONE = 0,
            POINT = 1,
            LINEAR = 2,
            ANISOTROPIC = 3
        }
        export enum Address {
            WRAP = 0,
            MIRROR = 1,
            CLAMP = 2,
            BORDER = 3
        }
        export enum ComparisonFunc {
            NEVER = 0,
            LESS = 1,
            EQUAL = 2,
            LESS_EQUAL = 3,
            GREATER = 4,
            NOT_EQUAL = 5,
            GREATER_EQUAL = 6,
            ALWAYS = 7
        }
        export enum StencilOp {
            ZERO = 0,
            KEEP = 1,
            REPLACE = 2,
            INCR = 3,
            DECR = 4,
            INVERT = 5,
            INCR_WRAP = 6,
            DECR_WRAP = 7
        }
        export enum BlendFactor {
            ZERO = 0,
            ONE = 1,
            SRC_ALPHA = 2,
            DST_ALPHA = 3,
            ONE_MINUS_SRC_ALPHA = 4,
            ONE_MINUS_DST_ALPHA = 5,
            SRC_COLOR = 6,
            DST_COLOR = 7,
            ONE_MINUS_SRC_COLOR = 8,
            ONE_MINUS_DST_COLOR = 9,
            SRC_ALPHA_SATURATE = 10,
            CONSTANT_COLOR = 11,
            ONE_MINUS_CONSTANT_COLOR = 12,
            CONSTANT_ALPHA = 13,
            ONE_MINUS_CONSTANT_ALPHA = 14
        }
        export enum BlendOp {
            ADD = 0,
            SUB = 1,
            REV_SUB = 2,
            MIN = 3,
            MAX = 4
        }
        export enum ColorMask {
            NONE = 0,
            R = 1,
            G = 2,
            B = 4,
            A = 8,
            ALL = 15
        }
        export enum ShaderStageFlagBit {
            NONE = 0,
            VERTEX = 1,
            CONTROL = 2,
            EVALUATION = 4,
            GEOMETRY = 8,
            FRAGMENT = 16,
            COMPUTE = 32,
            ALL = 63
        }
        export enum LoadOp {
            LOAD = 0,
            CLEAR = 1,
            DISCARD = 2
        }
        export enum StoreOp {
            STORE = 0,
            DISCARD = 1
        }
        export enum AccessFlagBit {
            NONE = 0,
            INDIRECT_BUFFER = 1,
            INDEX_BUFFER = 2,
            VERTEX_BUFFER = 4,
            VERTEX_SHADER_READ_UNIFORM_BUFFER = 8,
            VERTEX_SHADER_READ_TEXTURE = 16,
            VERTEX_SHADER_READ_OTHER = 32,
            FRAGMENT_SHADER_READ_UNIFORM_BUFFER = 64,
            FRAGMENT_SHADER_READ_TEXTURE = 128,
            FRAGMENT_SHADER_READ_COLOR_INPUT_ATTACHMENT = 256,
            FRAGMENT_SHADER_READ_DEPTH_STENCIL_INPUT_ATTACHMENT = 512,
            FRAGMENT_SHADER_READ_OTHER = 1024,
            COLOR_ATTACHMENT_READ = 2048,
            DEPTH_STENCIL_ATTACHMENT_READ = 4096,
            COMPUTE_SHADER_READ_UNIFORM_BUFFER = 8192,
            COMPUTE_SHADER_READ_TEXTURE = 16384,
            COMPUTE_SHADER_READ_OTHER = 32768,
            TRANSFER_READ = 65536,
            HOST_READ = 131072,
            PRESENT = 262144,
            VERTEX_SHADER_WRITE = 524288,
            FRAGMENT_SHADER_WRITE = 1048576,
            COLOR_ATTACHMENT_WRITE = 2097152,
            DEPTH_STENCIL_ATTACHMENT_WRITE = 4194304,
            COMPUTE_SHADER_WRITE = 8388608,
            TRANSFER_WRITE = 16777216,
            HOST_PREINITIALIZED = 33554432,
            HOST_WRITE = 67108864
        }
        export enum ResolveMode {
            NONE = 0,
            SAMPLE_ZERO = 1,
            AVERAGE = 2,
            MIN = 3,
            MAX = 4
        }
        export enum PipelineBindPoint {
            GRAPHICS = 0,
            COMPUTE = 1,
            RAY_TRACING = 2
        }
        export enum PrimitiveMode {
            POINT_LIST = 0,
            LINE_LIST = 1,
            LINE_STRIP = 2,
            LINE_LOOP = 3,
            LINE_LIST_ADJACENCY = 4,
            LINE_STRIP_ADJACENCY = 5,
            ISO_LINE_LIST = 6,
            TRIANGLE_LIST = 7,
            TRIANGLE_STRIP = 8,
            TRIANGLE_FAN = 9,
            TRIANGLE_LIST_ADJACENCY = 10,
            TRIANGLE_STRIP_ADJACENCY = 11,
            TRIANGLE_PATCH_ADJACENCY = 12,
            QUAD_PATCH_LIST = 13
        }
        export enum PolygonMode {
            FILL = 0,
            POINT = 1,
            LINE = 2
        }
        export enum ShadeModel {
            GOURAND = 0,
            FLAT = 1
        }
        export enum CullMode {
            NONE = 0,
            FRONT = 1,
            BACK = 2
        }
        export enum DynamicStateFlagBit {
            NONE = 0,
            LINE_WIDTH = 1,
            DEPTH_BIAS = 2,
            BLEND_CONSTANTS = 4,
            DEPTH_BOUNDS = 8,
            STENCIL_WRITE_MASK = 16,
            STENCIL_COMPARE_MASK = 32
        }
        export enum StencilFace {
            FRONT = 1,
            BACK = 2,
            ALL = 3
        }
        export enum DescriptorType {
            UNKNOWN = 0,
            UNIFORM_BUFFER = 1,
            DYNAMIC_UNIFORM_BUFFER = 2,
            STORAGE_BUFFER = 4,
            DYNAMIC_STORAGE_BUFFER = 8,
            SAMPLER_TEXTURE = 16,
            SAMPLER = 32,
            TEXTURE = 64,
            STORAGE_IMAGE = 128,
            INPUT_ATTACHMENT = 256
        }
        export enum QueueType {
            GRAPHICS = 0,
            COMPUTE = 1,
            TRANSFER = 2
        }
        export enum QueryType {
            OCCLUSION = 0,
            PIPELINE_STATISTICS = 1,
            TIMESTAMP = 2
        }
        export enum CommandBufferType {
            PRIMARY = 0,
            SECONDARY = 1
        }
        export enum ClearFlagBit {
            NONE = 0,
            COLOR = 1,
            DEPTH = 2,
            STENCIL = 4,
            DEPTH_STENCIL = 6,
            ALL = 7
        }
        export enum BarrierType {
            FULL = 0,
            SPLIT_BEGIN = 1,
            SPLIT_END = 2
        }
        export enum PassType {
            RASTER = 0,
            COMPUTE = 1,
            COPY = 2,
            MOVE = 3,
            RAYTRACE = 4,
            PRESENT = 5
        }
        export type BufferUsage = BufferUsageBit;
        export type BufferFlags = BufferFlagBit;
        export type MemoryAccess = MemoryAccessBit;
        export type MemoryUsage = MemoryUsageBit;
        export type TextureUsage = TextureUsageBit;
        export type TextureFlags = TextureFlagBit;
        export type FormatFeature = FormatFeatureBit;
        export type ShaderStageFlags = ShaderStageFlagBit;
        export type AccessFlags = AccessFlagBit;
        export type DynamicStateFlags = DynamicStateFlagBit;
        export type ClearFlags = ClearFlagBit;
        export class Size {
            x: number;
            y: number;
            z: number;
            constructor(x?: number, y?: number, z?: number);
            copy(info: Readonly<Size>): this;
        }
        export class DeviceCaps {
            maxVertexAttributes: number;
            maxVertexUniformVectors: number;
            maxFragmentUniformVectors: number;
            maxTextureUnits: number;
            maxImageUnits: number;
            maxVertexTextureUnits: number;
            maxColorRenderTargets: number;
            maxShaderStorageBufferBindings: number;
            maxShaderStorageBlockSize: number;
            maxUniformBufferBindings: number;
            maxUniformBlockSize: number;
            maxTextureSize: number;
            maxCubeMapTextureSize: number;
            uboOffsetAlignment: number;
            maxComputeSharedMemorySize: number;
            maxComputeWorkGroupInvocations: number;
            maxComputeWorkGroupSize: Size;
            maxComputeWorkGroupCount: Size;
            supportQuery: boolean;
            clipSpaceMinZ: number;
            screenSpaceSignY: number;
            clipSpaceSignY: number;
            constructor(maxVertexAttributes?: number, maxVertexUniformVectors?: number, maxFragmentUniformVectors?: number, maxTextureUnits?: number, maxImageUnits?: number, maxVertexTextureUnits?: number, maxColorRenderTargets?: number, maxShaderStorageBufferBindings?: number, maxShaderStorageBlockSize?: number, maxUniformBufferBindings?: number, maxUniformBlockSize?: number, maxTextureSize?: number, maxCubeMapTextureSize?: number, uboOffsetAlignment?: number, maxComputeSharedMemorySize?: number, maxComputeWorkGroupInvocations?: number, maxComputeWorkGroupSize?: Size, maxComputeWorkGroupCount?: Size, supportQuery?: boolean, clipSpaceMinZ?: number, screenSpaceSignY?: number, clipSpaceSignY?: number);
            copy(info: Readonly<DeviceCaps>): this;
        }
        export class DeviceOptions {
            enableBarrierDeduce: boolean;
            constructor(enableBarrierDeduce?: boolean);
            copy(info: Readonly<DeviceOptions>): this;
        }
        export class Offset {
            x: number;
            y: number;
            z: number;
            constructor(x?: number, y?: number, z?: number);
            copy(info: Readonly<Offset>): this;
        }
        export class Rect {
            x: number;
            y: number;
            width: number;
            height: number;
            constructor(x?: number, y?: number, width?: number, height?: number);
            copy(info: Readonly<Rect>): this;
        }
        export class Extent {
            width: number;
            height: number;
            depth: number;
            constructor(width?: number, height?: number, depth?: number);
            copy(info: Readonly<Extent>): this;
        }
        export class TextureSubresLayers {
            mipLevel: number;
            baseArrayLayer: number;
            layerCount: number;
            constructor(mipLevel?: number, baseArrayLayer?: number, layerCount?: number);
            copy(info: Readonly<TextureSubresLayers>): this;
        }
        export class TextureSubresRange {
            baseMipLevel: number;
            levelCount: number;
            baseArrayLayer: number;
            layerCount: number;
            constructor(baseMipLevel?: number, levelCount?: number, baseArrayLayer?: number, layerCount?: number);
            copy(info: Readonly<TextureSubresRange>): this;
        }
        export class TextureCopy {
            srcSubres: TextureSubresLayers;
            srcOffset: Offset;
            dstSubres: TextureSubresLayers;
            dstOffset: Offset;
            extent: Extent;
            constructor(srcSubres?: TextureSubresLayers, srcOffset?: Offset, dstSubres?: TextureSubresLayers, dstOffset?: Offset, extent?: Extent);
            copy(info: Readonly<TextureCopy>): this;
        }
        export class TextureBlit {
            srcSubres: TextureSubresLayers;
            srcOffset: Offset;
            srcExtent: Extent;
            dstSubres: TextureSubresLayers;
            dstOffset: Offset;
            dstExtent: Extent;
            constructor(srcSubres?: TextureSubresLayers, srcOffset?: Offset, srcExtent?: Extent, dstSubres?: TextureSubresLayers, dstOffset?: Offset, dstExtent?: Extent);
            copy(info: Readonly<TextureBlit>): this;
        }
        export class BufferTextureCopy {
            buffOffset: number;
            buffStride: number;
            buffTexHeight: number;
            texOffset: Offset;
            texExtent: Extent;
            texSubres: TextureSubresLayers;
            constructor(buffOffset?: number, buffStride?: number, buffTexHeight?: number, texOffset?: Offset, texExtent?: Extent, texSubres?: TextureSubresLayers);
            copy(info: Readonly<BufferTextureCopy>): this;
        }
        export class Viewport {
            left: number;
            top: number;
            width: number;
            height: number;
            minDepth: number;
            maxDepth: number;
            constructor(left?: number, top?: number, width?: number, height?: number, minDepth?: number, maxDepth?: number);
            copy(info: Readonly<Viewport>): this;
        }
        export class Color {
            x: number;
            y: number;
            z: number;
            w: number;
            constructor(x?: number, y?: number, z?: number, w?: number);
            copy(info: Readonly<Color>): this;
        }
        export class BindingMappingInfo {
            maxBlockCounts: number[];
            maxSamplerTextureCounts: number[];
            maxSamplerCounts: number[];
            maxTextureCounts: number[];
            maxBufferCounts: number[];
            maxImageCounts: number[];
            maxSubpassInputCounts: number[];
            setIndices: number[];
            constructor(maxBlockCounts?: number[], maxSamplerTextureCounts?: number[], maxSamplerCounts?: number[], maxTextureCounts?: number[], maxBufferCounts?: number[], maxImageCounts?: number[], maxSubpassInputCounts?: number[], setIndices?: number[]);
            copy(info: Readonly<BindingMappingInfo>): this;
        }
        export class SwapchainInfo {
            windowHandle: HTMLCanvasElement;
            vsyncMode: VsyncMode;
            width: number;
            height: number;
            constructor(windowHandle?: HTMLCanvasElement, vsyncMode?: VsyncMode, width?: number, height?: number);
            copy(info: Readonly<SwapchainInfo>): this;
        }
        export class DeviceInfo {
            bindingMappingInfo: BindingMappingInfo;
            constructor(bindingMappingInfo?: BindingMappingInfo);
            copy(info: Readonly<DeviceInfo>): this;
        }
        export class BufferInfo {
            usage: BufferUsage;
            memUsage: MemoryUsage;
            size: number;
            stride: number;
            flags: BufferFlags;
            constructor(usage?: BufferUsage, memUsage?: MemoryUsage, size?: number, stride?: number, flags?: BufferFlags);
            copy(info: Readonly<BufferInfo>): this;
        }
        export class BufferViewInfo {
            buffer: Buffer;
            offset: number;
            range: number;
            constructor(buffer?: Buffer, offset?: number, range?: number);
            copy(info: Readonly<BufferViewInfo>): this;
        }
        export class DrawInfo {
            vertexCount: number;
            firstVertex: number;
            indexCount: number;
            firstIndex: number;
            vertexOffset: number;
            instanceCount: number;
            firstInstance: number;
            constructor(vertexCount?: number, firstVertex?: number, indexCount?: number, firstIndex?: number, vertexOffset?: number, instanceCount?: number, firstInstance?: number);
            copy(info: Readonly<DrawInfo>): this;
        }
        export class DispatchInfo {
            groupCountX: number;
            groupCountY: number;
            groupCountZ: number;
            indirectBuffer: Buffer | null;
            indirectOffset: number;
            constructor(groupCountX?: number, groupCountY?: number, groupCountZ?: number, indirectBuffer?: Buffer | null, indirectOffset?: number);
            copy(info: Readonly<DispatchInfo>): this;
        }
        export class IndirectBuffer {
            drawInfos: DrawInfo[];
            constructor(drawInfos?: DrawInfo[]);
            copy(info: Readonly<IndirectBuffer>): this;
        }
        export class TextureInfo {
            type: TextureType;
            usage: TextureUsage;
            format: Format;
            width: number;
            height: number;
            flags: TextureFlags;
            layerCount: number;
            levelCount: number;
            samples: SampleCount;
            depth: number;
            externalRes: number;
            constructor(type?: TextureType, usage?: TextureUsage, format?: Format, width?: number, height?: number, flags?: TextureFlags, layerCount?: number, levelCount?: number, samples?: SampleCount, depth?: number, externalRes?: number);
            copy(info: Readonly<TextureInfo>): this;
        }
        export class TextureViewInfo {
            texture: Texture;
            type: TextureType;
            format: Format;
            baseLevel: number;
            levelCount: number;
            baseLayer: number;
            layerCount: number;
            constructor(texture?: Texture, type?: TextureType, format?: Format, baseLevel?: number, levelCount?: number, baseLayer?: number, layerCount?: number);
            copy(info: Readonly<TextureViewInfo>): this;
        }
        export class Uniform {
            name: string;
            type: Type;
            count: number;
            constructor(name?: string, type?: Type, count?: number);
            copy(info: Readonly<Uniform>): this;
        }
        export class UniformBlock {
            set: number;
            binding: number;
            name: string;
            members: Uniform[];
            count: number;
            constructor(set?: number, binding?: number, name?: string, members?: Uniform[], count?: number);
            copy(info: Readonly<UniformBlock>): this;
        }
        export class UniformSamplerTexture {
            set: number;
            binding: number;
            name: string;
            type: Type;
            count: number;
            constructor(set?: number, binding?: number, name?: string, type?: Type, count?: number);
            copy(info: Readonly<UniformSamplerTexture>): this;
        }
        export class UniformSampler {
            set: number;
            binding: number;
            name: string;
            count: number;
            constructor(set?: number, binding?: number, name?: string, count?: number);
            copy(info: Readonly<UniformSampler>): this;
        }
        export class UniformTexture {
            set: number;
            binding: number;
            name: string;
            type: Type;
            count: number;
            constructor(set?: number, binding?: number, name?: string, type?: Type, count?: number);
            copy(info: Readonly<UniformTexture>): this;
        }
        export class UniformStorageImage {
            set: number;
            binding: number;
            name: string;
            type: Type;
            count: number;
            memoryAccess: MemoryAccess;
            constructor(set?: number, binding?: number, name?: string, type?: Type, count?: number, memoryAccess?: MemoryAccess);
            copy(info: Readonly<UniformStorageImage>): this;
        }
        export class UniformStorageBuffer {
            set: number;
            binding: number;
            name: string;
            count: number;
            memoryAccess: MemoryAccess;
            constructor(set?: number, binding?: number, name?: string, count?: number, memoryAccess?: MemoryAccess);
            copy(info: Readonly<UniformStorageBuffer>): this;
        }
        export class UniformInputAttachment {
            set: number;
            binding: number;
            name: string;
            count: number;
            constructor(set?: number, binding?: number, name?: string, count?: number);
            copy(info: Readonly<UniformInputAttachment>): this;
        }
        export class ShaderStage {
            stage: ShaderStageFlagBit;
            source: string;
            constructor(stage?: ShaderStageFlagBit, source?: string);
            copy(info: Readonly<ShaderStage>): this;
        }
        export class Attribute {
            name: string;
            format: Format;
            isNormalized: boolean;
            stream: number;
            isInstanced: boolean;
            location: number;
            constructor(name?: string, format?: Format, isNormalized?: boolean, stream?: number, isInstanced?: boolean, location?: number);
            copy(info: Readonly<Attribute>): this;
        }
        export class ShaderInfo {
            name: string;
            stages: ShaderStage[];
            attributes: Attribute[];
            blocks: UniformBlock[];
            buffers: UniformStorageBuffer[];
            samplerTextures: UniformSamplerTexture[];
            samplers: UniformSampler[];
            textures: UniformTexture[];
            images: UniformStorageImage[];
            subpassInputs: UniformInputAttachment[];
            constructor(name?: string, stages?: ShaderStage[], attributes?: Attribute[], blocks?: UniformBlock[], buffers?: UniformStorageBuffer[], samplerTextures?: UniformSamplerTexture[], samplers?: UniformSampler[], textures?: UniformTexture[], images?: UniformStorageImage[], subpassInputs?: UniformInputAttachment[]);
            copy(info: Readonly<ShaderInfo>): this;
        }
        export class InputAssemblerInfo {
            attributes: Attribute[];
            vertexBuffers: Buffer[];
            indexBuffer: Buffer | null;
            indirectBuffer: Buffer | null;
            constructor(attributes?: Attribute[], vertexBuffers?: Buffer[], indexBuffer?: Buffer | null, indirectBuffer?: Buffer | null);
            copy(info: Readonly<InputAssemblerInfo>): this;
        }
        export class ColorAttachment {
            format: Format;
            sampleCount: SampleCount;
            loadOp: LoadOp;
            storeOp: StoreOp;
            barrier: GeneralBarrier;
            isGeneralLayout: boolean;
            constructor(format?: Format, sampleCount?: SampleCount, loadOp?: LoadOp, storeOp?: StoreOp, barrier?: GeneralBarrier, isGeneralLayout?: boolean);
            copy(info: Readonly<ColorAttachment>): this;
        }
        export class DepthStencilAttachment {
            format: Format;
            sampleCount: SampleCount;
            depthLoadOp: LoadOp;
            depthStoreOp: StoreOp;
            stencilLoadOp: LoadOp;
            stencilStoreOp: StoreOp;
            barrier: GeneralBarrier;
            isGeneralLayout: boolean;
            constructor(format?: Format, sampleCount?: SampleCount, depthLoadOp?: LoadOp, depthStoreOp?: StoreOp, stencilLoadOp?: LoadOp, stencilStoreOp?: StoreOp, barrier?: GeneralBarrier, isGeneralLayout?: boolean);
            copy(info: Readonly<DepthStencilAttachment>): this;
        }
        export class SubpassInfo {
            inputs: number[];
            colors: number[];
            resolves: number[];
            preserves: number[];
            depthStencil: number;
            depthStencilResolve: number;
            depthResolveMode: ResolveMode;
            stencilResolveMode: ResolveMode;
            constructor(inputs?: number[], colors?: number[], resolves?: number[], preserves?: number[], depthStencil?: number, depthStencilResolve?: number, depthResolveMode?: ResolveMode, stencilResolveMode?: ResolveMode);
            copy(info: Readonly<SubpassInfo>): this;
        }
        export class SubpassDependency {
            srcSubpass: number;
            dstSubpass: number;
            generalBarrier: GeneralBarrier;
            bufferBarriers: __private._cocos_core_gfx_base_states_buffer_barrier__BufferBarrier;
            buffers: Buffer;
            bufferBarrierCount: number;
            textureBarriers: TextureBarrier;
            textures: Texture;
            textureBarrierCount: number;
            constructor(srcSubpass?: number, dstSubpass?: number, generalBarrier?: GeneralBarrier, bufferBarriers?: __private._cocos_core_gfx_base_states_buffer_barrier__BufferBarrier, buffers?: Buffer, bufferBarrierCount?: number, textureBarriers?: TextureBarrier, textures?: Texture, textureBarrierCount?: number);
            copy(info: Readonly<SubpassDependency>): this;
        }
        export class RenderPassInfo {
            colorAttachments: ColorAttachment[];
            depthStencilAttachment: DepthStencilAttachment;
            subpasses: SubpassInfo[];
            dependencies: SubpassDependency[];
            constructor(colorAttachments?: ColorAttachment[], depthStencilAttachment?: DepthStencilAttachment, subpasses?: SubpassInfo[], dependencies?: SubpassDependency[]);
            copy(info: Readonly<RenderPassInfo>): this;
        }
        export class GeneralBarrierInfo {
            prevAccesses: AccessFlags;
            nextAccesses: AccessFlags;
            type: BarrierType;
            constructor(prevAccesses?: AccessFlags, nextAccesses?: AccessFlags, type?: BarrierType);
            copy(info: Readonly<GeneralBarrierInfo>): this;
        }
        export class TextureBarrierInfo {
            prevAccesses: AccessFlags;
            nextAccesses: AccessFlags;
            type: BarrierType;
            baseMipLevel: number;
            levelCount: number;
            baseSlice: number;
            sliceCount: number;
            discardContents: boolean;
            srcQueue: Queue | null;
            dstQueue: Queue | null;
            constructor(prevAccesses?: AccessFlags, nextAccesses?: AccessFlags, type?: BarrierType, baseMipLevel?: number, levelCount?: number, baseSlice?: number, sliceCount?: number, discardContents?: boolean, srcQueue?: Queue | null, dstQueue?: Queue | null);
            copy(info: Readonly<TextureBarrierInfo>): this;
        }
        export class BufferBarrierInfo {
            prevAccesses: AccessFlags;
            nextAccesses: AccessFlags;
            type: BarrierType;
            offset: number;
            size: number;
            discardContents: boolean;
            srcQueue: Queue | null;
            dstQueue: Queue | null;
            constructor(prevAccesses?: AccessFlags, nextAccesses?: AccessFlags, type?: BarrierType, offset?: number, size?: number, discardContents?: boolean, srcQueue?: Queue | null, dstQueue?: Queue | null);
            copy(info: Readonly<BufferBarrierInfo>): this;
        }
        export class FramebufferInfo {
            renderPass: RenderPass;
            colorTextures: Texture[];
            depthStencilTexture: Texture | null;
            constructor(renderPass?: RenderPass, colorTextures?: Texture[], depthStencilTexture?: Texture | null);
            copy(info: Readonly<FramebufferInfo>): this;
        }
        export class DescriptorSetLayoutBinding {
            binding: number;
            descriptorType: DescriptorType;
            count: number;
            stageFlags: ShaderStageFlags;
            immutableSamplers: Sampler[];
            constructor(binding?: number, descriptorType?: DescriptorType, count?: number, stageFlags?: ShaderStageFlags, immutableSamplers?: Sampler[]);
            copy(info: Readonly<DescriptorSetLayoutBinding>): this;
        }
        export class DescriptorSetLayoutInfo {
            bindings: DescriptorSetLayoutBinding[];
            constructor(bindings?: DescriptorSetLayoutBinding[]);
            copy(info: Readonly<DescriptorSetLayoutInfo>): this;
        }
        export class DescriptorSetInfo {
            layout: DescriptorSetLayout;
            constructor(layout?: DescriptorSetLayout);
            copy(info: Readonly<DescriptorSetInfo>): this;
        }
        export class PipelineLayoutInfo {
            setLayouts: DescriptorSetLayout[];
            constructor(setLayouts?: DescriptorSetLayout[]);
            copy(info: Readonly<PipelineLayoutInfo>): this;
        }
        export class InputState {
            attributes: Attribute[];
            constructor(attributes?: Attribute[]);
            copy(info: Readonly<InputState>): this;
        }
        export class CommandBufferInfo {
            queue: Queue;
            type: CommandBufferType;
            constructor(queue?: Queue, type?: CommandBufferType);
            copy(info: Readonly<CommandBufferInfo>): this;
        }
        export class QueueInfo {
            type: QueueType;
            constructor(type?: QueueType);
            copy(info: Readonly<QueueInfo>): this;
        }
        export class QueryPoolInfo {
            type: QueryType;
            maxQueryObjects: number;
            forceWait: boolean;
            constructor(type?: QueryType, maxQueryObjects?: number, forceWait?: boolean);
            copy(info: Readonly<QueryPoolInfo>): this;
        }
        export class FormatInfo {
            readonly name: string;
            readonly size: number;
            readonly count: number;
            readonly type: FormatType;
            readonly hasAlpha: boolean;
            readonly hasDepth: boolean;
            readonly hasStencil: boolean;
            readonly isCompressed: boolean;
            constructor(name?: string, size?: number, count?: number, type?: FormatType, hasAlpha?: boolean, hasDepth?: boolean, hasStencil?: boolean, isCompressed?: boolean);
        }
        export class MemoryStatus {
            bufferSize: number;
            textureSize: number;
            constructor(bufferSize?: number, textureSize?: number);
            copy(info: Readonly<MemoryStatus>): this;
        }
        export class DynamicStencilStates {
            writeMask: number;
            compareMask: number;
            reference: number;
            constructor(writeMask?: number, compareMask?: number, reference?: number);
            copy(info: Readonly<DynamicStencilStates>): this;
        }
        export class DynamicStates {
            viewport: Viewport;
            scissor: Rect;
            blendConstant: Color;
            lineWidth: number;
            depthBiasConstant: number;
            depthBiasClamp: number;
            depthBiasSlope: number;
            depthMinBounds: number;
            depthMaxBounds: number;
            stencilStatesFront: DynamicStencilStates;
            stencilStatesBack: DynamicStencilStates;
            constructor(viewport?: Viewport, scissor?: Rect, blendConstant?: Color, lineWidth?: number, depthBiasConstant?: number, depthBiasClamp?: number, depthBiasSlope?: number, depthMinBounds?: number, depthMaxBounds?: number, stencilStatesFront?: DynamicStencilStates, stencilStatesBack?: DynamicStencilStates);
            copy(info: Readonly<DynamicStates>): this;
        }
        /**
         * ========================= !DO NOT CHANGE THE ABOVE SECTION MANUALLY! =========================
         * The above section is auto-generated from native/cocos/renderer/core/gfx/GFXDef-common.h
         * by the script native/tools/gfx-define-generator/generate.js.
         * Changes to these public interfaces should be made there first and synced back.
         * ========================= !DO NOT CHANGE THE ABOVE SECTION MANUALLY! =========================
         */
        /**
         * @en GFX base object.
         * @zh GFX 基类对象。
         */
        export class GFXObject extends __private._cocos_core_data_gc_object__GCObject {
            get objectType(): ObjectType;
            get objectID(): number;
            get typedID(): number;
            protected _objectType: ObjectType;
            protected _objectID: number;
            protected _typedID: number;
            constructor(objectType: ObjectType);
        }
        export interface ISwapchainTextureInfo {
            swapchain: Swapchain;
            format: Format;
            width: number;
            height: number;
        }
        export enum AttributeName {
            ATTR_POSITION = "a_position",
            ATTR_NORMAL = "a_normal",
            ATTR_TANGENT = "a_tangent",
            ATTR_BITANGENT = "a_bitangent",
            ATTR_WEIGHTS = "a_weights",
            ATTR_JOINTS = "a_joints",
            ATTR_COLOR = "a_color",
            ATTR_COLOR1 = "a_color1",
            ATTR_COLOR2 = "a_color2",
            ATTR_TEX_COORD = "a_texCoord",
            ATTR_TEX_COORD1 = "a_texCoord1",
            ATTR_TEX_COORD2 = "a_texCoord2",
            ATTR_TEX_COORD3 = "a_texCoord3",
            ATTR_TEX_COORD4 = "a_texCoord4",
            ATTR_TEX_COORD5 = "a_texCoord5",
            ATTR_TEX_COORD6 = "a_texCoord6",
            ATTR_TEX_COORD7 = "a_texCoord7",
            ATTR_TEX_COORD8 = "a_texCoord8",
            ATTR_BATCH_ID = "a_batch_id",
            ATTR_BATCH_UV = "a_batch_uv"
        }
        export const FormatInfos: readonly FormatInfo[];
        export const DESCRIPTOR_BUFFER_TYPE: number;
        export const DESCRIPTOR_SAMPLER_TYPE: number;
        export const DESCRIPTOR_DYNAMIC_TYPE: number;
        export const DRAW_INFO_SIZE = 28;
        export type BufferSource = ArrayBuffer | IndirectBuffer;
        export interface FormatAlignment {
            width: number;
            height: number;
        }
        /**
         * @en GFX Device.
         * @zh GFX 设备。
         */
        export abstract class Device {
            /**
             * @en Current rendering API.
             * @zh 当前 GFX 使用的渲染 API。
             */
            get gfxAPI(): API;
            /**
             * @en GFX default queue.
             * @zh GFX 默认队列。
             */
            get queue(): Queue;
            /**
             * @en GFX default command buffer.
             * @zh GFX 默认命令缓冲。
             */
            get commandBuffer(): CommandBuffer;
            /**
             * @en Renderer description.
             * @zh 渲染器描述。
             */
            get renderer(): string;
            /**
             * @en Vendor description.
             * @zh 厂商描述。
             */
            get vendor(): string;
            /**
             * @en Number of draw calls currently recorded.
             * @zh 绘制调用次数。
             */
            get numDrawCalls(): number;
            /**
             * @en Number of instances currently recorded.
             * @zh 绘制 Instance 数量。
             */
            get numInstances(): number;
            /**
             * @en Number of triangles currently recorded.
             * @zh 渲染三角形数量。
             */
            get numTris(): number;
            /**
             * @en Total memory size currently allocated.
             * @zh 内存状态。
             */
            get memoryStatus(): MemoryStatus;
            /**
             * @en Current device capabilities.
             * @zh 当前设备能力数据。
             */
            get capabilities(): DeviceCaps;
            /**
             * @en Current device binding mappings.
             * @zh 当前设备的绑定槽位映射关系。
             */
            get bindingMappingInfo(): BindingMappingInfo;
            protected _gfxAPI: API;
            protected _renderer: string;
            protected _vendor: string;
            protected _features: boolean[];
            protected _formatFeatures: FormatFeatureBit[];
            protected _queue: Queue | null;
            protected _cmdBuff: CommandBuffer | null;
            protected _numDrawCalls: number;
            protected _numInstances: number;
            protected _numTris: number;
            protected _memoryStatus: MemoryStatus;
            protected _caps: DeviceCaps;
            protected _bindingMappingInfo: BindingMappingInfo;
            protected _samplers: Map<number, Sampler>;
            protected _generalBarrierss: Map<number, GeneralBarrier>;
            protected _textureBarriers: Map<number, TextureBarrier>;
            protected _bufferBarriers: Map<number, __private._cocos_core_gfx_base_states_buffer_barrier__BufferBarrier>;
            static canvas: HTMLCanvasElement;
            abstract initialize(info: Readonly<DeviceInfo>): boolean;
            abstract destroy(): void;
            /**
             * @en Acquire next swapchain image.
             * @zh 获取下一个交换链缓冲。
             */
            abstract acquire(swapchains: Readonly<Swapchain[]>): void;
            /**
             * @en Present current swapchain image.
             * @zh 上屏当前交换链缓冲。
             */
            abstract present(): void;
            /**
             * @en Flush the specified command buffers.
             * @zh 实际录制指定的命令缓冲。
             */
            abstract flushCommands(cmdBuffs: Readonly<CommandBuffer[]>): void;
            /**
             * @en Create command buffer.
             * @zh 创建命令缓冲。
             * @param info GFX command buffer description info.
             */
            abstract createCommandBuffer(info: Readonly<CommandBufferInfo>): CommandBuffer;
            /**
             * @en Create swapchain.
             * @zh 创建交换链。
             * @param info GFX swapchain description info.
             */
            abstract createSwapchain(info: Readonly<SwapchainInfo>): Swapchain;
            /**
             * @en Create buffer.
             * @zh 创建缓冲。
             * @param info GFX buffer description info.
             */
            abstract createBuffer(info: Readonly<BufferInfo> | BufferViewInfo): Buffer;
            /**
             * @en Create texture.
             * @zh 创建纹理。
             * @param info GFX texture description info.
             */
            abstract createTexture(info: Readonly<TextureInfo> | TextureViewInfo): Texture;
            /**
             * @en Create descriptor sets.
             * @zh 创建描述符集组。
             * @param info GFX descriptor sets description info.
             */
            abstract createDescriptorSet(info: Readonly<DescriptorSetInfo>): DescriptorSet;
            /**
             * @en Create shader.
             * @zh 创建着色器。
             * @param info GFX shader description info.
             */
            abstract createShader(info: Readonly<ShaderInfo>): Shader;
            /**
             * @en Create input assembler.
             * @zh 创建纹理。
             * @param info GFX input assembler description info.
             */
            abstract createInputAssembler(info: Readonly<InputAssemblerInfo>): InputAssembler;
            /**
             * @en Create render pass.
             * @zh 创建渲染过程。
             * @param info GFX render pass description info.
             */
            abstract createRenderPass(info: Readonly<RenderPassInfo>): RenderPass;
            /**
             * @en Create frame buffer.
             * @zh 创建帧缓冲。
             * @param info GFX frame buffer description info.
             */
            abstract createFramebuffer(info: Readonly<FramebufferInfo>): Framebuffer;
            /**
             * @en Create descriptor set layout.
             * @zh 创建描述符集布局。
             * @param info GFX descriptor set layout description info.
             */
            abstract createDescriptorSetLayout(info: Readonly<DescriptorSetLayoutInfo>): DescriptorSetLayout;
            /**
             * @en Create pipeline layout.
             * @zh 创建管线布局。
             * @param info GFX pipeline layout description info.
             */
            abstract createPipelineLayout(info: Readonly<PipelineLayoutInfo>): PipelineLayout;
            /**
             * @en Create pipeline state.
             * @zh 创建管线状态。
             * @param info GFX pipeline state description info.
             */
            abstract createPipelineState(info: Readonly<PipelineStateInfo>): PipelineState;
            /**
             * @en Create queue.
             * @zh 创建队列。
             * @param info GFX queue description info.
             */
            abstract createQueue(info: Readonly<QueueInfo>): Queue;
            /**
             * @en Create sampler.
             * @zh 创建采样器。
             * @param info GFX sampler description info.
             */
            abstract getSampler(info: Readonly<SamplerInfo>): Sampler;
            /**
             * @en Get swapchains.
             * @zh 获取交换链列表。
             */
            abstract getSwapchains(): Readonly<Swapchain[]>;
            /**
             * @en Create global barrier.
             * @zh 创建全局内存屏障。
             * @param info GFX global barrier description info.
             */
            abstract getGeneralBarrier(info: Readonly<GeneralBarrierInfo>): GeneralBarrier;
            /**
             * @en Create texture barrier.
             * @zh 创建贴图内存屏障。
             * @param info GFX texture barrier description info.
             */
            abstract getTextureBarrier(info: Readonly<TextureBarrierInfo>): TextureBarrier;
            /**
             * @en Create buffer barrier.
             * @zh 创建buffer内存屏障。
             * @param info GFX buffer barrier description info.
             */
            abstract getBufferBarrier(info: Readonly<BufferBarrierInfo>): __private._cocos_core_gfx_base_states_buffer_barrier__BufferBarrier;
            /**
             * @en Copy buffers to texture.
             * @zh 拷贝缓冲到纹理。
             * @param buffers The buffers to be copied.
             * @param texture The texture to copy to.
             * @param regions The region descriptions.
             */
            abstract copyBuffersToTexture(buffers: Readonly<ArrayBufferView[]>, texture: Texture, regions: Readonly<BufferTextureCopy[]>): void;
            /**
             * @en Copy texture to buffers
             * @zh 拷贝纹理到缓冲
             * @param texture The texture to be copied.
             * @param buffers The buffer to copy to.
             * @param regions The region descriptions
             */
            abstract copyTextureToBuffers(texture: Readonly<Texture>, buffers: ArrayBufferView[], regions: Readonly<BufferTextureCopy[]>): void;
            /**
             * @en Copy texture images to texture.
             * @zh 拷贝图像到纹理。
             * @param texImages The texture to be copied.
             * @param texture The texture to copy to.
             * @param regions The region descriptions.
             */
            abstract copyTexImagesToTexture(texImages: Readonly<TexImageSource[]>, texture: Texture, regions: Readonly<BufferTextureCopy[]>): void;
            /**
             * @en Whether the device has specific feature.
             * @zh 是否具备特性。
             * @param feature The GFX feature to be queried.
             */
            hasFeature(feature: Feature): boolean;
            /**
             * @en The extent a specific format is supported by the backend.
             * @zh 后端对特定格式的支持程度。
             * @param format The GFX format to be queried.
             */
            getFormatFeatures(format: Format): FormatFeature;
        }
        /**
         * @en GFX Swapchain.
         * @zh GFX 交换链。
         */
        export abstract class Swapchain extends GFXObject {
            /**
             * @en The color texture of this swapchain.
             * @zh 当前交换链的颜色缓冲。
             */
            get colorTexture(): Texture;
            /**
             * @en The depth stencil texture of this swapchain.
             * @zh 当前交换链的深度模板缓冲。
             */
            get depthStencilTexture(): Texture;
            /**
             * @en The surface transform to be applied in projection matrices.
             * @zh 需要在投影矩阵中应用的表面变换。
             */
            get surfaceTransform(): SurfaceTransform;
            get width(): number;
            get height(): number;
            protected _transform: SurfaceTransform;
            protected _colorTexture: Texture;
            protected _depthStencilTexture: Texture;
            constructor();
            abstract initialize(info: Readonly<SwapchainInfo>): void;
            abstract resize(width: number, height: number, surfaceTransform: SurfaceTransform): void;
            abstract destroy(): void;
        }
        /**
         * @en GFX frame buffer.
         * @zh GFX 帧缓冲。
         */
        export abstract class Framebuffer extends GFXObject {
            /**
             * @en Get current render pass.
             * @zh GFX 渲染过程。
             */
            get renderPass(): RenderPass;
            /**
             * @en Get current color views.
             * @zh 颜色纹理视图数组。
             */
            get colorTextures(): (Texture | null)[];
            /**
             * @en Get current depth stencil views.
             * @zh 深度模板纹理视图。
             */
            get depthStencilTexture(): Texture | null;
            protected _renderPass: RenderPass | null;
            protected _colorTextures: (Texture | null)[];
            protected _depthStencilTexture: Texture | null;
            constructor();
            abstract initialize(info: Readonly<FramebufferInfo>): void;
            abstract destroy(): void;
        }
        /**
         * @en GFX input assembler.
         * @zh GFX 输入汇集器。
         */
        export abstract class InputAssembler extends GFXObject {
            /**
             * @en Get current attributes.
             * @zh 顶点属性数组。
             */
            get attributes(): Attribute[];
            /**
             * @en Get current vertex buffers.
             * @zh 顶点缓冲数组。
             */
            get vertexBuffers(): Buffer[];
            /**
             * @en Get current index buffer.
             * @zh 索引缓冲。
             */
            get indexBuffer(): Buffer | null;
            /**
             * @en Get the indirect buffer, if present.
             * @zh 间接绘制缓冲。
             */
            get indirectBuffer(): Buffer | null;
            /**
             * @en Get hash of current attributes.
             * @zh 获取顶点属性数组的哈希值。
             */
            get attributesHash(): number;
            /**
             * @en Get current vertex count.
             * @zh 顶点数量。
             */
            set vertexCount(count: number);
            get vertexCount(): number;
            /**
             * @en Get starting vertex.
             * @zh 起始顶点。
             */
            set firstVertex(first: number);
            get firstVertex(): number;
            /**
             * @en Get current index count.
             * @zh 索引数量。
             */
            set indexCount(count: number);
            get indexCount(): number;
            /**
             * @en Get starting index.
             * @zh 起始索引。
             */
            set firstIndex(first: number);
            get firstIndex(): number;
            /**
             * @en Get current vertex offset.
             * @zh 顶点偏移量。
             */
            set vertexOffset(offset: number);
            get vertexOffset(): number;
            /**
             * @en Get current instance count.
             * @zh 实例数量。
             */
            set instanceCount(count: number);
            get instanceCount(): number;
            /**
             * @en Get starting instance.
             * @zh 起始实例。
             */
            set firstInstance(first: number);
            get firstInstance(): number;
            /**
             * @en set the draw range
             * @zh 设置渲染范围
             */
            set drawInfo(info: DrawInfo);
            /**
             * @en get the draw range
             * @zh 获取渲染范围
             */
            get drawInfo(): DrawInfo;
            protected _attributes: Attribute[];
            protected _attributesHash: number;
            protected _vertexBuffers: Buffer[];
            protected _indexBuffer: Buffer | null;
            protected _indirectBuffer: Buffer | null;
            protected _drawInfo: DrawInfo;
            constructor();
            /**
             * @en Get the specified vertex buffer.
             * @zh 获取顶点缓冲。
             * @param stream The stream index of the vertex buffer.
             */
            getVertexBuffer(stream?: number): Buffer | null;
            protected computeAttributesHash(): number;
            abstract initialize(info: Readonly<InputAssemblerInfo>): void;
            abstract destroy(): void;
        }
        /**
         * @en GFX descriptor sets layout.
         * @zh GFX 描述符集布局。
         */
        export abstract class DescriptorSetLayout extends GFXObject {
            get bindings(): DescriptorSetLayoutBinding[];
            get bindingIndices(): number[];
            get descriptorIndices(): number[];
            protected _bindings: DescriptorSetLayoutBinding[];
            protected _bindingIndices: number[];
            protected _descriptorIndices: number[];
            constructor();
            abstract initialize(info: Readonly<DescriptorSetLayoutInfo>): void;
            abstract destroy(): void;
        }
        /**
         * @en GFX pipeline layout.
         * @zh GFX 管线布局。
         */
        export abstract class PipelineLayout extends GFXObject {
            get setLayouts(): DescriptorSetLayout[];
            protected _setLayouts: DescriptorSetLayout[];
            constructor();
            abstract initialize(info: Readonly<PipelineLayoutInfo>): void;
            abstract destroy(): void;
        }
        /**
         * @en GFX rasterizer state.
         * @zh GFX 光栅化状态。
         */
        export class RasterizerState {
            isDiscard: boolean;
            polygonMode: PolygonMode;
            shadeModel: ShadeModel;
            cullMode: CullMode;
            isFrontFaceCCW: boolean;
            depthBiasEnabled: boolean;
            depthBias: number;
            depthBiasClamp: number;
            depthBiasSlop: number;
            isDepthClip: boolean;
            isMultisample: boolean;
            lineWidth: number;
            get native(): this;
            constructor(isDiscard?: boolean, polygonMode?: PolygonMode, shadeModel?: ShadeModel, cullMode?: CullMode, isFrontFaceCCW?: boolean, depthBiasEnabled?: boolean, depthBias?: number, depthBiasClamp?: number, depthBiasSlop?: number, isDepthClip?: boolean, isMultisample?: boolean, lineWidth?: number);
            reset(): void;
            assign(rs: RasterizerState): void;
            destroy(): void;
        }
        /**
         * @en GFX depth stencil state.
         * @zh GFX 深度模板状态。
         */
        export class DepthStencilState {
            depthTest: boolean;
            depthWrite: boolean;
            depthFunc: ComparisonFunc;
            stencilTestFront: boolean;
            stencilFuncFront: ComparisonFunc;
            stencilReadMaskFront: number;
            stencilWriteMaskFront: number;
            stencilFailOpFront: StencilOp;
            stencilZFailOpFront: StencilOp;
            stencilPassOpFront: StencilOp;
            stencilRefFront: number;
            stencilTestBack: boolean;
            stencilFuncBack: ComparisonFunc;
            stencilReadMaskBack: number;
            stencilWriteMaskBack: number;
            stencilFailOpBack: StencilOp;
            stencilZFailOpBack: StencilOp;
            stencilPassOpBack: StencilOp;
            stencilRefBack: number;
            get native(): this;
            constructor(depthTest?: boolean, depthWrite?: boolean, depthFunc?: ComparisonFunc, stencilTestFront?: boolean, stencilFuncFront?: ComparisonFunc, stencilReadMaskFront?: number, stencilWriteMaskFront?: number, stencilFailOpFront?: StencilOp, stencilZFailOpFront?: StencilOp, stencilPassOpFront?: StencilOp, stencilRefFront?: number, stencilTestBack?: boolean, stencilFuncBack?: ComparisonFunc, stencilReadMaskBack?: number, stencilWriteMaskBack?: number, stencilFailOpBack?: StencilOp, stencilZFailOpBack?: StencilOp, stencilPassOpBack?: StencilOp, stencilRefBack?: number);
            reset(): void;
            assign(dss: DepthStencilState): void;
            destroy(): void;
        }
        /**
         * @en GFX blend target.
         * @zh GFX 混合目标。
         */
        export class BlendTarget {
            blend: boolean;
            blendSrc: BlendFactor;
            blendDst: BlendFactor;
            blendEq: BlendOp;
            blendSrcAlpha: BlendFactor;
            blendDstAlpha: BlendFactor;
            blendAlphaEq: BlendOp;
            blendColorMask: ColorMask;
            constructor(blend?: boolean, blendSrc?: BlendFactor, blendDst?: BlendFactor, blendEq?: BlendOp, blendSrcAlpha?: BlendFactor, blendDstAlpha?: BlendFactor, blendAlphaEq?: BlendOp, blendColorMask?: ColorMask);
            reset(): void;
            assign(target: BlendTarget): void;
            destroy(): void;
        }
        /**
         * @en GFX blend state.
         * @zh GFX 混合状态。
         */
        export class BlendState {
            isA2C: boolean;
            isIndepend: boolean;
            blendColor: Color;
            targets: BlendTarget[];
            get native(): this;
            constructor(isA2C?: boolean, isIndepend?: boolean, blendColor?: Color, targets?: BlendTarget[]);
            /**
             * @en Should use this function to set target, or it will not work
             * on native platforms, as native can not support this feature,
             * such as `blendState[i] = target;`.
             *
             * @param index The index to set target.
             * @param target The target to be set.
             */
            setTarget(index: number, target: BlendTarget): void;
            reset(): void;
            destroy(): void;
        }
        export class PipelineStateInfo {
            shader: Shader;
            pipelineLayout: PipelineLayout;
            renderPass: RenderPass;
            inputState: InputState;
            rasterizerState: RasterizerState;
            depthStencilState: DepthStencilState;
            blendState: BlendState;
            primitive: PrimitiveMode;
            dynamicStates: DynamicStateFlags;
            bindPoint: PipelineBindPoint;
            constructor(shader?: Shader, pipelineLayout?: PipelineLayout, renderPass?: RenderPass, inputState?: InputState, rasterizerState?: RasterizerState, depthStencilState?: DepthStencilState, blendState?: BlendState, primitive?: PrimitiveMode, dynamicStates?: DynamicStateFlags, bindPoint?: PipelineBindPoint);
        }
        /**
         * @en GFX pipeline state.
         * @zh GFX 管线状态。
         */
        export abstract class PipelineState extends GFXObject {
            /**
             * @en Get current shader.
             * @zh GFX 着色器。
             */
            get shader(): Shader;
            /**
             * @en Get current pipeline layout.
             * @zh GFX 管线布局。
             */
            get pipelineLayout(): PipelineLayout;
            /**
             * @en Get current primitve mode.
             * @zh GFX 图元模式。
             */
            get primitive(): PrimitiveMode;
            /**
             * @en Get current rasterizer state.
             * @zh GFX 光栅化状态。
             */
            get rasterizerState(): RasterizerState;
            /**
             * @en Get current depth stencil state.
             * @zh GFX 深度模板状态。
             */
            get depthStencilState(): DepthStencilState;
            /**
             * @en Get current blend state.
             * @zh GFX 混合状态。
             */
            get blendState(): BlendState;
            /**
             * @en Get current input state.
             * @zh GFX 输入状态。
             */
            get inputState(): InputState;
            /**
             * @en Get current dynamic states.
             * @zh GFX 动态状态数组。
             */
            get dynamicStates(): DynamicStateFlags;
            /**
             * @en Get current render pass.
             * @zh GFX 渲染过程。
             */
            get renderPass(): RenderPass;
            protected _shader: Shader | null;
            protected _pipelineLayout: PipelineLayout | null;
            protected _primitive: PrimitiveMode;
            protected _is: InputState | null;
            protected _rs: RasterizerState;
            protected _dss: DepthStencilState;
            protected _bs: BlendState;
            protected _dynamicStates: DynamicStateFlags;
            protected _renderPass: RenderPass | null;
            constructor();
            abstract initialize(info: Readonly<PipelineStateInfo>): void;
            abstract destroy(): void;
        }
        /**
         * @en GFX Queue.
         * @zh GFX 队列。
         */
        export abstract class Queue extends GFXObject {
            /**
             * @en Get current type.
             * @zh 队列类型。
             */
            get type(): number;
            protected _type: QueueType;
            constructor();
            abstract initialize(info: Readonly<QueueInfo>): void;
            abstract destroy(): void;
            /**
             * @en Submit command buffers.
             * @zh 提交命令缓冲数组。
             * @param cmdBuffs The command buffers to be submitted.
             * @param fence The syncing fence.
             */
            abstract submit(cmdBuffs: Readonly<CommandBuffer[]>): void;
        }
        /**
         * @en GFX render pass.
         * @zh GFX 渲染过程。
         */
        export abstract class RenderPass extends GFXObject {
            protected _colorInfos: ColorAttachment[];
            protected _depthStencilInfo: DepthStencilAttachment | null;
            protected _subpasses: SubpassInfo[];
            protected _hash: number;
            get colorAttachments(): Readonly<ColorAttachment[]>;
            get depthStencilAttachment(): Readonly<DepthStencilAttachment> | null;
            get subPasses(): Readonly<SubpassInfo[]>;
            get hash(): number;
            constructor();
            protected computeHash(): number;
            abstract initialize(info: Readonly<RenderPassInfo>): void;
            abstract destroy(): void;
        }
        /**
         * @en GFX shader.
         * @zh GFX 着色器。
         */
        export abstract class Shader extends GFXObject {
            get name(): string;
            get attributes(): Attribute[];
            get blocks(): UniformBlock[];
            get samplers(): UniformSampler[];
            protected _name: string;
            protected _stages: ShaderStage[];
            protected _attributes: Attribute[];
            protected _blocks: UniformBlock[];
            protected _samplers: UniformSampler[];
            constructor();
            abstract initialize(info: Readonly<ShaderInfo>): void;
            abstract destroy(): void;
        }
        /**
         * @en GFX texture.
         * @zh GFX 纹理。
         */
        export abstract class Texture extends GFXObject {
            /**
             * @en Get texture type.
             * @zh 纹理类型。
             */
            get type(): TextureType;
            /**
             * @en Get texture usage.
             * @zh 纹理使用方式。
             */
            get usage(): TextureUsage;
            /**
             * @en Get texture format.
             * @zh 纹理格式。
             */
            get format(): Format;
            /**
             * @en Get texture width.
             * @zh 纹理宽度。
             */
            get width(): number;
            /**
             * @en Get texture height.
             * @zh 纹理高度。
             */
            get height(): number;
            /**
             * @en Get texture depth.
             * @zh 纹理深度。
             */
            get depth(): number;
            /**
             * @en Get texture array layer.
             * @zh 纹理数组层数。
             */
            get layerCount(): number;
            /**
             * @en Get texture mip level.
             * @zh 纹理 mip 层级数。
             */
            get levelCount(): number;
            /**
             * @en Get texture samples.
             * @zh 纹理采样数。
             */
            get samples(): SampleCount;
            /**
             * @en Get texture flags.
             * @zh 纹理标识位。
             */
            get flags(): TextureFlags;
            /**
             * @en Get texture size.
             * @zh 纹理大小。
             */
            get size(): number;
            /**
             * @en Get texture info.
             * @zh 纹理信息。
             */
            get info(): Readonly<TextureInfo>;
            /**
             * @en Get view info.
             * @zh 纹理视图信息。
             */
            get viewInfo(): Readonly<TextureViewInfo>;
            /**
             * @en Get texture type.
             * @zh 是否为纹理视图。
             */
            get isTextureView(): boolean;
            protected _info: TextureInfo;
            protected _viewInfo: TextureViewInfo;
            protected _isPowerOf2: boolean;
            protected _isTextureView: boolean;
            protected _size: number;
            constructor();
            abstract initialize(info: Readonly<TextureInfo> | Readonly<TextureViewInfo>): void;
            abstract destroy(): void;
            /**
             * @en Resize texture.
             * @zh 重置纹理大小。
             * @param width The new width.
             * @param height The new height.
             */
            abstract resize(width: number, height: number): void;
            protected abstract initAsSwapchainTexture(info: Readonly<ISwapchainTextureInfo>): void;
            static getLevelCount(width: number, height: number): number;
        }
        /**
         * @en GFX global barrier.
         * @zh GFX 全局内存屏障。
         */
        export class GeneralBarrier extends GFXObject {
            get info(): Readonly<GeneralBarrierInfo>;
            get hash(): number;
            protected _info: GeneralBarrierInfo;
            protected _hash: number;
            constructor(info: Readonly<GeneralBarrierInfo>, hash: number);
            static computeHash(info: Readonly<GeneralBarrierInfo>): number;
        }
        /**
         * @en GFX texture barrier.
         * @zh GFX 贴图内存屏障。
         */
        export class TextureBarrier extends GFXObject {
            get info(): Readonly<TextureBarrierInfo>;
            get hash(): number;
            protected _info: TextureBarrierInfo;
            protected _hash: number;
            constructor(info: Readonly<TextureBarrierInfo>, hash: number);
            static computeHash(info: Readonly<TextureBarrierInfo>): number;
        }
        /**
         * @en
         * Sets the renderer type, only useful on web
         *
         * @zh
         * 渲染模式。
         * 设置渲染器类型，仅适用于 web 端
         * @internal
         */
        export enum LegacyRenderMode {
            /**
             * @en
             * Automatically chosen by engine.
             * @zh
             * 通过引擎自动选择。
             */
            AUTO = 0,
            /**
             * @en
             * Forced to use canvas renderer.
             * @zh
             * 强制使用 canvas 渲染。
             */
            CANVAS = 1,
            /**
             * @en
             * Forced to use WebGL renderer, but this will be ignored on mobile browsers.
             * @zh
             * 强制使用 WebGL 渲染，但是在部分 Android 浏览器中这个选项会被忽略。
             */
            WEBGL = 2,
            /**
             * @en
             * Use Headless Renderer, which is useful in test or server env, only for internal use by cocos team for now
             * @zh
             * 使用空渲染器，可以用于测试和服务器端环境，目前暂时用于 Cocos 内部测试使用。
             */
            HEADLESS = 3
        }
        /**
         * @internal
         */
        export enum RenderType {
            UNKNOWN = "Bad expression <-1>",
            CANVAS = 0,
            WEBGL = 1,
            OPENGL = 2,
            HEADLESS = 3
        }
        /**
         * @internal
         */
        export class DeviceManager {
            get gfxDevice(): Device;
            get swapchain(): Swapchain;
            init(canvas: HTMLCanvasElement | null, bindingMappingInfo: BindingMappingInfo): void;
        }
        /**
         * @internal
         */
        export const deviceManager: DeviceManager;
    }
    export const VERSION = "3.6.3";
    /**
     * @en The root manager of the renderer which manages all device resources and the render pipeline.
     * @zh 基础渲染器管理类，管理所有设备相关的资源创建以及渲染管线。
     */
    export class Root {
        /**
         * @en The GFX device
         * @zh GFX 设备
         */
        get device(): gfx.Device;
        /**
         * @en The main window
         * @zh 主窗口
         */
        get mainWindow(): __private._cocos_core_renderer_core_render_window__RenderWindow | null;
        /**
         * @en The current active window
         * @zh 当前激活的窗口
         */
        set curWindow(window: __private._cocos_core_renderer_core_render_window__RenderWindow | null);
        get curWindow(): __private._cocos_core_renderer_core_render_window__RenderWindow | null;
        /**
         * @e The temporary window for data transmission
         * @zh 临时窗口（用于数据传输）
         * @internal
         */
        set tempWindow(window: __private._cocos_core_renderer_core_render_window__RenderWindow | null);
        get tempWindow(): __private._cocos_core_renderer_core_render_window__RenderWindow | null;
        /**
         * @en The windows list
         * @zh 窗口列表
         */
        get windows(): __private._cocos_core_renderer_core_render_window__RenderWindow[];
        /**
         * @zh
         * 启用自定义渲染管线
         */
        get usesCustomPipeline(): boolean;
        /**
         * @en The render pipeline
         * @zh 渲染管线
         */
        get pipeline(): __private._cocos_core_pipeline_custom_pipeline__PipelineRuntime;
        /**
         * @en The custom render pipeline
         * @zh 自定义渲染管线
         */
        get customPipeline(): __private._cocos_core_pipeline_custom_pipeline__Pipeline;
        /**
         * @en The pipeline events
         * @zh 渲染管线事件
         */
        get pipelineEvent(): __private._cocos_core_pipeline_pipeline_event__IPipelineEvent;
        /**
         * @en The draw batch manager for 2D UI, for engine internal usage, user do not need to use this.
         * @zh 2D UI 渲染合批管理器，引擎内部使用，用户无需使用此接口
         */
        get batcher2D(): UI;
        /**
         * @en Render scenes list
         * @zh 渲染场景列表
         */
        get scenes(): renderer.RenderScene[];
        /**
         * @en The debug view manager for rendering
         * @zh 渲染调试管理器
         */
        get debugView(): DebugView;
        /**
         * @en The time cumulated in seconds since the game began running.
         * @zh 累计时间（秒）。
         */
        get cumulativeTime(): number;
        /**
         * @en The current frame time in seconds.
         * @zh 帧时间（秒）。
         */
        get frameTime(): number;
        /**
         * @en The frame count during the last second
         * @zh 一秒内的累计帧数
         */
        get frameCount(): number;
        /**
         * @en The recent frame rate for the last second
         * @zh 当前每秒帧率
         */
        get fps(): number;
        /**
         * @en The wanted frame rate set by user
         * @zh 每秒设定帧率
         */
        set fixedFPS(fps: number);
        get fixedFPS(): number;
        /**
         * @internal
         */
        get dataPoolManager(): __private._cocos_3d_skeletal_animation_data_pool_manager__DataPoolManager;
        /**
         * @en Whether the built-in deferred pipeline is used.
         * @zh 是否启用内置延迟渲染管线
         */
        get useDeferredPipeline(): boolean;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _createSceneFun: (root: Root) => renderer.RenderScene;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _createWindowFun: (root: Root) => __private._cocos_core_renderer_core_render_window__RenderWindow;
        /**
         * @en The constructor of the root, user shouldn't create the root instance, it's managed by the [[Director]].
         * @zh 构造函数，用户不应该自己创建任何 Root 对象，它是由 [[Director]] 管理的。
         * @param device GFX device
         */
        constructor(device: gfx.Device);
        /**
         * @en The initialization function, user shouldn't initialize the root, it's managed by the [[Director]].
         * @zh 初始化函数，用户不应该自己初始化 Root，它是由 [[Director]] 管理的。
         * @param info Root initialization information
         */
        initialize(info: __private._cocos_core_root__IRootInfo): void;
        /**
         * @en Destroy the root, user shouldn't invoke this function, it will cause undefined behavior.
         * @zh 销毁 Root，用户不应该调用此方法，会造成未知行为。
         */
        destroy(): void;
        /**
         * @en Resize the on-screen render windows.
         * @zh 重置在屏窗口的大小。
         * @param width The new width of the window.
         * @param height The new height of the window.
         */
        resize(width: number, height: number): void;
        /**
         * @en Setup the render pipeline
         * @zh 设置渲染管线
         * @param rppl The render pipeline
         * @returns The setup is successful or not
         */
        setRenderPipeline(rppl?: RenderPipeline): boolean;
        /**
         * @en Notify the pipeline and all scenes that the global pipeline state have been updated so that they can update their render data and states.
         * @zh 通知渲染管线和所有场景全局管线状态已更新，需要更新自身状态。
         */
        onGlobalPipelineStateChanged(): void;
        /**
         * @en Active the render window as the [[curWindow]]
         * @zh 激活指定窗口为当前窗口 [[curWindow]]
         * @param window The render window to be activated
         */
        activeWindow(window: __private._cocos_core_renderer_core_render_window__RenderWindow): void;
        /**
         * @en Reset the time cumulated
         * @zh 重置累计时间
         */
        resetCumulativeTime(): void;
        /**
         * @en The entry function of the render process for every frame.
         * @zh 用于每帧执行渲染流程的入口函数
         * @param deltaTime @en The delta time since last update. @zh 距离上一帧间隔时间
         */
        frameMove(deltaTime: number): void;
        /**
         * @en Create a render window
         * @zh 创建一个新的窗口
         * @param info @en The window creation information @zh 窗口描述信息
         */
        createWindow(info: __private._cocos_core_renderer_core_render_window__IRenderWindowInfo): __private._cocos_core_renderer_core_render_window__RenderWindow | null;
        /**
         * @en Destroy a render window
         * @zh 销毁指定的窗口
         * @param window The render window to be destroyed
         */
        destroyWindow(window: __private._cocos_core_renderer_core_render_window__RenderWindow): void;
        /**
         * @en Destroy all render windows
         * @zh 销毁全部窗口
         */
        destroyWindows(): void;
        /**
         * @en Create a render scene
         * @zh 创建渲染场景
         * @param info @en The creation information for render scene @zh 渲染场景描述信息
         */
        createScene(info: renderer.IRenderSceneInfo): renderer.RenderScene;
        /**
         * @en Destroy the given render scene
         * @zh 销毁指定的渲染场景
         * @param scene @en The render scene to be destroyed. @zh 要销毁的渲染场景
         */
        destroyScene(scene: renderer.RenderScene): void;
        /**
         * @en Destroy all render scenes.
         * @zh 销毁全部场景。
         */
        destroyScenes(): void;
        /**
         * @en Create a model
         * @zh 创建模型
         * @param ModelCtor @en The class of the model @zh 模型的类
         * @returns The model created
         */
        createModel<T extends renderer.scene.Model>(ModelCtor: typeof renderer.scene.Model): T;
        /**
         * @en Destroy the given model
         * @zh 销毁指定的模型
         * @param m @en The model to be destroyed @zh 要销毁的模型
         */
        destroyModel(m: renderer.scene.Model): void;
        /**
         * @en Create a camera
         * @zh 创建一个相机
         * @returns The camera created.
         */
        createCamera(): renderer.scene.Camera;
        /**
         * @en Create a light source
         * @zh 创建光源
         * @param LightCtor @en The class of the light @zh 光源的类
         * @returns The light created
         */
        createLight<T extends renderer.scene.Light>(LightCtor: new () => T): T;
        /**
         * @en Destroy the given light
         * @zh 销毁指定的光源
         * @param l @en The light to be destroyed @zh 要销毁的光源
         */
        destroyLight(l: renderer.scene.Light): void;
        /**
         * @en recycle the given light to light object pool
         * @zh 回收指定的光源到对象池
         * @param l @en The light to be recycled @zh 要回收的光源
         */
        recycleLight(l: renderer.scene.Light): void;
    }
    /**
     * @en
     * Define an BitMask type.
     * @zh
     * 定义一个位掩码类型。
     * @param obj
     * @en A JavaScript literal object containing BitMask names and values.
     * @zh 包含 BitMask 名称和值的 JavaScript 文字对象。
     * @return @en The defined BitMask type @zh 定义的位掩码类型。
     */
    export function BitMask<T>(obj: T): T;
    export namespace BitMask {
        export var isBitMask: (BitMaskType: any) => any;
        export var getList: (BitMaskDef: any) => any;
    }
    /**
     * @en
     * Define an enum type. <br/>
     * If a enum item has a value of -1, it will be given an Integer number according to it's order in the list.<br/>
     * Otherwise it will use the value specified by user who writes the enum definition.
     *
     * @zh
     * 定义一个枚举类型。<br/>
     * 用户可以把枚举值设为任意的整数，如果设为 -1，系统将会分配为上一个枚举值 + 1。
     *
     * @param obj
     * @en A JavaScript literal object containing enum names and values, or a TypeScript enum type.
     * @zh 包含枚举名和值的 JavaScript literal 对象，或者是一个 TypeScript enum 类型。
     * @return @en The defined enum type. @zh 定义的枚举类型。
     */
    export function Enum<T>(obj: T): T;
    export namespace Enum {
        export var update: <T>(obj: T) => T;
        export var isEnum: <EnumT extends {}>(enumType: EnumT) => boolean;
        export var getList: <EnumT extends {}>(enumType: EnumT) => readonly __private._cocos_core_value_types_enum__Enum.Enumerator<EnumT>[];
    }
    /**
     * Make the enum type `enumType` as enumeration so that Creator may identify, operate on it.
     * Formally, as a result of invocation on this function with enum type `enumType`:
     * - `Enum.isEnum(enumType)` returns `true`;
     * - `Enum.getList(enumType)` returns the enumerators of `enumType`.
     * @param
     * @en enumType An enum type, eg, a kind of type with similar semantic defined by TypeScript.
     * @zh 枚举类型，例如 TypeScript 中定义的类型。
     */
    export function ccenum<EnumT extends {}>(enumType: EnumT): void;
    /**
     * @en The base class of all value types.
     * @zh 所有值类型的基类。
     */
    export class ValueType {
        /**
         * @en
         * Clone the current object. The clone result of the object should be equal to the current object,
         * i.e. satisfy `this.equals(this, value.clone())`.
         * The base version of this method do nothing and returns `this'.
         * The derived class **must** rewrite this method and the returned object should not be `this`, i.e. satisfy `this !== this.clone()`.
         * @zh
         * 克隆当前值。克隆的结果值应与当前值相等，即满足 `this.equals(this, value.clone())`。
         * 本方法的基类版本简单地返回 `this`；
         * 派生类**必须**重写本方法，并且返回的对象不应当为 `this`，即满足 `this !== this.clone()`。
         * @returns @en The cloned object. @zh 克隆的对象。
         */
        clone(): ValueType;
        /**
         * @en
         * Check whether the current object is equal to the specified object.
         * This check should be interchangeable, i.e. satisfy `this.equals(other) === other.equals(this)`.
         * The base version of this method will returns `false'.
         * @zh
         * 判断当前值是否与指定值相等。此判断应当具有交换性，即满足 `this.equals(other) === other.equals(this)`。
         * 本方法的基类版本简单地返回 `false`。
         * @param other @en The other object @zh 指定值。
         * @returns @en `true` if equal, otherwise returns `false` @zh 如果相等，则返回 `true`，否则返回 `false`。
         */
        equals(other: this): boolean;
        /**
         * @en
         * Set the property values of the current object with the given object.
         * The base version of this method will returns `this' and the derived class **must** rewrite this method.
         * @zh
         * 赋值当前值使其与指定值相等。
         * 本方法的基类版本简单地返回 `this`，派生类**必须**重写本方法。
         * @param other @en The other object. @zh 指定值。
         */
        set(other: this): void;
        /**
         * @en
         * Convert the current object to a string.
         * The base version of this method will returns an empty string.
         * @zh
         * 返回当前值的字符串表示。
         * 本方法的基类版本返回空字符串。
         * @returns @en The string representation of the current value. @zh 当前值的字符串表示。
         */
        toString(): string;
    }
    /**
     * @en
     * Since the new Prefab system is not yet complete, the prefab that has a large difference with prefab asset cannot be automatically migrated.
     * This component is used to save the relationship between the node with the referenced prefab asset in the old Prefab system.
     * When the new Prefab system is complete, it will be automatically migrated to the new Prefab system.
     *
     * @zh
     * PrefabLink
     * 由于新的 Prefab 系统还不完善，所以旧的 Prefab 系统中和 Prefab 资源差异过大的 Prefab 无法实现自动迁移。
     * 此组件用于保存在旧 Prefab 系统中这个节点关联的 Prefab 资源，等新的 Prefab 系统完善，会自动迁移到新的 Prefab 系统上。
     */
    export class PrefabLink extends Component {
        prefab: Prefab | null;
    }
    export namespace js {
        /**
         * @en
         * ID generator for runtime.
         *
         * @zh
         * 运行时 ID 生成器
         */
        export class IDGenerator {
            /**
             * @en
             * The global id generator might have a conflict problem once every 365 days,
             * if the game runs at 60 FPS and each frame 4760273 counts of new id are requested.
             *
             * @zh
             * 全局的 id 生成器，如果游戏以 60 FPS 运行，每帧获取 4760273 个新 id, 则可能在 365 天后发生冲突。
             */
            static global: IDGenerator;
            id: number;
            prefix: string;
            /**
             * @en Construct a new id generator
             * @zh 构造一个新的 id 生成器
             *
             * @param [category] @en You can specify a unique category to avoid id collision with other instance of IdGenerator. @zh 你能指定一个唯一的标识用于避免与其他 id 生成器冲突
             */
            constructor(category?: string);
            getNewId(): string;
        }
        /**
         * @en
         * A fixed-length object pool designed for general type.<br>
         * The implementation of this object pool is very simple,
         * it can helps you to improve your game performance for objects which need frequent release and recreate operations<br/>
         * @zh
         * 长度固定的对象缓存池，可以用来缓存各种对象类型。<br/>
         * 这个对象池的实现非常精简，它可以帮助您提高游戏性能，适用于优化对象的反复创建和销毁。
         * @class js.Pool
         * @example
         * ```
         *
         * Example 1:
         *
         * function Details () {
         *     this.uuidList = [];
         * };
         * Details.prototype.reset = function () {
         *     this.uuidList.length = 0;
         * };
         * Details.pool = new js.Pool(function (obj) {
         *     obj.reset();
         * }, 5);
         * Details.pool.get = function () {
         *     return this._get() || new Details();
         * };
         *
         * var detail = Details.pool.get();
         * ...
         * Details.pool.put(detail);
         *
         * Example 2:
         *
         * function Details (buffer) {
         *    this.uuidList = buffer;
         * };
         * ...
         * Details.pool.get = function (buffer) {
         *     var cached = this._get();
         *     if (cached) {
         *         cached.uuidList = buffer;
         *         return cached;
         *     }
         *     else {
         *         return new Details(buffer);
         *     }
         * };
         *
         * var detail = Details.pool.get( [] );
         * ...
         * ```
         */
        export class Pool<T> {
            /**
             * @en
             * The current number of available objects, the default is 0, it will gradually increase with the recycle of the object,
             * the maximum will not exceed the size specified when the constructor is called.
             * @zh
             * 当前可用对象数量，一开始默认是 0，随着对象的回收会逐渐增大，最大不会超过调用构造函数时指定的 size。
             * @default 0
             */
            count: number;
            /**
             * @en
             * Get and initialize an object from pool. This method defaults to null and requires the user to implement it.
             * @zh
             * 获取并初始化对象池中的对象。这个方法默认为空，需要用户自己实现。
             * @param args - parameters to used to initialize the object
             */
            get(): T | null;
            /**
             * 使用构造函数来创建一个指定对象类型的对象池，您可以传递一个回调函数，用于处理对象回收时的清理逻辑。
             * @method constructor
             * @param {Function} [cleanupFunc] - the callback method used to process the cleanup logic when the object is recycled.
             * @param {Object} cleanupFunc.obj
             * @param {Number} size - initializes the length of the array
             */
            constructor(cleanup: __private._cocos_core_utils_pool__CleanUpFunction<T>, size: number);
            /**
             * 使用构造函数来创建一个指定对象类型的对象池，您可以传递一个回调函数，用于处理对象回收时的清理逻辑。
             * @method constructor
             * @param {Function} [cleanupFunc] - the callback method used to process the cleanup logic when the object is recycled.
             * @param {Object} cleanupFunc.obj
             * @param {Number} size - initializes the length of the array
             */
            constructor(size: number);
            /**
             * @en
             * Get an object from pool, if no available object in the pool, null will be returned.
             * @zh
             * 获取对象池中的对象，如果对象池没有可用对象，则返回空。
             *
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _get(): T | null;
            /**
             * @en Put an object into the pool.
             * @zh 向对象池返还一个不再需要的对象。
             */
            put(obj: T): void;
            /**
             * @en Resize the pool.
             * @zh 设置对象池容量。
             */
            resize(length: number): void;
        }
        export const array: typeof __private._cocos_core_utils_array;
        export const js: {
            IDGenerator: typeof IDGenerator;
            Pool: typeof Pool;
            array: typeof __private._cocos_core_utils_array;
            isNumber: typeof isNumber;
            isString: typeof isString;
            isEmptyObject: typeof isEmptyObject;
            getPropertyDescriptor: typeof getPropertyDescriptor;
            addon: typeof addon;
            mixin: typeof mixin;
            extend: typeof extend;
            getSuper: typeof getSuper;
            isChildClassOf: typeof isChildClassOf;
            clear: typeof clear;
            value: (object: Record<string | number, any>, propertyName: string, value_: any, writable?: boolean | undefined, enumerable?: boolean | undefined) => void;
            getset: (object: Record<string | number, any>, propertyName: string, getter: __private._types_globals__Getter, setter?: boolean | __private._types_globals__Setter | undefined, enumerable?: boolean, configurable?: boolean) => void;
            get: (object: Record<string | number, any>, propertyName: string, getter: __private._types_globals__Getter, enumerable?: boolean | undefined, configurable?: boolean | undefined) => void;
            set: (object: Record<string | number, any>, propertyName: string, setter: __private._types_globals__Setter, enumerable?: boolean | undefined, configurable?: boolean | undefined) => void;
            unregisterClass: typeof unregisterClass;
            getClassName: typeof getClassName;
            setClassName: typeof setClassName;
            setClassAlias: typeof setClassAlias;
            getClassByName: typeof getClassByName;
            getClassById: typeof getClassById;
            /**
             * @en All classes registered in the engine, indexed by name.
             * @zh 引擎中已注册的所有类型，通过名称进行索引。
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             * @example
             * ```
             * import { js } from 'cc';
             * // save all registered classes before loading scripts
             * let builtinClassIds = js._registeredClassIds;
             * let builtinClassNames = js._registeredClassNames;
             * // load some scripts that contain CCClass
             * ...
             * // clear all loaded classes
             * js._registeredClassIds = builtinClassIds;
             * js._registeredClassNames = builtinClassNames;
             * ```
             *
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _registeredClassNames: Record<string, __private._types_globals__Constructor<unknown>>;
            /**
             * @en All classes registered in the engine, indexed by ID.
             * @zh 引擎中已注册的所有类型，通过 ID 进行索引。
             * @example
             * ```
             * import { js } from 'cc';
             * // save all registered classes before loading scripts
             * let builtinClassIds = js._registeredClassIds;
             * let builtinClassNames = js._registeredClassNames;
             * // load some scripts that contain CCClass
             * ...
             * // clear all loaded classes
             * js._registeredClassIds = builtinClassIds;
             * js._registeredClassNames = builtinClassNames;
             * ```
             *
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _registeredClassIds: Record<string, __private._types_globals__Constructor<unknown>>;
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _getClassId: typeof _getClassId;
            getClassId: typeof getClassId;
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _setClassId: (id: string, constructor: __private._types_globals__Constructor<unknown>) => void;
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _getClassById: typeof _getClassById;
            obsolete: typeof obsolete;
            obsoletes: typeof obsoletes;
            formatStr: typeof formatStr;
            shiftArguments: typeof shiftArguments;
            createMap: typeof createMap;
        };
        /// <reference types="./@types/globals" />
        /**
         * @en
         * Check the object whether is number or not
         * If a number is created by using 'new Number(10086)', the typeof it will be "object"...
         * Then you can use this function if you care about this case.
         * @zh
         * 检查对象是否是 number 类型，如果通过 'new Number(10086)' 创建了一个数字，则使用 typeof 判断此数字时，将返回 'object' 类型，此时你可以通过此方法来进行判断
         * @param object object to be checked
         * @return whether this object is number or not
         */
        export function isNumber(object: any): boolean;
        /**
         * @en
         * Check the object whether is string or not.
         * If a string is created by using 'new String("blabla")', the typeof it will be "object"...
         * Then you can use this function if you care about this case.
         * @zh
         * 检查对象是否是 string 类型，如果通过 'new String("blabla")' 创建了一个字符串，则使用 typeof 判断此字符串时，将返回 'object' 类型，此时你可以通过此方法来进行判断
         * @param object object to be checked
         * @return whether this object is string or not
         */
        export function isString(object: any): boolean;
        /**
         * @en
         * Checks if the object `obj` does not have one or more enumerable properties (including properties from proto chain).
         * @zh
         * 检查此对象是否为空对象
         * @param obj The object.
         * @returns The result. Note that if the `obj` is not of type `'object'`, `true` is returned.
         */
        export function isEmptyObject(obj: any): boolean;
        /**
         * @en
         * A simple wrapper of `Object.create(null)` which ensures the return object have no prototype (and thus no inherited members).
         * This eliminates the need to make `hasOwnProperty` judgments when we look for values by key on the object,
         * which is helpful for performance in this case.
         * @zh
         * 该方法是对 `Object.create(null)` 的简单封装。
         * `Object.create(null)` 用于创建无 prototype （也就无继承）的空对象。
         * 这样我们在该对象上查找属性时，就不用进行 `hasOwnProperty` 判断，此时对性能提升有帮助。
         *
         * @param [forceDictMode=false] Apply the delete operator to newly created map object.
         * This causes V8 to put the object in "dictionary mode" and disables creation of hidden classes
         * which are very expensive for objects that are constantly changing shape.
         */
        export function createMap(forceDictMode?: boolean): any;
        /**
         * @en
         * Get class name of the object, if object is just a {} (and which class named 'Object'), it will return "".
         * (modified from <a href="http://stackoverflow.com/questions/1249531/how-to-get-a-javascript-objects-class">the code from this stackoverflow post</a>)
         * @zh
         * 获取对象的类型名称，如果对象是 {} 字面量，将会返回 ""
         * @param objOrCtor instance or constructor
         */
        export function getClassName(objOrCtor: any): string;
        /**
         * @en
         * Defines a polyfill field for obsoleted codes.
         * @zh
         * 为废弃代码定义一个填充字段
         * @param object - YourObject or YourClass.prototype
         * @param obsoleted - "OldParam" or "YourClass.OldParam"
         * @param newExpr - "NewParam" or "YourClass.NewParam"
         * @param  [writable=false]
         */
        export function obsolete(object: any, obsoleted: string, newExpr: string, writable?: boolean): void;
        /**
         * @en
         * Defines all polyfill fields for obsoleted codes corresponding to the enumerable properties of props.
         * @zh
         * 为所有可废弃属性定义填充字段
         * @param obj - YourObject or YourClass.prototype
         * @param objName - "YourObject" or "YourClass"
         * @param props
         * @param [writable=false]
         */
        export function obsoletes(obj: any, objName: any, props: any, writable: any): void;
        /**
         * @en
         * A string tool to construct a string with format string.
         * @zh
         * 通过格式字符串构造一个字符串
         * @param msg - A JavaScript string containing zero or more substitution strings (%s).
         * @param subst - JavaScript objects with which to replace substitution strings within msg.
         * This gives you additional control over the format of the output.
         * @example
         * ```
         * import { js } from 'cc';
         * js.formatStr("a: %s, b: %s", a, b);
         * js.formatStr(a, b, c);
         * ```
         */
        export function formatStr(msg: string, ...subst: any[]): string;
        export function shiftArguments(): any[];
        /**
         * Get property descriptor in object and all its ancestors.
         */
        export function getPropertyDescriptor(object: any, propertyName: string): PropertyDescriptor | null;
        export function copyAllProperties(source: any, target: any, excepts: Array<string>): void;
        /**
         * @en
         * Copy all properties not defined in object from arguments[1...n].
         * @zh
         * 如果目标对象上没有该属性，则将源对象属性拷贝到目标对象上
         * @param object Object to extend its properties.
         * @param sources Source object to copy properties from.
         * @return The result object.
         */
        export function addon(object?: Record<string | number, any>, ...sources: any[]): Record<string | number, any>;
        /**
         * @en
         * Copy all properties from arguments[1...n] to object.
         * @zh
         * 拷贝源对象所有属性到目标对象上，如果有属性冲突，则以源对象为准
         * @return The result object.
         */
        export function mixin(object?: Record<string | number, any>, ...sources: any[]): Record<string | number, any>;
        /**
         * @en
         * Derive the class from the supplied base class.
         * Both classes are just native javascript constructors, not created by `Class`, so
         * usually you will want to inherit using [[CCClass]] instead.
         * @zh
         * 将一个类型继承另一个类型
         * 两个类型都需要是 javascript 的构建函数，而不是 `Class`, 所以你通常可以用 [[CCClass]] 来代替
         * @param base The baseclass to inherit.
         * @return The result class.
         */
        export function extend(cls: Function, base: Function): Function | undefined;
        /**
         * @en
         * Get super class.
         * @zh
         * 获取父类
         * @param constructor The constructor of subclass.
         */
        export function getSuper(constructor: Function): any;
        /**
         * @en
         * Checks whether subclass is child of superclass or equals to superclass.
         * @zh
         * 判断一类型是否是另一类型的子类或本身
         * @param subclass sub class to be checked
         * @param superclass super class to be checked
         * @return whether subclass is child of superclass
         */
        export function isChildClassOf(subclass: unknown, superclass: unknown): boolean;
        /**
         * @en
         * Removes all enumerable properties from object.
         * @zh
         * 移除对象中所有可枚举属性
         */
        export function clear(object: Record<string | number, any>): void;
        /**
         * @en
         * Register the class by specified name manually
         * @zh
         * 通过指定的名称手动注册类型
         * @method setClassName
         * @param className
         * @param constructor
         */
        export function setClassName(className: string, constructor: __private._types_globals__Constructor): void;
        /**
         * @en Set an alias name for class.
         * If `setClassAlias(target, alias)`, `alias` will be a single way short cut for class `target`.
         * If you try `js.getClassByName(alias)`, you will get target.
         * But `js.getClassName(target)` will return the original name of `target`, not the alias.
         * @zh 为类设置别名。
         * 当 `setClassAlias(target, alias)` 后，
         * `alias` 将作为类 `target`的“单向 ID” 和“单向名称”。
         * 因此，`getClassById(alias)` 和 `getClassByName(alias)` 都会得到 `target`。
         * 这种映射是单向的，意味着 `getClassName(target)` 和 `getClassId(target)` 将不会是 `alias`。
         * @param target Constructor of target class.
         * @param alias Alias to set. The name shall not have been set as class name or alias of another class.
         */
        export function setClassAlias(target: __private._types_globals__Constructor, alias: string): void;
        /**
         * @en
         * Unregister a class from cocos.
         *
         * If you dont need a registered class anymore, you should unregister the class so that cocos will not keep its reference anymore.
         * Please note that its still your responsibility to free other references to the class.
         * @zh
         * 取消注册类型，如果你不再需要一个注册的类，你应该取消注册这个类，这样 cocos 就不会再保留它的引用。
         * 请注意，你仍然有责任释放对该类的其他引用。
         *
         * @param ...constructor - the class you will want to unregister, any number of classes can be added
         */
        export function unregisterClass(...constructors: Function[]): void;
        /**
         * @en
         * Get the registered class by id
         * @zh
         * 通过 id 获取已注册的类型
         * @param classId
         * @return constructor
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        export function _getClassById(classId: any): __private._types_globals__Constructor<unknown>;
        /**
         * @en
         * Get the registered class by id
         * @zh
         * 通过 id 获取已注册的类型
         * @param classId
         * @return constructor
         */
        export function getClassById(classId: any): __private._types_globals__Constructor<unknown>;
        /**
         * @en
         * Get the registered class by name
         * @zh
         * 通过名字获取已注册的类型
         * @param classname
         * @return constructor of the class
         */
        export function getClassByName(classname: any): __private._types_globals__Constructor<unknown>;
        /**
         * @en
         * Get class id of the object
         * @zh
         * 获取对象的 class id
         * @param obj - instance or constructor
         * @param [allowTempId = true]   - can return temp id in editor
         * @return
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        export function _getClassId(obj: any, allowTempId?: boolean): string;
        /**
         * @en
         * Get class id of the object
         * @zh
         * 获取对象的 class id
         * @param obj - instance or constructor
         * @param [allowTempId = true]   - can return temp id in editor
         * @return
         */
        export function getClassId(obj: any, allowTempId?: boolean): string;
        /**
         * @en
         * Define value, just help to call Object.defineProperty.<br>
         * The configurable will be true.
         * @zh
         * 定义值，帮助调用 Object.defineProperty.
         * 该属性默认可读写
         * @param [writable=false]
         * @param [enumerable=false]
         */
        export const value: (object: Record<string | number, any>, propertyName: string, value_: any, writable?: boolean, enumerable?: boolean) => void;
        /**
         * @en
         * Define get set accessor, just help to call Object.defineProperty(...).
         * @zh
         * 定义 get set 访问器，帮助调用 Object.defineProperty()
         * @param [setter=null]
         * @param [enumerable=false]
         * @param [configurable=false]
         */
        export const getset: (object: Record<string | number, any>, propertyName: string, getter: __private._types_globals__Getter, setter?: __private._types_globals__Setter | boolean, enumerable?: boolean, configurable?: boolean) => void;
        /**
         * @en
         * Define get accessor, just help to call Object.defineProperty(...).
         * @zh
         * 定义 get 访问器，帮助调用 Object.defineProperty()
         * @param [enumerable=false]
         * @param [configurable=false]
         */
        export const get: (object: Record<string | number, any>, propertyName: string, getter: __private._types_globals__Getter, enumerable?: boolean, configurable?: boolean) => void;
        /**
         * @en
         * Define set accessor, just help to call Object.defineProperty(...)
         * @zh
         * 定义 set 访问器，帮助调用 Object.defineProperty
         * @param [enumerable=false]
         * @param [configurable=false]
         */
        export const set: (object: Record<string | number, any>, propertyName: string, setter: __private._types_globals__Setter, enumerable?: boolean, configurable?: boolean) => void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        export const _idToClass: Record<string, __private._types_globals__Constructor>;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        export const _nameToClass: Record<string, __private._types_globals__Constructor>;
        /**
         * @en
         * Register the class by specified id, if its classname is not defined, the class name will also be set.
         * @zh
         * 通过 id 注册类型
         * @method _setClassId
         * @param classId
         * @param constructor
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        export const _setClassId: (id: string, constructor: __private._types_globals__Constructor) => void;
    }
    export namespace misc {
        export function pushToMap(map: any, key: any, value: any, pushFront: any): void;
        export function contains(refNode: any, otherNode: any): boolean;
        export function isDomNode(obj: any): boolean;
        export function callInNextTick(callback: any, p1?: any, p2?: any): void;
        export function tryCatchFunctor_EDITOR(funcName: any): Function;
        export function isPlainEmptyObj_DEV(obj: any): boolean;
        /**
         * @en Clamp a value between from and to. </br>
         * if the original value is larger than max_inclusive, return max_inclusive. </br>
         * if the original value is smaller than min_inclusive, return min_inclusive. </br>
         * else return the original value.
         * @zh 限定浮点数的最大最小值。<br/>
         * 数值大于 max_inclusive 则返回 max_inclusive。<br/>
         * 数值小于 min_inclusive 则返回 min_inclusive。<br/>
         * 否则返回自身。
         * @param value @en Original value @zh 初始值
         * @param min_inclusive @en Minimum value in between @zh 最小值
         * @param max_inclusive @en Maximum value in between @zh 最大值
         * @return {Number} @en The value clamped @zh 目标值
         * @example
         * var v1 = clampf(20, 0, 20); // 20;
         * var v2 = clampf(-1, 0, 20); //  0;
         * var v3 = clampf(10, 0, 20); // 10;
         */
        export function clampf(value: number, min_inclusive: number, max_inclusive: number): number;
        /**
         * @en converts degrees to radians
         * @zh 角度转弧度
         * @param angle @en The degree to convert @zh 角度
         * @return {Number} The radian. @zh 弧度
         */
        export function degreesToRadians(angle: number): number;
        /**
         * @en converts radians to degrees
         * @zh 弧度转角度
         * @param angle @en The radian to convert @zh 弧度
         * @return {Number} @en The degree @zh 角度
         */
        export function radiansToDegrees(angle: any): number;
        export const BUILTIN_CLASSID_RE: RegExp;
        export const BASE64_VALUES: number[];
    }
    export namespace path {
        /**
         * @en Join strings to be a path.
         * @zh 拼接字符串为路径。
         * @example {@link cocos/core/utils/CCPath/join.js}
         */
        export function join(...segments: string[]): string;
        /**
         * @en Get the ext name of a path including '.', like '.png'.
         * @zh 返回 Path 的扩展名，包括 '.'，例如 '.png'。
         * @example {@link cocos/core/utils/CCPath/extname.js}
         */
        export function extname(path: string): string;
        /**
         * @en Get the main name of a file name.
         * @zh 获取文件名的主名称。
         * @deprecated
         */
        export function mainFileName(fileName: string): string;
        /**
         * @en Get the file name of a file path.
         * @zh 获取文件路径的文件名。
         * @example {@link cocos/core/utils/CCPath/basename.js}
         */
        export function basename(path: string, extName?: string): string;
        /**
         * @en Get dirname of a file path.
         * @zh 获取文件路径的目录名。
         * @example {@link cocos/core/utils/CCPath/dirname.js}
         */
        export function dirname(path: string): string;
        /**
         * @en Change extname of a file path.
         * @zh 更改文件路径的扩展名。
         * @example {@link cocos/core/utils/CCPath/changeExtname.js}
         */
        export function changeExtname(path: string, extName?: string): string;
        /**
         * @en Change file name of a file path.
         * @zh 更改文件路径的文件名。
         * @example {@link cocos/core/utils/CCPath/changeBasename.js}
         */
        export function changeBasename(path: string, baseName: string, isSameExt?: boolean): string;
        export function _normalize(url: any): any;
        export function stripSep(path: string): string;
        export function getSeperator(): "/" | "\\";
    }
    /**
     * @deprecated since v3.6.0, this is an engine private interface that will be removed in the future.
     */
    export function setDefaultLogTimes(times: number): void;
    /**
     * @deprecated since v3.6.0, this is an engine private interface that will be removed in the future.
     */
    export let replaceProperty: (owner: object, ownerName: string, properties: __private._cocos_core_utils_x_deprecated__IReplacement[]) => void;
    /**
     * @deprecated since v3.6.0, this is an engine private interface that will be removed in the future.
     */
    export let removeProperty: (owner: object, ownerName: string, properties: __private._cocos_core_utils_x_deprecated__IRemoveItem[]) => void;
    /**
     * @deprecated since v3.6.0, this is an engine private interface that will be removed in the future.
     */
    export let markAsWarning: (owner: object, ownerName: string, properties: __private._cocos_core_utils_x_deprecated__IMarkItem[]) => void;
    /**
     * @en
     * Conversion of non-UI nodes to UI Node (Local) Space coordinate system.
     * @zh
     * 非 UI 节点转换到 UI 节点(局部) 空间坐标系。
     * @deprecated since Cocos Creator 3D v1.2, please use [[Camera.convertToUINode]]
     * @param mainCamera @en The main camera @zh 主相机
     * @param wpos @en The world space location. @zh 世界空间位置。
     * @param uiNode @en The UI node. @zh UI 节点。
     * @param out @en The output local position in UI @zh 返回 UI 节点局部坐标。
     */
    export function WorldNode3DToLocalNodeUI(mainCamera: Camera, wpos: math.Vec3, uiNode: Node, out?: math.Vec3): math.Vec3;
    /**
     * @en
     * Conversion of non-UI nodes to UI Node (World) Space coordinate system.
     * @zh
     * 非 UI 节点转换到 UI 节点(世界)空间坐标系。
     * @deprecated since Cocos Creator 3D v1.2, please use [[Camera.convertToUINode]]
     * @param mainCamera @en The main camera @zh 主相机
     * @param wpos @en The world space location. @zh 世界空间位置。
     * @param out @en The output world position in UI @zh 返回 UI 空间世界坐标。
     */
    export function WorldNode3DToWorldNodeUI(mainCamera: Camera, wpos: math.Vec3, out?: math.Vec3): math.Vec3;
    /**
     * @en It will be removed in v1.2. Please use [[Camera.convertToUINode]]。
     * @zh 将在 v1.2 移除，请使用 Camera 的 `convertToUINode`。
     * @deprecated since Cocos Creator 3D v1.2
     */
    export const convertUtils: {
        WorldNode3DToLocalNodeUI: typeof WorldNode3DToLocalNodeUI;
        WorldNode3DToWorldNodeUI: typeof WorldNode3DToWorldNodeUI;
    };
    export namespace _decorator {
        /**
         * @en
         * Marks the target class as "uniquely referenced" which means, in the aspect of serialization,
         * no more than one objects should reference to same instance of that class.
         * When serializing references to objects of such class,
         * they're treated as different object even they point to actually the same.
         * While deserializing, these two references would point two distinct objects.
         * For example:
         * ```ts
         * import { _decorator } from 'cc';
         * @_decorator.ccclass
         * @_decorator.uniquelyReferenced
         * class Foo { }
         *
         * @_decorator.ccclass
         * class Bar {
         *   @_decorator.property
         *   public foo = new Foo();
         * }
         *
         * const bar1 = new Bar();
         * const bar2 = new Bar();
         * bar2.foo = bar1.foo; // Programmatically let them reference to the same
         * ```
         * `bar1` and `bar2` reference to the same `Foo` object.
         * However, after deserializing, `bar1.foo === bar2.foo` always evaluates to `false`.
         * @zh
         * 将目标类标记为“被唯一引用”的，其意味着就序列化而言，不会有多个对象引用该类的同一实例。
         * 当序列化到该类的对象引用时，即使它们明面上指向同一对象，也会被当作是不同对象；
         * 而当反序列化后，这两个引用将指向截然不同的两个对象。
         * 例如：
         * ```ts
         * import { _decorator } from 'cc';
         * @_decorator.ccclass
         * @_decorator.uniquelyReferenced
         * class Foo { }
         *
         * @_decorator.ccclass
         * class Bar {
         *   @_decorator.property
         *   public foo = new Foo();
         * }
         *
         * const bar1 = new Bar();
         * const bar2 = new Bar();
         * bar2.foo = bar1.foo; // 由程序逻辑让它们引用同一个对象
         * ```
         * `bar1` 和 `bar2` 引用同一个 `Foo` 对象。
         * 但在反序列化之后，`bar1.foo === bar2.foo` 永不成立。
         */
        export const uniquelyReferenced: ClassDecorator;
        /**
         * @en Declare a standard class as a CCClass, please refer to the [document](https://docs.cocos.com/creator3d/manual/en/scripting/ccclass.html)
         * @zh 将标准写法的类声明为 CC 类，具体用法请参阅[类型定义](https://docs.cocos.com/creator3d/manual/zh/scripting/ccclass.html)。
         * @param name - The class name used for serialization.
         * @example
         * ```ts
         * import { _decorator, Component } from 'cc';
         * const {ccclass} = _decorator;
         *
         * // define a CCClass, omit the name
         *  @ccclass
         * class NewScript extends Component {
         *     // ...
         * }
         *
         * // define a CCClass with a name
         *  @ccclass('LoginData')
         * class LoginData {
         *     // ...
         * }
         * ```
         */
        export const ccclass: ((name?: string) => ClassDecorator) & ClassDecorator;
        /**
         * @en Declare as a CCClass property with options
         * @zh 声明属性为 CCClass 属性。
         * @param options property options
         */
        export function property(options?: __private._cocos_core_data_decorators_property__IPropertyOptions): __private._cocos_core_data_decorators_utils__LegacyPropertyDecorator;
        /**
         * @en Declare as a CCClass property with the property type
         * @zh 标注属性为 cc 属性。<br/>
         * 等价于`@property({type})`。
         * @param type A [[ccclass]] type or a [[ValueType]]
         */
        export function property(type: __private._cocos_core_data_decorators_property__PropertyType): __private._cocos_core_data_decorators_utils__LegacyPropertyDecorator;
        /**
         * @en Declare as a CCClass property
         * @zh 标注属性为 cc 属性。<br/>
         * 等价于`@property()`。
         */
        export function property(...args: Parameters<__private._cocos_core_data_decorators_utils__LegacyPropertyDecorator>): void;
        /**
         * @en Declare that the current component relies on another type of component.
         * If the required component doesn't exist, the engine will create a new empty instance of the required component and add to the node.
         * @zh 为声明为 CCClass 的组件添加依赖的其它组件。当组件添加到节点上时，如果依赖的组件不存在，引擎将会自动将依赖组件添加到同一个节点，防止脚本出错。该设置在运行时同样有效。
         * @param requiredComponent The required component type
         * @example
         * ```ts
         * import {_decorator, Sprite, Component} from cc;
         * import {ccclass, requireComponent} from _decorator;
         *
         * @ccclass
         * @requireComponent(Sprite)
         * class SpriteCtrl extends Component {
         *     // ...
         * }
         * ```
         */
        export const requireComponent: (requiredComponent: Function | Function[]) => ClassDecorator;
        /**
         * @en Set the component priority, it decides at which order the life cycle functions of components will be invoked. Smaller priority get invoked before larger priority.
         * This will affect `onLoad`, `onEnable`, `start`, `update` and `lateUpdate`, but `onDisable` and `onDestroy` won't be affected.
         * @zh 设置脚本生命周期方法调用的优先级。优先级小于 0 的组件将会优先执行，优先级大于 0 的组件将会延后执行。优先级仅会影响 onLoad, onEnable, start, update 和 lateUpdate，而 onDisable 和 onDestroy 不受影响。
         * @param priority - The execution order of life cycle methods for Component. Smaller priority get invoked before larger priority.
         * @example
         * ```ts
         * import { _decorator, Component } from 'cc';
         * const {ccclass, executionOrder} = _decorator;
         *
         * @ccclass
         * @executionOrder(1)
         * class CameraCtrl extends Component {
         *     // ...
         * }
         * ```
         */
        export const executionOrder: (priority: number) => ClassDecorator;
        /**
         * @en Forbid add multiple instances of the component to the same node.
         * @zh 防止多个相同类型（或子类型）的组件被添加到同一个节点。
         * @example
         * ```ts
         * import { _decorator, Component } from 'cc';
         * const {ccclass, disallowMultiple} = _decorator;
         *
         * @ccclass
         * @disallowMultiple
         * class CameraCtrl extends Component {
         *     // ...
         * }
         * ```
         */
        export const disallowMultiple: ClassDecorator & ((yes?: boolean) => ClassDecorator);
        export const allowReplicated: ClassDecorator;
        /**
         * @en Makes a CCClass that inherit from component execute in edit mode.<br/>
         * By default, all components are only executed in play mode,<br/>
         * which means they will not have their callback functions executed while the Editor is in edit mode.<br/>
         * @zh 允许继承自 Component 的 CCClass 在编辑器里执行。<br/>
         * 默认情况下，所有 Component 都只会在运行时才会执行，也就是说它们的生命周期回调不会在编辑器里触发。
         * @example
         * ```ts
         * import { _decorator, Component } from 'cc';
         * const {ccclass, executeInEditMode} = _decorator;
         *
         *  @ccclass
         *  @executeInEditMode
         * class NewScript extends Component {
         *     // ...
         * }
         * ```
         */
        export const executeInEditMode: ClassDecorator & ((yes?: boolean) => ClassDecorator);
        /**
         * @en Add the current component to the specific menu path in `Add Component` selector of the inspector panel
         * @zh 将当前组件添加到组件菜单中，方便用户查找。例如 "Rendering/CameraCtrl"。
         * @param path - The path is the menu represented like a pathname. For example the menu could be "Rendering/CameraCtrl".
         * @example
         * ```ts
         * import { _decorator, Component } from 'cc';
         * const {ccclass, menu} = _decorator;
         *
         * @ccclass
         * @menu("Rendering/CameraCtrl")
         * class NewScript extends Component {
         *     // ...
         * }
         * ```
         */
        export const menu: (path: string) => ClassDecorator;
        /**
         * @en When [[_decorator.executeInEditMode]] is set,
         * this decorator will make the editor running in high FPS mode when a node with the component is focused
         * @zh 当指定了 [[_decorator.executeInEditMode]] 以后，playOnFocus 可以在选中当前组件所在的节点时，提高编辑器的场景刷新频率到 60 FPS，否则场景就只会在必要的时候进行重绘。
         * @example
         * ```ts
         * import { _decorator, Component } from 'cc';
         * const {ccclass, playOnFocus, executeInEditMode} = _decorator;
         *
         * @ccclass
         * @executeInEditMode
         * @playOnFocus
         * class CameraCtrl extends Component {
         *     // ...
         * }
         * ```
         */
        export const playOnFocus: ClassDecorator & ((yes?: boolean) => ClassDecorator);
        /**
         * @en Use a customized inspector page in the **inspector**
         * @zh 自定义当前组件在 **属性检查器** 中渲染时所用的 UI 页面描述。
         * @param url The url of the page definition in js
         * @example
         * ```ts
         * import { _decorator, Component } from 'cc';
         * const {ccclass, inspector} = _decorator;
         *
         * @ccclass
         * @inspector("packages://inspector/inspectors/comps/camera-ctrl.js")
         * class NewScript extends Component {
         *     // ...
         * }
         * ```
         */
        export const inspector: (url: string) => ClassDecorator;
        /**
         * @en Define the icon of the component.
         * @zh 自定义当前组件在编辑器中显示的图标 url。
         * @param url
         * @private
         * @example
         * ```ts
         * import { _decorator, Component } from 'cc';
         * const {ccclass, icon} = _decorator;
         *
         *  @ccclass
         *  @icon("xxxx.png")
         * class NewScript extends Component {
         *     // ...
         * }
         * ```
         */
        export const icon: (url: string) => ClassDecorator;
        /**
         * @en Define the help documentation url,
         * if given, the component section in the **Inspector** will have a help documentation icon reference to the web page given.
         * @zh 指定当前组件的帮助文档的 url，设置过后，在 **属性检查器** 中就会出现一个帮助图标，用户点击将打开指定的网页。
         * @param url The url of the help documentation
         * @example
         * ```ts
         * import { _decorator, Component } from 'cc';
         * const {ccclass, help} = _decorator;
         *
         * @ccclass
         * @help("app://docs/html/components/spine.html")
         * class NewScript extends Component {
         *     // ...
         * }
         * ```
         */
        export const help: (url: string) => ClassDecorator;
        /**
         * @en Declare the property as the given type
         * @zh 标记该属性的类型。
         * @param type
         */
        export function type(type: Function | [
            Function
        ] | any): PropertyDecorator;
        export function type<T>(type: __private._cocos_core_data_utils_attribute__PrimitiveType<T> | [
            __private._cocos_core_data_utils_attribute__PrimitiveType<T>
        ]): PropertyDecorator;
        /**
         * @en Declare the property as integer
         * @zh 将该属性标记为整数。
         */
        export const integer: PropertyDecorator;
        /**
         * @en Declare the property as float
         * @zh 将该属性标记为浮点数。
         */
        export const float: PropertyDecorator;
        /**
         * @en Declare the property as boolean
         * @zh 将该属性标记为布尔值。
         */
        export const boolean: PropertyDecorator;
        /**
         * @en Declare the property as string
         * @zh 将该属性标记为字符串。
         */
        export const string: PropertyDecorator;
    }
    export function CCClass<TFunction>(options: {
        name?: string;
        extends: null | (Function & {
            __props__?: any;
            _sealed?: boolean;
        });
        ctor: TFunction;
        properties?: any;
        editor?: any;
    }): any;
    export namespace CCClass {
        export var _isCCClass: (constructor: any) => boolean;
        export var fastDefine: (className: any, constructor: any, serializableFields: any) => void;
        export var Attr: typeof __private._cocos_core_data_utils_attribute;
        export var attr: typeof __private._cocos_core_data_utils_attribute.attr;
        export var isCCClassOrFastDefined: typeof __private._cocos_core_data_class__isCCClassOrFastDefined;
        export var getInheritanceChain: (constructor: any) => any[];
        export var isArray: (defaultVal: any) => boolean;
        export var getDefault: (defaultVal: any) => any;
        export var escapeForJS: (s: any) => string;
        export var IDENTIFIER_RE: RegExp;
        export var getNewValueTypeCode: (value: any) => string;
    }
    /**
     * @en
     * The base class of most of all the objects in Fireball.
     * @zh
     * 大部分对象的基类。
     * @private
     */
    export class CCObject implements __private._cocos_core_data_editor_extras_tag__EditorExtendableObject {
        static _deferredDestroy(): void;
        /**
         * @internal
         */
        [editorExtrasTag]: unknown;
        /**
         * @internal
         */
        _objFlags: number;
        protected _name: string;
        constructor(name?: string);
        /**
         * @en The name of the object.
         * @zh 该对象的名称。
         * @default ""
         * @example
         * ```
         * obj.name = "New Obj";
         * ```
         */
        get name(): string;
        set name(value: string);
        /**
         * @en After inheriting CCObject objects, control whether you need to hide, lock, serialize, and other functions.
         * @zh 在继承 CCObject 对象后，控制是否需要隐藏，锁定，序列化等功能。
         */
        set hideFlags(hideFlags: CCObject.Flags);
        get hideFlags(): CCObject.Flags;
        set replicated(value: boolean);
        get replicated(): boolean;
        /**
         * @en
         * Indicates whether the object is not yet destroyed. (It will not be available after being destroyed)<br>
         * When an object's `destroy` is called, it is actually destroyed after the end of this frame.
         * So `isValid` will return false from the next frame, while `isValid` in the current frame will still be true.
         * If you want to determine whether the current frame has called `destroy`, use `isValid(obj, true)`,
         * but this is often caused by a particular logical requirements, which is not normally required.
         *
         * @zh
         * 表示该对象是否可用（被 destroy 后将不可用）。<br>
         * 当一个对象的 `destroy` 调用以后，会在这一帧结束后才真正销毁。<br>
         * 因此从下一帧开始 `isValid` 就会返回 false，而当前帧内 `isValid` 仍然会是 true。<br>
         * 如果希望判断当前帧是否调用过 `destroy`，请使用 `isValid(obj, true)`，不过这往往是特殊的业务需求引起的，通常情况下不需要这样。
         * @default true
         * @readOnly
         * @example
         * ```ts
         * import { Node, log } from 'cc';
         * const node = new Node();
         * log(node.isValid);    // true
         * node.destroy();
         * log(node.isValid);    // true, still valid in this frame
         * // after a frame...
         * log(node.isValid);    // false, destroyed in the end of last frame
         * ```
         */
        get isValid(): boolean;
        /**
         * @en
         * Destroy this Object, and release all its own references to other objects.<br/>
         * Actual object destruction will delayed until before rendering.
         * From the next frame, this object is not usable any more.
         * You can use `isValid(obj)` to check whether the object is destroyed before accessing it.
         * @zh
         * 销毁该对象，并释放所有它对其它对象的引用。<br/>
         * 实际销毁操作会延迟到当前帧渲染前执行。从下一帧开始，该对象将不再可用。
         * 您可以在访问对象之前使用 `isValid(obj)` 来检查对象是否已被销毁。
         * @return whether it is the first time the destroy being called
         * @example
         * ```
         * obj.destroy();
         * ```
         */
        destroy(): boolean;
        /**
         * @en
         * Clear all references in the instance.
         *
         * NOTE: this method will not clear the getter or setter functions which defined in the instance of CCObject.
         *
         * @zh
         * 清理实例的所有引用
         * 注意：此方法不会清理实例上的 getter 与 setter 方法。
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         * @example
         * ```
         * // You can override the _destruct method if you need, for example:
         *       _destruct: function () {
         *           for (var key in this) {
         *               if (this.hasOwnProperty(key)) {
         *                   switch (typeof this[key]) {
         *                       case 'string':
         *                           this[key] = '';
         *                           break;
         *                       case 'object':
         *                       case 'function':
         *                           this[key] = null;
         *                           break;
         *               }
         *           }
         *       }
         * ```
         */
        _destruct(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _destroyImmediate(): void;
    }
    export namespace CCObject {
        export enum Flags {
            Destroyed,
            /**
             * @en The object will not be saved.
             * @zh 该对象将不会被保存。
             */
            DontSave,
            /**
             * @en The object will not be saved when building a player.
             * @zh 构建项目时，该对象将不会被保存。
             */
            EditorOnly,
            Dirty,
            /**
             * @en Dont destroy automatically when loading a new scene.
             * @zh 加载一个新场景时，不自动删除该对象。
             * @private
             */
            DontDestroy,
            /**
             * @en
             * @zh
             * @private
             */
            PersistentMask,
            /**
             * @en
             * @zh
             * @private
             */
            Destroying,
            /**
             * @en The node is deactivating.
             * @zh 节点正在反激活的过程中。
             * @private
             */
            Deactivating,
            /**
             * @en
             * Hide in game and hierarchy.
             * This flag is readonly, it can only be used as an argument of scene.addEntity() or Entity.createWithFlags().
             * @zh
             * 在游戏和层级中隐藏该对象。<br/>
             * 该标记只读，它只能被用作 scene.addEntity()的一个参数。
             */
            /**
             * @en The lock node, when the node is locked, cannot be clicked in the scene.
             * @zh 锁定节点，锁定后场景内不能点击。
             * @private
             */
            LockedInEditor,
            /**
             * @en Hide the object in editor.
             * @zh 在编辑器中隐藏该对象。
             */
            HideInHierarchy,
            /**
             * @en The object will not be saved and hide the object in editor,and lock node, when the node is locked,
             * cannot be clicked in the scene,and The object will not be saved when building a player.
             * @zh 该对象将不会被保存,构建项目时，该对象将不会被保存, 锁定节点，锁定后场景内不能点击, 在编辑器中隐藏该对象。
             */
            AllHideMasks,
            /**
             * @en
             * Hide in game view, hierarchy, and scene view... etc.
             * This flag is readonly, it can only be used as an argument of scene.addEntity() or Entity.createWithFlags().
             * @zh
             * 在游戏视图，层级，场景视图等等...中隐藏该对象。
             * 该标记只读，它只能被用作 scene.addEntity()的一个参数。
             */
            IsPreloadStarted,
            IsOnLoadStarted,
            IsOnLoadCalled,
            IsOnEnableCalled,
            IsStartCalled,
            IsEditorOnEnableCalled,
            IsPositionLocked,
            IsRotationLocked,
            IsScaleLocked,
            IsAnchorLocked,
            IsSizeLocked,
            IsReplicated,
            IsClientLoad
        }
        export let __props__: string[];
        export let __values__: string[];
    }
    export function isValid(value: any, strictMode?: boolean): boolean;
    /**
     * @module cc
     */
    /**
     * @en Deserializes a previously serialized object to reconstruct it to the original.
     * @zh 将序列化后的对象进行反序列化以使其复原。
     *
     * @param data Serialized data.
     * @param details - Additional loading result.
     * @param options Deserialization Options.
     * @return The original object.
     */
    export function deserialize(data: __private._cocos_core_data_deserialize__IFileData | string | CCON | any, details: Details | any, options?: __private._cocos_core_data_deserialize__IOptions | any): unknown;
    export namespace deserialize {
        export namespace Internal {
            export type SharedString_ = __private._cocos_core_data_deserialize__SharedString;
            export type Empty_ = __private._cocos_core_data_deserialize__Empty;
            export type StringIndex_ = __private._cocos_core_data_deserialize__StringIndex;
            export type InstanceIndex_ = __private._cocos_core_data_deserialize__InstanceIndex;
            export type StringIndexBnotNumber_ = __private._cocos_core_data_deserialize__StringIndexBnotNumber;
            export const enum DataTypeID_ {
                SimpleType = 0,
                InstanceRef = 1,
                Array_InstanceRef = 2,
                Array_AssetRefByInnerObj = 3,
                Class = 4,
                ValueTypeCreated = 5,
                AssetRefByInnerObj = 6,
                TRS = 7,
                ValueType = 8,
                Array_Class = 9,
                CustomizedClass = 10,
                Dict = 11,
                Array = 12,
                ARRAY_LENGTH = 13
            }
            export type DataTypes_ = __private._cocos_core_data_deserialize__DataTypes;
            export type AnyData_ = __private._cocos_core_data_deserialize__AnyData;
            export type OtherObjectData_ = __private._cocos_core_data_deserialize__OtherObjectData;
            export type OtherObjectTypeID_ = __private._cocos_core_data_deserialize__OtherObjectTypeID;
            export type AnyCCClass_ = __private._cocos_core_data_deserialize__AnyCCClass;
            export type IClass_ = __private._cocos_core_data_deserialize__IClass;
            export type IMask_ = __private._cocos_core_data_deserialize__IMask;
            export type IClassObjectData_ = __private._cocos_core_data_deserialize__IClassObjectData;
            export type ICustomObjectDataContent_ = __private._cocos_core_data_deserialize__ICustomObjectDataContent;
            export type ICustomObjectData_ = __private._cocos_core_data_deserialize__ICustomObjectData;
            export type ITRSData_ = __private._cocos_core_data_deserialize__ITRSData;
            export type IDictData_ = __private._cocos_core_data_deserialize__IDictData;
            export type IArrayData_ = __private._cocos_core_data_deserialize__IArrayData;
            export const enum Refs_ {
                EACH_RECORD_LENGTH = 3,
                OWNER_OFFSET = 0,
                KEY_OFFSET = 1,
                TARGET_OFFSET = 2
            }
            export type IRefs_ = __private._cocos_core_data_deserialize__IRefs;
            export const enum File_ {
                Version = 0,
                Context = 0,
                SharedUuids = 1,
                SharedStrings = 2,
                SharedClasses = 3,
                SharedMasks = 4,
                Instances = 5,
                InstanceTypes = 6,
                Refs = 7,
                DependObjs = 8,
                DependKeys = 9,
                DependUuidIndices = 10,
                ARRAY_LENGTH = 11
            }
            export type IFileData_ = __private._cocos_core_data_deserialize__IFileData;
            export type IPackedFileData_ = __private._cocos_core_data_deserialize__IPackedFileData;
        }
        export var Details: typeof _Details;
        export var reportMissingClass: typeof __private._cocos_core_data_report_missing_class__reportMissingClass;
        export var isCompiledJson: typeof __private._cocos_core_data_deserialize__isCompiledJson;
        export var _macros: {
            EMPTY_PLACEHOLDER: 0;
            CUSTOM_OBJ_DATA_CLASS: 0;
            CUSTOM_OBJ_DATA_CONTENT: 1;
            CLASS_TYPE: 0;
            CLASS_KEYS: 1;
            CLASS_PROP_TYPE_OFFSET: 2;
            MASK_CLASS: 0;
            OBJ_DATA_MASK: 0;
            DICT_JSON_LAYOUT: 0;
            ARRAY_ITEM_VALUES: 0;
            PACKED_SECTIONS: Internal.File_.Instances;
        };
        export var _BuiltinValueTypes: (typeof ValueType)[];
        export var _serializeBuiltinValueTypes: typeof __private._cocos_core_data_deserialize__serializeBuiltinValueTypes;
        export type SerializableClassConstructor = new () => unknown;
        export type ReportMissingClass = (id: string) => void;
        export type ClassFinder = {
            (id: string, serialized: unknown, owner?: unknown[] | Record<PropertyKey, unknown>, propName?: string): SerializableClassConstructor | undefined;
            onDereferenced?: (deserializedList: Array<Record<PropertyKey, unknown> | undefined>, id: number, object: Record<string, unknown> | unknown[], propName: string) => void;
        };
    }
    /** **************************************************************************
     * IMPLEMENTS
     *************************************************************************** */
    /**
     * @en Contains information collected during deserialization
     * @zh 包含反序列化时的一些信息。
     * @class Details
     */
    export class Details {
        /**
         * @en
         * the object list whose field needs to load asset by uuid
         * @zh
         * 对象列表，其中每个对象有属性需要通过 uuid 进行资源加载
         */
        uuidObjList: __private._cocos_core_data_deserialize__IFileData[deserialize.Internal.File_.DependObjs] | null;
        /**
         * @en
         * the corresponding field name which referenced to the asset
         * @zh
         * 引用着资源的字段名称
         */
        uuidPropList: __private._cocos_core_data_deserialize__IFileData[deserialize.Internal.File_.DependKeys] | null;
        /**
         * @en
         * list of the depends assets' uuid
         * @zh
         * 依赖资源的 uuid 列表
         */
        uuidList: __private._cocos_core_data_deserialize__IFileData[deserialize.Internal.File_.DependUuidIndices] | null;
        /**
         * @en
         * list of the depends assets' type
         * @zh
         * 依赖的资源类型列表
         */
        uuidTypeList: string[];
        static pool: js.Pool<Details>;
        assignAssetsBy: (getter: (uuid: string, options: {
            type: __private._types_globals__Constructor<Asset>;
            owner: Record<string, unknown>;
            prop: string;
        }) => Asset) => void;
        /**
         * @method init
         * @param {Object} data
         */
        init(data?: __private._cocos_core_data_deserialize__IFileData): void;
        /**
         * @method reset
         */
        reset(): void;
        /**
         * @method push
         * @param {Object} obj
         * @param {String} propName
         * @param {String} uuid
         */
        push(obj: object, propName: string, uuid: string, type?: string): void;
    }
    /**
     * @internal DO NOT USE IT IN YOUR CODES.
     * @param constructor
     * @returns
     */
    export function getSerializationMetadata(constructor: Function): SerializationMetadata | undefined;
    /**
     * @internal For internal usage only. DO NOT USE IT IN YOUR CODES.
     */
    export interface SerializationMetadata {
        uniquelyReferenced?: boolean;
    }
    /**
     * @zh 从 Prefab 实例化出新节点。
     * @en Instantiate a node from the Prefab.
     * @param prefab The prefab.
     * @returns The instantiated node.
     * @example
     * ```ts
     * import { instantiate, director } from 'cc';
     * // Instantiate node from prefab.
     * const node = instantiate(prefabAsset);
     * node.parent = director.getScene();
     * ```
     */
    export function instantiate(prefab: Prefab): Node;
    /**
     * @en Clones the object `original.
     * @zh 克隆指定的任意类型的对象。
     * @param original An existing object that you want to make a copy of.
     * It can be any JavaScript object(`typeof original === 'object'`) but:
     * - it shall not be array or null;
     * - it shall not be object of `Asset`;
     * - if it's an object of `CCObject`, it should not have been destroyed.
     * @returns The newly instantiated object.
     * @example
     * ```ts
     * import { instantiate, director } from 'cc';
     * // Clone a node.
     * const node = instantiate(targetNode);
     * node.parent = director.getScene();
     * ```
     */
    export function instantiate<T>(original: T): T;
    export namespace instantiate {
        export var _clone: typeof __private._cocos_core_data_instantiate__doInstantiate;
    }
    /**
     * @en
     * Indicates that the editor should treats this property or array element as a Integer value.
     * @zh
     * 指定编辑器以整数形式对待该属性或数组元素。
     * @example
     * ```ts
     * import { CCInteger, _decorator } from "cc";
     *
     * // in class definition:
     *
     * @_decorator.property({type: CCInteger})
     * count = 0;
     *
     * @_decorator.property({type: [CCInteger]})
     * array = [];
     * ```
     */
    export const CCInteger: __private._cocos_core_data_utils_attribute__PrimitiveType<number>;
    /**
     * @en
     * Indicates that the editor should treats this property or array element as a Float value.
     * @zh
     * 指定编辑器以浮点数形式对待该属性或数组元素。
     * @example
     * ```ts
     * import { CCFloat, _decorator } from "cc";
     *
     * // in class definition:
     *
     * @_decorator.property({type: CCFloat})
     * x = 0;
     *
     * @_decorator.property({type: [CCFloat]})
     * array = [];
     * ```
     */
    export const CCFloat: __private._cocos_core_data_utils_attribute__PrimitiveType<number>;
    /**
     * @en
     * Indicates that the editor should treats this property or array element as a Boolean value.
     * @zh
     * 指定编辑器以布尔值形式对待该属性或数组元素。
     *
     * @example
     * ```ts
     * import { CCBoolean, _decorator } from "cc";
     * // in class definition
     * @_decorator.property({type: CCBoolean})
     * isTrue = false;
     *
     * @_decorator.property({type: [CCBoolean]})
     * array = [];
     * ```
     */
    export const CCBoolean: __private._cocos_core_data_utils_attribute__PrimitiveType<boolean>;
    /**
     * @en
     * Indicates that the editor should treats this property or array element as a String value.
     * @zh
     * 指定编辑器以字符串形式对待该属性或数组元素。
     * @example
     * ```ts
     * import { CCString, _decorator } from "cc";
     *
     * // in class definition
     *
     * @_decorator.property({type: CCString})
     * name = '';
     *
     * @_decorator.property({type: [CCString]})
     * array = [];
     * ```
     */
    export const CCString: __private._cocos_core_data_utils_attribute__PrimitiveType<string>;
    /**
     * @deprecated Since V3.5.0.
     */
    export class CompactValueTypeArray {
        static StorageUnit: typeof __private._cocos_core_data_utils_compact_value_type_array__StorageUnit;
        static ElementType: typeof __private._cocos_core_data_utils_compact_value_type_array__ElementType;
        /**
         * Returns the length in bytes that a buffer needs to encode the specified value array in form of CVTA.
         * @param values The value array.
         * @param unit Target element type.
         */
        static lengthFor(values: any[], elementType: __private._cocos_core_data_utils_compact_value_type_array__ElementType, unit: __private._cocos_core_data_utils_compact_value_type_array__StorageUnit): number;
        /**
         * Compresses the specified value array in form of CVTA into target buffer.
         * @param values The value array.
         * @param unit Target element type.
         * @param arrayBuffer Target buffer.
         * @param byteOffset Offset into target buffer.
         */
        static compress(values: any[], elementType: __private._cocos_core_data_utils_compact_value_type_array__ElementType, unit: __private._cocos_core_data_utils_compact_value_type_array__StorageUnit, arrayBuffer: ArrayBuffer, byteOffset: number, presumedByteOffset: number): CompactValueTypeArray;
        /**
         * Decompresses this CVTA.
         * @param arrayBuffer The buffer this CVTA stored in.
         */
        decompress<T>(arrayBuffer: ArrayBuffer): T[];
    }
    /**
     * Tag to visit editor extras of an object. Never concern about its value please.
     * @internal
     */
    export const editorExtrasTag = "__editorExtras__";
    /**
     * Tag to define the custom deserialization method.
     * @internal
     */
    export const deserializeTag: unique symbol;
    /**
     * Tag to define the custom serialization method.
     * @internal
     */
    export const serializeTag: unique symbol;
    export interface SerializationInput {
        /**
         * Reads a property from input.
         * @param name Property name.
         * @returns The property's value, after deserialized.
         */
        readProperty(name: string): unknown;
        /**
         * Deserializes this object according to the original procedure.
         */
        readThis(): void;
        /**
         * Deserializes super according to the original procedure.
         */
        readSuper(): void;
    }
    export interface SerializationOutput {
        /**
         * Writes a property into output.
         * @param name Property name.
         * @param value Property value.
         */
        writeProperty(name: string, value: unknown): void;
        /**
         * Serialize this object according to the original procedure.
         */
        writeThis(): void;
        /**
         * Serialize super according to the original procedure.
         */
        writeSuper(): void;
    }
    export type SerializationContext = {
        /**
         * The main serializing asset or root node in the scene/prefab passed to serialization procedure.
         */
        root: unknown;
        /**
         * True if the serialization procedure is targeting CCON.
         */
        toCCON: boolean;
        /**
         * Customized arguments passed to serialization procedure.
         */
        customArguments: Record<PropertyKey, unknown>;
    };
    export interface CustomSerializable {
        [serializeTag](output: SerializationOutput, context: SerializationContext): void;
        [deserializeTag]?(input: SerializationInput, context: __private._cocos_core_data_custom_serializable__DeserializationContext): void;
    }
    /**
     * @en
     * EventTarget is an object to which an event is dispatched when something has occurred.
     * [[Node]]s are the most common event targets, but other objects can be event targets too.
     * If a class cannot extend from EventTarget, it can consider using [[Eventify]].
     *
     * @zh
     * 事件目标是具有注册监听器、派发事件能力的类，[[Node]] 是最常见的事件目标，
     * 但是其他类也可以继承自事件目标以获得管理监听器和派发事件的能力。
     * 如果无法继承自 EventTarget，也可以使用 [[Eventify]]
     */
    export const EventTarget: new (...args: any[]) => __private._cocos_core_event_event_target__Empty & __private._cocos_core_event_eventify__IEventified;
    export type EventTarget = InstanceType<typeof EventTarget>;
    /**
     * @en Generate a new class from the given base class, after polyfill all functionalities in [[IEventified]] as if it's extended from [[EventTarget]]
     * @zh 生成一个类，该类继承自指定的基类，并以和 [[EventTarget]] 等同的方式实现了 [[IEventified]] 的所有接口。
     * @param base The base class
     * @example
     * ```ts
     * class Base { say() { console.log('Hello!'); } }
     * class MyClass extends Eventify(Base) { }
     * function (o: MyClass) {
     *     o.say(); // Ok: Extend from `Base`
     *     o.emit('sing', 'The ghost'); // Ok: `MyClass` implements IEventified
     * }
     * ```
     */
    export function Eventify<TBase>(base: __private._cocos_core_event_eventify__Constructor<TBase>): __private._cocos_core_event_eventify__Constructor<TBase & __private._cocos_core_event_eventify__IEventified>;
    /**
     * @zh
     * Async Delegate 用于支持异步回调的代理，你可以新建一个异步代理，并注册异步回调，等到对应的时机触发代理事件。
     *
     * @en
     * Async Delegate is a delegate that supports asynchronous callbacks.
     * You can create a new AsyncDelegate, register the asynchronous callback, and wait until the corresponding time to dispatch the event.
     *
     * @example
     * ```ts
     * const ad = new AsyncDelegate();
     * ad.add(() => {
     *     return new Promise((resolve, reject) => {
     *        setTimeout(() => {
     *            console.log('hello world');
     *            resolve();
     *        }, 1000);
     *     })
     * });
     * await ad.dispatch();
     * ```
     */
    export class AsyncDelegate<T extends (...args: any) => (Promise<void> | void) = () => (Promise<void> | void)> {
        /**
         * @en
         * Add an async callback or sync callback.
         *
         * @zh
         * 添加一个异步回调或同步回调。
         *
         * @param callback
         * @en The callback to add, and will be invoked when this delegate is dispatching.
         * @zh 要添加的回调，并将在该委托调度时被调用。
         */
        add(callback: T): void;
        /**
         * @zh
         * 查询是否已注册某个回调。
         * @en
         * Queries if a callback has been registered.
         *
         * @param callback @en The callback to query. @zh 要查询的回调函数。
         * @returns @en Whether the callback has been added. @zh 是否已经添加了回调。
         */
        hasListener(callback: T): boolean;
        /**
         * @en
         * Remove the specific callback of this delegate.
         *
         * @zh
         * 移除此代理中某个具体的回调。
         *
         * @param callback @en The callback to remove. @zh 要移除的某个回调。
         */
        remove(callback: T): void;
        /**
         * @en
         * Dispatching the delegate event. This function will trigger all previously registered callbacks and does not guarantee execution order.
         *
         * @zh
         * 派发代理事件。此函数会触发所有之前注册的回调，并且不保证执行顺序。
         *
         * @param args @en The parameters to be transferred to callback. @zh 传递给回调函数的参数。
         * @returns @en The promise awaiting all async callback resolved. @zh 等待所有异步回调结束的 Promise 对象。
         */
        dispatch(...args: Parameters<T>): Promise<void[]>;
    }
    /**
     * @en
     * Base class for handling assets used in Creator.<br/>
     *
     * You may want to override:<br/>
     * - createNode<br/>
     * - getset functions of _nativeAsset<br/>
     * - `Object._serialize`<br/>
     * - `Object._deserialize`<br/>
     * @zh
     * Creator 中的资源基类。<br/>
     *
     * 您可能需要重写：<br/>
     * - createNode <br/>
     * - _nativeAsset 的 getset 方法<br/>
     * - `Object._serialize`<br/>
     * - `Object._deserialize`<br/>
     *
     * @class Asset
     * @extends CCObject
     */
    export class Asset extends __private._cocos_core_assets_asset__Asset_base {
        /**
         * 应 AssetDB 要求提供这个方法。
         * @internal
         * @method deserialize
         * @param {String} data
         * @return {Asset}
         */
        static deserialize(data: any): any;
        /**
         * @en
         * Whether the asset is loaded or not
         * @zh
         * 该资源是否已经成功加载。
         *
         * @deprecated since v3.3
         */
        loaded: boolean;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _uuid: string;
        /**
         * @internal
         */
        isDefault: boolean;
        /**
         * @en
         * Serializable url for native asset. For internal usage.
         * @zh
         * 用于本机资产的可序列化URL。供内部使用。
         * @default ""
         *
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _native: string;
        /**
         * @internal
         */
        _nativeUrl: string;
        /**
         * @en
         * Returns the url of this asset's native object, if none it will returns an empty string.
         * @zh
         * 返回该资源对应的目标平台资源的 URL，如果没有将返回一个空字符串。
         * @readOnly
         */
        get nativeUrl(): string;
        /**
         * @en
         * The underlying native asset of this asset if one is available.<br>
         * This property can be used to access additional details or functionality related to the asset.<br>
         * This property will be initialized by the loader if `_native` is available.
         * @zh
         * 此资源的基础资源（如果有）。 此属性可用于访问与资源相关的其他详细信息或功能。<br>
         * 如果`_native`可用，则此属性将由加载器初始化。
         * @default null
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        get _nativeAsset(): any;
        set _nativeAsset(obj: any);
        constructor(...args: ConstructorParameters<typeof CCObject>);
        /**
         * @en
         * Returns the string representation of the object.<br>
         * The `Asset` object overrides the `toString()` method of the `Object` object.<br>
         * JavaScript calls the toString() method automatically<br>
         * when an asset is to be represented as a text value or when a texture is referred to in a string concatenation.<br>
         * <br>
         * For assets of the native type, it will return `this.nativeUrl`.<br>
         * Otherwise, an empty string is returned.<br>
         * This method may be overwritten by subclasses.
         * @zh
         * 返回对象的字符串表示形式。<br>
         * `Asset` 对象将会重写 `Object` 对象的 `toString()` 方法。<br>
         * 当资源要表示为文本值时或在字符串连接时引用时，<br>
         * JavaScript 会自动调用 toString() 方法。<br>
         * <br>
         * 对于原始类型的资源，它将返回`this.nativeUrl`。<br>
         * 否则，返回空字符串。<br>
         * 子类可能会覆盖此方法。
         * @method toString
         * @return {String}
         */
        toString(): string;
        /**
         * 应 AssetDB 要求提供这个方法。
         * 返回一个序列化后的对象
         *
         * @method serialize
         * @return {String}
         * @private
         */
        serialize(): void;
        /**
         * @en
         * Set native file name for this asset.
         * @zh
         * 为此资源设置原始文件名。
         * @seealso nativeUrl
         *
         * @param filename
         * @param inLibrary
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _setRawAsset(filename: string, inLibrary?: boolean): void;
        /**
         * @en
         * Create a new node using this asset in the scene.<br/>
         * If this type of asset don't have its corresponding node type, this method should be null.
         * @zh
         * 使用该资源在场景中创建一个新节点。<br/>
         * 如果这类资源没有相应的节点类型，该方法应该是空的。
         */
        createNode?(callback: __private._cocos_core_assets_asset__CreateNodeCallback): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        get _nativeDep(): {
            __isNative__: boolean;
            uuid: string;
            ext: string;
        } | undefined;
        /**
         * @en
         * The number of reference
         *
         * @zh
         * 引用的数量
         */
        get refCount(): number;
        /**
         * @en
         * Add references of asset
         *
         * @zh
         * 增加资源的引用
         *
         * @return itself
         *
         */
        addRef(): Asset;
        /**
         * @en
         * Reduce references of asset and it will be auto released when refCount equals 0.
         *
         * @zh
         * 减少资源的引用并尝试进行自动释放。
         *
         * @return itself
         *
         */
        decRef(autoRelease?: boolean): Asset;
        onLoaded(): void;
        initDefault(uuid?: string): void;
        validate(): boolean;
        destroy(): boolean;
    }
    export class BufferAsset extends Asset {
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        get _nativeAsset(): ArrayBufferView | ArrayBuffer;
        set _nativeAsset(bin: ArrayBufferView | ArrayBuffer);
        /**
         * @zh 获取此资源中的缓冲数据。
         * @en Get the ArrayBuffer data of this asset.
         * @returns @en The ArrayBuffer. @zh 缓冲数据。
         */
        buffer(): ArrayBuffer;
        validate(): boolean;
    }
    /**
     * @en Class for prefab handling.
     * @zh 预制资源类。
     */
    export class Prefab extends Asset {
        /**
         * @en Enumeration for optimization policy
         * @zh Prefab 创建实例所用的优化策略枚举类型
         */
        static OptimizationPolicy: {
            /**
             * @en The optimization policy is automatically chosen based on the number of instantiations.
             * When you first create an instance, the behavior is the same as SINGLE_INSTANCE.
             * MULTI_INSTANCE will be automatically used after multiple creation.
             * @zh 根据创建次数自动调整优化策略。初次创建实例时，行为等同 SINGLE_INSTANCE，多次创建后将自动采用 MULTI_INSTANCE。
             */
            AUTO: number;
            /**
             * @en Optimize for single instance creation.<br>
             * This option skips code generation for this prefab.
             * When this prefab will usually create only one instances, please select this option.
             * @zh 优化单次创建性能。<br>
             * 该选项会跳过针对这个 prefab 的代码生成优化操作。当该 prefab 加载后，一般只会创建一个实例时，请选择此项。
             */
            SINGLE_INSTANCE: number;
            /**
             * @en Optimize for creating instances multiple times.<br>
             * This option enables code generation for this prefab.
             * When this prefab will usually create multiple instances, please select this option.
             * It is also recommended to select this option if the prefab instance in the scene
             * has Auto Sync enabled and there are multiple instances in the scene.
             * @zh 优化多次创建性能。<br>
             * 该选项会启用针对这个 prefab 的代码生成优化操作。当该 prefab 加载后，一般会创建多个实例时，请选择此项。如果该 prefab 在场景中的节点启用了自动关联，并且在场景中有多份实例，也建议选择此项。
             */
            MULTI_INSTANCE: number;
        };
        static OptimizationPolicyThreshold: number;
        /**
         * @en The main [[Node]] in the prefab
         * @zh Prefab 中的根节点，[[Node]] 类型
         */
        data: any;
        /**
         * @zh
         * 设置实例化这个 prefab 时所用的优化策略。根据使用情况设置为合适的值，能优化该 prefab 实例化所用的时间。推荐在编辑器的资源中设置。
         * @en
         * Indicates the optimization policy for instantiating this prefab.
         * Set to a suitable value based on usage, can optimize the time it takes to instantiate this prefab.
         * Suggest to set this policy in the editor's asset inspector.
         * @default Prefab.OptimizationPolicy.AUTO
         * @example
         * ```ts
         * import { Prefab } from 'cc';
         * prefab.optimizationPolicy = Prefab.OptimizationPolicy.MULTI_INSTANCE;
         * ```
         */
        optimizationPolicy: number;
        persistent: boolean;
        constructor();
        createNode(cb: (err: Error | null, node: Node) => void): void;
        /**
         * @en
         * Dynamically translation prefab data into minimized code.<br/>
         * This method will be called automatically before the first time the prefab being instantiated,<br/>
         * but you can re-call to refresh the create function once you modified the original prefab data in script.
         * @zh
         * 将预制数据动态转换为最小化代码。<br/>
         * 此方法将在第一次实例化预制件之前自动调用，<br/>
         * 但是您可以在脚本中修改原始预制数据后重新调用以刷新创建功能。
         */
        compileCreateFunction(): void;
        initDefault(uuid?: string): void;
        validate(): boolean;
        onLoaded(): void;
    }
    export namespace Prefab {
        export namespace _utils {
            export class TargetInfo {
                localID: string[];
            }
            export class TargetOverrideInfo {
                source: Component | Node | null;
                sourceInfo: TargetInfo | null;
                propertyPath: string[];
                target: Node | null;
                targetInfo: TargetInfo | null;
            }
            export class CompPrefabInfo {
                fileId: string;
            }
            export class PropertyOverrideInfo {
                targetInfo: TargetInfo | null;
                propertyPath: string[];
                value: any;
                isTarget(localID: string[], propPath: string[]): boolean | undefined;
            }
            export class MountedChildrenInfo {
                targetInfo: TargetInfo | null;
                nodes: Node[];
                isTarget(localID: string[]): boolean | undefined;
            }
            export class MountedComponentsInfo {
                targetInfo: TargetInfo | null;
                components: Component[];
                isTarget(localID: string[]): boolean | undefined;
            }
            /**
             * Prefab实例类
             * @internal
             */
            export class PrefabInstance {
                fileId: string;
                prefabRootNode?: Node;
                mountedChildren: MountedChildrenInfo[];
                mountedComponents: MountedComponentsInfo[];
                propertyOverrides: PropertyOverrideInfo[];
                removedComponents: TargetInfo[];
                targetMap: Record<string, any | Node | Component>;
                /**
                 * make sure prefab instance expand only once
                 * @internal
                 */
                expanded: boolean;
                findPropertyOverride(localID: string[], propPath: string[]): Prefab._utils.PropertyOverrideInfo | null | undefined;
                removePropertyOverride(localID: string[], propPath: string[]): void;
            }
            export class PrefabInfo {
                root?: Node;
                asset?: Prefab;
                fileId: string;
                instance?: PrefabInstance;
                targetOverrides?: TargetOverrideInfo[];
                nestedPrefabInstanceRoots?: Node[];
            }
            export function createNodeWithPrefab(node: Node): void;
            export function generateTargetMap(node: Node, targetMap: any, isRoot: boolean): void;
            export function getTarget(localID: string[], targetMap: any): Component | Node | null;
            export function applyMountedChildren(node: Node, mountedChildren: MountedChildrenInfo[], targetMap: Record<string, any | Node | Component>): void;
            export function applyMountedComponents(node: Node, mountedComponents: MountedComponentsInfo[], targetMap: Record<string, any | Node | Component>): void;
            export function applyRemovedComponents(node: Node, removedComponents: TargetInfo[], targetMap: Record<string, any | Node | Component>): void;
            export function applyPropertyOverrides(node: Node, propertyOverrides: PropertyOverrideInfo[], targetMap: Record<string, any | Node | Component>): void;
            export function applyTargetOverrides(node: BaseNode): void;
            export function expandPrefabInstanceNode(node: Node, recursively?: boolean): void;
            export function expandNestedPrefabInstanceNode(node: BaseNode): void;
            export function applyNodeAndComponentId(node: Node, rootId: string): void;
        }
    }
    /**
     * @en Sub mesh for rendering which contains all geometry data, it can be used to create [[gfx.InputAssembler]].
     * @zh 包含所有顶点数据的渲染子网格，可以用来创建 [[gfx.InputAssembler]]。
     */
    export class RenderingSubMesh {
        /**
         * @en
         * mesh object where this sub mesh locates
         * @zh
         * 子网格所处的网格模型对象
         */
        mesh?: Mesh;
        /**
         * @en
         * sub mesh's index in mesh
         * @zh
         * 子网格在网格模型中的索引
         */
        subMeshIdx?: number;
        /**
         * @en
         * sub mesh's constructor
         * @zh
         * 子网格构造函数
         * @param vertexBuffers @en vertex buffers @zh 顶点缓冲区数组
         * @param attributes @en vertex attributes @zh 顶点属性数组
         * @param primitiveMode @en primitive mode @zh 图元类型
         * @param indexBuffer @en index buffer @zh 索引缓冲区
         * @param indirectBuffer @en indirect buffer @zh 间接缓冲区
         */
        constructor(vertexBuffers: gfx.Buffer[], attributes: gfx.Attribute[], primitiveMode: gfx.PrimitiveMode, indexBuffer?: gfx.Buffer | null, indirectBuffer?: gfx.Buffer | null, isOwnerOfIndexBuffer?: boolean);
        /**
         * @en All vertex attributes used by the sub mesh
         * @zh 所有顶点属性。
         */
        get attributes(): gfx.Attribute[];
        /**
         * @en All vertex buffers used by the sub mesh
         * @zh 使用的所有顶点缓冲区。
         */
        get vertexBuffers(): gfx.Buffer[];
        /**
         * @en Index buffer used by the sub mesh
         * @zh 使用的索引缓冲区，若未使用则无需指定。
         */
        get indexBuffer(): gfx.Buffer | null;
        /**
         * @en Indirect buffer used by the sub mesh
         * @zh 间接绘制缓冲区。
         */
        get indirectBuffer(): gfx.Buffer | null;
        /**
         * @en Primitive mode used by the sub mesh
         * @zh 图元类型。
         */
        get primitiveMode(): gfx.PrimitiveMode;
        /**
         * @en The geometric info of the sub mesh, used for raycast.
         * @zh （用于射线检测的）几何信息。
         */
        get geometricInfo(): __private._cocos_core_assets_rendering_sub_mesh__IGeometricInfo;
        /**
         * @en Invalidate the geometric info of the sub mesh after geometry changed.
         * @zh 网格更新后，设置（用于射线检测的）几何信息为无效，需要重新计算。
         */
        invalidateGeometricInfo(): void;
        /**
         * @en the draw range
         * @zh 渲染范围
         */
        set drawInfo(info: gfx.DrawInfo | null | undefined);
        get drawInfo(): gfx.DrawInfo | null | undefined;
        /**
         * @en Flatted vertex buffers
         * @zh 扁平化的顶点缓冲区。
         */
        get flatBuffers(): __private._cocos_core_assets_rendering_sub_mesh__IFlatBuffer[];
        /**
         * @en generate flatted vertex buffers
         * @zh 生成扁平化的顶点缓冲区。
         */
        genFlatBuffers(): void;
        /**
         * @en The vertex buffer for joint after mapping
         * @zh 骨骼索引按映射表处理后的顶点缓冲。
         */
        get jointMappedBuffers(): gfx.Buffer[];
        /**
         * @en The input assembler info
         * @zh 输入汇集器信息
         */
        get iaInfo(): gfx.InputAssemblerInfo;
        /**
         * @en destroy sub mesh
         * @zh 销毁子网格
         */
        destroy(): void;
        /**
         * @en Adds a vertex attribute input called 'a_vertexId' into this sub-mesh.
         * This is useful if you want to simulate `gl_VertexId` in WebGL context prior to 2.0.
         * Once you call this function, the vertex attribute is permanently added.
         * Subsequent calls to this function take no effect.
         * @zh 添加一个 'a_vertexId' 顶点属性， 用于在 WebGL 2.0 之前的平台模拟 `gl_VertexId`，
         * 一旦你调用此函数， 顶点属性永久被添加， 后续调用无效果。
         * @param device @en Device used to create related rendering resources @zh 用于创建相关渲染资源的设备对象
         */
        enableVertexIdChannel(device: gfx.Device): void;
    }
    /**
     * @en Class for scene loading.
     * @zh 场景资源类。
     *
     */
    export class SceneAsset extends Asset {
        /**
         * @en The scene node
         * @zh 场景节点。
         */
        scene: Scene | null;
        initDefault(uuid?: string): void;
        validate(): boolean;
    }
    /**
     * @en Class for text file.
     * @zh 文本资源。
     */
    export class TextAsset extends Asset {
        /**
         * @en The text content.
         * @zh 此资源包含的文本。
         */
        text: string;
        toString(): string;
    }
    /**
     * @en Json asset, it will automatically parse the json to a JS object.
     * @zh Json 资源。
     * Json 资源加载后将直接解析为对象。如果你希望获得 JSON 的原始文本，你需要使用文本资源（使用文件名后缀“.txt”）。
     */
    export class JsonAsset extends Asset {
        /**
         * @en The parsed JS object
         * @zh 解析后的对象。
         */
        json: object | null;
    }
    /**
     * @en Image Asset.
     * @zh 图像资源。
     */
    export class ImageAsset extends Asset {
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        get _nativeAsset(): __private._cocos_core_assets_image_asset__ImageSource;
        set _nativeAsset(value: __private._cocos_core_assets_image_asset__ImageSource);
        /**
         * @en Image data.
         * @zh 此图像资源的图像数据。
         */
        get data(): ArrayBufferView | ImageBitmap | HTMLCanvasElement | HTMLImageElement | null;
        /**
         * @en The pixel width of the image.
         * @zh 此图像资源的像素宽度。
         */
        get width(): number;
        /**
         * @en The pixel height of the image.
         * @zh 此图像资源的像素高度。
         */
        get height(): number;
        /**
         * @en The pixel format of the image.
         * @zh 此图像资源的像素格式。
         */
        get format(): __private._cocos_core_assets_asset_enum__PixelFormat;
        /**
         * @en Whether the image is in compressed texture format.
         * @zh 此图像资源是否为压缩像素格式。
         */
        get isCompressed(): boolean;
        /**
         * @en The original source image URL, it could be empty.
         * @zh 此图像资源的原始图像源的 URL。当原始图像元不是 HTML 文件时可能为空。
         * @deprecated Please use [[nativeUrl]]
         */
        get url(): string;
        constructor(nativeAsset?: __private._cocos_core_assets_image_asset__ImageSource);
        /**
         * @en Reset the source of the image asset.
         * @zh 重置此图像资源使用的原始图像源。
         * @param data The new source
         */
        reset(data: __private._cocos_core_assets_image_asset__ImageSource): void;
        destroy(): boolean;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _serialize(): "" | {
            fmt: string;
            w: number;
            h: number;
        } | undefined;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _deserialize(data: any): void;
        initDefault(uuid?: string): void;
        validate(): boolean;
    }
    /**
     * @en The 2D texture asset. It supports mipmap, each level of mipmap use an [[ImageAsset]].
     * @zh 二维贴图资源。二维贴图资源的每个 Mipmap 层级都为一张 [[ImageAsset]]。
     */
    export class Texture2D extends __private._cocos_core_assets_simple_texture__SimpleTexture {
        /**
         * @en All levels of mipmap images, be noted, automatically generated mipmaps are not included.
         * When setup mipmap, the size of the texture and pixel format could be modified.
         * @zh 所有层级 Mipmap，注意，这里不包含自动生成的 Mipmap。
         * 当设置 Mipmap 时，贴图的尺寸以及像素格式可能会改变。
         */
        get mipmaps(): ImageAsset[];
        set mipmaps(value: ImageAsset[]);
        /**
         * @en Level 0 mipmap image.
         * Be noted, `this.image = img` equals `this.mipmaps = [img]`,
         * sets image will clear all previous mipmaps.
         * @zh 0 级 Mipmap。
         * 注意，`this.image = img` 等价于 `this.mipmaps = [img]`，
         * 也就是说，通过 `this.image` 设置 0 级 Mipmap 时将隐式地清除之前的所有 Mipmap。
         */
        get image(): ImageAsset | null;
        set image(value: ImageAsset | null);
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _mipmaps: ImageAsset[];
        initialize(): void;
        onLoaded(): void;
        /**
         * @en Reset the current texture with given size, pixel format and mipmap images.
         * After reset, the gfx resource will become invalid, you must use [[uploadData]] explicitly to upload the new mipmaps to GPU resources.
         * @zh 将当前贴图重置为指定尺寸、像素格式以及指定 mipmap 层级。重置后，贴图的像素数据将变为未定义。
         * mipmap 图像的数据不会自动更新到贴图中，你必须显式调用 [[uploadData]] 来上传贴图数据。
         * @param info The create information
         */
        reset(info: __private._cocos_core_assets_texture_2d__ITexture2DCreateInfo): void;
        /**
         * @en Reset the current texture with given size, pixel format and mipmap images.
         * After reset, the gfx resource will become invalid, you must use [[uploadData]] explicitly to upload the new mipmaps to GPU resources.
         * @zh 将当前贴图重置为指定尺寸、像素格式以及指定 mipmap 层级。重置后，贴图的像素数据将变为未定义。
         * mipmap 图像的数据不会自动更新到贴图中，你必须显式调用 [[uploadData]] 来上传贴图数据。
         * @param width Pixel width
         * @param height Pixel height
         * @param format Pixel format
         * @param mipmapLevel Mipmap level count
         * @param baseLevel Mipmap base level
         * @param maxLevel Mipmap maximum level
         * @deprecated since v1.0 please use [[reset]] instead
         */
        create(width: number, height: number, format?: __private._cocos_core_assets_asset_enum__PixelFormat, mipmapLevel?: number, baseLevel?: number, maxLevel?: number): void;
        toString(): string;
        updateMipmaps(firstLevel?: number, count?: number): void;
        /**
         * @en If the level 0 mipmap image is a HTML element, then return it, otherwise return null.
         * @zh 若此贴图 0 级 Mipmap 的图像资源的实际源存在并为 HTML 元素则返回它，否则返回 `null`。
         * @returns HTML element or `null`
         * @deprecated Please use [[ImageAsset.data]] instead
         */
        getHtmlElementObj(): HTMLCanvasElement | HTMLImageElement | null;
        /**
         * @en Destroy the current 2d texture, clear up all mipmap levels and the related GPU resources.
         * @zh 销毁此贴图，清空所有 Mipmap 并释放占用的 GPU 资源。
         */
        destroy(): boolean;
        /**
         * @en Gets the description of the 2d texture
         * @zh 返回此贴图的描述。
         * @returns The description
         */
        description(): string;
        /**
         * @en Release used GPU resources.
         * @zh 释放占用的 GPU 资源。
         * @deprecated please use [[destroy]] instead
         */
        releaseTexture(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _serialize(ctxForExporting: any): {
            base: any;
            mipmaps: (string | null)[];
        } | null;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _deserialize(serializedData: any, handle: any): void;
        protected _getGfxTextureCreateInfo(presumed: __private._cocos_core_assets_simple_texture__PresumedGFXTextureInfo): gfx.TextureInfo;
        protected _getGfxTextureViewCreateInfo(presumed: __private._cocos_core_assets_simple_texture__PresumedGFXTextureViewInfo): gfx.TextureViewInfo;
        initDefault(uuid?: string): void;
        validate(): boolean;
    }
    /**
     * @en The texture cube asset.
     * Each mipmap level of a texture cube have 6 [[ImageAsset]], represents 6 faces of the cube.
     * @zh 立方体贴图资源。
     * 立方体贴图资源的每个 Mipmap 层级都为 6 张 [[ImageAsset]]，分别代表了立方体贴图的 6 个面。
     */
    export class TextureCube extends __private._cocos_core_assets_simple_texture__SimpleTexture {
        static FaceIndex: typeof __private._cocos_core_assets_texture_cube__FaceIndex;
        isRGBE: boolean;
        _mipmapAtlas: __private._cocos_core_assets_texture_cube__ITextureCubeMipmapAtlas | null;
        _mipmapMode: __private._cocos_core_assets_texture_cube__MipmapMode;
        /**
         * @en All levels of mipmap images, be noted, automatically generated mipmaps are not included.
         * When setup mipmap, the size of the texture and pixel format could be modified.
         * @zh 所有层级 Mipmap，注意，这里不包含自动生成的 Mipmap。
         * 当设置 Mipmap 时，贴图的尺寸以及像素格式可能会改变。
         */
        get mipmaps(): __private._cocos_core_assets_texture_cube__ITextureCubeMipmap[];
        set mipmaps(value: __private._cocos_core_assets_texture_cube__ITextureCubeMipmap[]);
        /**
         * @en Fill mipmaps with convolutional maps.
         * @zh 使用卷积图填充mipmaps。
         * @param value All mipmaps of each face of the cube map are stored in the form of atlas
         * and the value contains the atlas of the 6 faces and the layout information of each mipmap layer.
         */
        set mipmapAtlas(value: __private._cocos_core_assets_texture_cube__ITextureCubeMipmapAtlas | null);
        get mipmapAtlas(): __private._cocos_core_assets_texture_cube__ITextureCubeMipmapAtlas | null;
        /**
         * @en Whether mipmaps are baked convolutional maps.
         * @zh mipmaps是否为烘焙出来的卷积图。
         */
        isUsingOfflineMipmaps(): boolean;
        /**
         * @en Level 0 mipmap image.
         * Be noted, `this.image = img` equals `this.mipmaps = [img]`,
         * sets image will clear all previous mipmaps.
         * @zh 0 级 Mipmap。
         * 注意，`this.image = img` 等价于 `this.mipmaps = [img]`，
         * 也就是说，通过 `this.image` 设置 0 级 Mipmap 时将隐式地清除之前的所有 Mipmap。
         */
        get image(): __private._cocos_core_assets_texture_cube__ITextureCubeMipmap | null;
        set image(value: __private._cocos_core_assets_texture_cube__ITextureCubeMipmap | null);
        /**
         * @en Create a texture cube with an array of [[Texture2D]] which represents 6 faces of the texture cube.
         * @zh 通过二维贴图数组指定每个 Mipmap 的每个面创建立方体贴图。
         * @param textures Texture array, the texture count must be multiple of 6. Every 6 textures are 6 faces of a mipmap level.
         * The order should obey [[FaceIndex]] order.
         * @param out Output texture cube, if not given, will create a new texture cube.
         * @returns The created texture cube.
         * @example
         * ```ts
         * const textures = new Array<Texture2D>(6);
         * textures[TextureCube.FaceIndex.front] = frontImage;
         * textures[TextureCube.FaceIndex.back] = backImage;
         * textures[TextureCube.FaceIndex.left] = leftImage;
         * textures[TextureCube.FaceIndex.right] = rightImage;
         * textures[TextureCube.FaceIndex.top] = topImage;
         * textures[TextureCube.FaceIndex.bottom] = bottomImage;
         * const textureCube = TextureCube.fromTexture2DArray(textures);
         * ```
         */
        static fromTexture2DArray(textures: Texture2D[], out?: TextureCube): TextureCube;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _mipmaps: __private._cocos_core_assets_texture_cube__ITextureCubeMipmap[];
        onLoaded(): void;
        /**
         * @en Reset the current texture with given size, pixel format and mipmap images.
         * After reset, the gfx resource will become invalid, you must use [[uploadData]] explicitly to upload the new mipmaps to GPU resources.
         * @zh 将当前贴图重置为指定尺寸、像素格式以及指定 mipmap 层级。重置后，贴图的像素数据将变为未定义。
         * mipmap 图像的数据不会自动更新到贴图中，你必须显式调用 [[uploadData]] 来上传贴图数据。
         * @param info The create information
         */
        reset(info: __private._cocos_core_assets_texture_cube__ITextureCubeCreateInfo): void;
        updateMipmaps(firstLevel?: number, count?: number): void;
        /**
         * @en Destroy this texture, clear all mipmaps and release GPU resources
         * @zh 销毁此贴图，清空所有 Mipmap 并释放占用的 GPU 资源。
         */
        destroy(): boolean;
        /**
         * @en Release used GPU resources.
         * @zh 释放占用的 GPU 资源。
         * @deprecated please use [[destroy]] instead
         */
        releaseTexture(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _serialize(ctxForExporting: any): Record<string, unknown> | null;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _deserialize(serializedData: __private._cocos_core_assets_texture_cube__ITextureCubeSerializeData, handle: any): void;
        protected _getGfxTextureCreateInfo(presumed: __private._cocos_core_assets_simple_texture__PresumedGFXTextureInfo): gfx.TextureInfo;
        protected _getGfxTextureViewCreateInfo(presumed: __private._cocos_core_assets_simple_texture__PresumedGFXTextureViewInfo): gfx.TextureViewInfo;
        initDefault(uuid?: string): void;
        validate(): boolean;
    }
    /**
     * @en Effect asset is the base template for instantiating material, all effects should be unique globally.
     * All effects are managed in a static map of EffectAsset.
     * @zh Effect 资源，作为材质实例初始化的模板，每个 effect 资源都应是全局唯一的。
     * 所有 Effect 资源都由此类的一个静态对象管理。
     */
    export class EffectAsset extends Asset {
        /**
         * @en Register the effect asset to the static map
         * @zh 将指定 effect 注册到全局管理器。
         */
        static register(asset: EffectAsset): void;
        /**
         * @en Unregister the effect asset from the static map
         * @zh 将指定 effect 从全局管理器移除。
         */
        static remove(asset: EffectAsset | string): void;
        /**
         * @en Get the effect asset by the given name.
         * @zh 获取指定名字的 effect 资源。
         */
        static get(name: string): EffectAsset | null;
        /**
         * @en Get all registered effect assets.
         * @zh 获取所有已注册的 effect 资源。
         */
        static getAll(): Record<string, EffectAsset>;
        protected static _effects: Record<string, EffectAsset>;
        static isLayoutValid(): boolean;
        static setLayoutValid(): void;
        protected static _layoutValid: boolean;
        /**
         * @en The techniques used by the current effect.
         * @zh 当前 effect 的所有可用 technique。
         */
        techniques: EffectAsset.ITechniqueInfo[];
        /**
         * @en The shaders used by the current effect.
         * @zh 当前 effect 使用的所有 shader。
         */
        shaders: EffectAsset.IShaderInfo[];
        /**
         * @en The preprocess macro combinations for the shader
         * @zh 每个 shader 需要预编译的宏定义组合。
         */
        combinations: EffectAsset.IPreCompileInfo[];
        hideInEditor: boolean;
        /**
         * @en The loaded callback which should be invoked by the [[CCLoader]], will automatically register the effect.
         * @zh 通过 [[CCLoader]] 加载完成时的回调，将自动注册 effect 资源。
         */
        onLoaded(): void;
        protected _precompile(): void;
        destroy(): boolean;
        initDefault(uuid?: string): void;
        validate(): boolean;
    }
    export namespace EffectAsset {
        export interface IPropertyInfo {
            type: number;
            handleInfo?: [
                string,
                number,
                number
            ];
            samplerHash?: number;
            value?: number[] | string;
            linear?: boolean;
        }
        export interface IPassStates {
            priority?: number;
            primitive?: gfx.PrimitiveMode;
            stage?: pipeline.RenderPassStage;
            rasterizerState?: gfx.RasterizerState;
            depthStencilState?: gfx.DepthStencilState;
            blendState?: gfx.BlendState;
            dynamicStates?: gfx.DynamicStateFlags;
            phase?: string | number;
        }
        export interface IPassInfo extends IPassStates {
            program: string;
            embeddedMacros?: renderer.MacroRecord;
            propertyIndex?: number;
            switch?: string;
            properties?: Record<string, IPropertyInfo>;
        }
        export interface ITechniqueInfo {
            passes: IPassInfo[];
            name?: string;
        }
        export interface IBlockInfo {
            binding: number;
            name: string;
            members: gfx.Uniform[];
            stageFlags: gfx.ShaderStageFlags;
        }
        export interface ISamplerTextureInfo {
            binding: number;
            name: string;
            type: gfx.Type;
            count: number;
            stageFlags: gfx.ShaderStageFlags;
        }
        export interface ISamplerInfo {
            set: number;
            binding: number;
            name: string;
            count: number;
            stageFlags: gfx.ShaderStageFlags;
        }
        export interface ITextureInfo {
            set: number;
            binding: number;
            name: string;
            type: gfx.Type;
            count: number;
            stageFlags: gfx.ShaderStageFlags;
        }
        export interface IBufferInfo {
            binding: number;
            name: string;
            memoryAccess: gfx.MemoryAccess;
            stageFlags: gfx.ShaderStageFlags;
        }
        export interface IImageInfo {
            binding: number;
            name: string;
            type: gfx.Type;
            count: number;
            memoryAccess: gfx.MemoryAccess;
            stageFlags: gfx.ShaderStageFlags;
        }
        export interface IInputAttachmentInfo {
            set: number;
            binding: number;
            name: string;
            count: number;
            stageFlags: gfx.ShaderStageFlags;
        }
        export interface IAttributeInfo {
            name: string;
            format: gfx.Format;
            isNormalized: boolean;
            stream: number;
            isInstanced: boolean;
            location: number;
            defines: string[];
        }
        export interface IDefineInfo {
            name: string;
            type: string;
            range?: number[];
            options?: string[];
            default?: string;
        }
        export interface IBuiltin {
            name: string;
            defines: string[];
        }
        export interface IBuiltinInfo {
            buffers: IBuiltin[];
            blocks: IBuiltin[];
            samplerTextures: IBuiltin[];
            images: IBuiltin[];
        }
        export interface IShaderInfo {
            name: string;
            hash: number;
            glsl4: {
                vert: string;
                frag: string;
            };
            glsl3: {
                vert: string;
                frag: string;
            };
            glsl1: {
                vert: string;
                frag: string;
            };
            builtins: {
                globals: IBuiltinInfo;
                locals: IBuiltinInfo;
                statistics: Record<string, number>;
            };
            defines: IDefineInfo[];
            attributes: IAttributeInfo[];
            blocks: IBlockInfo[];
            samplerTextures: ISamplerTextureInfo[];
            samplers: ISamplerInfo[];
            textures: ITextureInfo[];
            buffers: IBufferInfo[];
            images: IImageInfo[];
            subpassInputs: IInputAttachmentInfo[];
        }
        export interface IPreCompileInfo {
            [name: string]: boolean[] | number[] | string[];
        }
    }
    /**
     * @en The basic infos for material initialization.
     * @zh 用来初始化材质的基本信息。
     */
    export interface IMaterialInfo {
        /**
         * @en The EffectAsset to use. Must provide if `effectName` is not specified.
         * @zh
         * 这个材质将使用的 EffectAsset，直接提供资源引用，和 `effectName` 至少要指定一个。
         */
        effectAsset?: EffectAsset | null;
        /**
         * @en
         * The name of the EffectAsset to use. Must provide if `effectAsset` is not specified.
         * @zh
         * 这个材质将使用的 EffectAsset，通过 effect 名指定，和 `effectAsset` 至少要指定一个。
         */
        effectName?: string;
        /**
         * @en
         * The index of the technique to use.
         * @zh
         * 这个材质将使用第几个 technique，默认为 0。
         */
        technique?: number;
        /**
         * @en
         * The shader macro definitions. Default to 0 or the specified value in [[EffectAsset]].
         * @zh
         * 这个材质定义的预处理宏，默认全为 0，或 [[EffectAsset]] 中的指定值。
         */
        defines?: renderer.MacroRecord | renderer.MacroRecord[];
        /**
         * @en
         * The override values on top of the pipeline states specified in [[EffectAsset]].
         * @zh
         * 这个材质的自定义管线状态，将覆盖 effect 中的属性。<br>
         * 注意在可能的情况下请尽量少的自定义管线状态，以减小对渲染效率的影响。
         */
        states?: renderer.PassOverrides | renderer.PassOverrides[];
    }
    /**
     * @en The material asset, specifies in details how a model is drawn on screen.
     * @zh 材质资源类，包含模型绘制方式的全部细节描述。
     */
    export class Material extends Asset {
        /**
         * @en Get hash for a material
         * @zh 获取一个材质的哈希值
         * @param material
         */
        static getHash(material: Material): number;
        protected _effectAsset: EffectAsset | null;
        protected _techIdx: number;
        protected _defines: renderer.MacroRecord[];
        protected _states: renderer.PassOverrides[];
        protected _props: Record<string, __private._cocos_core_assets_material__MaterialPropertyFull | __private._cocos_core_assets_material__MaterialPropertyFull[]>[];
        protected _passes: renderer.Pass[];
        protected _hash: number;
        constructor();
        /**
         * @en The current [[EffectAsset]].
         * @zh 当前使用的 [[EffectAsset]] 资源。
         */
        get effectAsset(): EffectAsset | null;
        /**
         * @en Name of the current [[EffectAsset]].
         * @zh 当前使用的 [[EffectAsset]] 资源名。
         */
        get effectName(): string;
        /**
         * @en The current technique index.
         * @zh 当前的 technique 索引。
         */
        get technique(): number;
        /**
         * @en The passes defined in this material.
         * @zh 当前正在使用的 pass 数组。
         */
        get passes(): renderer.Pass[];
        /**
         * @en The hash value of this material.
         * @zh 材质的 hash。
         */
        get hash(): number;
        /**
         * @en The parent material
         * @zh 父材质
         */
        get parent(): Material | null;
        /**
         * @en The owner render component
         * @zh 该材质所归属的渲染组件
         */
        get owner(): Renderer | null;
        /**
         * @en Initialize this material with the given information.
         * @zh 根据所给信息初始化这个材质，初始化正常结束后材质即可立即用于渲染。
         * @param info Material description info.
         */
        initialize(info: IMaterialInfo): void;
        reset(info: IMaterialInfo): void;
        /**
         * @en
         * Destroy the material definitively.<br>
         * Cannot re-initialize after destroy.<br>
         * Modifications on active materials can be acheived by<br>
         * creating a new Material, invoke the `copy` function<br>
         * with the desired overrides, and assigning it to the target components.
         * @zh
         * 彻底销毁材质，注意销毁后无法重新初始化。<br>
         * 如需修改现有材质，请创建一个新材质，<br>
         * 调用 copy 函数传入需要的 overrides 并赋给目标组件。
         */
        destroy(): boolean;
        /**
         * @en Recompile the shader with the specified macro overrides. Allowed only on material instances.
         * @zh 使用指定预处理宏重新编译当前 pass（数组）中的 shader。只允许对材质实例执行。
         * @param overrides The shader macro override values.
         * @param passIdx The pass to apply to. Will apply to all passes if not specified.
         */
        recompileShaders(overrides: renderer.MacroRecord, passIdx?: number): void;
        /**
         * @en Override the passes with the specified pipeline states. Allowed only on material instances.
         * @zh 使用指定管线状态重载当前的 pass（数组）。只允许对材质实例执行。
         * @param overrides The pipeline state override values.
         * @param passIdx The pass to apply to. Will apply to all passes if not specified.
         */
        overridePipelineStates(overrides: renderer.PassOverrides, passIdx?: number): void;
        /**
         * @en Callback function after material is loaded in [[CCLoader]]. Initialize the resources automatically.
         * @zh 通过 [[CCLoader]] 加载完成时的回调，将自动初始化材质资源。
         */
        onLoaded(): void;
        /**
         * @en Reset all the uniforms to the default value specified in [[EffectAsset]].
         * @zh 重置材质的所有 uniform 参数数据为 [[EffectAsset]] 中的默认初始值。
         * @param clearPasses Will the rendering data be cleared too?
         */
        resetUniforms(clearPasses?: boolean): void;
        /**
         * @en
         * Convenient property setter provided for quick material setup.<br>
         * [[renderer.Pass.setUniform]] should be used instead if you need to do per-frame uniform update.
         * @zh
         * 设置材质 uniform 参数的统一入口。<br>
         * 注意如果需要每帧更新 uniform，建议使用 [[renderer.Pass.setUniform]] 以获得更好的性能。
         * @param name The target uniform name.
         * @param val The target value.
         * @param passIdx The pass to apply to. Will apply to all passes if not specified.
         */
        setProperty(name: string, val: __private._cocos_core_assets_material__MaterialPropertyFull | __private._cocos_core_assets_material__MaterialPropertyFull[], passIdx?: number): void;
        /**
         * @en
         * Get the specified uniform value for this material.<br>
         * Note that only uniforms set through [[Material.setProperty]] can be acquired here.<br>
         * For the complete rendering data, use [[renderer.Pass.getUniform]] instead.
         * @zh
         * 获取当前材质的指定 uniform 参数的值。<br>
         * 注意只有通过 [[Material.setProperty]] 函数设置的参数才能从此函数取出，<br>
         * 如需取出完整的渲染数据，请使用 [[renderer.Pass.getUniform]]。
         * @param name The property or uniform name.
         * @param passIdx The target pass index. If not specified, return the first found value in all passes.
         */
        getProperty(name: string, passIdx?: number): __private._cocos_core_assets_material__MaterialPropertyFull | __private._cocos_core_assets_material__MaterialPropertyFull[];
        /**
         * @en Copy the target material, with optional overrides.
         * @zh 复制目标材质到当前实例，允许提供重载信息。
         * @param mat The material to be copied.
         * @param overrides The overriding states on top of the original material.
         */
        copy(mat: Material, overrides?: IMaterialInfo): void;
        protected _fillInfo(info: IMaterialInfo): void;
        protected _prepareInfo(patch: Record<string, unknown> | Record<string, unknown>[], cur: Record<string, unknown>[]): void;
        protected _createPasses(): renderer.Pass[];
        protected _update(keepProps?: boolean): void;
        protected _uploadProperty(pass: renderer.Pass, name: string, val: __private._cocos_core_assets_material__MaterialPropertyFull | __private._cocos_core_assets_material__MaterialPropertyFull[]): boolean;
        protected _bindTexture(pass: renderer.Pass, handle: number, val: __private._cocos_core_assets_material__MaterialPropertyFull, index?: number): void;
        protected _doDestroy(): void;
        initDefault(uuid?: string): void;
        validate(): boolean;
    }
    /**
     * @en Render texture is a render target for [[Camera]] or [[Canvas]] component,
     * the render pipeline will use its `RenderWindow` as the target of the rendering process.
     * @zh 渲染贴图是 [[Camera]] 或 [[Canvas]] 组件的渲染目标对象，渲染管线会使用它的 `RenderWindow` 作为渲染的目标窗口。
     */
    export class RenderTexture extends __private._cocos_core_assets_texture_base__TextureBase {
        /**
         * @en The render window for the render pipeline, it's created internally and cannot be modified.
         * @zh 渲染管线所使用的渲染窗口，内部逻辑创建，无法被修改。
         */
        get window(): __private._cocos_core_renderer_core_render_window__RenderWindow | null;
        /**
         * @en Initialize the render texture. Using IRenderTextureCreateInfo.
         * @zh 初始化渲染贴图。设置渲染贴图的名称、尺寸、渲染通道信息。
         * @param info @en The create info of render texture @zh 渲染贴图的创建信息
         */
        initialize(info: __private._cocos_core_assets_render_texture__IRenderTextureCreateInfo): void;
        /**
         * @en Reset the render texture. User may change the name, size or render pass info of the render texture.
         * @zh 重新初始化渲染贴图。用户可以更改渲染贴图的名称、尺寸、渲染通道信息。
         * @param info @en The create info of render texture @zh 渲染贴图的创建信息
         */
        reset(info: __private._cocos_core_assets_render_texture__IRenderTextureCreateInfo): void;
        /**
         * @en Destroy the render texture.
         * @zh 销毁渲染贴图。
         */
        destroy(): boolean;
        /**
         * @en Resize the render texture
         * @zh 修改渲染贴图的尺寸
         * @param width The pixel width, the range is from 1 to 2048
         * @param height The pixel height, the range is from 1 to 2048
         */
        resize(width: number, height: number): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _serialize(ctxForExporting: any): any;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _deserialize(serializedData: any, handle: any): void;
        /**
         * @en Gets the related [[gfx.Texture]] resource, it's also the color attachment for the render window
         * @zh 获取渲染贴图的 GFX 资源，同时也是渲染窗口所指向的颜色缓冲贴图资源
         */
        getGFXTexture(): gfx.Texture | null;
        /**
         * @en Callback function after render texture is loaded in [[CCLoader]]. Initialize the render texture.
         * @zh 通过 [[CCLoader]] 加载完成时的回调，初始化渲染贴图。
         */
        onLoaded(): void;
        /**
         * @en Implementation of the render texture initialization.
         * @zh 初始化渲染贴图的具体实现。
         * @param info @en The create info of render texture @zh 渲染贴图的创建信息
         */
        protected _initWindow(info?: __private._cocos_core_assets_render_texture__IRenderTextureCreateInfo): void;
        /**
         * @en Initialize the render texture with uuid. The default size is 1x1.
         * @zh 初始化渲染贴图。使用uuid进行初始化，贴图的尺寸为 1x1。
         * @param uuid @en asset uuid @zh 资源 uuid
         */
        initDefault(uuid?: string): void;
        /**
         * @en Validate the correctness of the render texture.
         * @zh 验证渲染贴图的正确性。
         */
        validate(): boolean;
        /**
         * @en Read pixel buffer from render texture @zh 从 render texture 读取像素数据
         * @param x @en The location on x axis @zh 起始位置X轴坐标
         * @param y @en The location on y axis @zh 起始位置Y轴坐标
         * @param width @en The pixel width @zh 像素宽度
         * @param height @en The pixel height @zh 像素高度
         * @param buffer @en The buffer to hold pixel data @zh 像素缓存
         */
        readPixels(x?: number, y?: number, width?: number, height?: number, buffer?: Uint8Array): Uint8Array | null;
    }
    /**
     * @en The script asset base class
     * @zh 脚本资源基类。
     */
    export class Script extends Asset {
    }
    /**
     * @en JavaScript asset.
     * @zh JavaScript 脚本资源。
     */
    export class JavaScript extends Script {
    }
    /**
     * @en TypeScript asset
     * @zh TypeScript 脚本资源。
     */
    export class TypeScript extends Script {
    }
    /**
     * @en Outputs a message at the "debug" log level.
     * @zh 输出一条“调试”日志等级的消息。
     */
    export function debug(...data: any[]): void;
    /**
     * @en Outputs a message to the Cocos Creator Console (editor) or Web Console (runtime).
     * @zh 输出一条消息到 Cocos Creator 编辑器的 Console 或运行时 Web 端的 Console 中。
     * @param message - A JavaScript string containing zero or more substitution strings.
     * @param optionalParams - JavaScript objects with which to replace substitution strings within msg.
     * This gives you additional control over the format of the output.
     */
    export function log(message?: any, ...optionalParams: any[]): void;
    /**
     * @en
     * Outputs an error message to the Cocos Creator Console (editor) or Web Console (runtime).<br/>
     * - In Cocos Creator, error is red.<br/>
     * - In Chrome, error have a red icon along with red message text.<br/>
     * @zh
     * 输出错误消息到 Cocos Creator 编辑器的 Console 或运行时页面端的 Console 中。<br/>
     * - 在 Cocos Creator 中，错误信息显示是红色的。<br/>
     * - 在 Chrome 中，错误信息有红色的图标以及红色的消息文本。<br/>
     * @param message - A JavaScript string containing zero or more substitution strings.
     * @param optionalParams - JavaScript objects with which to replace substitution strings within msg.
     * This gives you additional control over the format of the output.
     */
    export function error(message?: any, ...optionalParams: any[]): void;
    /**
     * @en
     * Outputs a warning message to the Cocos Creator Console (editor) or Web Console (runtime).
     * - In Cocos Creator, warning is yellow.
     * - In Chrome, warning have a yellow warning icon with the message text.
     * @zh
     * 输出警告消息到 Cocos Creator 编辑器的 Console 或运行时 Web 端的 Console 中。<br/>
     * - 在 Cocos Creator 中，警告信息显示是黄色的。<br/>
     * - 在 Chrome 中，警告信息有着黄色的图标以及黄色的消息文本。<br/>
     * @param message - A JavaScript string containing zero or more substitution strings.
     * @param optionalParams - JavaScript objects with which to replace substitution strings within msg.
     * This gives you additional control over the format of the output.
     */
    export function warn(message?: any, ...optionalParams: any[]): void;
    /**
     * @en
     * Assert the condition and output error messages if the condition is not true.
     * @zh
     * 对检查测试条件进行检查，如果条件不为 true 则输出错误消息
     * @param value - The condition to check on
     * @param message - A JavaScript string containing zero or more substitution strings.
     * @param optionalParams - JavaScript objects with which to replace substitution strings within msg.
     * This gives you additional control over the format of the output.
     */
    export function assert(value: any, message?: string, ...optionalParams: any[]): asserts value;
    export function logID(id: number, ...optionalParams: any[]): void;
    export function errorID(id: number, ...optionalParams: any[]): void;
    export function warnID(id: number, ...optionalParams: any[]): void;
    export function assertID(condition: any, id: number, ...optionalParams: any[]): void;
    /**
     * @en Returns whether or not to display the FPS and debug information.
     * @zh 是否显示 FPS 信息和部分调试信息。
     * @deprecated Since v3.6, Please use profiler.isShowingStates instead
     */
    export function isDisplayStats(): boolean;
    /**
     * @en Sets whether display the FPS and debug informations on the bottom-left corner.
     * @zh 设置是否在左下角显示 FPS 和部分调试。
     * @deprecated Since v3.6, Please use profiler.showStats instead
     */
    export function setDisplayStats(displayStats: boolean): void;
    /**
     * @en Gets error message with the error id and possible parameters.
     * @zh 通过 error id 和必要的参数来获取错误信息。
     */
    export function getError(errorId: number, ...param: any[]): string;
    /**
     * @en Enum for debug modes.
     * @zh 调试模式。
     */
    export enum DebugMode {
        /**
         * @en The debug mode none.
         * @zh 禁止模式，禁止显示任何日志消息。
         */
        NONE = 0,
        /**
         * @en The debug mode none.
         * @zh 调试模式，显示所有日志消息。
         */
        VERBOSE = 1,
        /**
         * @en Information mode, which display messages with level higher than "information" level.
         * @zh 信息模式，显示“信息”级别以上的日志消息。
         */
        INFO = 2,
        /**
         * @en Information mode, which display messages with level higher than "warning" level.
         * @zh 警告模式，显示“警告”级别以上的日志消息。
         */
        WARN = 3,
        /**
         * @en Information mode, which display only messages with "error" level.
         * @zh 错误模式，仅显示“错误”级别的日志消息。
         */
        ERROR = 4,
        /**
         * @en The debug mode info for web page.
         * @zh 信息模式（仅 WEB 端有效），在画面上输出所有信息。
         */
        INFO_FOR_WEB_PAGE = 5,
        /**
         * @en The debug mode warn for web page.
         * @zh 警告模式（仅 WEB 端有效），在画面上输出 warn 级别以上的（包含 error）信息。
         */
        WARN_FOR_WEB_PAGE = 6,
        /**
         * @en The debug mode error for web page.
         * @zh 错误模式（仅 WEB 端有效），在画面上输出 error 信息。
         */
        ERROR_FOR_WEB_PAGE = 7
    }
    export const screen: __private._cocos_core_platform_screen__Screen;
    /**
     * @en A set of system related variables
     * @zh 一系列系统相关环境变量
     */
    export const sys: {
        Feature: typeof __private._pal_system_info_enum_type_feature__Feature;
        /**
         * @en
         * Returns if the specified platform related feature is supported.
         * @zh
         * 返回指定的平台相关的特性是否支持。
         */
        hasFeature(feature: sys.Feature): boolean;
        /**
         * @en
         * Network type enumeration
         * @zh
         * 网络类型枚举
         */
        NetworkType: typeof __private._pal_system_info_enum_type_network_type__NetworkType;
        /**
         * @en
         * LanguageCode type enumeration
         * @zh
         * 语言码类型枚举
         */
        Language: typeof __private._pal_system_info_enum_type_language__Language;
        /**
         * @en
         * OS type enumeration
         * @zh
         * 操作系统类型枚举
         */
        OS: typeof __private._pal_system_info_enum_type_operating_system__OS;
        /**
         * @en
         * Platform type enumeration
         * @zh
         * 平台类型枚举
         */
        Platform: typeof __private._pal_system_info_enum_type_platform__Platform;
        /**
         * @en
         * Browser type enumeration
         * @zh
         * 浏览器类型枚举
         */
        BrowserType: typeof __private._pal_system_info_enum_type_browser_type__BrowserType;
        /**
         * @en Whether the running platform is native app
         * @zh 指示运行平台是否是原生平台
         */
        isNative: boolean;
        /**
         * @en Whether the running platform is browser
         * @zh 指示运行平台是否是浏览器
         */
        isBrowser: boolean;
        /**
         * @en Indicate whether the current running context is a mobile system
         * @zh 指示当前运行平台是否是移动端平台
         */
        isMobile: boolean;
        /**
         * @en Whether the endianness of current platform is little endian
         * @zh 当前平台字节顺序是否是小端序
         */
        isLittleEndian: boolean;
        /**
         * @en The running platform
         * @zh 当前运行平台或环境
         */
        platform: __private._pal_system_info_enum_type_platform__Platform;
        /**
         * @en Indicate the current language of the running system
         * @zh 指示当前运行环境的语言
         */
        language: __private._pal_system_info_enum_type_language__Language;
        /**
         * @en
         * Get current language iso 639-1 code.
         * Examples of valid language codes include "zh-tw", "en", "en-us", "fr", "fr-fr", "es-es", etc.
         * The actual value totally depends on results provided by destination platform.
         * @zh
         * 指示当前运行环境的语言
         * 获取当前的语言iso 639-1代码。
         * 有效的语言代码包括 "zh-tw"、"en"、"en-us"、"fr"、"fr-fr"、"es-es "等。
         * 实际值完全取决于目的地平台提供的结果。
         */
        languageCode: string;
        /**
         * @en Indicate the running os name
         * @zh 指示当前运行系统
         */
        os: __private._pal_system_info_enum_type_operating_system__OS;
        /**
         * @en Indicate the running os version string
         * @zh 指示当前运行系统版本字符串
         */
        osVersion: string;
        /**
         * @en Indicate the running os main version
         * @zh 指示当前系统主版本
         */
        osMainVersion: number;
        /**
         * @en Indicate the running browser type
         * @zh 指示当前运行的浏览器类型
         */
        browserType: __private._pal_system_info_enum_type_browser_type__BrowserType;
        /**
         * @en Indicate the running browser version
         * @zh 指示当前运行的浏览器版本
         */
        browserVersion: string;
        /**
         * @en Whether the running platform is xr app
         * @zh 指示运行平台是否是XR平台
         */
        isXR: boolean;
        /**
         * @en Indicate the real pixel resolution of the whole game window
         * @zh 指示游戏窗口的像素分辨率
         *
         * @deprecated since v3.4.0, please use screen.windowSize instead.
         */
        windowPixelResolution: math.Size;
        /**
         * @en The capabilities of the current platform
         * @zh 当前平台的功能可用性
         *
         * @deprecated since v3.4.0, please use sys.hasFeature() instead.
         */
        capabilities: {
            canvas: boolean;
            opengl: boolean;
            webp: boolean;
            imageBitmap: boolean;
            touches: boolean;
            mouse: boolean;
            keyboard: boolean;
            accelerometer: boolean;
        };
        /**
         * @en It is a local storage component based on HTML5 localStorage API, on web platform, it's equal to window.localStorage
         * @zh HTML5 标准中的 localStorage 的本地存储功能，在 Web 端等价于 window.localStorage
         */
        localStorage: Storage;
        /**
         * @en Get the network type of current device, return `sys.NetworkType.LAN` if failure.
         * @zh 获取当前设备的网络类型, 如果网络类型无法获取，默认将返回 `sys.NetworkType.LAN`
         */
        getNetworkType(): __private._pal_system_info_enum_type_network_type__NetworkType;
        /**
         * @en Get the battery level of current device, return 1.0 if failure.
         * @zh 获取当前设备的电池电量，如果电量无法获取，默认将返回 1
         * @return - 0.0 ~ 1.0
         */
        getBatteryLevel(): number;
        /**
         * @en Forces the garbage collection, only available in native platforms
         * @zh 强制进行 JS 内存垃圾回收，尽在原生平台有效
         */
        garbageCollect(): void;
        /**
         * @en Check whether an object is valid,
         * In web engine, it will return true if the object exist
         * In native engine, it will return true if the JS object and the correspond native object are both valid
         * @zh 检查一个对象是否非空或在原生平台有效，
         * 在 Web 平台，只要对象非空或非 Undefined 就会返回 true，在原生平台，我们会检查当前 JS 对象和其绑定的原生对象是否都有效
         * @param obj The object to be checked
         */
        isObjectValid(obj: any): boolean;
        /**
         * @en Dump systemInfo informations
         * @zh 在控制台打印当前的主要系统信息
         */
        dump(): void;
        /**
         * @en Try to open a url in browser, may not work in some platforms
         * @zh 尝试打开一个 web 页面，并非在所有平台都有效
         */
        openURL(url: any): void;
        /**
         * @internal
         */
        init(): void;
        /**
         * @en Get the current time in milliseconds
         * @zh 获取当前时间（毫秒为单位）
         */
        now(): number;
        /**
         * Restart the JS VM, only available in native platforms
         * @private
         */
        restartVM(): void;
        /**
         * @en
         * Returns the safe area of the screen (in design resolution) based on the game view coordinate system.
         * If the screen is not notched, this method returns a Rect of the same size as visibleSize by default.
         * Currently supports Android, iOS and WeChat, ByteDance Mini Game platform.
         * @zh
         * 返回基于游戏视图坐标系的手机屏幕安全区域（设计分辨率为单位），如果不是异形屏将默认返回一个和 visibleSize 一样大的 Rect。目前支持安卓、iOS 原生平台和微信、字节小游戏平台。
         * @method getSafeAreaRect
         * @return {Rect}
         */
        getSafeAreaRect(): math.Rect;
    };
    export namespace sys {
        /**
         * @en
         * Platform related feature enum type.
         * @zh
         * 平台相关的特性枚举类型。
         */
        export type Feature = __private._types_globals__EnumAlias<typeof __private._pal_system_info_enum_type_feature__Feature>;
    }
    export class View extends __private._cocos_core_platform_view__View_base {
        static instance: View;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _designResolutionSize: math.Size;
        constructor();
        init(): void;
        /**
         * @en
         * Sets whether resize canvas automatically when browser's size changed.<br/>
         * Useful only on web.
         * @zh 设置当发现浏览器的尺寸改变时，是否自动调整 canvas 尺寸大小。
         * 仅在 Web 模式下有效。
         * @param enabled - Whether enable automatic resize with browser's resize event
         */
        resizeWithBrowserSize(enabled: boolean): void;
        /**
         * @en
         * Sets the callback function for `view`'s resize action,<br/>
         * this callback will be invoked before applying resolution policy, <br/>
         * so you can do any additional modifications within the callback.<br/>
         * Useful only on web.
         * @zh 设置 `view` 调整视窗尺寸行为的回调函数，
         * 这个回调函数会在应用适配模式之前被调用，
         * 因此你可以在这个回调函数内添加任意附加改变，
         * 仅在 Web 平台下有效。
         * @param callback - The callback function
         */
        setResizeCallback(callback: (() => void) | null): void;
        /**
         * @en
         * Sets the orientation of the game, it can be landscape, portrait or auto.
         * When set it to landscape or portrait, and screen w/h ratio doesn't fit,
         * `view` will automatically rotate the game canvas using CSS.
         * Note that this function doesn't have any effect in native,
         * in native, you need to set the application orientation in native project settings
         * @zh 设置游戏屏幕朝向，它能够是横版，竖版或自动。
         * 当设置为横版或竖版，并且屏幕的宽高比例不匹配时，
         * `view` 会自动用 CSS 旋转游戏场景的 canvas，
         * 这个方法不会对 native 部分产生任何影响，对于 native 而言，你需要在应用设置中的设置排版。
         * @param orientation - Possible values: macro.ORIENTATION_LANDSCAPE | macro.ORIENTATION_PORTRAIT | macro.ORIENTATION_AUTO
         */
        setOrientation(orientation: number): void;
        /**
         * @en
         * Sets whether the engine modify the "viewport" meta in your web page.<br/>
         * It's enabled by default, we strongly suggest you not to disable it.<br/>
         * And even when it's enabled, you can still set your own "viewport" meta, it won't be overridden<br/>
         * Only useful on web
         * @zh 设置引擎是否调整 viewport meta 来配合屏幕适配。
         * 默认设置为启动，我们强烈建议你不要将它设置为关闭。
         * 即使当它启动时，你仍然能够设置你的 viewport meta，它不会被覆盖。
         * 仅在 Web 模式下有效
         * @param enabled - Enable automatic modification to "viewport" meta
         * @deprecated since v3.3
         */
        adjustViewportMeta(enabled: boolean): void;
        /**
         * @en
         * Retina support is enabled by default for Apple device but disabled for other devices,<br/>
         * it takes effect only when you called setDesignResolutionPolicy<br/>
         * Only useful on web
         * @zh 对于 Apple 这种支持 Retina 显示的设备上默认进行优化而其他类型设备默认不进行优化，
         * 它仅会在你调用 setDesignResolutionPolicy 方法时有影响。
         * 仅在 Web 模式下有效。
         * @param enabled - Enable or disable retina display
         *
         * @deprecated since v3.4.0
         */
        enableRetina(enabled: boolean): void;
        /**
         * @en
         * Check whether retina display is enabled.<br/>
         * Only useful on web
         * @zh 检查是否对 Retina 显示设备进行优化。
         * 仅在 Web 模式下有效。
         *
         * @deprecated since v3.4.0
         */
        isRetinaEnabled(): boolean;
        /**
         * @en
         * If enabled, the application will try automatically to enter full screen mode on mobile devices<br/>
         * You can pass true as parameter to enable it and disable it by passing false.<br/>
         * Only useful on web
         * @zh 启动时，移动端游戏会在移动端自动尝试进入全屏模式。
         * 你能够传入 true 为参数去启动它，用 false 参数来关闭它。
         * @param enabled - Enable or disable auto full screen on mobile devices
         *
         * @deprecated since v3.3, please use screen.requestFullScreen() instead.
         */
        enableAutoFullScreen(enabled: boolean): void;
        /**
         * @en
         * Check whether auto full screen is enabled.<br/>
         * Only useful on web
         * @zh 检查自动进入全屏模式是否启动。
         * 仅在 Web 模式下有效。
         * @return Auto full screen enabled or not
         *
         * @deprecated since v3.3
         */
        isAutoFullScreenEnabled(): boolean;
        /**
         * @en Set the canvas size in CSS pixels on Web platform.
         * This method is not supported on other platforms.
         * @zh  Web 平台下，可以以 CSS 像素尺寸来设置 canvas 尺寸。
         * 这个方法并不支持其他平台。
         * @private
         * @param {Number} width
         * @param {Number} height
         *
         * @deprecated since v3.4.0, setting size in CSS pixels is not recommended, please use screen.windowSize instead.
         */
        setCanvasSize(width: number, height: number): void;
        /**
         * @en
         * Returns the canvas size of the view.<br/>
         * On native platforms, it returns the screen size since the view is a fullscreen view.<br/>
         * On web, it returns the size of the canvas element.
         * @zh 返回视图中 canvas 的尺寸。
         * 在 native 平台下，它返回全屏视图下屏幕的尺寸。
         * 在 Web 平台下，它返回 canvas 元素尺寸。
         *
         * @deprecated since v3.4.0, please use screen.windowSize instead.
         */
        getCanvasSize(): math.Size;
        /**
         * @en
         * Returns the frame size of the view in CSS pixels.<br/>
         * On native platforms, it returns the screen size since the view is a fullscreen view.<br/>
         * On web, it returns the size of the canvas's outer DOM element.
         * @zh 以 CSS 像素尺寸返回视图中边框尺寸。
         * 在 native 平台下，它返回全屏视图下屏幕的尺寸。
         * 在 web 平台下，它返回 canvas 元素的外层 DOM 元素尺寸。
         *
         * @deprecated since v3.4.0, getting size in CSS pixels is not recommended, please use screen.windowSize instead.
         */
        getFrameSize(): math.Size;
        /**
         * @en Setting the frame size of the view in CSS pixels.
         * On native, it sets the frame size of view.<br/>
         * On web, it sets the size of the canvas's outer DOM element.
         * @zh 以 CSS 像素尺寸设置视图中边框尺寸。
         * 在 native 平台下，设置视图框架尺寸。
         * 在 web 平台下，设置 canvas 外层 DOM 元素尺寸。
         * @param {Number} width
         * @param {Number} height
         *
         * @deprecated since v3.4.0, setting size in CSS pixels is not recommended, please use screen.windowSize instead.
         */
        setFrameSize(width: number, height: number): void;
        /**
         * @en Returns the visible area size of the view port.
         * @zh 返回视图窗口可见区域尺寸。
         */
        getVisibleSize(): math.Size;
        /**
         * @en Returns the visible area size of the view port.
         * @zh 返回视图窗口可见区域像素尺寸。
         */
        getVisibleSizeInPixel(): math.Size;
        /**
         * @en Returns the visible origin of the view port.
         * @zh 返回视图窗口可见区域原点。
         */
        getVisibleOrigin(): math.Vec2;
        /**
         * @en Returns the visible origin of the view port.
         * @zh 返回视图窗口可见区域像素原点。
         */
        getVisibleOriginInPixel(): math.Vec2;
        /**
         * @en Returns the current resolution policy
         * @zh 返回当前分辨率方案
         * @see [[ResolutionPolicy]]
         */
        getResolutionPolicy(): ResolutionPolicy;
        /**
         * @en Sets the current resolution policy
         * @zh 设置当前分辨率模式
         * @see [[ResolutionPolicy]]
         */
        setResolutionPolicy(resolutionPolicy: ResolutionPolicy | number): void;
        /**
         * @en Sets the resolution policy with designed view size in points.<br/>
         * The resolution policy include: <br/>
         * [1] ResolutionExactFit       Fill screen by stretch-to-fit: if the design resolution ratio of width to height is different from the screen resolution ratio, your game view will be stretched.<br/>
         * [2] ResolutionNoBorder       Full screen without black border: if the design resolution ratio of width to height is different from the screen resolution ratio, two areas of your game view will be cut.<br/>
         * [3] ResolutionShowAll        Full screen with black border: if the design resolution ratio of width to height is different from the screen resolution ratio, two black borders will be shown.<br/>
         * [4] ResolutionFixedHeight    Scale the content's height to screen's height and proportionally scale its width<br/>
         * [5] ResolutionFixedWidth     Scale the content's width to screen's width and proportionally scale its height<br/>
         * [ResolutionPolicy]        [Web only feature] Custom resolution policy, constructed by ResolutionPolicy<br/>
         * @zh 通过设置设计分辨率和匹配模式来进行游戏画面的屏幕适配。
         * @param width Design resolution width.
         * @param height Design resolution height.
         * @param resolutionPolicy The resolution policy desired
         */
        setDesignResolutionSize(width: number, height: number, resolutionPolicy: ResolutionPolicy | number): void;
        /**
         * @en Returns the designed size for the view.
         * @zh 返回视图的设计分辨率。
         */
        getDesignResolutionSize(): math.Size;
        /**
         * @en Sets the container to desired pixel resolution and fit the game content to it.
         * This function is very useful for adaptation in mobile browsers.
         * In some HD android devices, the resolution is very high, but its browser performance may not be very good.
         * In this case, enabling retina display is very costy and not suggested, and if retina is disabled, the image may be blurry.
         * But this API can be helpful to set a desired pixel resolution which is in between.
         * This API will do the following:
         *     1. Set viewport's width to the desired width in pixel
         *     2. Set body width to the exact pixel resolution
         *     3. The resolution policy will be reset with designed view size in points.
         * @zh 设置容器（container）需要的像素分辨率并且适配相应分辨率的游戏内容。
         * @param width Design resolution width.
         * @param height Design resolution height.
         * @param resolutionPolicy The resolution policy desired
         *
         * @deprecated since v3.6.0
         */
        setRealPixelResolution(width: number, height: number, resolutionPolicy: ResolutionPolicy | number): void;
        /**
         * @en Returns the view port rectangle.
         * @zh 返回视窗剪裁区域。
         */
        getViewportRect(): math.Rect;
        /**
         * @en Returns scale factor of the horizontal direction (X axis).
         * @zh 返回横轴的缩放比，这个缩放比是将画布像素分辨率放到设计分辨率的比例。
         */
        getScaleX(): number;
        /**
         * @en Returns scale factor of the vertical direction (Y axis).
         * @zh 返回纵轴的缩放比，这个缩放比是将画布像素分辨率缩放到设计分辨率的比例。
         */
        getScaleY(): number;
        /**
         * @en Returns device pixel ratio for retina display.
         * @zh 返回设备或浏览器像素比例。
         *
         * @deprecated since v3.4.0, please use screen.devicePixelRatio instead.
         */
        getDevicePixelRatio(): number;
        /**
         * @en Returns the real location in view for a translation based on a related position
         * @zh 将屏幕坐标转换为游戏视图下的坐标。
         * @param tx - The X axis translation
         * @param ty - The Y axis translation
         * @param relatedPos - The related position object including "left", "top", "width", "height" informations
         * @param out - The out object to save the conversion result
         *
         * @deprecated since v3.4.0
         */
        convertToLocationInView(tx: number, ty: number, relatedPos: any, out?: math.Vec2): math.Vec2;
    }
    /**
     * @en ResolutionPolicy class is the root strategy class of scale strategy,
     * its main task is to maintain the compatibility with Cocos2d-x.
     *
     * @zh ResolutionPolicy 类是适配策略的根策略类，它的主要任务是保持与 Cocos2d-x 的兼容性。
     */
    export class ResolutionPolicy {
        /**
         * @en The entire application is visible in the specified area without trying to preserve the original aspect ratio.
         * Distortion can occur, and the application may appear stretched or compressed.
         *
         * @zh 整个应用程序在指定区域可见，无需尝试保留原始纵横比，
         * 可能会发生变形，出现画面拉伸或压缩。
         */
        static EXACT_FIT: number;
        /**
         * @en The entire application fills the specified area, without distortion but possibly with some cropping,
         * while maintaining the original aspect ratio of the application.
         *
         * @zh 整个应用程序填充指定区域，没有变形，但可能有一些裁剪，
         * 同时保持画面的原始纵横比。
         */
        static NO_BORDER: number;
        /**
         * @en The entire application is visible in the specified area without distortion while maintaining the original
         * aspect ratio of the application. Borders can appear on two sides of the application.
         *
         * @zh 整个应用程序在指定区域可见，没有变形，同时保持原始纵横比，
         * 边框可能出现在画面的旁侧。
         */
        static SHOW_ALL: number;
        /**
         * @en The application takes the height of the design resolution size and modifies the width of the internal
         * canvas so that it fits the aspect ratio of the device
         * no distortion will occur however you must make sure your application works on different
         * aspect ratios
         *
         * @zh 该应用程序采用设计分辨率大小的高度并修改内部画布的宽度，使其适合设备的纵横比，不会发生变形，
         * 但是您必须确保您的应用程序在不同的纵横比的设备下工作。
         */
        static FIXED_HEIGHT: number;
        /**
         * @en The application takes the width of the design resolution size and modifies the height of the internal
         * canvas so that it fits the aspect ratio of the device
         * no distortion will occur however you must make sure your application works on different
         * aspect ratios
         *
         * @zh 该应用程序采用设计分辨率大小的宽度并修改内部画布的高度，使其适合设备的纵横比，不会发生变形
         * 但是您必须确保您的应用程序在不同的纵横比的设备下工作。
         */
        static FIXED_WIDTH: number;
        /**
         * @en Unknown policy
         *
         * @zh 未知的策略
         */
        static UNKNOWN: number;
        static ContainerStrategy: typeof __private._cocos_core_platform_view__ContainerStrategy;
        static ContentStrategy: typeof __private._cocos_core_platform_view__ContentStrategy;
        name: string;
        /**
         * Constructor of ResolutionPolicy
         * @param containerStg
         * @param contentStg
         */
        constructor(containerStg: __private._cocos_core_platform_view__ContainerStrategy, contentStg: __private._cocos_core_platform_view__ContentStrategy);
        get canvasSize(): math.Size;
        /**
         * @en Manipulation before applying the resolution policy
         * @zh 策略应用前的操作
         * @param _view The target view
         */
        preApply(_view: View): void;
        /**
         * @en Function to apply this resolution policy
         * The return value is {scale: [scaleX, scaleY], viewport: {new Rect}},
         * The target view can then apply these value to itself, it's preferred not to modify directly its private variables
         * @zh 调用策略方法
         * @param _view - The target view
         * @param designedResolution - The user defined design resolution
         * @return An object contains the scale X/Y values and the viewport rect
         */
        apply(_view: View, designedResolution: math.Size): __private._cocos_core_platform_view__AdaptResult;
        /**
         * @en Manipulation after appyling the strategy
         * @zh 策略应用之后的操作
         * @param _view - The target view
         */
        postApply(_view: View): void;
        /**
         * @en Setup the container's scale strategy
         * @zh 设置容器的适配策略
         * @param containerStg The container strategy
         */
        setContainerStrategy(containerStg: __private._cocos_core_platform_view__ContainerStrategy): void;
        /**
         * @en Setup the content's scale strategy
         * @zh 设置内容的适配策略
         * @param contentStg The content strategy
         */
        setContentStrategy(contentStg: __private._cocos_core_platform_view__ContentStrategy): void;
    }
    /**
     * @en view is the singleton view object.
     * @zh view 是全局的视图单例对象。
     */
    export const view: View;
    /**
     * @zh
     * 游戏配置。
     * @en
     * Game configuration.
     */
    export interface IGameConfig {
        /**
         * @zh
         * 引擎配置文件路径
         * @en
         * The path of settings.json
         */
        settingsPath?: string;
        /**
         * @zh
         * 设置 debug 模式，在浏览器中这个选项会被忽略。
         * @en
         * Set debug mode, only valid in non-browser environment.
         */
        debugMode?: __private._cocos_core_platform_debug.DebugMode;
        /**
         * @zh
         * 覆盖 settings 模块中的配置项, 用于控制引擎的启动和初始化，你可以在 game.init 中传入参数，也可以在 [game.onPostBaseInitDelegate] 事件回调中覆盖。
         * 需要注意的是你需要在 application.js 模板中指定此选项和监听此事件。
         * @en
         * Overrides the settings module's some configuration, which is used to control the startup and initialization of the engine.
         * You can pass in parameters in game.init or override them in the [game.onPostBaseInitDelegate] event callback.
         * Note: you need to specify this option in the application.js template or add a delegate callback.
         */
        overrideSettings: Partial<{
            [k in Settings.Category[keyof Settings.Category]]: Record<string, any>;
        }>;
        /**
         * @zh
         * 当 showFPS 为 true 的时候界面的左下角将显示 fps 的信息，否则被隐藏。
         * @en
         * Left bottom corner fps information will show when "showFPS" equals true, otherwise it will be hide.
         * @deprecated Since v3.6, Please use ```overrideSettings: { Settings.Category.PROFILING: { "showFPS": true }}``` to set this.
         */
        showFPS?: boolean;
        /**
         * @zh
         * 设置想要的帧率你的游戏，但真正的FPS取决于你的游戏实现和运行环境。
         * @en
         * Set the wanted frame rate for your game, but the real fps depends on your game implementation and the running environment.
         * @deprecated Since v3.6, Please use ```overrideSettings: { Settings.Category.SCREEN: { "frameRate": 60 }}``` to set this.
         */
        frameRate?: number;
        /**
         * @zh
         * 渲染模式。
         * 设置渲染器类型，仅适用于 web 端：
         * - 0 - 通过引擎自动选择。
         * - 1 - 强制使用 canvas 渲染。
         * - 2 - 强制使用 WebGL 渲染，但是在部分 Android 浏览器中这个选项会被忽略。
         * - 3 - 使用空渲染器，可以用于测试和服务器端环境，目前暂时用于 Cocos 内部测试使用
         * @en
         * Sets the renderer type, only useful on web:
         * - 0 - Automatically chosen by engine.
         * - 1 - Forced to use canvas renderer.
         * - 2 - Forced to use WebGL renderer, but this will be ignored on mobile browsers.
         * - 3 - Use Headless Renderer, which is useful in test or server env, only for internal use by cocos team for now
         * @deprecated Since v3.6, Please use ```overrideSettings: { Settings.Category.RENDERING: { "renderMode": 0 }}``` to set this.
         */
        renderMode?: 0 | 1 | 2 | 3;
        /**
         * @en
         * Render pipeline resources
         * @zh
         * Render pipeline 资源
         * @deprecated Since v3.6, Please use ```overrideSettings: { Settings.Category.RENDERING: { "renderPipeline": '' }}``` to set this.
         */
        renderPipeline?: string;
        /**
         * @en
         * Asset Manager initialization options
         * @zh
         * 资源管理器初始化设置
         * @deprecated Since v3.6, Please use ```overrideSettings: { Settings.Category.ASSETS: {}}``` to set this.
         */
        assetOptions?: __private._cocos_core_asset_manager_asset_manager__IAssetManagerOptions;
        /**
         * @en
         * GPU instancing options
         * @zh
         * GPU instancing 选项
         * @deprecated Since v3.6, Please use ```overrideSettings: { Settings.Category.ANIMATION: { customJointTextureLayouts: [] }}``` to set this.
         */
        customJointTextureLayouts?: __private._cocos_3d_skeletal_animation_skeletal_animation_utils__ICustomJointTextureLayout[];
        /**
         * @en
         * Physics system config
         * @zh
         * 物理系统设置
         * @deprecated Since v3.6, Please use ```overrideSettings: { Settings.Category.PHYSICS: {}}``` to set this.
         */
        physics?: physics.IPhysicsConfig;
        /**
         * @en
         * The orientation from the builder configuration.
         * Available value can be 'auto', 'landscape', 'portrait'.
         * @zh
         * 屏幕旋转方向，可选 “自动”，“横屏”，“竖屏”
         * @deprecated Since v3.6, Please use ```overrideSettings: { Settings.Category.SCREEN: { 'orientation': 'auto' }}``` to set this.
         */
        orientation?: __private._pal_screen_adapter__ConfigOrientation;
        /**
         * @en
         * Determine whether the game frame exact fits the screen.
         * Now it only works on Web platform.
         * @zh
         * 是否让游戏外框对齐到屏幕上，目前只在 web 平台生效
         * @deprecated Since v3.6, Please use ```overrideSettings: { Settings.Category.SCREEN: { 'exactFitScreen': true }}``` to set this.
         */
        exactFitScreen: boolean;
    }
    /**
     * @en An object to boot the game.
     * @zh 包含游戏主体信息并负责驱动游戏的游戏对象。
     */
    export class Game extends EventTarget {
        /**
         * @en Event triggered when game hide to background.<br>
         * Please note that this event is not 100% guaranteed to be fired on Web platform,<br>
         * on native platforms, it corresponds to enter background event, os status bar or notification center may not trigger this event.
         * @zh 游戏进入后台时触发的事件。<br>
         * 请注意，在 WEB 平台，这个事件不一定会 100% 触发，这完全取决于浏览器的回调行为。<br>
         * 在原生平台，它对应的是应用被切换到后台事件，下拉菜单和上拉状态栏等不一定会触发这个事件，这取决于系统行为。
         * @example
         * ```ts
         * import { game, audioEngine } from 'cc';
         * game.on(Game.EVENT_HIDE, function () {
         *     audioEngine.pauseMusic();
         *     audioEngine.pauseAllEffects();
         * });
         * ```
         */
        static readonly EVENT_HIDE = "game_on_hide";
        /**
         * @en Event triggered when game back to foreground<br>
         * Please note that this event is not 100% guaranteed to be fired on Web platform,<br>
         * on native platforms, it corresponds to enter foreground event.
         * @zh 游戏进入前台运行时触发的事件。<br>
         * 请注意，在 WEB 平台，这个事件不一定会 100% 触发，这完全取决于浏览器的回调行为。<br>
         * 在原生平台，它对应的是应用被切换到前台事件。
         */
        static readonly EVENT_SHOW: string;
        /**
         * @en Event triggered when system in low memory status.<br>
         * This event is only triggered on native iOS/Android platform.
         * @zh 程序在内存不足时触发的事件。<br>
         * 该事件只会在 iOS/Android 平台触发。
         */
        static readonly EVENT_LOW_MEMORY: string;
        /**
         * @en Event triggered after game inited, at this point all engine objects and game scripts are loaded
         * @zh 游戏启动后的触发事件，此时加载所有的引擎对象和游戏脚本。
         */
        static readonly EVENT_GAME_INITED = "game_inited";
        /**
         * @en Event triggered after engine inited, at this point you will be able to use all engine classes.<br>
         * It was defined as EVENT_RENDERER_INITED in cocos creator v1.x and renamed in v2.0.
         * Since Cocos Creator v3.0, EVENT_RENDERER_INITED is a new event, look up define for details.
         * @zh 在引擎初始化之后触发的事件，此时您能够使用引擎所有的类。<br>
         * 它在 Cocos Creator v1.x 版本中名字为 EVENT_RENDERER_INITED，在 v2.0 更名为 EVENT_ENGINE_INITED
         * 并在 Cocos Creator v3.0 中将 EVENT_RENDERER_INITED 用作为渲染器初始化的事件。
         */
        static readonly EVENT_ENGINE_INITED = "engine_inited";
        /**
         * @en Event triggered after renderer inited, at this point you will be able to use all gfx renderer feature.<br>
         * @zh 在渲染器初始化之后触发的事件，此事件在 EVENT_ENGINE_INITED 之前触发，此时开始可使用 gfx 渲染框架。
         */
        static readonly EVENT_RENDERER_INITED: string;
        /**
         * @en Event triggered pre base module initialization, at this point you can not use pal/logging/sys/settings API.
         * @zh 基础模块初始化之前的事件，在这个事件点你无法使用 pal/logging/sys/settings 的相关接口。
         */
        static readonly EVENT_PRE_BASE_INIT = "pre_base_init";
        /**
         * @en Event triggered post base module initialization, at this point you can use pal/logging/sys/settings API safely.
         * @zh 基础模块初始化之后的事件，在这个事件点你可以安全使用 pal/logging/sys/settings 的相关接口。
         */
        static readonly EVENT_POST_BASE_INIT = "post_base_init";
        /**
         * @en Event triggered pre infrastructure initialization, at this point you can not use assetManager/gfx/screen/builtinResMgr/macro/Layer API.
         * @zh 基础设施初始化之前的事件，在这个事件点你无法使用 assetManager/gfx/screen/builtinResMgr/macro/Layer 的相关接口。
         */
        static readonly EVENT_PRE_INFRASTRUCTURE_INIT = "pre_infrastructure_init";
        /**
         * @en Event triggered post infrastructure initialization, at this point you can use assetManager/gfx/screen/builtinResMgr/macro/Layer API safely.
         * @zh 基础设施初始化之后的事件，在这个事件点你可以安全使用 assetManager/gfx/screen/builtinResMgr/macro/Layer 的相关接口。
         */
        static readonly EVENT_POST_INFRASTRUCTURE_INIT = "post_infrastructure_init";
        /**
         * @en Event triggered pre subsystem initialization, at this point you can not use physics/animation/rendering/tween/etc API.
         * @zh 子系统初始化之前的事件，在这个事件点你无法使用 physics/animation/rendering/tween/etc 的相关接口。
         */
        static readonly EVENT_PRE_SUBSYSTEM_INIT = "pre_subsystem_init";
        /**
         * @en Event triggered post subsystem initialization, at this point you can use physics/animation/rendering/tween/etc API safely.
         * @zh 子系统初始化之后的事件，在这个事件点你可以安全使用 physics/animation/rendering/tween/etc 的相关接口。
         */
        static readonly EVENT_POST_SUBSYSTEM_INIT = "post_subsystem_init";
        /**
         * @en Event triggered pre project data initialization,
         * at this point you can not access project data using [resources.load]/[director.loadScene] API.
         * @zh 项目数据初始化之前的事件，在这个事件点你无法使用访问项目数据的相关接口，例如 [resources.load]/[director.loadScene] 等 API。
         */
        static readonly EVENT_PRE_PROJECT_INIT = "pre_project_init";
        /**
         * @en Event triggered post project data initialization,
         * at this point you can access project data using [resources.load]/[director.loadScene] API safely.
         * @zh 项目数据初始化之后的事件，在这个事件点你可以安全使用访问项目数据的相关接口，例如 [resources.load]/[director.loadScene] 等 API。
         */
        static readonly EVENT_POST_PROJECT_INIT = "post_project_init";
        /**
         * @en Event triggered when game restart
         * @zh 调用restart后，触发事件
         */
        static readonly EVENT_RESTART = "game_on_restart";
        /**
         * @en Web Canvas 2d API as renderer backend.
         * @zh 使用 Web Canvas 2d API 作为渲染器后端。
         */
        static readonly RENDER_TYPE_CANVAS = 0;
        /**
         * @en WebGL API as renderer backend.
         * @zh 使用 WebGL API 作为渲染器后端。
         */
        static readonly RENDER_TYPE_WEBGL = 1;
        /**
         * @en OpenGL API as renderer backend.
         * @zh 使用 OpenGL API 作为渲染器后端。
         */
        static readonly RENDER_TYPE_OPENGL = 2;
        /**
         * @en Headless Renderer, usually used in test or server env
         * @zh 空渲染器，通常用于测试环境或服务器端模式
         */
        static readonly RENDER_TYPE_HEADLESS = 3;
        /**
         * @en If delta time since last frame is more than this threshold in seconds,
         * the game timer will consider user is debugging and adjust the delta time to [[frameTime]].
         * @zh 如果距离上一帧的帧间隔超过了这个阈值（单位是 s），那么就会被认为正在调试，帧间隔会被自动调节为 [[frameTime]].
         */
        static DEBUG_DT_THRESHOLD: number;
        /**
         * @en The outer frame of the game canvas; parent of game container.
         * @zh 游戏画布的外框，container 的父容器。
         *
         * @deprecated since 3.4.0, frame is a concept on web standard, please manager screens via the `screen` module.
         */
        frame: HTMLDivElement | null;
        /**
         * @en The container of game canvas.
         * @zh 游戏画布的容器。
         *
         * @deprecated since 3.4.0, container is a concept on web standard, please manager screens via the `screen` module.
         */
        container: HTMLDivElement | null;
        /**
         * @en The canvas of the game.
         * @zh 游戏的画布。
         */
        canvas: HTMLCanvasElement | null;
        /**
         * @en The renderer backend of the game.
         * @zh 游戏的渲染器类型。
         */
        renderType: number;
        eventTargetOn: <TFunction extends (...any: any[]) => void>(type: string | number, callback: TFunction, thisArg?: any, once?: boolean | undefined) => TFunction;
        eventTargetOnce: <TFunction extends (...any: any[]) => void>(type: string | number, callback: TFunction, thisArg?: any) => TFunction;
        /**
         * @en
         * The current game configuration,
         * please be noticed any modification directly on this object after the game initialization won't take effect.
         * @zh
         * 当前的游戏配置
         * 注意：请不要直接修改这个对象，它不会有任何效果。
         */
        config: IGameConfig;
        /**
         * @en Callback when the scripts of engine have been load.
         * @zh 当引擎完成启动后的回调函数。
         * @method onStart
         */
        onStart: Game.OnStart | null;
        /**
         * @en Indicates whether the engine and the renderer has been initialized
         * @zh 引擎和渲染器是否以完成初始化
         */
        get inited(): boolean;
        /**
         * @en Expected frame rate of the game.
         * @zh 游戏的设定帧率。
         */
        get frameRate(): number | string;
        set frameRate(frameRate: number | string);
        /**
         * @en The delta time since last frame, unit: s.
         * @zh 获取上一帧的增量时间，以秒为单位。
         */
        get deltaTime(): number;
        /**
         * @en The total passed time since game start, unit: ms
         * @zh 获取从游戏开始到现在总共经过的时间，以毫秒为单位
         */
        get totalTime(): number;
        /**
         * @en The start time of the current frame in milliseconds.
         * @zh 获取当前帧开始的时间（以 ms 为单位）。
         */
        get frameStartTime(): number;
        /**
         * @en The expected delta time of each frame in milliseconds
         * @zh 期望帧率对应的每帧时间（以 ms 为单位）
         */
        frameTime: number;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _isCloning: boolean;
        /**
         * @en The event delegate pre base module initialization. At this point you can not use pal/logging/sys/settings API.
         * @zh 基础模块初始化之前的事件代理。在这个事件点你无法使用 pal/logging/sys/settings 的相关接口。
         */
        readonly onPreBaseInitDelegate: AsyncDelegate<() => (Promise<void> | void)>;
        /**
         * @en The event delegate post base module initialization. At this point you can use pal/logging/sys/settings API safely.
         * @zh 基础模块初始化之后的事件代理。在这个事件点你可以安全使用 pal/logging/sys/settings 的相关接口。
         */
        readonly onPostBaseInitDelegate: AsyncDelegate<() => (Promise<void> | void)>;
        /**
         * @en The event delegate pre infrastructure module initialization.
         * At this point you can not use assetManager/gfx/screen/builtinResMgr/macro/Layer API.
         * @zh 基础设施模块初始化之前的事件代理。在这个事件点你无法使用 assetManager/gfx/screen/builtinResMgr/macro/Layer 的相关接口。
         */
        readonly onPreInfrastructureInitDelegate: AsyncDelegate<() => (Promise<void> | void)>;
        /**
         * @en The event delegate post infrastructure module initialization.
         * At this point you can use assetManager/gfx/screen/builtinResMgr/macro/Layer API safely.
         *
         * @zh 基础设施模块初始化之后的事件代理。在这个事件点你可以安全使用 assetManager/gfx/screen/builtinResMgr/macro/Layer 的相关接口。
         */
        readonly onPostInfrastructureInitDelegate: AsyncDelegate<() => (Promise<void> | void)>;
        /**
         * @en The event delegate pre sub system module initialization. At this point you can not use physics/animation/rendering/tween/etc API.
         * @zh 子系统模块初始化之前的事件代理。在这个事件点你无法使用 physics/animation/rendering/tween/etc 的相关接口。
         */
        readonly onPreSubsystemInitDelegate: AsyncDelegate<() => (Promise<void> | void)>;
        /**
         * @en The event delegate post sub system module initialization. At this point you can use physics/animation/rendering/tween/etc API safely.
         * @zh 子系统模块初始化之后的事件代理。在这个事件点你可以安全使用 physics/animation/rendering/tween/etc 的相关接口。
         */
        readonly onPostSubsystemInitDelegate: AsyncDelegate<() => (Promise<void> | void)>;
        /**
         * @en The event delegate pre project data initialization.
         * At this point you can not access project data using [resources.load]/[director.loadScene] API.
         * @zh 项目数据初始化之前的事件代理。在这个事件点你无法使用访问项目数据的相关接口，例如 [resources.load]/[director.loadScene] 等 API。
         */
        readonly onPreProjectInitDelegate: AsyncDelegate<() => (Promise<void> | void)>;
        /**
         * @en The event delegate post project data initialization.
         * at this point you can access project data using [resources.load]/[director.loadScene] API safely.
         * @zh 项目数据初始化之后的事件代理。
         * 在这个事件点你可以安全使用访问项目数据的相关接口，例如 [resources.load]/[director.loadScene] 等 API。
         */
        readonly onPostProjectInitDelegate: AsyncDelegate<() => (Promise<void> | void)>;
        /**
         * @en Set frame rate of game.
         * @zh 设置游戏帧率。
         * @deprecated since v3.3.0 please use [[game.frameRate]]
         */
        setFrameRate(frameRate: number | string): void;
        /**
         * @en Get frame rate set for the game, it doesn't represent the real frame rate.
         * @zh 获取设置的游戏帧率（不等同于实际帧率）。
         * @return frame rate
         * @deprecated since v3.3.0 please use [[game.frameRate]]
         */
        getFrameRate(): number;
        /**
         * @en Run the game frame by frame with a fixed delta time correspond to frame rate.
         * @zh 以固定帧间隔执行一帧游戏循环，帧间隔与设定的帧率匹配。
         */
        step(): void;
        /**
         * @en Pause the game main loop. This will pause:
         * - game logic execution
         * - rendering process
         * - input event dispatching (excluding Web and Minigame platforms)
         *
         * This is different with `director.pause()` which only pause the game logic execution.
         *
         * @zh 暂停游戏主循环。包含：
         * - 游戏逻辑
         * - 渲染
         * - 输入事件派发（Web 和小游戏平台除外）
         *
         * 这点和只暂停游戏逻辑的 `director.pause()` 不同。
         */
        pause(): void;
        /**
         * @en Resume the game from pause. This will resume:<br>
         * game logic execution, rendering process, event manager, background music and all audio effects.<br>
         * @zh 恢复游戏主循环。包含：游戏逻辑，渲染，事件处理，背景音乐和所有音效。
         */
        resume(): void;
        /**
         * @en Check whether the game is paused.
         * @zh 判断游戏是否暂停。
         */
        isPaused(): boolean;
        /**
         * @en Restart game.
         * @zh 重新开始游戏
         */
        restart(): Promise<void>;
        /**
         * @en End game, it will close the game window
         * @zh 退出游戏
         */
        end(): void;
        /**
         * @en
         * Register an callback of a specific event type on the game object.<br>
         * This type of event should be triggered via `emit`.<br>
         * @zh
         * 注册 game 的特定事件类型回调。这种类型的事件应该被 `emit` 触发。<br>
         *
         * @param type - A string representing the event type to listen for.
         * @param callback - The callback that will be invoked when the event is dispatched.<br>
         *                              The callback is ignored if it is a duplicate (the callbacks are unique).
         * @param target - The target (this object) to invoke the callback, can be null
         * @param once - After the first invocation, whether the callback should be unregistered.
         * @return - Just returns the incoming callback so you can save the anonymous function easier.
         */
        on(type: string, callback: () => void, target?: any, once?: boolean): any;
        /**
         * @en
         * Register an callback of a specific event type on the game object,<br>
         * the callback will remove itself after the first time it is triggered.<br>
         * @zh
         * 注册 game 的特定事件类型回调，回调会在第一时间被触发后删除自身。
         *
         * @param type - A string representing the event type to listen for.
         * @param callback - The callback that will be invoked when the event is dispatched.<br>
         *                              The callback is ignored if it is a duplicate (the callbacks are unique).
         * @param target - The target (this object) to invoke the callback, can be null
         */
        once(type: string, callback: () => void, target?: any): any;
        /**
         * @en Init game with configuration object. Initialization process like below:
         * -PreBaseInitEvent
         * -BaseModuleInitialization(logging, sys, settings)
         * -PostBaseInitEvent
         * -PreInfrastructureInitEvent
         * -InfrastructureModuleInitialization(assetManager, builtinResMgr, gfxDevice, screen, Layer, macro)
         * -PostInfrastructureInitEvent
         * -PreSubsystemInitEvent
         * -SubsystemModuleInitialization(animation, physics, tween, ui, middleware, etc)
         * -PostSubsystemInitEvent
         * -EngineInitedEvent
         * -PreProjectDataInitEvent
         * -ProjectDataInitialization(GamePlayScripts, resources, etc)
         * -PostProjectDataInitEvent
         * -GameInitedEvent
         *
         * @zh 使用指定的配置初始化引擎。初始化流程如下：
         * -PreBaseInitEvent
         * -BaseModuleInitialization(logging, sys, settings)
         * -PostBaseInitEvent
         * -PreInfrastructureInitEvent
         * -InfrastructureModuleInitialization(assetManager, builtinResMgr, gfxDevice, screen, Layer, macro)
         * -PostInfrastructureInitEvent
         * -PreSubsystemInitEvent
         * -SubsystemModuleInitialization(animation, physics, tween, ui, middleware, etc)
         * -PostSubsystemInitEvent
         * -EngineInitedEvent
         * -PreProjectDataInitEvent
         * -ProjectDataInitialization(GamePlayScripts, resources, etc)
         * -PostProjectDataInitEvent
         * -GameInitedEvent
         * @param config - Pass configuration object
         */
        init(config: IGameConfig): Promise<void>;
        /**
         * @internal only for game-view
         */
        _loadProjectBundles(): Promise<void[]>;
        /**
         * @en Run game with configuration object and onStart function.
         * @zh 运行游戏，并且指定引擎配置和 onStart 的回调。
         * @param onStart - function to be executed after game initialized
         */
        run(onStart?: Game.OnStart): void;
        /**
         * @en
         * Add a persistent root node to the game, the persistent node won't be destroyed during scene transition.<br>
         * The target node must be placed in the root level of hierarchy, otherwise this API won't have any effect.
         * @zh
         * 声明常驻根节点，该节点不会在场景切换中被销毁。<br>
         * 目标节点必须位于为层级的根节点，否则无效。
         * @param node - The node to be made persistent
         * @deprecated Since v3.6.0, please use director.addPersistRootNode instead.
         */
        addPersistRootNode(node: Node): void;
        /**
         * @en Remove a persistent root node.
         * @zh 取消常驻根节点。
         * @param node - The node to be removed from persistent node list
         * @deprecated Since v3.6.0, please use director.removePersistRootNode instead.
         */
        removePersistRootNode(node: Node): void;
        /**
         * @en Check whether the node is a persistent root node.
         * @zh 检查节点是否是常驻根节点。
         * @param node - The node to be checked.
         * @deprecated Since v3.6.0, please use director.isPersistRootNode instead.
         */
        isPersistRootNode(node: Node): boolean;
    }
    export namespace Game {
        export type OnStart = () => void;
    }
    /**
     * @en
     * This is a Game instance.
     * @zh
     * 这是一个 Game 类的实例，包含游戏主体信息并负责驱动游戏的游戏对象。
     */
    export const game: Game;
    export interface ISchedulable {
        id?: string;
        uuid?: string;
    }
    /**
     * @en
     * Scheduler is responsible of triggering the scheduled callbacks.<br>
     * You should not use NSTimer. Instead use this class.<br>
     * <br>
     * There are 2 different types of callbacks (selectors):<br>
     *     - update callback: the 'update' callback will be called every frame. You can customize the priority.<br>
     *     - custom callback: A custom callback will be called every frame, or with a custom interval of time<br>
     * <br>
     * The 'custom selectors' should be avoided when possible. It is faster,<br>
     * and consumes less memory to use the 'update callback'. *
     * @zh
     * Scheduler 是负责触发回调函数的类。<br>
     * 通常情况下，建议使用 `director.getScheduler()` 来获取系统定时器。<br>
     * 有两种不同类型的定时器：<br>
     *     - update 定时器：每一帧都会触发。您可以自定义优先级。<br>
     *     - 自定义定时器：自定义定时器可以每一帧或者自定义的时间间隔触发。<br>
     * 如果希望每帧都触发，应该使用 update 定时器，使用 update 定时器更快，而且消耗更少的内存。
     */
    export class Scheduler extends System {
        static ID: string;
        /**
         * @en This method should be called for any target which needs to schedule tasks, and this method should be called before any scheduler API usage.
         * This method will add a `id` property if it doesn't exist.
         * @zh 任何需要用 Scheduler 管理任务的对象主体都应该调用这个方法，并且应该在调用任何 Scheduler API 之前调用这个方法。
         * 这个方法会给对象添加一个 `id` 属性，如果这个属性不存在的话。
         * @param target
         */
        static enableForTarget(target: ISchedulable): void;
        constructor();
        /**
         * @en
         * Modifies the time of all scheduled callbacks.<br>
         * You can use this property to create a 'slow motion' or 'fast forward' effect.<br>
         * Default is 1.0. To create a 'slow motion' effect, use values below 1.0.<br>
         * To create a 'fast forward' effect, use values higher than 1.0.<br>
         * Note：It will affect EVERY scheduled selector / action.
         * @zh
         * 设置时间间隔的缩放比例。<br>
         * 您可以使用这个方法来创建一个 “slow motion（慢动作）” 或 “fast forward（快进）” 的效果。<br>
         * 默认是 1.0。要创建一个 “slow motion（慢动作）” 效果,使用值低于 1.0。<br>
         * 要使用 “fast forward（快进）” 效果，使用值大于 1.0。<br>
         * 注意：它影响该 Scheduler 下管理的所有定时器。
         * @param timeScale
         */
        setTimeScale(timeScale: any): void;
        /**
         * @en Returns time scale of scheduler.
         * @zh 获取时间间隔的缩放比例。
         */
        getTimeScale(): number;
        /**
         * @en 'update' the scheduler. (You should NEVER call this method, unless you know what you are doing.)
         * @zh update 调度函数。(不应该直接调用这个方法，除非完全了解这么做的结果)
         * @param dt delta time
         */
        update(dt: any): void;
        /**
         * @en
         * <p>
         *   The scheduled method will be called every 'interval' seconds.<br/>
         *   If paused is YES, then it won't be called until it is resumed.<br/>
         *   If 'interval' is 0, it will be called every frame, but if so, it recommended to use 'scheduleUpdateForTarget:' instead.<br/>
         *   If the callback function is already scheduled, then only the interval parameter will be updated without re-scheduling it again.<br/>
         *   repeat let the action be repeated repeat + 1 times, use `macro.REPEAT_FOREVER` to let the action run continuously<br/>
         *   delay is the amount of time the action will wait before it'll start. Unit: s<br/>
         * </p>
         * @zh
         * 指定回调函数，调用对象等信息来添加一个新的定时器。<br/>
         * 如果 paused 值为 true，那么直到 resume 被调用才开始计时。<br/>
         * 当时间间隔达到指定值时，设置的回调函数将会被调用。<br/>
         * 如果 interval 值为 0，那么回调函数每一帧都会被调用，但如果是这样，
         * 建议使用 scheduleUpdateForTarget 代替。<br/>
         * 如果回调函数已经被定时器使用，那么只会更新之前定时器的时间间隔参数，不会设置新的定时器。<br/>
         * repeat 值可以让定时器触发 repeat + 1 次，使用 `macro.REPEAT_FOREVER`
         * 可以让定时器一直循环触发。<br/>
         * delay 值指定延迟时间，定时器会在延迟指定的时间之后开始计时，单位: 秒。
         * @param callback
         * @param target
         * @param interval
         * @param [repeat]
         * @param [delay=0]
         * @param [paused=fasle]
         */
        schedule(callback: (dt?: number) => void, target: ISchedulable, interval: number, repeat?: number, delay?: number, paused?: boolean): void;
        /**
         * @en
         * Schedules the update callback for a given target,
         * During every frame after schedule started, the "update" function of target will be invoked.
         * @zh
         * 使用指定的优先级为指定的对象设置 update 定时器。<br>
         * update 定时器每一帧都会被触发，触发时自动调用指定对象的 "update" 函数。<br>
         * 优先级的值越低，定时器被触发的越早。
         * @param target
         * @param priority
         * @param paused
         */
        scheduleUpdate(target: ISchedulable, priority: number, paused: boolean): void;
        /**
         * @en
         * Unschedules a callback for a callback and a given target.
         * If you want to unschedule the "update", use `unscheduleUpdate()`
         * @zh
         * 取消指定对象定时器。
         * 如果需要取消 update 定时器，请使用 unscheduleUpdate()。
         * @param callback The callback to be unscheduled
         * @param target The target bound to the callback.
         */
        unschedule(callback: any, target: ISchedulable): void;
        /**
         * @en Unschedules the update callback for a given target.
         * @zh 取消指定对象的 update 定时器。
         * @param target The target to be unscheduled.
         */
        unscheduleUpdate(target: ISchedulable): void;
        /**
         * @en
         * Unschedules all scheduled callbacks for a given target.
         * This also includes the "update" callback.
         * @zh 取消指定对象的所有定时器，包括 update 定时器。
         * @param target The target to be unscheduled.
         */
        unscheduleAllForTarget(target: any): void;
        /**
         * @en
         * Unschedules all scheduled callbacks from all targets including the system callbacks.<br/>
         * You should NEVER call this method, unless you know what you are doing.
         * @zh
         * 取消所有对象的所有定时器，包括系统定时器。<br/>
         * 不要调用此函数，除非你确定你在做什么。
         */
        unscheduleAll(): void;
        /**
         * @en
         * Unschedules all callbacks from all targets with a minimum priority.<br/>
         * You should only call this with `PRIORITY_NON_SYSTEM_MIN` or higher.
         * @zh
         * 取消所有优先级的值大于指定优先级的定时器。<br/>
         * 你应该只取消优先级的值大于 PRIORITY_NON_SYSTEM_MIN 的定时器。
         * @param minPriority The minimum priority of selector to be unscheduled. Which means, all selectors which
         *        priority is higher than minPriority will be unscheduled.
         */
        unscheduleAllWithMinPriority(minPriority: number): void;
        /**
         * @en Checks whether a callback for a given target is scheduled.
         * @zh 检查指定的回调函数和回调对象组合是否存在定时器。
         * @param callback The callback to check.
         * @param target The target of the callback.
         * @return True if the specified callback is invoked, false if not.
         */
        isScheduled(callback: any, target: ISchedulable): boolean;
        /**
         * @en
         * Pause all selectors from all targets.<br/>
         * You should NEVER call this method, unless you know what you are doing.
         * @zh
         * 暂停所有对象的所有定时器。<br/>
         * 不要调用这个方法，除非你知道你正在做什么。
         */
        pauseAllTargets(): ISchedulable[];
        /**
         * @en
         * Pause all selectors from all targets with a minimum priority. <br/>
         * You should only call this with kCCPriorityNonSystemMin or higher.
         * @zh
         * 暂停所有优先级的值大于指定优先级的定时器。<br/>
         * 你应该只暂停优先级的值大于 PRIORITY_NON_SYSTEM_MIN 的定时器。
         * @param minPriority
         */
        pauseAllTargetsWithMinPriority(minPriority: number): ISchedulable[];
        /**
         * @en
         * Resume selectors on a set of targets.<br/>
         * This can be useful for undoing a call to pauseAllCallbacks.
         * @zh
         * 恢复指定数组中所有对象的定时器。<br/>
         * 这个函数是 pauseAllCallbacks 的逆操作。
         * @param targetsToResume
         */
        resumeTargets(targetsToResume: any): void;
        /**
         * @en
         * Pauses the target.<br/>
         * All scheduled selectors/update for a given target won't be 'ticked' until the target is resumed.<br/>
         * If the target is not present, nothing happens.
         * @zh
         * 暂停指定对象的定时器。<br/>
         * 指定对象的所有定时器都会被暂停。<br/>
         * 如果指定的对象没有定时器，什么也不会发生。
         * @param target
         */
        pauseTarget(target: ISchedulable): void;
        /**
         * @en
         * Resumes the target.<br/>
         * The 'target' will be unpaused, so all schedule selectors/update will be 'ticked' again.<br/>
         * If the target is not present, nothing happens.
         * @zh
         * 恢复指定对象的所有定时器。<br/>
         * 指定对象的所有定时器将继续工作。<br/>
         * 如果指定的对象没有定时器，什么也不会发生。
         * @param target
         */
        resumeTarget(target: ISchedulable): void;
        /**
         * @en Returns whether or not the target is paused.
         * @zh 返回指定对象的定时器是否处于暂停状态。
         * @param target
         */
        isTargetPaused(target: ISchedulable): boolean;
    }
    /**
     * @en
     * ATTENTION: USE `director` INSTEAD OF `Director`.
     * `director` is a singleton object which manage your game's logic flow.
     * Since the `director` is a singleton, you don't need to call any constructor or create functions,
     * the standard way to use it is by calling:
     * `director.methodName();`
     * It creates and handle the main Window and manages how and when to execute the Scenes.
     *
     * @zh
     * 注意：用 `director` 代替 `Director`。
     * `director` 一个管理你的游戏的逻辑流程的单例对象。
     * 由于 `director` 是一个单例，你不需要调用任何构造函数或创建函数，
     * 使用它的标准方法是通过调用：
     * `director.methodName();`
     * 它创建和处理主窗口并且管理什么时候执行场景。
     */
    export class Director extends EventTarget {
        /**
         * @en The event which will be triggered when the singleton of Director initialized.
         * @zh Director 单例初始化时触发的事件
         * @event Director.EVENT_INIT
         */
        /**
         * @en The event which will be triggered when the singleton of Director initialized.
         * @zh Director 单例初始化时触发的事件
         */
        static readonly EVENT_INIT = "director_init";
        /**
         * @en The event which will be triggered when the singleton of Director reset.
         * @zh Director 单例重置时触发的事件
         * @event Director.EVENT_RESET
         */
        /**
         * @en The event which will be triggered when the singleton of Director reset.
         * @zh Director 单例重置时触发的事件
         */
        static readonly EVENT_RESET = "director_reset";
        /**
         * @en The event which will be triggered before loading a new scene.
         * @zh 加载新场景之前所触发的事件。
         * @event Director.EVENT_BEFORE_SCENE_LOADING
         * @param {String} sceneName - The loading scene name
         */
        /**
         * @en The event which will be triggered before loading a new scene.
         * @zh 加载新场景之前所触发的事件。
         */
        static readonly EVENT_BEFORE_SCENE_LOADING = "director_before_scene_loading";
        /**
         * @en The event which will be triggered before launching a new scene.
         * @zh 运行新场景之前所触发的事件。
         * @event Director.EVENT_BEFORE_SCENE_LAUNCH
         * @param {String} sceneName - New scene which will be launched
         */
        /**
         * @en The event which will be triggered before launching a new scene.
         * @zh 运行新场景之前所触发的事件。
         */
        static readonly EVENT_BEFORE_SCENE_LAUNCH = "director_before_scene_launch";
        /**
         * @en The event which will be triggered after launching a new scene.
         * @zh 运行新场景之后所触发的事件。
         * @event Director.EVENT_AFTER_SCENE_LAUNCH
         * @param {String} sceneName - New scene which is launched
         */
        /**
         * @en The event which will be triggered after launching a new scene.
         * @zh 运行新场景之后所触发的事件。
         */
        static readonly EVENT_AFTER_SCENE_LAUNCH = "director_after_scene_launch";
        /**
         * @en The event which will be triggered at the beginning of every frame.
         * @zh 每个帧的开始时所触发的事件。
         * @event Director.EVENT_BEFORE_UPDATE
         */
        /**
         * @en The event which will be triggered at the beginning of every frame.
         * @zh 每个帧的开始时所触发的事件。
         */
        static readonly EVENT_BEFORE_UPDATE = "director_before_update";
        /**
         * @en The event which will be triggered after engine and components update logic.
         * @zh 将在引擎和组件 “update” 逻辑之后所触发的事件。
         * @event Director.EVENT_AFTER_UPDATE
         */
        /**
         * @en The event which will be triggered after engine and components update logic.
         * @zh 将在引擎和组件 “update” 逻辑之后所触发的事件。
         */
        static readonly EVENT_AFTER_UPDATE = "director_after_update";
        /**
         * @en The event which will be triggered before the rendering process.
         * @zh 渲染过程之前所触发的事件。
         * @event Director.EVENT_BEFORE_DRAW
         */
        static readonly EVENT_BEFORE_DRAW = "director_before_draw";
        /**
         * @en The event which will be triggered after the rendering process.
         * @zh 渲染过程之后所触发的事件。
         * @event Director.EVENT_AFTER_DRAW
         */
        static readonly EVENT_AFTER_DRAW = "director_after_draw";
        /**
         * @en The event which will be triggered before the pipeline render commit.
         * @zh 当前渲染帧提交前所触发的事件。
         * @event Director.EVENT_BEFORE_COMMIT
         */
        static readonly EVENT_BEFORE_COMMIT = "director_before_commit";
        /**
         * @en The event which will be triggered before the physics process.<br/>
         * @zh 物理过程之前所触发的事件。
         * @event Director.EVENT_BEFORE_PHYSICS
         */
        static readonly EVENT_BEFORE_PHYSICS = "director_before_physics";
        /**
         * @en The event which will be triggered after the physics process.<br/>
         * @zh 物理过程之后所触发的事件。
         * @event Director.EVENT_AFTER_PHYSICS
         */
        static readonly EVENT_AFTER_PHYSICS = "director_after_physics";
        /**
         * @en The event which will be triggered at the frame begin.<br/>
         * @zh 一帧开始时所触发的事件。
         * @event Director.EVENT_BEGIN_FRAME
         */
        static readonly EVENT_BEGIN_FRAME = "director_begin_frame";
        /**
         * @en The event which will be triggered at the frame end.<br/>
         * @zh 一帧结束之后所触发的事件。
         * @event Director.EVENT_END_FRAME
         */
        static readonly EVENT_END_FRAME = "director_end_frame";
        static instance: Director;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _compScheduler: __private._cocos_core_scene_graph_component_scheduler__ComponentScheduler;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _nodeActivator: NodeActivator;
        constructor();
        /**
         * @en Calculates delta time since last time it was called, the result is saved to an internal property.
         * @zh 计算从上一帧到现在的时间间隔，结果保存在私有属性中
         * @deprecated since v3.3.0 no need to use it anymore
         */
        calculateDeltaTime(now: any): void;
        /**
         * @en End the life of director in the next frame
         * @zh 执行完当前帧后停止 director 的执行
         */
        end(): void;
        /**
         * @en Pause the director's ticker, only involve the game logic execution.<br>
         * It won't pause the rendering process nor the event manager.<br>
         * If you want to pause the entire game including rendering, audio and event,<br>
         * please use `game.pause`.
         * @zh 暂停正在运行的场景，该暂停只会停止游戏逻辑执行，但是不会停止渲染和 UI 响应。<br>
         * 如果想要更彻底得暂停游戏，包含渲染，音频和事件，请使用 `game.pause` 。
         */
        pause(): void;
        /**
         * @en Purge the `director` itself, including unschedule all schedule,<br>
         * remove all event listeners, clean up and exit the running scene, stops all animations, clear cached data.
         * @zh 清除 `director` 本身，包括停止所有的计时器，<br>
         * 移除所有的事件监听器，清理并退出当前运行的场景，停止所有动画，清理缓存数据。
         */
        purgeDirector(): void;
        /**
         * @en Reset the director, can be used to restart the director after purge
         * @zh 重置此 Director，可用于在清除后重启 Director。
         */
        reset(): void;
        /**
         * @en
         * Run a scene. Replaces the running scene with a new one or enter the first scene.<br>
         * The new scene will be launched immediately.
         * @zh 运行指定场景。将正在运行的场景替换为（或重入为）新场景。新场景将立即启动。
         * @param scene - The need run scene.
         * @param onBeforeLoadScene - The function invoked at the scene before loading.
         * @param onLaunched - The function invoked at the scene after launch.
         */
        runSceneImmediate(scene: Scene | SceneAsset, onBeforeLoadScene?: Director.OnBeforeLoadScene, onLaunched?: Director.OnSceneLaunched): void;
        /**
         * @en
         * Run a scene. Replaces the running scene with a new one or enter the first scene.<br>
         * The new scene will be launched at the end of the current frame.<br>
         * @zh 运行指定场景。
         * @param scene - The need run scene.
         * @param onBeforeLoadScene - The function invoked at the scene before loading.
         * @param onLaunched - The function invoked at the scene after launch.
         * @private
         */
        runScene(scene: Scene | SceneAsset, onBeforeLoadScene?: Director.OnBeforeLoadScene, onLaunched?: Director.OnSceneLaunched): void;
        /**
         * @en Loads the scene by its name.
         * @zh 通过场景名称进行加载场景。
         *
         * @param sceneName - The name of the scene to load.
         * @param onLaunched - callback, will be called after scene launched.
         * @return if error, return false
         */
        loadScene(sceneName: string, onLaunched?: Director.OnSceneLaunched, onUnloaded?: Director.OnUnload): boolean;
        /**
         * @en
         * Pre-loads the scene asset to reduces loading time. You can call this method at any time you want.<br>
         * After calling this method, you still need to launch the scene by `director.loadScene`.<br>
         * It will be totally fine to call `director.loadScene` at any time even if the preloading is not<br>
         * yet finished, the scene will be launched after loaded automatically.
         * @zh 预加载场景资源，你可以在任何时候调用这个方法。
         * 调用完后，你仍然需要通过 `director.loadScene` 来启动场景，因为这个方法不会执行场景加载操作。<br>
         * 就算预加载还没完成，你也可以直接调用 `director.loadScene`，加载完成后场景就会启动。
         * @param sceneName @en The name of the scene to load @zh 场景名称。
         * @param onLoaded @en Callback to execute once the scene is loaded @zh 加载回调。
         */
        preloadScene(sceneName: string, onLoaded?: Director.OnSceneLoaded): void;
        /**
         * @en
         * Pre-loads the scene to reduces loading time. You can call this method at any time you want.<br>
         * After calling this method, you still need to launch the scene by `director.loadScene`.<br>
         * It will be totally fine to call `director.loadScene` at any time even if the preloading is not<br>
         * yet finished, the scene will be launched after loaded automatically.
         * @zh 预加载场景，你可以在任何时候调用这个方法。
         * 调用完后，你仍然需要通过 `director.loadScene` 来启动场景，因为这个方法不会执行场景加载操作。<br>
         * 就算预加载还没完成，你也可以直接调用 `director.loadScene`，加载完成后场景就会启动。
         * @param sceneName @en The name of scene to load @zh 场景名称。
         * @param onProgress @en Callback to execute when the load progression change.  @zh 加载进度回调。
         * @param onLoaded @en Callback to execute once the scene is loaded @zh 加载回调。
         */
        preloadScene(sceneName: string, onProgress: Director.OnLoadSceneProgress, onLoaded: Director.OnSceneLoaded): void;
        /**
         * @en Resume game logic execution after pause, if the current scene is not paused, nothing will happen.
         * @zh 恢复暂停场景的游戏逻辑，如果当前场景没有暂停将没任何事情发生。
         */
        resume(): void;
        get root(): Root | null;
        /**
         * @en Returns current logic Scene.
         * @zh 获取当前逻辑场景。
         * @example
         * ```
         * import { director } from 'cc';
         * // This will help you to get the Canvas node in scene
         * director.getScene().getChildByName('Canvas');
         * ```
         */
        getScene(): Scene | null;
        /**
         * @en Returns the delta time since last frame.
         * @zh 获取上一帧的增量时间。
         * @deprecated since v3.3.0, please use game.deltaTime instead
         */
        getDeltaTime(): number;
        /**
         * @en Returns the total passed time since game start, unit: ms
         * @zh 获取从游戏开始到现在总共经过的时间，单位为 ms
         * @deprecated since v3.3.0, please use game.totalTime instead
         */
        getTotalTime(): number;
        /**
         * @en Returns the current time.
         * @zh 获取当前帧的时间。
         * @deprecated since v3.3.0, please use game.frameStartTime instead
         */
        getCurrentTime(): number;
        /**
         * @en Returns how many frames were called since the director started.
         * @zh 获取 director 启动以来游戏运行的总帧数。
         */
        getTotalFrames(): number;
        /**
         * @en Returns whether or not the Director is paused.
         * @zh 是否处于暂停状态。
         */
        isPaused(): boolean;
        /**
         * @en Returns the scheduler associated with this director.
         * @zh 获取和 director 相关联的调度器。
         */
        getScheduler(): Scheduler;
        /**
         * @en Sets the scheduler associated with this director.
         * @zh 设置和 director 相关联的调度器。
         */
        setScheduler(scheduler: Scheduler): void;
        /**
         * @en Register a system.
         * @zh 注册一个系统。
         */
        registerSystem(name: string, sys: System, priority: number): void;
        unregisterSystem(sys: System): void;
        /**
         * @en get a system.
         * @zh 获取一个 system。
         */
        getSystem(name: string): System | undefined;
        /**
         * @en Returns the `AnimationManager` associated with this director. Please use getSystem(AnimationManager.ID)
         * @zh 获取和 director 相关联的 `AnimationManager`（动画管理器）。请使用 getSystem(AnimationManager.ID) 来替代
         * @deprecated since 3.0.0
         */
        getAnimationManager(): any;
        /**
         * @en Starts the director
         * @zh 开始执行游戏逻辑
         */
        startAnimation(): void;
        /**
         * @en Stops the director
         * @zh 停止执行游戏逻辑，每帧渲染会继续执行
         */
        stopAnimation(): void;
        /**
         * @en Run main loop of director
         * @zh 运行主循环
         * @deprecated Since v3.6, please use [tick] instead
         */
        mainLoop(now: number): void;
        /**
         * @en Run main loop of director
         * @zh 运行主循环
         * @param dt Delta time in seconds
         */
        tick(dt: number): void;
        /**
         * @internal
         */
        init(): void;
        /**
         * @en
         * Add a persistent root node to the game, the persistent node won't be destroyed during scene transition.<br>
         * The target node must be placed in the root level of hierarchy, otherwise this API won't have any effect.
         * @zh
         * 声明常驻根节点，该节点不会在场景切换中被销毁。<br>
         * 目标节点必须位于为层级的根节点，否则无效。
         * @param node - The node to be made persistent
         */
        addPersistRootNode(node: Node): void;
        /**
         * @en Remove a persistent root node.
         * @zh 取消常驻根节点。
         * @param node - The node to be removed from persistent node list
         */
        removePersistRootNode(node: Node): void;
        /**
         * @en Check whether the node is a persistent root node.
         * @zh 检查节点是否是常驻根节点。
         * @param node - The node to be checked
         */
        isPersistRootNode(node: Node): boolean;
    }
    export namespace Director {
        export type OnBeforeLoadScene = () => void;
        export type OnUnload = () => void;
        export type OnSceneLoaded = (error: null | Error, sceneAsset?: SceneAsset) => void;
        export type OnSceneLaunched = (error: null | Error, scene?: Scene) => void;
        /**
         * @param completedCount - The number of the items that are already completed.
         * @param totalCount - The total number of the items.
         * @param item - The latest item which flow out the pipeline.
         */
        export type OnLoadSceneProgress = (completedCount: number, totalCount: number, item: any) => void;
    }
    /**
     * @en Director of the game, used to control game update loop and scene management
     * @zh 游戏的导演，用于控制游戏更新循环与场景管理。
     */
    export const director: Director;
    export function createDefaultPipeline(): ForwardPipeline;
    export namespace pipeline {
        export enum SetIndex {
            GLOBAL = 0,
            MATERIAL = 1,
            LOCAL = 2
        }
        /**
         * @en The predefined render priorities
         * @zh 预设的渲染优先级。
         */
        export enum RenderPriority {
            MIN = 0,
            MAX = 255,
            DEFAULT = 128
        }
        /**
         * @internal This method only used to init localDescriptorSetLayout.layouts[UBOSkinning.NAME]
         */
        export function localDescriptorSetLayout_ResizeMaxJoints(maxCount: number): void;
        /**
         * @en Does the device support single-channeled half float texture? (for both color attachment and sampling)
         * @zh 当前设备是否支持单通道半浮点贴图？（颜色输出和采样）
         */
        export function supportsR16HalfFloatTexture(device: gfx.Device): boolean;
        /**
         * @en Does the device support single-channeled float texture? (for both color attachment and sampling)
         * @zh 当前设备是否支持单通道浮点贴图？（颜色输出和采样）
         */
        export function supportsR32FloatTexture(device: gfx.Device): boolean;
        export const PIPELINE_FLOW_MAIN = "MainFlow";
        export const PIPELINE_FLOW_FORWARD = "ForwardFlow";
        export const PIPELINE_FLOW_SHADOW = "ShadowFlow";
        export const PIPELINE_FLOW_SMAA = "SMAAFlow";
        export const PIPELINE_FLOW_TONEMAP = "ToneMapFlow";
        /**
         * @en The predefined render pass stage ids
         * @zh 预设的渲染阶段。
         */
        export enum RenderPassStage {
            DEFAULT = 100,
            UI = 200
        }
        /**
         * @en Render object interface
         * @zh 渲染对象接口。
         */
        export interface IRenderObject {
            model: renderer.scene.Model;
            depth: number;
        }
        export interface IRenderPass {
            priority: number;
            hash: number;
            depth: number;
            shaderId: number;
            subModel: renderer.scene.SubModel;
            passIdx: number;
        }
        /**
         * @en Render batch interface
         * @zh 渲染批次接口。
         */
        export interface IRenderBatch {
            pass: renderer.Pass;
        }
        /**
         * @en Render queue descriptor
         * @zh 渲染队列描述。
         */
        export interface IRenderQueueDesc {
            isTransparent: boolean;
            phases: number;
            sortFunc: (a: IRenderPass, b: IRenderPass) => number;
        }
        export interface IDescriptorSetLayoutInfo {
            bindings: gfx.DescriptorSetLayoutBinding[];
            layouts: Record<string, gfx.UniformBlock | gfx.UniformSamplerTexture | gfx.UniformStorageImage | gfx.UniformStorageBuffer>;
        }
        export const globalDescriptorSetLayout: IDescriptorSetLayoutInfo;
        export const localDescriptorSetLayout: IDescriptorSetLayoutInfo;
        /**
         * @en The uniform bindings
         * @zh Uniform 参数绑定。
         */
        export enum PipelineGlobalBindings {
            UBO_GLOBAL = 0,
            UBO_CAMERA = 1,
            UBO_SHADOW = 2,
            UBO_CSM = 3,
            SAMPLER_SHADOWMAP = 4,
            SAMPLER_ENVIRONMENT = 5,
            SAMPLER_SPOT_SHADOW_MAP = 6,
            SAMPLER_DIFFUSEMAP = 7,
            COUNT = 8
        }
        export enum ModelLocalBindings {
            UBO_LOCAL = 0,
            UBO_FORWARD_LIGHTS = 1,
            UBO_SKINNING_ANIMATION = 2,
            UBO_SKINNING_TEXTURE = 3,
            UBO_MORPH = 4,
            UBO_UI_LOCAL = 5,
            SAMPLER_JOINTS = 6,
            SAMPLER_MORPH_POSITION = 7,
            SAMPLER_MORPH_NORMAL = 8,
            SAMPLER_MORPH_TANGENT = 9,
            SAMPLER_LIGHTMAP = 10,
            SAMPLER_SPRITE = 11,
            SAMPLER_REFLECTION = 12,
            STORAGE_REFLECTION = 13,
            COUNT = 14
        }
        export const bindingMappingInfo: gfx.BindingMappingInfo;
        /**
         * @en The global uniform buffer object
         * @zh 全局 UBO。
         */
        export class UBOGlobal {
            static readonly TIME_OFFSET = 0;
            static readonly SCREEN_SIZE_OFFSET: number;
            static readonly NATIVE_SIZE_OFFSET: number;
            static readonly DEBUG_VIEW_MODE_OFFSET: number;
            static readonly DEBUG_VIEW_COMPOSITE_PACK_1_OFFSET: number;
            static readonly DEBUG_VIEW_COMPOSITE_PACK_2_OFFSET: number;
            static readonly DEBUG_VIEW_COMPOSITE_PACK_3_OFFSET: number;
            static readonly COUNT: number;
            static readonly SIZE: number;
            static readonly NAME = "CCGlobal";
            static readonly BINDING = PipelineGlobalBindings.UBO_GLOBAL;
            static readonly DESCRIPTOR: gfx.DescriptorSetLayoutBinding;
            static readonly LAYOUT: gfx.UniformBlock;
        }
        /**
         * @en The global camera uniform buffer object
         * @zh 全局相机 UBO。
         */
        export class UBOCamera {
            static readonly MAT_VIEW_OFFSET = 0;
            static readonly MAT_VIEW_INV_OFFSET: number;
            static readonly MAT_PROJ_OFFSET: number;
            static readonly MAT_PROJ_INV_OFFSET: number;
            static readonly MAT_VIEW_PROJ_OFFSET: number;
            static readonly MAT_VIEW_PROJ_INV_OFFSET: number;
            static readonly CAMERA_POS_OFFSET: number;
            static readonly SURFACE_TRANSFORM_OFFSET: number;
            static readonly SCREEN_SCALE_OFFSET: number;
            static readonly EXPOSURE_OFFSET: number;
            static readonly MAIN_LIT_DIR_OFFSET: number;
            static readonly MAIN_LIT_COLOR_OFFSET: number;
            static readonly AMBIENT_SKY_OFFSET: number;
            static readonly AMBIENT_GROUND_OFFSET: number;
            static readonly GLOBAL_FOG_COLOR_OFFSET: number;
            static readonly GLOBAL_FOG_BASE_OFFSET: number;
            static readonly GLOBAL_FOG_ADD_OFFSET: number;
            static readonly NEAR_FAR_OFFSET: number;
            static readonly VIEW_PORT_OFFSET: number;
            static readonly COUNT: number;
            static readonly SIZE: number;
            static readonly NAME = "CCCamera";
            static readonly BINDING = PipelineGlobalBindings.UBO_CAMERA;
            static readonly DESCRIPTOR: gfx.DescriptorSetLayoutBinding;
            static readonly LAYOUT: gfx.UniformBlock;
        }
        /**
         * @en The uniform buffer object for 'cast shadow(fixed || csm)' && 'dir fixed area shadow' && 'spot shadow' && 'sphere shadow' && 'planar shadow'
         * @zh 这个 UBO 仅仅只给 'cast shadow(fixed || csm)' && 'dir fixed area shadow' && 'spot shadow' && 'sphere shadow' && 'planar shadow' 使用
         */
        export class UBOShadow {
            static readonly MAT_LIGHT_VIEW_OFFSET = 0;
            static readonly MAT_LIGHT_VIEW_PROJ_OFFSET: number;
            static readonly SHADOW_INV_PROJ_DEPTH_INFO_OFFSET: number;
            static readonly SHADOW_PROJ_DEPTH_INFO_OFFSET: number;
            static readonly SHADOW_PROJ_INFO_OFFSET: number;
            static readonly SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET: number;
            static readonly SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET: number;
            static readonly SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET: number;
            static readonly SHADOW_COLOR_OFFSET: number;
            static readonly PLANAR_NORMAL_DISTANCE_INFO_OFFSET: number;
            static readonly COUNT: number;
            static readonly SIZE: number;
            static readonly NAME = "CCShadow";
            static readonly BINDING = PipelineGlobalBindings.UBO_SHADOW;
            static readonly DESCRIPTOR: gfx.DescriptorSetLayoutBinding;
            static readonly LAYOUT: gfx.UniformBlock;
        }
        /**
         * @en The uniform buffer object only for dir csm shadow(level: 1 ~ 4)
         * @zh 级联阴影使用的UBO
         */
        export class UBOCSM {
            static readonly CSM_LEVEL_COUNT = 4;
            static readonly CSM_VIEW_DIR_0_OFFSET = 0;
            static readonly CSM_VIEW_DIR_1_OFFSET: number;
            static readonly CSM_VIEW_DIR_2_OFFSET: number;
            static readonly CSM_ATLAS_OFFSET: number;
            static readonly MAT_CSM_VIEW_PROJ_OFFSET: number;
            static readonly CSM_PROJ_DEPTH_INFO_OFFSET: number;
            static readonly CSM_PROJ_INFO_OFFSET: number;
            static readonly CSM_SPLITS_INFO_OFFSET: number;
            static readonly COUNT: number;
            static readonly SIZE: number;
            static readonly NAME = "CCCSM";
            static readonly BINDING = PipelineGlobalBindings.UBO_CSM;
            static readonly DESCRIPTOR: gfx.DescriptorSetLayoutBinding;
            static readonly LAYOUT: gfx.UniformBlock;
        }
        export const UNIFORM_SHADOWMAP_BINDING = PipelineGlobalBindings.SAMPLER_SHADOWMAP;
        export const UNIFORM_ENVIRONMENT_BINDING = PipelineGlobalBindings.SAMPLER_ENVIRONMENT;
        export const UNIFORM_DIFFUSEMAP_BINDING = PipelineGlobalBindings.SAMPLER_DIFFUSEMAP;
        export const UNIFORM_SPOT_SHADOW_MAP_TEXTURE_BINDING = PipelineGlobalBindings.SAMPLER_SPOT_SHADOW_MAP;
        /**
         * @en The local uniform buffer object
         * @zh 本地 UBO。
         */
        export class UBOLocal {
            static readonly MAT_WORLD_OFFSET = 0;
            static readonly MAT_WORLD_IT_OFFSET: number;
            static readonly LIGHTINGMAP_UVPARAM: number;
            static readonly LOCAL_SHADOW_BIAS: number;
            static readonly COUNT: number;
            static readonly SIZE: number;
            static readonly NAME = "CCLocal";
            static readonly BINDING = ModelLocalBindings.UBO_LOCAL;
            static readonly DESCRIPTOR: gfx.DescriptorSetLayoutBinding;
            static readonly LAYOUT: gfx.UniformBlock;
        }
        /**
         * @en The world bound uniform buffer object
         * @zh 世界空间包围盒 UBO。
         */
        export class UBOWorldBound {
            static readonly WORLD_BOUND_CENTER = 0;
            static readonly WORLD_BOUND_HALF_EXTENTS: number;
            static readonly COUNT: number;
            static readonly SIZE: number;
            static readonly NAME = "CCWorldBound";
            static readonly BINDING = ModelLocalBindings.UBO_LOCAL;
            static readonly DESCRIPTOR: gfx.DescriptorSetLayoutBinding;
            static readonly LAYOUT: gfx.UniformBlock;
        }
        export const INST_MAT_WORLD = "a_matWorld0";
        export class UBOLocalBatched {
            static readonly BATCHING_COUNT = 10;
            static readonly MAT_WORLDS_OFFSET = 0;
            static readonly COUNT: number;
            static readonly SIZE: number;
            static readonly NAME = "CCLocalBatched";
            static readonly BINDING = ModelLocalBindings.UBO_LOCAL;
            static readonly DESCRIPTOR: gfx.DescriptorSetLayoutBinding;
            static readonly LAYOUT: gfx.UniformBlock;
        }
        /**
         * @en The uniform buffer object for forward lighting
         * @zh 前向灯光 UBO。
         */
        export class UBOForwardLight {
            static readonly LIGHTS_PER_PASS = 1;
            static readonly LIGHT_POS_OFFSET = 0;
            static readonly LIGHT_COLOR_OFFSET: number;
            static readonly LIGHT_SIZE_RANGE_ANGLE_OFFSET: number;
            static readonly LIGHT_DIR_OFFSET: number;
            static readonly COUNT: number;
            static readonly SIZE: number;
            static readonly NAME = "CCForwardLight";
            static readonly BINDING = ModelLocalBindings.UBO_FORWARD_LIGHTS;
            static readonly DESCRIPTOR: gfx.DescriptorSetLayoutBinding;
            static readonly LAYOUT: gfx.UniformBlock;
        }
        export class UBODeferredLight {
            static readonly LIGHTS_PER_PASS = 10;
        }
        export const JOINT_UNIFORM_CAPACITY = 30;
        /**
         * @en The uniform buffer object for skinning texture
         * @zh 骨骼贴图 UBO。
         */
        export class UBOSkinningTexture {
            static readonly JOINTS_TEXTURE_INFO_OFFSET = 0;
            static readonly COUNT: number;
            static readonly SIZE: number;
            static readonly NAME = "CCSkinningTexture";
            static readonly BINDING = ModelLocalBindings.UBO_SKINNING_TEXTURE;
            static readonly DESCRIPTOR: gfx.DescriptorSetLayoutBinding;
            static readonly LAYOUT: gfx.UniformBlock;
        }
        export class UBOSkinningAnimation {
            static readonly JOINTS_ANIM_INFO_OFFSET = 0;
            static readonly COUNT: number;
            static readonly SIZE: number;
            static readonly NAME = "CCSkinningAnimation";
            static readonly BINDING = ModelLocalBindings.UBO_SKINNING_ANIMATION;
            static readonly DESCRIPTOR: gfx.DescriptorSetLayoutBinding;
            static readonly LAYOUT: gfx.UniformBlock;
        }
        export const INST_JOINT_ANIM_INFO = "a_jointAnimInfo";
        export class UBOSkinning {
            static get JOINT_UNIFORM_CAPACITY(): number;
            static get COUNT(): number;
            static get SIZE(): number;
            static readonly NAME = "CCSkinning";
            static readonly BINDING = ModelLocalBindings.UBO_SKINNING_TEXTURE;
            static readonly DESCRIPTOR: gfx.DescriptorSetLayoutBinding;
            static readonly LAYOUT: gfx.UniformBlock;
            /**
             * @internal This method only used init UBOSkinning configure.
             */
            static initLayout(capacity: number): void;
        }
        /**
         * @en The uniform buffer object for morph setting
         * @zh 形变配置的 UBO
         */
        export class UBOMorph {
            static readonly MAX_MORPH_TARGET_COUNT = 60;
            static readonly OFFSET_OF_WEIGHTS = 0;
            static readonly OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH: number;
            static readonly OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT: number;
            static readonly OFFSET_OF_VERTICES_COUNT: number;
            static readonly COUNT_BASE_4_BYTES: number;
            static readonly SIZE: number;
            static readonly NAME = "CCMorph";
            static readonly BINDING = ModelLocalBindings.UBO_MORPH;
            static readonly DESCRIPTOR: gfx.DescriptorSetLayoutBinding;
            static readonly LAYOUT: gfx.UniformBlock;
        }
        export class UBOUILocal {
            static readonly NAME = "CCUILocal";
            static readonly BINDING = ModelLocalBindings.UBO_UI_LOCAL;
            static readonly DESCRIPTOR: gfx.DescriptorSetLayoutBinding;
            static readonly LAYOUT: gfx.UniformBlock;
        }
        export const UNIFORM_JOINT_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_JOINTS;
        export const UNIFORM_REALTIME_JOINT_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_JOINTS;
        export const UNIFORM_POSITION_MORPH_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_MORPH_POSITION;
        export const UNIFORM_NORMAL_MORPH_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_MORPH_NORMAL;
        export const UNIFORM_TANGENT_MORPH_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_MORPH_TANGENT;
        export const UNIFORM_LIGHTMAP_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_LIGHTMAP;
        export const UNIFORM_SPRITE_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_SPRITE;
        export const UNIFORM_REFLECTION_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_REFLECTION;
        export const UNIFORM_REFLECTION_STORAGE_BINDING = ModelLocalBindings.STORAGE_REFLECTION;
        export const CAMERA_DEFAULT_MASK: number;
        export const CAMERA_EDITOR_MASK: number;
        export const MODEL_ALWAYS_MASK: number;
    }
    /**
     * @en Render pipeline describes how we handle the rendering process for all render objects in the related render scene root.
     * It contains some general pipeline configurations, necessary rendering resources and some [[RenderFlow]]s.
     * The rendering process function [[render]] is invoked by [[Root]] for all [[Camera]]s.
     * @zh 渲染管线对象决定了引擎对相关渲染场景下的所有渲染对象实施的完整渲染流程。
     * 这个类主要包含一些通用的管线配置，必要的渲染资源和一些 [[RenderFlow]]。
     * 渲染流程函数 [[render]] 会由 [[Root]] 发起调用并对所有 [[Camera]] 执行预设的渲染流程。
     */
    export abstract class RenderPipeline extends Asset implements __private._cocos_core_pipeline_pipeline_event__IPipelineEvent, __private._cocos_core_pipeline_custom_pipeline__PipelineRuntime {
        /**
         * @en The tag of pipeline.
         * @zh 管线的标签。
         * @readonly
         */
        get tag(): number;
        /**
         * @en The flows of pipeline.
         * @zh 管线的渲染流程列表。
         * @readonly
         */
        get flows(): RenderFlow[];
        /**
         * @en Tag
         * @zh 标签
         * @readonly
         */
        protected _tag: number;
        /**
         * @en Flows
         * @zh 渲染流程列表
         * @readonly
         */
        protected _flows: RenderFlow[];
        protected _quadIB: gfx.Buffer | null;
        protected _quadVBOnscreen: gfx.Buffer | null;
        protected _quadVBOffscreen: gfx.Buffer | null;
        protected _quadIAOnscreen: gfx.InputAssembler | null;
        protected _quadIAOffscreen: gfx.InputAssembler | null;
        protected _eventProcessor: PipelineEventProcessor;
        /**
         * @zh
         * 四边形输入汇集器。
         */
        get quadIAOnscreen(): gfx.InputAssembler;
        get quadIAOffscreen(): gfx.InputAssembler;
        getPipelineRenderData(): __private._cocos_core_pipeline_render_pipeline__PipelineRenderData;
        /**
         * @en
         * Constant macro string, static throughout the whole runtime.
         * Used to pass device-specific parameters to shader.
         * @zh 常量宏定义字符串，运行时全程不会改变，用于给 shader 传一些只和平台相关的参数。
         * @readonly
         */
        get constantMacros(): string;
        /**
         * @en
         * The current global-scoped shader macros.
         * Used to control effects like IBL, fog, etc.
         * @zh 当前的全局宏定义，用于控制如 IBL、雾效等模块。
         * @readonly
         */
        get macros(): renderer.MacroRecord;
        get device(): gfx.Device;
        get globalDSManager(): __private._cocos_core_pipeline_global_descriptor_set_manager__GlobalDSManager;
        get descriptorSetLayout(): gfx.DescriptorSetLayout;
        get descriptorSet(): gfx.DescriptorSet;
        get commandBuffers(): gfx.CommandBuffer[];
        get pipelineUBO(): __private._cocos_core_pipeline_pipeline_ubo__PipelineUBO;
        get pipelineSceneData(): PipelineSceneData;
        set profiler(value: renderer.scene.Model | null);
        get profiler(): renderer.scene.Model | null;
        /**
         * @deprecated since v3.6, please use camera.geometryRenderer instead.
         */
        get geometryRenderer(): GeometryRenderer | null;
        set clusterEnabled(value: boolean);
        get clusterEnabled(): boolean;
        set bloomEnabled(value: boolean);
        get bloomEnabled(): boolean;
        protected _device: gfx.Device;
        protected _globalDSManager: __private._cocos_core_pipeline_global_descriptor_set_manager__GlobalDSManager;
        protected _descriptorSet: gfx.DescriptorSet;
        protected _commandBuffers: gfx.CommandBuffer[];
        protected _pipelineUBO: __private._cocos_core_pipeline_pipeline_ubo__PipelineUBO;
        protected _macros: renderer.MacroRecord;
        protected _constantMacros: string;
        protected _profiler: renderer.scene.Model | null;
        protected _geometryRenderer: GeometryRenderer | null;
        protected _pipelineSceneData: PipelineSceneData;
        protected _pipelineRenderData: __private._cocos_core_pipeline_render_pipeline__PipelineRenderData | null;
        protected _renderPasses: Map<number, gfx.RenderPass>;
        protected _width: number;
        protected _height: number;
        protected _lastUsedRenderArea: gfx.Rect;
        protected _clusterEnabled: boolean;
        protected _bloomEnabled: boolean;
        /**
         * @en The initialization process, user shouldn't use it in most case, only useful when need to generate render pipeline programmatically.
         * @zh 初始化函数，正常情况下不会用到，仅用于程序化生成渲染管线的情况。
         * @param info The render pipeline information
         */
        initialize(info: __private._cocos_core_pipeline_render_pipeline__IRenderPipelineInfo): boolean;
        createRenderPass(clearFlags: gfx.ClearFlags, colorFmt: gfx.Format, depthFmt: gfx.Format): gfx.RenderPass;
        getRenderPass(clearFlags: gfx.ClearFlags, fbo: gfx.Framebuffer): gfx.RenderPass;
        newFramebufferByRatio(dyingFramebuffer: gfx.Framebuffer): gfx.Framebuffer;
        /**
         * @en generate renderArea by camera
         * @zh 生成renderArea
         * @param camera the camera
         * @returns
         */
        generateRenderArea(camera: renderer.scene.Camera, out: gfx.Rect): void;
        generateViewport(camera: renderer.scene.Camera, out?: gfx.Viewport): gfx.Viewport;
        generateScissor(camera: renderer.scene.Camera, out?: gfx.Rect): gfx.Rect;
        get shadingScale(): number;
        set shadingScale(val: number);
        getMacroString(name: string): string;
        getMacroInt(name: string): number;
        getMacroBool(name: string): boolean;
        setMacroString(name: string, value: string): void;
        setMacroInt(name: string, value: number): void;
        setMacroBool(name: string, value: boolean): void;
        /**
         * @en Activate the render pipeline after loaded, it mainly activate the flows
         * @zh 当渲染管线资源加载完成后，启用管线，主要是启用管线内的 flow
         * TODO: remove swapchain dependency at this stage
         * after deferred pipeline can handle multiple swapchains
         */
        activate(swapchain: gfx.Swapchain): boolean;
        protected _ensureEnoughSize(cameras: renderer.scene.Camera[]): void;
        /**
         * @en Render function, it basically run the render process of all flows in sequence for the given view.
         * @zh 渲染函数，对指定的渲染视图按顺序执行所有渲染流程。
         * @param view Render view。
         */
        render(cameras: renderer.scene.Camera[]): void;
        /**
         * @zh
         * 销毁四边形输入汇集器。
         */
        protected _destroyQuadInputAssembler(): void;
        protected _destroyBloomData(): void;
        /**
         * @zh
         * 创建四边形输入汇集器。
         */
        protected _createQuadInputAssembler(): __private._cocos_core_pipeline_render_pipeline__PipelineInputAssemblerData;
        updateQuadVertexData(renderArea: gfx.Rect, window: __private._cocos_core_renderer_core_render_window__RenderWindow): void;
        /**
         * @en Internal destroy function
         * @zh 内部销毁函数。
         */
        destroy(): boolean;
        onGlobalPipelineStateChanged(): void;
        protected _generateConstantMacros(): void;
        protected updateGeometryRenderer(cameras: renderer.scene.Camera[]): void;
        generateBloomRenderData(): void;
        /**
         * @en
         * Register an callback of the pipeline event type on the RenderPipeline.
         * @zh
         * 在渲染管线中注册管线事件类型的回调。
         */
        on(type: PipelineEventType, callback: any, target?: any, once?: boolean): typeof callback;
        /**
         * @en
         * Register an callback of the pipeline event type on the RenderPipeline,
         * the callback will remove itself after the first time it is triggered.
         * @zh
         * 在渲染管线中注册管线事件类型的回调, 回调后会在第一时间删除自身。
         */
        once(type: PipelineEventType, callback: any, target?: any): typeof callback;
        /**
         * @en
         * Removes the listeners previously registered with the same type, callback, target and or useCapture,
         * if only type is passed as parameter, all listeners registered with that type will be removed.
         * @zh
         * 删除之前用同类型、回调、目标或 useCapture 注册的事件监听器，如果只传递 type，将会删除 type 类型的所有事件监听器。
         */
        off(type: PipelineEventType, callback?: any, target?: any): void;
        /**
         * @zh 派发一个指定事件，并传递需要的参数
         * @en Trigger an event directly with the event name and necessary arguments.
         * @param type - event type
         * @param args - Arguments when the event triggered
         */
        emit(type: PipelineEventType, arg0?: any, arg1?: any, arg2?: any, arg3?: any, arg4?: any): void;
        /**
         * @en Removes all callbacks previously registered with the same target (passed as parameter).
         * This is not for removing all listeners in the current event target,
         * and this is not for removing all listeners the target parameter have registered.
         * It's only for removing all listeners (callback and target couple) registered on the current event target by the target parameter.
         * @zh 在当前 EventTarget 上删除指定目标（target 参数）注册的所有事件监听器。
         * 这个函数无法删除当前 EventTarget 的所有事件监听器，也无法删除 target 参数所注册的所有事件监听器。
         * 这个函数只能删除 target 参数在当前 EventTarget 上注册的所有事件监听器。
         * @param typeOrTarget - The target to be searched for all related listeners
         */
        targetOff(typeOrTarget: any): void;
        /**
         * @zh 移除在特定事件类型中注册的所有回调或在某个目标中注册的所有回调。
         * @en Removes all callbacks registered in a certain event type or all callbacks registered with a certain target
         * @param typeOrTarget - The event type or target with which the listeners will be removed
         */
        removeAll(typeOrTarget: any): void;
        /**
         * @zh 检查指定事件是否已注册回调。
         * @en Checks whether there is correspond event listener registered on the given event.
         * @param type - Event type.
         * @param callback - Callback function when event triggered.
         * @param target - Callback callee.
         */
        hasEventListener(type: PipelineEventType, callback?: any, target?: any): boolean;
    }
    /**
     * @en Render flow is a sub process of the [[RenderPipeline]], it dispatch the render task to all the [[RenderStage]]s.
     * @zh 渲染流程是渲染管线（[[RenderPipeline]]）的一个子过程，它将渲染任务派发到它的所有渲染阶段（[[RenderStage]]）中执行。
     */
    export abstract class RenderFlow {
        /**
         * @en The name of the render flow
         * @zh 渲染流程的名字
         */
        get name(): string;
        /**
         * @en Priority of the current flow
         * @zh 当前渲染流程的优先级。
         */
        get priority(): number;
        /**
         * @en Tag of the current flow
         * @zh 当前渲染流程的标签。
         */
        get tag(): number;
        /**
         * @en The stages of flow.
         * @zh 渲染流程 stage 列表。
         * @readonly
         */
        get stages(): RenderStage[];
        protected _name: string;
        protected _priority: number;
        protected _tag: number;
        protected _stages: RenderStage[];
        protected _pipeline: RenderPipeline;
        /**
         * @en Get pipeline
         * @zh 获取pipeline
         */
        get pipeline(): RenderPipeline;
        /**
         * @en The initialization process, user shouldn't use it in most case, only useful when need to generate render pipeline programmatically.
         * @zh 初始化函数，正常情况下不会用到，仅用于程序化生成渲染管线的情况。
         * @param info The render flow information
         */
        initialize(info: __private._cocos_core_pipeline_render_flow__IRenderFlowInfo): boolean;
        /**
         * @en Activate the current render flow in the given pipeline
         * @zh 为指定的渲染管线开启当前渲染流程
         * @param pipeline The render pipeline to activate this render flow
         */
        activate(pipeline: RenderPipeline): void;
        /**
         * @en Render function, it basically run all render stages in sequence for the given view.
         * @zh 渲染函数，对指定的渲染视图按顺序执行所有渲染阶段。
         * @param view Render view。
         */
        render(camera: renderer.scene.Camera): void;
        /**
         * @en Destroy function.
         * @zh 销毁函数。
         */
        destroy(): void;
    }
    /**
     * @en The render stage actually renders render objects to the output window or other GFX [[gfx.Framebuffer]].
     * Typically, a render stage collects render objects it's responsible for, clear the camera,
     * record and execute command buffer, and at last present the render result.
     * @zh 渲染阶段是实质上的渲染执行者，它负责收集渲染数据并执行渲染将渲染结果输出到屏幕或其他 GFX [[gfx.Framebuffer]] 中。
     * 典型的渲染阶段会收集它所管理的渲染对象，按照 [[Camera]] 的清除标记进行清屏，记录并执行渲染指令缓存，并最终呈现渲染结果。
     */
    export abstract class RenderStage {
        /**
         * @en Name of the current stage
         * @zh 当前渲染阶段的名字。
         */
        get name(): string;
        /**
         * @en Priority of the current stage
         * @zh 当前渲染阶段的优先级。
         */
        get priority(): number;
        /**
         * @en Tag of the current stage
         * @zh 当前渲染阶段的标签。
         */
        get tag(): number;
        /**
         * @en Name
         * @zh 名称。
         */
        protected _name: string;
        /**
         * @en Priority
         * @zh 优先级。
         */
        protected _priority: number;
        /**
         * @en Whether to enable
         * @zh 是否启用。
         */
        protected _enabled: boolean;
        set enabled(val: boolean);
        get enabled(): boolean;
        /**
         * @en Type
         * @zh 类型。
         */
        protected _tag: number;
        protected _pipeline: RenderPipeline;
        protected _flow: RenderFlow;
        /**
         * @en The initialization process, user shouldn't use it in most case, only useful when need to generate render pipeline programmatically.
         * @zh 初始化函数，正常情况下不会用到，仅用于程序化生成渲染管线的情况。
         * @param info The render stage information
         */
        initialize(info: __private._cocos_core_pipeline_render_stage__IRenderStageInfo): boolean;
        /**
         * @en Activate the current render stage in the given render flow
         * @zh 为指定的渲染流程开启当前渲染阶段
         * @param flow The render flow to activate this render stage
         */
        activate(pipeline: RenderPipeline, flow: RenderFlow): void;
        /**
         * @en Destroy function
         * @zh 销毁函数。
         */
        abstract destroy(): any;
        /**
         * @en Render function
         * @zh 渲染函数。
         * @param view The render view
         */
        abstract render(camera: renderer.scene.Camera): any;
    }
    export class PipelineSceneData {
        /**
         * @en Is open HDR.
         * @zh 是否开启 HDR。
         * @readonly
         */
        get isHDR(): boolean;
        set isHDR(val: boolean);
        get shadingScale(): number;
        set shadingScale(val: number);
        get csmSupported(): boolean;
        set csmSupported(val: boolean);
        fog: renderer.scene.Fog;
        ambient: renderer.scene.Ambient;
        skybox: renderer.scene.Skybox;
        shadows: renderer.scene.Shadows;
        csmLayers: __private._cocos_core_pipeline_shadow_csm_layers__CSMLayers;
        octree: renderer.scene.Octree;
        /**
         * @en The list for valid punctual Lights, only available after the scene culling of the current frame.
         * @zh 场景中精确的有效光源，仅在当前帧的场景剔除完成后有效。
         */
        validPunctualLights: renderer.scene.Light[];
        /**
         * @en The list for render objects, only available after the scene culling of the current frame.
         * @zh 渲染对象数组，仅在当前帧的场景剔除完成后有效。
         */
        renderObjects: pipeline.IRenderObject[];
        shadowFrameBufferMap: Map<renderer.scene.Light, gfx.Framebuffer>;
        protected _device: gfx.Device;
        protected _geometryRendererMaterials: Material[];
        protected _geometryRendererPasses: renderer.Pass[];
        protected _geometryRendererShaders: gfx.Shader[];
        protected _occlusionQueryVertexBuffer: gfx.Buffer | null;
        protected _occlusionQueryIndicesBuffer: gfx.Buffer | null;
        protected _occlusionQueryInputAssembler: gfx.InputAssembler | null;
        protected _occlusionQueryMaterial: Material | null;
        protected _occlusionQueryShader: gfx.Shader | null;
        protected _isHDR: boolean;
        protected _shadingScale: number;
        protected _csmSupported: boolean;
        constructor();
        activate(device: gfx.Device): boolean;
        initGeometryRendererMaterials(): void;
        get geometryRendererPasses(): renderer.Pass[];
        get geometryRendererShaders(): gfx.Shader[];
        initOcclusionQuery(): void;
        getOcclusionQueryPass(): renderer.Pass | null;
        updatePipelineSceneData(): void;
        destroy(): void;
    }
    /**
     * @en The forward render pipeline
     * @zh 前向渲染管线。
     */
    export class ForwardPipeline extends RenderPipeline {
        protected renderTextures: __private._cocos_core_pipeline_pipeline_serialization__RenderTextureConfig[];
        protected _postRenderPass: gfx.RenderPass | null;
        get postRenderPass(): gfx.RenderPass | null;
        initialize(info: __private._cocos_core_pipeline_render_pipeline__IRenderPipelineInfo): boolean;
        activate(swapchain: gfx.Swapchain): boolean;
        protected _ensureEnoughSize(cameras: renderer.scene.Camera[]): void;
        destroy(): boolean;
    }
    /**
     * @en The forward flow in forward render pipeline
     * @zh 前向渲染流程。
     */
    export class ForwardFlow extends RenderFlow {
        /**
         * @en The shared initialization information of forward render flow
         * @zh 共享的前向渲染流程初始化参数
         */
        static initInfo: __private._cocos_core_pipeline_render_flow__IRenderFlowInfo;
        initialize(info: __private._cocos_core_pipeline_render_flow__IRenderFlowInfo): boolean;
        activate(pipeline: RenderPipeline): void;
        render(camera: renderer.scene.Camera): void;
        destroy(): void;
    }
    /**
     * @en The forward render stage
     * @zh 前向渲染阶段。
     */
    export class ForwardStage extends RenderStage {
        static initInfo: __private._cocos_core_pipeline_render_stage__IRenderStageInfo;
        protected renderQueues: __private._cocos_core_pipeline_pipeline_serialization__RenderQueueDesc[];
        protected _renderQueues: __private._cocos_core_pipeline_render_queue__RenderQueue[];
        additiveInstanceQueues: __private._cocos_core_pipeline_render_instanced_queue__RenderInstancedQueue[];
        constructor();
        addRenderInstancedQueue(queue: __private._cocos_core_pipeline_render_instanced_queue__RenderInstancedQueue): void;
        removeRenderInstancedQueue(queue: __private._cocos_core_pipeline_render_instanced_queue__RenderInstancedQueue): void;
        initialize(info: __private._cocos_core_pipeline_render_stage__IRenderStageInfo): boolean;
        activate(pipeline: ForwardPipeline, flow: ForwardFlow): void;
        destroy(): void;
        render(camera: renderer.scene.Camera): void;
    }
    /**
     * @en The deferred render pipeline
     * @zh 延迟渲染管线。
     */
    export class DeferredPipeline extends RenderPipeline {
        protected renderTextures: __private._cocos_core_pipeline_pipeline_serialization__RenderTextureConfig[];
        initialize(info: __private._cocos_core_pipeline_render_pipeline__IRenderPipelineInfo): boolean;
        activate(swapchain: gfx.Swapchain): boolean;
        destroy(): boolean;
        onGlobalPipelineStateChanged(): void;
        getPipelineRenderData(): __private._cocos_core_pipeline_deferred_deferred_pipeline__DeferredRenderData;
        protected _ensureEnoughSize(cameras: renderer.scene.Camera[]): void;
    }
    /**
     * @en The main flow in deferred render pipeline
     * @zh 延迟渲染流程。
     */
    export class MainFlow extends RenderFlow {
        /**
         * @en The shared initialization information of main render flow
         * @zh 共享的延迟渲染流程初始化参数
         */
        static initInfo: __private._cocos_core_pipeline_render_flow__IRenderFlowInfo;
        initialize(info: __private._cocos_core_pipeline_render_flow__IRenderFlowInfo): boolean;
        activate(pipeline: RenderPipeline): void;
        render(camera: renderer.scene.Camera): void;
        destroy(): void;
    }
    /**
     * @en The gbuffer render stage
     * @zh 前向渲染阶段。
     */
    export class GbufferStage extends RenderStage {
        static initInfo: __private._cocos_core_pipeline_render_stage__IRenderStageInfo;
        protected renderQueues: __private._cocos_core_pipeline_pipeline_serialization__RenderQueueDesc[];
        protected _renderQueues: __private._cocos_core_pipeline_render_queue__RenderQueue[];
        constructor();
        initialize(info: __private._cocos_core_pipeline_render_stage__IRenderStageInfo): boolean;
        activate(pipeline: DeferredPipeline, flow: MainFlow): void;
        destroy(): void;
        render(camera: renderer.scene.Camera): void;
    }
    /**
     * @en The lighting render stage
     * @zh 前向渲染阶段。
     */
    export class LightingStage extends RenderStage {
        static initInfo: __private._cocos_core_pipeline_render_stage__IRenderStageInfo;
        constructor();
        initialize(info: __private._cocos_core_pipeline_render_stage__IRenderStageInfo): boolean;
        gatherLights(camera: renderer.scene.Camera): void;
        protected _createStageDescriptor(pass: renderer.Pass): void;
        activate(pipeline: DeferredPipeline, flow: MainFlow): void;
        destroy(): void;
        render(camera: renderer.scene.Camera): void;
    }
    /**
     * @en The bloom post-process stage
     * @zh Bloom 后处理阶段。
     */
    export class BloomStage extends RenderStage {
        static initInfo: __private._cocos_core_pipeline_render_stage__IRenderStageInfo;
        threshold: number;
        intensity: number;
        iterations: number;
        constructor();
        initialize(info: __private._cocos_core_pipeline_render_stage__IRenderStageInfo): boolean;
        activate(pipeline: RenderPipeline, flow: RenderFlow): void;
        destroy(): void;
        render(camera: renderer.scene.Camera): void;
    }
    /**
     * @en The postprocess render stage
     * @zh 后处理渲染阶段。
     */
    export class PostProcessStage extends RenderStage {
        static initInfo: __private._cocos_core_pipeline_render_stage__IRenderStageInfo;
        constructor();
        initialize(info: __private._cocos_core_pipeline_render_stage__IRenderStageInfo): boolean;
        activate(pipeline: RenderPipeline, flow: RenderFlow): void;
        destroy(): void;
        render(camera: renderer.scene.Camera): void;
    }
    /**
     * @en Shadow map render flow
     * @zh 阴影贴图绘制流程
     */
    export class ShadowFlow extends RenderFlow {
        /**
         * @en A common initialization info for shadow map render flow
         * @zh 一个通用的 ShadowFlow 的初始化信息对象
         */
        static initInfo: __private._cocos_core_pipeline_render_flow__IRenderFlowInfo;
        initialize(info: __private._cocos_core_pipeline_render_flow__IRenderFlowInfo): boolean;
        activate(pipeline: RenderPipeline): void;
        render(camera: renderer.scene.Camera): void;
        destroy(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _initShadowFrameBuffer(pipeline: RenderPipeline, light: renderer.scene.Light, swapchain: gfx.Swapchain): void;
    }
    /**
     * @en Shadow map render stage
     * @zh 阴影渲染阶段。
     */
    export class ShadowStage extends RenderStage {
        /**
         * @en A common initialization info for shadow map render stage
         * @zh 一个通用的 ShadowStage 的初始化信息对象
         */
        static initInfo: __private._cocos_core_pipeline_render_stage__IRenderStageInfo;
        /**
         * @en Sets the render shadow map info
         * @zh 设置阴影渲染信息
         * @param light
         * @param shadowFrameBuffer
         * @param level 层级
         */
        setUsage(globalDS: gfx.DescriptorSet, light: renderer.scene.Light, shadowFrameBuffer: gfx.Framebuffer, level?: number): void;
        destroy(): void;
        clearFramebuffer(camera: renderer.scene.Camera): void;
        render(camera: renderer.scene.Camera): void;
        activate(pipeline: ForwardPipeline, flow: ShadowFlow): void;
    }
    export class InstancedBuffer {
        instances: __private._cocos_core_pipeline_instanced_buffer__IInstancedItem[];
        pass: renderer.Pass;
        hasPendingModels: boolean;
        dynamicOffsets: number[];
        constructor(pass: renderer.Pass);
        destroy(): void;
        merge(subModel: renderer.scene.SubModel, passIdx: number, shaderImplant?: gfx.Shader | null): void;
        uploadBuffers(cmdBuff: gfx.CommandBuffer): void;
        clear(): void;
    }
    export class PipelineStateManager {
        static getOrCreatePipelineState(device: gfx.Device, pass: renderer.Pass, shader: gfx.Shader, renderPass: gfx.RenderPass, ia: gfx.InputAssembler): gfx.PipelineState;
    }
    export class PipelineEventProcessor extends EventTarget {
        eventTargetOn: <TFunction extends (...any: any[]) => void>(type: string | number, callback: TFunction, thisArg?: any, once?: boolean | undefined) => TFunction;
        eventTargetOnce: <TFunction extends (...any: any[]) => void>(type: string | number, callback: TFunction, thisArg?: any) => TFunction;
        on(type: PipelineEventType, callback: any, target?: any, once?: boolean): typeof callback;
        once(type: PipelineEventType, callback: any, target?: any): typeof callback;
    }
    export enum PipelineEventType {
        /**
         * @en
         * The event type for render frame begin event
         *
         * @zh
         * 帧渲染开始事件。
         */
        RENDER_FRAME_BEGIN = "render-frame-begin",
        /**
         * @en
         * The event type for render frame end event
         *
         * @zh
         * 帧渲染结束事件。
         */
        RENDER_FRAME_END = "render-frame-end",
        /**
         * @en
         * The event type for render camera begin event
         *
         * @zh
         * 相机渲染开始事件。
         */
        RENDER_CAMERA_BEGIN = "render-camera-begin",
        /**
         * @en
         * The event type for render camera end event
         *
         * @zh
         * 相机渲染结束事件。
         */
        RENDER_CAMERA_END = "render-camera-end",
        /**
         * @en
         * FBO attachment texture zoom event
         *
         * @zh
         * FBO附件纹理缩放事件。
         */
        ATTACHMENT_SCALE_CAHNGED = "attachment-scale-changed"
    }
    /**
     * @en Rendering debug view control class
     * @zh 渲染调试控制类
     */
    export class DebugView {
        /**
         * @en Toggle rendering single debug mode.
         * @zh 设置渲染单项调试模式。
         */
        get singleMode(): __private._cocos_core_pipeline_debug_view__DebugViewSingleType;
        set singleMode(val: __private._cocos_core_pipeline_debug_view__DebugViewSingleType);
        /**
         * @en Toggle normal / pure lighting mode.
         * @zh 切换正常光照和仅光照模式。
         */
        get lightingWithAlbedo(): boolean;
        set lightingWithAlbedo(val: boolean);
        /**
         * @en Toggle CSM layer coloration mode.
         * @zh 切换级联阴影染色调试模式。
         */
        get csmLayerColoration(): boolean;
        set csmLayerColoration(val: boolean);
        protected _singleMode: __private._cocos_core_pipeline_debug_view__DebugViewSingleType;
        protected _compositeModeValue: number;
        protected _lightingWithAlbedo: boolean;
        protected _csmLayerColoration: boolean;
        protected _nativeConfig: any;
        constructor();
        /**
         * @en Whether enabled with specified rendering composite debug mode.
         * @zh 获取指定的渲染组合调试模式是否开启。
         * @param Specified composite type.
         */
        isCompositeModeEnabled(val: number): boolean;
        /**
         * @en Toggle specified rendering composite debug mode.
         * @zh 开关指定的渲染组合调试模式。
         * @param Specified composite type, enable or disable.
         */
        enableCompositeMode(val: __private._cocos_core_pipeline_debug_view__DebugViewCompositeType, enable: boolean): void;
        /**
         * @en Toggle all rendering composite debug mode.
         * @zh 开关所有的渲染组合调试模式。
         */
        enableAllCompositeMode(enable: boolean): void;
        /**
         * @en Get rendering debug view on / off state.
         * @zh 查询当前是否开启了渲染调试模式。
         */
        isEnabled(): boolean;
        /**
         * @en Disable all debug view modes, reset to standard rendering mode.
         * @zh 关闭所有的渲染调试模式，恢复到正常渲染。
         */
        reset(): void;
        /**
         * @internal
         */
        protected _activate(): void;
        protected _updatePipeline(): void;
    }
    export const getPhaseID: (phaseName: string | number) => number;
    export const assetManager: AssetManager;
    /**
     * @en
     * This module controls asset's behaviors and information, include loading, releasing etc. it is a singleton
     * All member can be accessed with `assetManager`.
     *
     * @zh
     * 此模块管理资源的行为和信息，包括加载，释放等，这是一个单例，所有成员能够通过 `assetManager` 调用
     *
     */
    export class AssetManager {
        /**
         * @en
         * Normal loading pipeline
         *
         * @zh
         * 正常加载管线
         *
         */
        pipeline: AssetManager.Pipeline;
        /**
         * @en
         * Fetching pipeline
         *
         * @zh
         * 下载管线
         *
         */
        fetchPipeline: AssetManager.Pipeline;
        /**
         * @en
         * Url transformer
         *
         * @zh
         * Url 转换器
         *
         */
        transformPipeline: AssetManager.Pipeline;
        /**
         * @en
         * The collection of bundle which is already loaded, you can remove cache with [[removeBundle]]
         *
         * @zh
         * 已加载 bundle 的集合， 你能通过 [[removeBundle]] 来移除缓存
         *
         */
        bundles: __private._cocos_core_asset_manager_cache__ICache<AssetManager.Bundle>;
        /**
         * @en
         * The collection of asset which is already loaded, you can remove cache with [[releaseAsset]]
         *
         * @zh
         * 已加载资源的集合， 你能通过 [[releaseAsset]] 来移除缓存
         */
        assets: __private._cocos_core_asset_manager_cache__ICache<Asset>;
        /**
         * @internal only using in L10N for now
         */
        readonly assetsOverrideMap: Map<string, string>;
        generalImportBase: string;
        generalNativeBase: string;
        /**
         * @en
         * Manage relationship between asset and its dependencies
         *
         * @zh
         * 管理资源依赖关系
         */
        dependUtil: __private._cocos_core_asset_manager_depend_util__DependUtil;
        /**
         * @en
         * Whether or not load asset forcibly, if it is true, asset will be loaded regardless of error
         *
         * @zh
         * 是否强制加载资源, 如果为 true ，加载资源将会忽略报错
         *
         */
        force: boolean;
        /**
         * @en
         * Whether to use image bitmap to load image first. If enabled, images loading will become faster but memory usage will increase.
         *
         * @zh
         * 是否优先使用 image bitmap 来加载图片，启用之后，图片加载速度会更快, 但内存占用会变高，
         *
         */
        allowImageBitmap: boolean;
        /**
         * @en
         * Some useful function
         *
         * @zh
         * 一些有用的方法
         *
         */
        utils: typeof __private._cocos_core_asset_manager_helper;
        /**
         * @en
         * Manage all downloading task
         *
         * @zh
         * 管理所有下载任务
         *
         */
        downloader: __private._cocos_core_asset_manager_downloader__Downloader;
        /**
         * @en
         * Manage all parsing task
         *
         * @zh
         * 管理所有解析任务
         *
         */
        parser: __private._cocos_core_asset_manager_parser__Parser;
        /**
         * @en
         * Manage all packed asset
         *
         * @zh
         * 管理所有合并后的资源
         *
         */
        packManager: __private._cocos_core_asset_manager_pack_manager__PackManager;
        /**
         * @en
         * Whether or not cache the loaded asset
         *
         * @zh
         * 是否缓存已加载的资源
         *
         */
        cacheAsset: boolean;
        /**
         * @en
         * Cache manager is a module which controls all caches downloaded from server in non-web platform.
         *
         * @zh
         * 缓存管理器是一个模块，在非 WEB 平台上，用于管理所有从服务器上下载下来的缓存
         *
         */
        cacheManager: __private._cocos_core_asset_manager_cache_manager__default | null;
        /**
         * @en
         * The preset of options
         *
         * @zh
         * 可选参数的预设集
         *
         */
        presets: Record<string, Record<string, any>>;
        factory: __private._cocos_core_asset_manager_factory__Factory;
        preprocessPipe: __private._cocos_core_asset_manager_pipeline__IPipe;
        fetchPipe: __private._cocos_core_asset_manager_pipeline__IPipe;
        loadPipe: __private._cocos_core_asset_manager_pipeline__IPipe;
        references: AssetManager.Cache<any[]> | null;
        /**
         * @en
         * The builtin 'main' bundle
         *
         * @zh
         * 内置 main 包
         */
        get main(): AssetManager.Bundle | null;
        /**
         * @en
         * The builtin 'resources' bundle
         *
         * @zh
         * 内置 resources 包
         *
         */
        get resources(): AssetManager.Bundle | null;
        /**
         * @en
         * Initialize assetManager with options
         *
         * @zh
         * 初始化资源管理器
         *
         * @param options - the configuration
         *
         */
        init(options?: __private._cocos_core_asset_manager_asset_manager__IAssetManagerOptions): void;
        /**
         * @en
         * Get the bundle which has been loaded
         *
         * @zh
         * 获取已加载的分包
         *
         * @param name - The name of bundle
         * @return - The loaded bundle
         *
         * @example
         * // ${project}/assets/test1
         * assetManager.getBundle('test1');
         *
         * assetManager.getBundle('resources');
         *
         */
        getBundle(name: string): AssetManager.Bundle | null;
        /**
         * @en
         * Remove this bundle. NOTE: The asset within this bundle will not be released automatically,
         * you can call [[AssetManager.Bundle.releaseAll]] manually before remove it if you need
         *
         * @zh
         * 移除此包, 注意：这个包内的资源不会自动释放, 如果需要的话你可以在摧毁之前手动调用 [[AssetManager.Bundle.releaseAll]] 进行释放
         *
         * @param bundle - The bundle to be removed
         *
         * @typescript
         * removeBundle(bundle: AssetManager.Bundle): void
         */
        removeBundle(bundle: AssetManager.Bundle): void;
        /**
         * @en
         * General interface used to load assets with a progression callback and a complete callback. You can achieve almost all
         * effect you want with combination of `requests` and `options`.It is highly recommended that you use more simple API,
         * such as `load`, `loadDir` etc. Every custom parameter in `options` will be distribute to each of `requests`. if request
         * already has same one, the parameter in request will be given priority. Besides, if request has dependencies, `options`
         * will distribute to dependencies too. Every custom parameter in `requests` will be transferred to handler of `downloader`
         * and `parser` as `options`. You can register you own handler downloader or parser to collect these custom parameters for some effect.
         *
         * Reserved Keyword: `uuid`, `url`, `path`, `dir`, `scene`, `type`, `priority`, `preset`, `audioLoadMode`, `ext`,
         * `bundle`, `onFileProgress`, `maxConcurrency`, `maxRequestsPerFrame`, `maxRetryCount`, `version`, `xhrResponseType`,
         * `xhrWithCredentials`, `xhrMimeType`, `xhrTimeout`, `xhrHeader`, `reloadAsset`, `cacheAsset`, `cacheEnabled`,
         * Please DO NOT use these words as custom options!
         *
         * @zh
         * 通用加载资源接口，可传入进度回调以及完成回调，通过组合 `request` 和 `options` 参数，几乎可以实现和扩展所有想要的加载效果。非常建议
         * 你使用更简单的API，例如 `load`、`loadDir` 等。`options` 中的自定义参数将会分发到 `requests` 的每一项中，如果request中已存在同名的
         * 参数则以 `requests` 中为准，同时如果有其他依赖资源，则 `options` 中的参数会继续向依赖项中分发。request中的自定义参数都会以 `options`
         * 形式传入加载流程中的 `downloader`, `parser` 的方法中, 你可以扩展 `downloader`, `parser` 收集参数完成想实现的效果。
         *
         * 保留关键字: `uuid`, `url`, `path`, `dir`, `scene`, `type`, `priority`, `preset`, `audioLoadMode`, `ext`, `bundle`, `onFileProgress`,
         *  `maxConcurrency`, `maxRequestsPerFrame`, `maxRetryCount`, `version`, `xhrResponseType`, `xhrWithCredentials`, `xhrMimeType`, `xhrTimeout`, `xhrHeader`,
         *  `reloadAsset`, `cacheAsset`, `cacheEnabled`, 请不要使用这些字段为自定义参数!
         *
         * @param requests - The request you want to load
         * @param options - Optional parameters
         * @param onProgress - Callback invoked when progression change
         * @param onProgress.finished - The number of the items that are already completed
         * @param onProgress.total - The total number of the items
         * @param onProgress.item - The current request item
         * @param onComplete - Callback invoked when finish loading
         * @param onComplete.err - The error occurred in loading process.
         * @param onComplete.data - The loaded content
         *
         * @example
         * assetManager.loadAny({url: 'http://example.com/a.png'}, (err, img) => log(img));
         * assetManager.loadAny(['60sVXiTH1D/6Aft4MRt9VC'], (err, assets) => log(assets));
         * assetManager.loadAny([{ uuid: '0cbZa5Y71CTZAccaIFluuZ'}, {url: 'http://example.com/a.png'}], (err, assets) => log(assets));
         * assetManager.downloader.register('.asset', (url, options, onComplete) => {
         *      url += '?userName=' + options.userName + "&password=" + options.password;
         *      assetManager.downloader.downloadFile(url, null, onComplete);
         * });
         * assetManager.parser.register('.asset', (file, options, onComplete) => {
         *      var json = JSON.parse(file);
         *      var skin = json[options.skin];
         *      var model = json[options.model];
         *      onComplete(null, {skin, model});
         * });
         * assetManager.loadAny({ url: 'http://example.com/my.asset', skin: 'xxx', model: 'xxx', userName: 'xxx', password: 'xxx' });
         *
         */
        loadAny(requests: __private._cocos_core_asset_manager_shared__Request, options: __private._cocos_core_asset_manager_shared__IOptions | null, onProgress: __private._cocos_core_asset_manager_shared__ProgressCallback | null, onComplete: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData | null): void;
        loadAny(requests: __private._cocos_core_asset_manager_shared__Request, onProgress: __private._cocos_core_asset_manager_shared__ProgressCallback | null, onComplete: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData | null): void;
        loadAny(requests: __private._cocos_core_asset_manager_shared__Request, options: __private._cocos_core_asset_manager_shared__IOptions | null, onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData | null): void;
        loadAny<T extends Asset>(requests: string, onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<T> | null): void;
        loadAny<T extends Asset>(requests: string[], onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<T[]> | null): void;
        loadAny(requests: __private._cocos_core_asset_manager_shared__Request, onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData | null): void;
        /**
         * @en
         * General interface used to preload assets with a progression callback and a complete callback.It is highly recommended that you use
         * more simple API, such as `preloadRes`, `preloadResDir` etc. Everything about preload is just likes `assetManager.loadAny`, the
         * difference is `assetManager.preloadAny` will only download asset but not parse asset. You need to invoke `assetManager.loadAny(preloadTask)`
         * to finish loading asset
         *
         * @zh
         * 通用预加载资源接口，可传入进度回调以及完成回调，非常建议你使用更简单的 API ，例如 `preloadRes`, `preloadResDir` 等。`preloadAny` 和 `loadAny`
         * 几乎一样，区别在于 `preloadAny` 只会下载资源，不会去解析资源，你需要调用 `assetManager.loadAny(preloadTask)` 来完成资源加载。
         *
         * @param requests - The request you want to preload
         * @param options - Optional parameters
         * @param onProgress - Callback invoked when progression change
         * @param onProgress.finished - The number of the items that are already completed
         * @param onProgress.total - The total number of the items
         * @param onProgress.item - The current request item
         * @param onComplete - Callback invoked when finish preloading
         * @param onComplete.err - The error occurred in preloading process.
         * @param onComplete.items - The preloaded content
         *
         * @example
         * assetManager.preloadAny('0cbZa5Y71CTZAccaIFluuZ', (err) => assetManager.loadAny('0cbZa5Y71CTZAccaIFluuZ'));
         *
         */
        preloadAny(requests: __private._cocos_core_asset_manager_shared__Request, options: __private._cocos_core_asset_manager_shared__IOptions | null, onProgress: __private._cocos_core_asset_manager_shared__ProgressCallback | null, onComplete: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<AssetManager.RequestItem[]> | null): void;
        preloadAny(requests: __private._cocos_core_asset_manager_shared__Request, onProgress: __private._cocos_core_asset_manager_shared__ProgressCallback | null, onComplete: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<AssetManager.RequestItem[]> | null): void;
        preloadAny(requests: __private._cocos_core_asset_manager_shared__Request, options: __private._cocos_core_asset_manager_shared__IOptions | null, onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<AssetManager.RequestItem[]> | null): void;
        preloadAny(requests: __private._cocos_core_asset_manager_shared__Request, onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<AssetManager.RequestItem[]> | null): void;
        /**
         * @en
         * Load remote asset with url, such as audio, image, text and so on.
         *
         * @zh
         * 使用 url 加载远程资源，例如音频，图片，文本等等。
         *
         * @param url - The url of asset
         * @param options - Some optional parameters
         * @param options.audioLoadMode - Indicate which mode audio you want to load
         * @param options.ext - If the url does not have a extension name, you can specify one manually.
         * @param onComplete - Callback invoked when finish loading
         * @param onComplete.err - The error occurred in loading process.
         * @param onComplete.asset - The loaded texture
         *
         * @example
         * assetManager.loadRemote('http://www.cloud.com/test1.jpg', (err, texture) => console.log(err));
         * assetManager.loadRemote('http://www.cloud.com/test2.mp3', (err, audioClip) => console.log(err));
         * assetManager.loadRemote('http://www.cloud.com/test3', { ext: '.png' }, (err, texture) => console.log(err));
         *
         */
        loadRemote<T extends Asset>(url: string, options: __private._cocos_core_asset_manager_shared__IRemoteOptions | null, onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<T> | null): void;
        loadRemote<T extends Asset>(url: string, onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<T> | null): void;
        /**
         * @en
         * load bundle
         *
         * @zh
         * 加载资源包
         *
         * @param nameOrUrl - The name or root path of bundle
         * @param options - Some optional paramter, same like downloader.downloadFile
         * @param options.version - The version of this bundle, you can check config.json in this bundle
         * @param onComplete - Callback when bundle loaded or failed
         * @param onComplete.err - The occurred error, null indicates success
         * @param onComplete.bundle - The loaded bundle
         *
         * @example
         * loadBundle('http://localhost:8080/test', null, (err, bundle) => console.log(err));
         *
         */
        loadBundle(nameOrUrl: string, options: __private._cocos_core_asset_manager_shared__IBundleOptions | null, onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<AssetManager.Bundle> | null): void;
        loadBundle(nameOrUrl: string, onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<AssetManager.Bundle> | null): void;
        /**
         * @en
         * Release asset and it's dependencies.
         * This method will not only remove the cache of the asset in assetManager, but also clean up its content.
         * For example, if you release a texture, the texture asset and its gl texture data will be freed up.
         * Notice, this method may cause the texture to be unusable, if there are still other nodes use the same texture,
         * they may turn to black and report gl errors.
         *
         * @zh
         * 释放资源以及其依赖资源, 这个方法不仅会从 assetManager 中删除资源的缓存引用，还会清理它的资源内容。
         * 比如说，当你释放一个 texture 资源，这个 texture 和它的 gl 贴图数据都会被释放。
         * 注意，这个函数可能会导致资源贴图或资源所依赖的贴图不可用，如果场景中存在节点仍然依赖同样的贴图，它们可能会变黑并报 GL 错误。
         *
         * @param asset - The asset to be released
         *
         * @example
         * // release a texture which is no longer need
         * assetManager.releaseAsset(texture);
         *
         */
        releaseAsset(asset: Asset): void;
        /**
         * @en
         * Release all assets. Refer to [[releaseAsset]] for detailed information.
         *
         * @zh
         * 释放所有资源。详细信息请参考 [[releaseAsset]]
         *
         */
        releaseAll(): void;
        /**
         * For internal usage.
         * @param json
         * @param options
         * @param onComplete
         * @private
         */
        loadWithJson<T extends Asset>(json: Record<string, any>, options: __private._cocos_core_asset_manager_shared__IJsonAssetOptions | null, onProgress: __private._cocos_core_asset_manager_shared__ProgressCallback | null, onComplete: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<T> | null): void;
        loadWithJson<T extends Asset>(json: Record<string, any>, onProgress: __private._cocos_core_asset_manager_shared__ProgressCallback | null, onComplete: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<T> | null): void;
        loadWithJson<T extends Asset>(json: Record<string, any>, options: __private._cocos_core_asset_manager_shared__IJsonAssetOptions | null, onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<T> | null): void;
        loadWithJson<T extends Asset>(json: Record<string, any>, onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<T> | null): void;
    }
    export namespace AssetManager {
        /**
         * @en
         * Pipeline can execute the task for some effect.
         *
         * @zh
         * 管线能执行任务达到某个效果
         *
         */
        export class Pipeline {
            /**
             * @en
             * The id of pipeline
             *
             * @zh
             * 管线的 id
             *
             */
            id: number;
            /**
             * @en
             * The name of pipeline
             *
             * @zh
             * 管线的名字
             *
             */
            name: string;
            /**
             * @en
             * All pipes of pipeline
             *
             * @zh
             * 所有的管道
             *
             */
            pipes: __private._cocos_core_asset_manager_pipeline__IPipe[];
            /**
             * @en
             * Create a new pipeline
             *
             * @zh
             * 创建一个管线
             *
             * @param name - The name of pipeline
             * @param funcs - The array of pipe, every pipe must be function which take two parameters,
             * the first is a `Task` flowed in pipeline, the second is complete callback
             *
             * @example
             * const pipeline = new Pipeline('download', [
             * (task, done) => {
             *      const url = task.input;
             *      assetManager.downloader.downloadFile(url, null, null, (err, result) => {
             *          task.output = result;
             *          done(err);
             *      });
             * },
             * (task, done) => {
             *      const text = task.input;
             *      const json = JSON.stringify(text);
             *      task.output = json;
             *      done();
             * }
             * ]);
             *
             */
            constructor(name: string, funcs: __private._cocos_core_asset_manager_pipeline__IPipe[]);
            /**
             * @en
             * At specific point insert a new pipe to pipeline
             *
             * @zh
             * 在某个特定的点为管线插入一个新的 pipe
             *
             * @param func - The new pipe
             * @param func.task - The task handled with pipeline will be transferred to this function
             * @param func.done - Callback you need to invoke manually when this pipe is finished. if the pipeline is synchronous, callback is unnecessary.
             * @param index - The specific point you want to insert at.
             * @return pipeline
             *
             * @example
             * var pipeline = new Pipeline('test', []);
             * pipeline.insert((task, done) => {
             *      // do something
             *      done();
             * }, 0);
             *
             */
            insert(func: __private._cocos_core_asset_manager_pipeline__IPipe, index: number): Pipeline;
            /**
             * @en
             * Append a new pipe to the pipeline
             *
             * @zh
             * 添加一个管道到管线中
             *
             * @param func - The new pipe
             * @param func.task - The task handled with pipeline will be transferred to this function
             * @param func.done - Callback you need to invoke manually when this pipe is finished. if the pipeline is synchronous, callback is unnecessary.
             * @return pipeline
             *
             * @example
             * var pipeline = new Pipeline('test', []);
             * pipeline.append((task, done) => {
             *      // do something
             *      done();
             * });
             *
             */
            append(func: __private._cocos_core_asset_manager_pipeline__IPipe): Pipeline;
            /**
             * @en
             * Remove pipe which at specific point
             *
             * @zh
             * 移除特定位置的管道
             *
             * @param index - The specific point
             * @return pipeline
             *
             * @example
             * var pipeline = new Pipeline('test', (task, done) => {
             *      // do something
             *      done();
             * });
             * pipeline.remove(0);
             *
             */
            remove(index: number): Pipeline;
            /**
             * @en
             * Execute task synchronously
             *
             * @zh
             * 同步执行任务
             *
             * @param task - The task will be executed
             * @returns result
             *
             * @example
             * var pipeline = new Pipeline('sync', [(task) => {
             *      let input = task.input;
             *      task.output = doSomething(task.input);
             * }]);
             *
             * var task = new Task({input: 'test'});
             * console.log(pipeline.sync(task));
             *
             */
            sync(task: Task): any;
            /**
             * @en
             * Execute task asynchronously
             *
             * @zh
             * 异步执行任务
             *
             * @param task - The task will be executed
             *
             * @example
             * var pipeline = new Pipeline('sync', [(task, done) => {
             *      let input = task.input;
             *      task.output = doSomething(task.input);
             *      done();
             * }]);
             * var task = new Task({input: 'test', onComplete: (err, result) => console.log(result)});
             * pipeline.async(task);
             *
             */
            async(task: Task): void;
        }
        /**
         * @en
         * Task is used to run in the pipeline for some effect
         *
         * @zh
         * 任务用于在管线中运行以达成某种效果
         *
         */
        export class Task {
            static MAX_DEAD_NUM: number;
            /**
             * @en
             * Create a new task from pool
             *
             * @zh
             * 从对象池中创建 task
             *
             * @static
             * @method create
             * @param options - Some optional paramters
             * @param options.onComplete - Callback when the task complete, if the pipeline is synchronous, onComplete is unnecessary.
             * @param options.onProgress - Continuously callback when the task is runing, if the pipeline is synchronous, onProgress is unnecessary.
             * @param options.onError - Callback when something goes wrong, if the pipeline is synchronous, onError is unnecessary.
             * @param options.input - Something will be handled with pipeline
             * @param options.progress - Progress information, you may need to assign it manually when multiple pipeline share one progress
             * @param options.options - Custom parameters
             * @returns task
             *
             */
            static create(options: __private._cocos_core_asset_manager_task__ITaskOption): Task;
            /**
             * @en
             * The id of task
             *
             * @zh
             * 任务id
             *
             */
            id: number;
            /**
             * @en
             * The callback when task is completed
             *
             * @zh
             * 完成回调
             *
             */
            onComplete: __private._cocos_core_asset_manager_task__TaskCompleteCallback | null;
            /**
             * @en
             * The callback of progression
             *
             * @zh
             * 进度回调
             *
             */
            onProgress: __private._cocos_core_asset_manager_task__TaskProgressCallback | null;
            /**
             * @en
             * The callback when something goes wrong
             *
             * @zh
             * 错误回调
             *
             */
            onError: __private._cocos_core_asset_manager_task__TaskErrorCallback | null;
            /**
             * @en
             * The source of task
             *
             * @zh
             * 任务的源
             *
             */
            source: any;
            /**
             * @en
             * The output of task
             *
             * @zh
             * 任务的输出
             */
            output: any;
            /**
             * @en
             * The input of task
             *
             * @zh
             * 任务的输入
             *
             */
            input: any;
            /**
             * @en
             * The progression of task
             *
             * @zh
             * 任务的进度
             *
             */
            progress: any;
            /**
             * @en
             * Custom options
             *
             * @zh
             * 自定义参数
             *
             */
            options: Record<string, any> | null;
            /**
             * @en
             * Whether or not this task is completed
             *
             * @zh
             * 此任务是否已经完成
             *
             */
            isFinish: boolean;
            /**
             * @en
             * Create a new Task
             *
             * @zh
             * 创建一个任务
             *
             * @param options - Some optional paramters
             * @param options.onComplete - Callback when the task is completed, if the pipeline is synchronous, onComplete is unnecessary.
             * @param options.onProgress - Continuously callback when the task is runing, if the pipeline is synchronous, onProgress is unnecessary.
             * @param options.onError - Callback when something goes wrong, if the pipeline is synchronous, onError is unnecessary.
             * @param options.input - Something will be handled with pipeline
             * @param options.progress - Progress information, you may need to assign it manually when multiple pipeline share one progress
             * @param options.options - Custom parameters
             */
            constructor(options?: __private._cocos_core_asset_manager_task__ITaskOption);
            /**
             * @en
             * Set parameters of this task
             *
             * @zh
             * 设置任务的参数
             *
             * @param options - Some optional parameters
             * @param options.onComplete - Callback when the task is completed, if the pipeline is synchronous, onComplete is unnecessary.
             * @param options.onProgress - Continuously callback when the task is running, if the pipeline is synchronous, onProgress is unnecessary.
             * @param options.onError - Callback when something goes wrong, if the pipeline is synchronous, onError is unnecessary.
             * @param options.input - Something will be handled with pipeline
             * @param options.progress - Progress information, you may need to assign it manually when multiple pipeline share one progress
             * @param options.options - Custom parameters
             *
             * @example
             * var task = new Task();
             * task.set({input: ['test'], onComplete: (err, result) => console.log(err), onProgress: (finish, total) => console.log(finish / total)});
             *
             */
            set(options?: __private._cocos_core_asset_manager_task__ITaskOption): void;
            /**
             * @en
             * Dispatch event
             *
             * @zh
             * 发布事件
             *
             * @param event - The event name
             * @param param1 - Parameter 1
             * @param param2 - Parameter 2
             * @param param3 - Parameter 3
             * @param param4 - Parameter 4
             *
             * @example
             * var task = Task.create();
             * Task.onComplete = (msg) => console.log(msg);
             * Task.dispatch('complete', 'hello world');
             *
             */
            dispatch(event: string, param1?: any, param2?: any, param3?: any, param4?: any): void;
            /**
             * @en
             * Recycle this for reuse
             *
             * @zh
             * 回收 task 用于复用
             *
             */
            recycle(): void;
        }
        /**
         * @en
         * use to cache something
         *
         * @zh
         * 用于缓存某些内容
         *
         */
        export class Cache<T = any> implements __private._cocos_core_asset_manager_cache__ICache<T> {
            protected _map: Record<string, T> | null;
            protected _count: number;
            /**
             * @en
             * Create a cache
             *
             * @zh
             * 创建一个 cache
             *
             * @param map - An object used to initialize
             *
             */
            constructor(map?: Record<string, T>);
            /**
             * @en
             * Add Key-Value to cache
             *
             * @zh
             * 增加键值对到缓存中
             *
             * @param key - The key
             * @param val - The value
             * @returns The value
             *
             * @example
             * var cache = new Cache();
             * cache.add('test', null);
             *
             */
            add(key: string, val: T): T;
            /**
             * @en
             * Get the cached content by key
             *
             * @zh
             * 通过 key 获取对应的 value
             *
             * @param key - The key
             * @returns The corresponding content
             *
             * @example
             * let cache = new Cache();
             * let test = cache.get('test');
             *
             */
            get(key: string): T | undefined | null;
            /**
             * @en
             * Check whether or not content exists by key
             *
             * @zh
             * 通过 Key 判断是否存在对应的内容
             *
             * @param key - The key
             * @returns True indicates that content of the key exists
             *
             * @example
             * var cache = new Cache();
             * var exist = cache.has('test');
             *
             */
            has(key: string): boolean;
            /**
             * @en
             * Remove the cached content by key
             *
             * @zh
             * 通过 Key 移除对应的内容
             *
             * @param key - The key
             * @returns The removed content
             *
             * @example
             * var cache = new Cache();
             * var content = cache.remove('test');
             *
             */
            remove(key: string): T | undefined | null;
            /**
             * @en
             * Clear all content
             *
             * @zh
             * 清除所有内容
             *
             * @example
             * var cache = new Cache();
             * cache.clear();
             *
             */
            clear(): void;
            /**
             * @en
             * Enumerate all content and invoke function
             *
             * @zh
             * 枚举所有内容并执行方法
             *
             * @param func - Function to be invoked
             * @param func.val - The value
             * @param func.key - The corresponding key
             *
             * @example
             * var cache = new Cache();
             * cache.forEach((val, key) => console.log(key));
             *
             */
            forEach(func: (val: T, key: string) => void): void;
            /**
             * @en
             * Enumerate all content to find one element which can fulfill condition
             *
             * @zh
             * 枚举所有内容，找到一个可以满足条件的元素
             *
             * @param predicate - The condition
             * @returns content
             *
             * @example
             * var cache = new Cache();
             * var val = cache.find((val, key) => key === 'test');
             *
             */
            find(predicate: (val: T, key: string) => boolean): T | null;
            /**
             * @en
             * The count of cached content
             *
             * @zh
             * 缓存数量
             *
             */
            get count(): number;
            /**
             * @en
             * Destroy this cache
             *
             * @zh
             * 销毁这个 cache
             *
             */
            destroy(): void;
        }
        /**
         * @en
         * A collection of information about a request
         *
         * @zh
         * 请求的相关信息集合
         *
         */
        export class RequestItem {
            /**
             * @en
             * The id of request, combined from uuid and isNative
             *
             * @zh
             * 请求的 id, 由 uuid 和 isNative 组合而成
             */
            get id(): string;
            static MAX_DEAD_NUM: number;
            /**
             * @en
             * Create a new request item from pool
             *
             * @zh
             * 从对象池中创建 requestItem
             *
             * @returns requestItem
             *
             */
            static create(): RequestItem;
            /**
             * @en
             * The uuid of request
             *
             * @zh
             * 请求资源的uuid
             *
             */
            uuid: string;
            overrideUuid: string;
            /**
             * @en
             * The final url of request
             *
             * @zh
             * 请求的最终url
             *
             */
            url: string;
            /**
             * @en
             * The extension name of asset
             *
             * @zh
             * 资源的扩展名
             *
             */
            ext: string;
            /**
             * @en
             * The content of asset
             *
             * @zh
             * 资源的内容
             *
             */
            content: any;
            /**
             * @en
             * The file of asset
             *
             * @zh
             * 资源的文件
             *
             */
            file: any;
            /**
             * @en
             * The information of asset
             *
             * @zh
             * 资源的相关信息
             *
             */
            info: __private._cocos_core_asset_manager_config__IAssetInfo | null;
            config: __private._cocos_core_asset_manager_config__default | null;
            /**
             * @en
             * Whether or not it is native asset
             *
             * @zh
             * 资源是否是原生资源
             *
             */
            isNative: boolean;
            /**
             * @en
             * Custom options
             *
             * @zh
             * 自定义参数
             *
             */
            options: Record<string, any>;
            /**
             * @en
             * Recycle this for reuse
             *
             * @zh
             * 回收 requestItem 用于复用
             *
             */
            recycle(): void;
        }
        /**
         * @en
         * A bundle contains an amount of assets(includes scene), you can load, preload, release asset which is in this bundle
         *
         * @zh
         * 一个包含一定数量资源（包括场景）的包，你可以加载，预加载，释放此包内的资源
         *
         */
        export class Bundle {
            /**
             * for internal use
             * @private
             */
            get config(): __private._cocos_core_asset_manager_config__default;
            /**
             * @en
             * The name of this bundle
             *
             * @zh
             * 此 bundle 的名称
             *
             */
            get name(): string;
            /**
             * @en
             * The dependency of this bundle
             *
             * @zh
             * 此 bundle 的依赖
             *
             */
            get deps(): string[];
            /**
             * @en
             * The root path of this bundle, such like 'http://example.com/bundle1'
             *
             * @zh
             * 此 bundle 的根路径, 例如 'http://example.com/bundle1'
             *
             */
            get base(): string;
            /**
             * @en
             * Get asset's info using path, only valid when asset is in bundle folder.
             *
             * @zh
             * 使用 path 获取资源的配置信息
             *
             * @param path - The relative path of asset, such as 'images/a'
             * @param type - The constructor of asset, such as  `Texture2D`
             * @returns The asset info
             *
             * @example
             * var info = bundle.getInfoWithPath('image/a', Texture2D);
             *
             */
            getInfoWithPath(path: string, type?: __private._cocos_core_asset_manager_shared__AssetType | null): __private._cocos_core_asset_manager_config__IAddressableInfo | null;
            /**
             * @en
             * Get all asset's info within specific folder
             *
             * @zh
             * 获取在某个指定文件夹下的所有资源信息
             *
             * @param path - The relative path of folder, such as 'images'
             * @param type - The constructor should be used to filter paths
             * @param out - The output array
             * @returns Infos
             *
             * @example
             * var infos = [];
             * bundle.getDirWithPath('images', Texture2D, infos);
             */
            getDirWithPath(path: string, type?: __private._cocos_core_asset_manager_shared__AssetType | null, out?: __private._cocos_core_asset_manager_config__IAddressableInfo[]): __private._cocos_core_asset_manager_config__IAddressableInfo[];
            /**
             * @en
             * Get asset's info with uuid
             *
             * @zh
             * 通过 uuid 获取资源信息
             *
             * @method getAssetInfo
             * @param  uuid - The asset's uuid
             * @returns info
             *
             * @example
             * var info = bundle.getAssetInfo('fcmR3XADNLgJ1ByKhqcC5Z');
             *
             */
            getAssetInfo(uuid: string): __private._cocos_core_asset_manager_config__IAssetInfo | null;
            /**
             * @en
             * Get scene'info with name
             *
             * @zh
             * 通过场景名获取场景信息
             *
             * @method getSceneInfo
             * @param name - The name of scene
             * @return info
             *
             * @example
             * var info = bundle.getSceneInfo('first.fire');
             *
             */
            getSceneInfo(name: string): __private._cocos_core_asset_manager_config__ISceneInfo | null;
            /**
             * @en
             * Initialize this bundle with options
             *
             * @zh
             * 初始化此 bundle
             *
             * @param options
             *
             */
            init(options: __private._cocos_core_asset_manager_config__IConfigOption): void;
            /**
             * @en
             * Load the asset within this bundle by the path which is relative to bundle's path
             *
             * @zh
             * 通过相对路径加载分包中的资源。路径是相对分包文件夹路径的相对路径
             *
             * @param paths - Paths of the target assets.The path is relative to the bundle's folder, extensions must be omitted.
             * @param type - Only asset of type will be loaded if this argument is supplied.
             * @param onProgress - Callback invoked when progression change.
             * @param onProgress.finish - The number of the items that are already completed.
             * @param onProgress.total - The total number of the items.
             * @param onProgress.item - The finished request item.
             * @param onComplete - Callback invoked when all assets loaded.
             * @param onComplete.error - The error info or null if loaded successfully.
             * @param onComplete.assets - The loaded assets.
             *
             * @example
             * // load the texture (${project}/assets/resources/textures/background.jpg) from resources
             * resources.load('textures/background', Texture2D, (err, texture) => console.log(err));
             *
             * // load the audio (${project}/assets/resources/music/hit.mp3) from resources
             * resources.load('music/hit', AudioClip, (err, audio) => console.log(err));
             *
             * // load the prefab (${project}/assets/bundle1/misc/character/cocos) from bundle1 folder
             * bundle1.load('misc/character/cocos', Prefab, (err, prefab) => console.log(err));
             *
             * // load the sprite frame (${project}/assets/some/xxx/bundle2/imgs/cocos.png) from bundle2 folder
             * bundle2.load('imgs/cocos', SpriteFrame, null, (err, spriteFrame) => console.log(err));
             *
             */
            load<T extends Asset>(paths: string, type: __private._cocos_core_asset_manager_shared__AssetType<T> | null, onProgress: __private._cocos_core_asset_manager_shared__ProgressCallback | null, onComplete: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<T> | null): void;
            load<T extends Asset>(paths: string[], type: __private._cocos_core_asset_manager_shared__AssetType<T> | null, onProgress: __private._cocos_core_asset_manager_shared__ProgressCallback | null, onComplete: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<T[]> | null): void;
            load<T extends Asset>(paths: string, onProgress: __private._cocos_core_asset_manager_shared__ProgressCallback | null, onComplete: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<T> | null): void;
            load<T extends Asset>(paths: string[], onProgress: __private._cocos_core_asset_manager_shared__ProgressCallback | null, onComplete: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<T[]> | null): void;
            load<T extends Asset>(paths: string, onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<T> | null): void;
            load<T extends Asset>(paths: string[], onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<T[]> | null): void;
            load<T extends Asset>(paths: string, type: __private._cocos_core_asset_manager_shared__AssetType<T> | null, onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<T> | null): void;
            load<T extends Asset>(paths: string[], type: __private._cocos_core_asset_manager_shared__AssetType<T> | null, onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<T[]> | null): void;
            /**
             * @en
             * Preload the asset within this bundle by the path which is relative to bundle's path.
             * After calling this method, you still need to finish loading by calling `Bundle.load`.
             * It will be totally fine to call `Bundle.load` at any time even if the preloading is not
             * yet finished
             *
             * @zh
             * 通过相对路径预加载分包中的资源。路径是相对分包文件夹路径的相对路径。调用完后，你仍然需要通过 `Bundle.load` 来完成加载。
             * 就算预加载还没完成，你也可以直接调用 `Bundle.load`。
             *
             * @param paths - Paths of the target asset.The path is relative to bundle folder, extensions must be omitted.
             * @param type - Only asset of type will be loaded if this argument is supplied.
             * @param onProgress - Callback invoked when progression change.
             * @param onProgress.finish - The number of the items that are already completed.
             * @param onProgress.total - The total number of the items.
             * @param onProgress.item - The finished request item.
             * @param onComplete - Callback invoked when the resource loaded.
             * @param onComplete.error - The error info or null if loaded successfully.
             * @param onComplete.items - The preloaded items.
             *
             * @example
             * // preload the texture (${project}/assets/resources/textures/background.jpg) from resources
             * resources.preload('textures/background', Texture2D);
             *
             * // preload the audio (${project}/assets/resources/music/hit.mp3) from resources
             * resources.preload('music/hit', AudioClip);
             * // wait for while
             * resources.load('music/hit', AudioClip, (err, audioClip) => {});
             *
             * * // preload the prefab (${project}/assets/bundle1/misc/character/cocos) from bundle1 folder
             * bundle1.preload('misc/character/cocos', Prefab);
             *
             * // load the sprite frame of (${project}/assets/bundle2/imgs/cocos.png) from bundle2 folder
             * bundle2.preload('imgs/cocos', SpriteFrame);
             * // wait for while
             * bundle2.load('imgs/cocos', SpriteFrame, (err, spriteFrame) => {});
             *
             */
            preload(paths: string | string[], type: __private._cocos_core_asset_manager_shared__AssetType | null, onProgress: __private._cocos_core_asset_manager_shared__ProgressCallback | null, onComplete: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<RequestItem[]> | null): void;
            preload(paths: string | string[], onProgress: __private._cocos_core_asset_manager_shared__ProgressCallback | null, onComplete: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<RequestItem[]> | null): void;
            preload(paths: string | string[], onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<RequestItem[]> | null): void;
            preload(paths: string | string[], type: __private._cocos_core_asset_manager_shared__AssetType | null, onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<RequestItem[]> | null): void;
            /**
             * @en
             * Load all assets under a folder inside the bundle folder.<br>
             * <br>
             * Note: All asset paths in Creator use forward slashes, paths using backslashes will not work.
             *
             * @zh
             * 加载目标文件夹中的所有资源, 注意：路径中只能使用斜杠，反斜杠将停止工作
             *
             * @param dir - path of the target folder.The path is relative to the bundle folder, extensions must be omitted.
             * @param type - Only asset of type will be loaded if this argument is supplied.
             * @param onProgress - Callback invoked when progression change.
             * @param onProgress.finish - The number of the items that are already completed.
             * @param onProgress.total - The total number of the items.
             * @param onProgress.item - The latest request item
             * @param onComplete - A callback which is called when all assets have been loaded, or an error occurs.
             * @param onComplete.error - If one of the asset failed, the complete callback is immediately called with the error.
             *                           If all assets are loaded successfully, error will be null.
             * @param onComplete.assets - An array of all loaded assets.
             *
             * @example
             * // load all audios (resources/audios/)
             * resources.loadDir('audios', AudioClip, (err, audios) => {});
             *
             * // load all textures in "resources/imgs/"
             * resources.loadDir('imgs', Texture2D, null, function (err, textures) {
             *     var texture1 = textures[0];
             *     var texture2 = textures[1];
             * });
             *
             * // load all prefabs (${project}/assets/bundle1/misc/characters/) from bundle1 folder
             * bundle1.loadDir('misc/characters', Prefab, (err, prefabs) => console.log(err));
             *
             * // load all sprite frame (${project}/assets/some/xxx/bundle2/skills/) from bundle2 folder
             * bundle2.loadDir('skills', SpriteFrame, null, (err, spriteFrames) => console.log(err));
             *
             */
            loadDir<T extends Asset>(dir: string, type: __private._cocos_core_asset_manager_shared__AssetType<T> | null, onProgress: __private._cocos_core_asset_manager_shared__ProgressCallback | null, onComplete: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<T[]> | null): void;
            loadDir<T extends Asset>(dir: string, onProgress: __private._cocos_core_asset_manager_shared__ProgressCallback | null, onComplete: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<T[]> | null): void;
            loadDir<T extends Asset>(dir: string, onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<T[]> | null): void;
            loadDir<T extends Asset>(dir: string, type: __private._cocos_core_asset_manager_shared__AssetType<T> | null, onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<T[]> | null): void;
            /**
             * @en
             * Preload all assets under a folder inside the bundle folder.<br> After calling this method, you still need to
             * finish loading by calling `Bundle.loadDir`.
             * It will be totally fine to call `Bundle.loadDir` at any time even if the preloading is not yet finished
             *
             * @zh
             * 预加载目标文件夹中的所有资源。调用完后，你仍然需要通过 `Bundle.loadDir` 来完成加载。
             * 就算预加载还没完成，你也可以直接调用 `Bundle.loadDir`。
             *
             * @param dir - path of the target folder.The path is relative to the bundle folder, extensions must be omitted.
             * @param type - Only asset of type will be preloaded if this argument is supplied.
             * @param onProgress - Callback invoked when progression change.
             * @param onProgress.finish - The number of the items that are already completed.
             * @param onProgress.total - The total number of the items.
             * @param onProgress.item - The latest request item
             * @param onComplete - A callback which is called when all assets have been loaded, or an error occurs.
             * @param onComplete.error - If one of the asset failed, the complete callback is immediately called with the error.
             *                                   If all assets are preloaded successfully, error will be null.
             * @param onComplete.items - An array of all preloaded items.
             *
             * @example
             * // preload all audios (resources/audios/)
             * resources.preloadDir('audios', AudioClip);
             *
             * // preload all textures in "resources/imgs/"
             * resources.preloadDir('imgs', Texture2D);
             * // wait for while
             * resources.loadDir('imgs', Texture2D, (err, textures) => {});
             *
             * // preload all prefabs (${project}/assets/bundle1/misc/characters/) from bundle1 folder
             * bundle1.preloadDir('misc/characters', Prefab);
             *
             * // preload all sprite frame (${project}/assets/some/xxx/bundle2/skills/) from bundle2 folder
             * bundle2.preloadDir('skills', SpriteFrame);
             * // wait for while
             * bundle2.loadDir('skills', SpriteFrame, (err, spriteFrames) => {});
             */
            preloadDir(dir: string, type: __private._cocos_core_asset_manager_shared__AssetType | null, onProgress: __private._cocos_core_asset_manager_shared__ProgressCallback | null, onComplete: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<RequestItem[]> | null): void;
            preloadDir(dir: string, onProgress: __private._cocos_core_asset_manager_shared__ProgressCallback | null, onComplete: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<RequestItem[]> | null): void;
            preloadDir(dir: string, onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<RequestItem[]> | null): void;
            preloadDir(dir: string, type: __private._cocos_core_asset_manager_shared__AssetType | null, onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<RequestItem[]> | null): void;
            /**
             * @en
             * Loads the scene asset within this bundle by its name.
             *
             * @zh
             * 通过场景名称加载分包中的场景资源。
             *
             * @param sceneName - The name of the scene to load.
             * @param options - Some optional parameters
             * @param onProgress - Callback invoked when progression change.
             * @param onProgress.finish - The number of the items that are already completed.
             * @param onProgress.total - The total number of the items.
             * @param onProgress.item - The latest request item
             * @param onComplete - callback, will be called after scene launched.
             * @param onComplete.err - The occurred error, null indicetes success
             * @param onComplete.sceneAsset - The scene asset
             *
             * @example
             * bundle1.loadScene('first', (err, sceneAsset) => director.runScene(sceneAsset));
             *
             */
            loadScene(sceneName: string, options: __private._cocos_core_asset_manager_shared__IAssetOptions | null, onProgress: __private._cocos_core_asset_manager_shared__ProgressCallback | null, onComplete: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<SceneAsset> | null): void;
            loadScene(sceneName: string, onProgress: __private._cocos_core_asset_manager_shared__ProgressCallback | null, onComplete: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<SceneAsset> | null): void;
            loadScene(sceneName: string, options: __private._cocos_core_asset_manager_shared__IAssetOptions | null, onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<SceneAsset> | null): void;
            loadScene(sceneName: string, onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackWithData<SceneAsset> | null): void;
            /**
             * @en
             * Preload the scene asset within this bundle by its name. After calling this method, you still need to finish loading
             * by calling `Bundle.loadScene` or `director.loadScene`.It will be totally fine to call `Bundle.loadDir` at any
             * time even if the preloading is not yet finished
             *
             * @zh
             * 通过场景名称预加载分包中的场景资源.调用完后，你仍然需要通过 `Bundle.loadScene` 或 `director.loadScene` 来完成加载。
             * 就算预加载还没完成，你也可以直接调用 `Bundle.loadScene` 或 `director.loadScene`。
             *
             * @param sceneName - The name of the scene to preload.
             * @param options - Some optional parameters
             * @param onProgress - callback, will be called when the load progression change.
             * @param onProgress.finish - The number of the items that are already completed
             * @param onProgress.total - The total number of the items
             * @param onProgress.item The latest request item
             * @param onComplete - callback, will be called after scene loaded.
             * @param onComplete.error - null or the error object.
             *
             * @example
             * bundle1.preloadScene('first');
             * // wait for a while
             * bundle1.loadScene('first', (err, scene) => director.runScene(scene));
             *
             */
            preloadScene(sceneName: string, options: __private._cocos_core_asset_manager_shared__IAssetOptions | null, onProgress: __private._cocos_core_asset_manager_shared__ProgressCallback, onComplete: __private._cocos_core_asset_manager_shared__CompleteCallbackNoData | null): void;
            preloadScene(sceneName: string, onProgress: __private._cocos_core_asset_manager_shared__ProgressCallback | null, onComplete: __private._cocos_core_asset_manager_shared__CompleteCallbackNoData | null): void;
            preloadScene(sceneName: string, options: __private._cocos_core_asset_manager_shared__IAssetOptions | null, onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackNoData | null): void;
            preloadScene(sceneName: string, onComplete?: __private._cocos_core_asset_manager_shared__CompleteCallbackNoData | null): void;
            /**
             * @en
             * Get cached asset within this bundle by path and type. <br>
             * After you load asset with [[load]] or [[loadDir]],
             * you can acquire them by passing the path to this API.
             *
             * NOTE：The `path` and `type` parameters passed need to be the same as those passed to `Bundle.load`,
             * otherwise it may return some other resources with the same name!
             *
             * @zh
             * 通过路径与类型获取已缓存资源。在你使用 [[load]] 或者 [[loadDir]] 之后，
             * 你能通过传路径通过这个 API 获取到这些资源。
             *
             * 注意：传入的 path 与 type 参数需要与 `Bundle.load` 加载资源时传入的参数一致，否则可能会获取到其他同名资源
             *
             * @param path - The path of asset
             * @param type - Only asset of type will be returned if this argument is supplied.
             * @returns - the asset has been cached
             *
             * @example
             * bundle1.get('music/hit', AudioClip);
             */
            get<T extends Asset>(path: string, type?: __private._cocos_core_asset_manager_shared__AssetType<T> | null): T | null;
            /**
             * @en
             * Release the asset loaded by [[load]] or [[loadDir]]
             * and it's dependencies. Refer to [[AssetManager.releaseAsset]] for detailed informations.
             *
             * NOTE：The `path` and `type` parameters passed need to be the same as those passed to `Bundle.load`,
             * otherwise it may release some other resources with the same name!
             *
             * @zh
             * 释放通过 [[load]] 或者 [[loadDir]] 加载的资源。
             * 详细信息请参考 [[AssetManager.releaseAsset]]
             *
             * 注意：传入的 path 与 type 参数需要与 `Bundle.load` 加载资源时传入的参数一致，否则可能会释放到其他同名资源
             *
             * @param path - The path of asset
             * @param type - Only asset of type will be released if this argument is supplied.
             *
             * @example
             * // release a texture which is no longer need
             * bundle1.release('misc/character/cocos');
             *
             */
            release(path: string, type?: __private._cocos_core_asset_manager_shared__AssetType | null): void;
            /**
             * @en
             * Release all unused assets within this bundle. Refer to [[AssetManager.releaseAll]] for detailed informations.
             *
             * @zh
             * 释放此包中的所有没有用到的资源。详细信息请参考 [[AssetManager.releaseAll]]
             *
             * @private
             *
             * @example
             * // release all unused asset within bundle1
             * bundle1.releaseUnusedAssets();
             *
             */
            releaseUnusedAssets(): void;
            /**
             * @en
             * Release all assets within this bundle. Refer to [[AssetManager.releaseAll]] for detailed information.
             *
             * @zh
             * 释放此包中的所有资源。详细信息请参考 [[AssetManager.releaseAll]]
             *
             * @example
             * // release all asset within bundle1
             * bundle1.releaseAll();
             */
            releaseAll(): void;
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _destroy(): void;
        }
        /**
         * @en
         * The builtin bundles
         *
         * @zh
         * 内置 bundle
         *
         */
        export enum BuiltinBundleName {
            /**
             * @en
             * The builtin bundle of default asset
             *
             * @zh
             * 内置 bundle, 对应默认资源
             */
            INTERNAL = "internal",
            /**
             * @en
             * The builtin bundle corresponds to 'assets/resources'.
             *
             * @zh
             * 内置 bundle, 对应 'assets/resources' 目录
             *
             */
            RESOURCES = "resources",
            /**
             * @en
             * The builtin bundle
             *
             * @zh
             * 内置 bundle
             *
             */
            MAIN = "main",
            /**
             * @en
             * The builtin bundle, exists when Start Scene asset bundle is checked on the project building panel
             *
             * @zh
             * 内置 bundle, 如果构建面板开启了首场景分包，则会有 START_SCENE bundle
             *
             */
            START_SCENE = "start-scene"
        }
    }
    /**
     * @en
     * resources is a bundle and controls all asset under assets/resources
     *
     * @zh
     * resources 是一个 bundle，用于管理所有在 assets/resources 下的资源
     */
    export const resources: AssetManager.Bundle;
    /**
     * @en Loader for resource loading process. The engine automatically initialize its singleton object [[loader]].
     * @zh 资源加载管理器，引擎会自动创建一个单例对象 [[loader]]。
     *
     * @class loader
     * @static
     * @deprecated since v3.0 loader is deprecated, please backup your project and upgrade to assetManager
     */
    export class CCLoader {
        /**
         * @en The default progression callback during the loading process,
         * if no progression callback is passed to [[load]] function, then this default callback will be used.
         * @zh Loader 默认的进度回调函数，如果在调用 [[load]] 函数时没有指定进度回调函数的话，会调用默认进度回调函数。
         *
         * @deprecated since v3.0, loader.onProgress is deprecated, please transfer onProgress to API as a parameter
         */
        set onProgress(val: __private._cocos_core_asset_manager_shared__ProgressCallback);
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _autoReleaseSetting: Record<string, boolean>;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        get _cache(): Record<string, Asset>;
        /**
         * @en
         * Load resources with a progression callback and a complete callback.<br>
         *
         * @zh
         * 使用进度回调和完整回调加载资源。<br>
         *
         * @example
         * ```TypeScript
         * loader.load('a.png', function (err, tex) {
         *     log('Result should be a texture: ' + (tex instanceof Texture2D));
         * });
         *
         * loader.load('http://example.com/a.png', function (err, tex) {
         *     log('Should load a texture from external url: ' + (tex instanceof Texture2D));
         * });
         *
         * loader.load({url: 'http://example.com/getImageREST?file=a.png', type: 'png'}, function (err, tex) {
         *     log('Should load a texture from RESTful API by specify the type: ' + (tex instanceof Texture2D));
         * });
         * ```
         *
         * @param res - Url list in an array
         * @param progressCallback - Callback invoked when progression change
         * @param {Number} progressCallback.completedCount - The number of the items that are already completed
         * @param {Number} progressCallback.totalCount - The total number of the items
         * @param {Object} progressCallback.item - The latest item which flow out the pipeline
         * @param completeCallback - Callback invoked when all resources loaded
         * @deprecated since v3.0, loader.load is deprecated, please use assetManager.loadRemote instead
         */
        load(res: string | string[] | Record<string, any>, progressCallback?: ((...args: any[]) => void) | null, completeCallback?: ((...args: any[]) => void) | null): void;
        /**
         * @en Gets a new XMLHttpRequest instance.
         * @zh 获取一个新的 XMLHttpRequest 的实例。
         *
         * @deprecated since v3.0 loader.getXMLHttpRequest is deprecated, please use XMLHttpRequest directly
         */
        getXMLHttpRequest(): XMLHttpRequest;
        /**
         * @en Returns an item in pipeline.
         * @zh 根据 id 获取一个 item
         * @param id The id of the item
         *
         * @return {Object}
         * @deprecated since v3.0 loader.getItem is deprecated, please use assetManager.assets.get instead
         */
        getItem(id: any): {
            content: Asset | null | undefined;
        } | null;
        /**
         * @en
         * Load assets from the "resources" folder inside the "assets" folder of your project.<br>
         * <br>
         * Note: All asset URLs in Creator use forward slashes, URLs using backslashes will not work.
         * @zh
         * 从项目的 “assets” 文件夹下的 “resources” 文件夹中加载资源<br>
         * <br>
         * 注意：Creator 中的所有资源 URL 都使用正斜杠，使用反斜杠的 URL 将不起作用。
         *
         * @deprecated since v3.0 loader.loadRes is deprecated, please use resources.load  instead
         * @param url - Url of the target resource.
         *                       The url is relative to the "resources" folder, extensions must be omitted.
         * @param type - Only asset of type will be loaded if this argument is supplied.
         * @param progressCallback - Callback invoked when progression change.
         * @param {Number} progressCallback.completedCount - The number of the items that are already completed.
         * @param {Number} progressCallback.totalCount - The total number of the items.
         * @param {Object} progressCallback.item - The latest item which flow out the pipeline.
         * @param completeCallback - Callback invoked when the resource loaded.
         * @param {Error} completeCallback.error - The error info or null if loaded successfully.
         * @param {Object} completeCallback.resource - The loaded resource if it can be found otherwise returns null.
         * @example
         * ```typescript
         * // load the prefab (project/assets/resources/misc/character/cocos) from resources folder
         * loader.loadRes('misc/character/cocos', function (err, prefab) {
         *     if (err) {
         *         error(err.message || err);
         *         return;
         *     }
         *     log('Result should be a prefab: ' + (prefab instanceof Prefab));
         * });
         *
         * // load the sprite frame of (project/assets/resources/imgs/cocos.png) from resources folder
         * loader.loadRes('imgs/cocos', SpriteFrame, function (err, spriteFrame) {
         *     if (err) {
         *         error(err.message || err);
         *         return;
         *     }
         *     log('Result should be a sprite frame: ' + (spriteFrame instanceof SpriteFrame));
         * });
         *
         */
        loadRes<T extends Asset>(url: string, type: __private._types_globals__Constructor<T>, progressCallback: __private._cocos_core_asset_manager_deprecated__LoadProgressCallback, completeCallback: __private._cocos_core_asset_manager_deprecated__LoadCompleteCallback<T>): any;
        loadRes<T extends Asset>(url: string, type: __private._types_globals__Constructor<T>, completeCallback: __private._cocos_core_asset_manager_deprecated__LoadCompleteCallback<T>): any;
        loadRes<T extends Asset>(url: string, progressCallback: __private._cocos_core_asset_manager_deprecated__LoadProgressCallback, completeCallback: __private._cocos_core_asset_manager_deprecated__LoadCompleteCallback<T>): any;
        loadRes<T extends Asset>(url: string, completeCallback: __private._cocos_core_asset_manager_deprecated__LoadCompleteCallback<T>): any;
        /**
         * @en This method is like [[loadRes]] except that it accepts array of url.
         * @zh 此方法除了接受 URL 数组参数外，与 [[loadRes]] 方法相同。
         *
         * @deprecated since v3.0 loader.loadResArray is deprecated, please use resources.load instead
         * @param urls - Array of URLs of the target resource.
         *                          The url is relative to the "resources" folder, extensions must be omitted.
         * @param type - Only asset of type will be loaded if this argument is supplied.
         * @param progressCallback - Callback invoked when progression change.
         * @param {Number} progressCallback.completedCount - The number of the items that are already completed.
         * @param {Number} progressCallback.totalCount - The total number of the items.
         * @param {Object} progressCallback.item - The latest item which flow out the pipeline.
         * @param completeCallback - A callback which is called when all assets have been loaded, or an error occurs.
         * @param {Error} completeCallback.error - If one of the asset failed, the complete callback is immediately called
         *                                         with the error. If all assets are loaded successfully, error will be null.
         * @param {Asset[]|Array} completeCallback.assets - An array of all loaded assets.
         *                                                     If nothing to load, assets will be an empty array.
         * @example
         * ```typescript
         * // load the SpriteFrames from resources folder
         * let spriteFrames;
         * let urls = ['misc/characters/character_01', 'misc/weapons/weapons_01'];
         * loader.loadResArray(urls, SpriteFrame, function (err, assets) {
         *     if (err) {
         *         error(err);
         *         return;
         *     }
         *     spriteFrames = assets;
         *     // ...
         * });
         * ```
         */
        loadResArray<T extends Asset>(urls: string[], type?: __private._types_globals__Constructor<T>, progressCallback?: __private._cocos_core_asset_manager_deprecated__LoadProgressCallback, completeCallback?: __private._cocos_core_asset_manager_deprecated__LoadCompleteCallback<T[]>): void;
        /**
         * @en
         * Load all assets in a folder inside the "assets/resources" folder of your project.<br>
         * <br>
         * Note: All asset URLs in Creator use forward slashes, URLs using backslashes will not work.
         * @zh
         * 将所有资产加载到项目 “assets / resources” 文件夹中
         * <br>
         * 注意：Creator 中的所有资源 URL 都使用正斜杠，使用反斜杠的 URL 将不起作用。
         *
         * @deprecated since v3.0 loader.loadResDir is deprecated, please use resources.loadDir instead
         * @param url - Url of the target folder.
         *                       The url is relative to the "resources" folder, extensions must be omitted.
         * @param type - Only asset of type will be loaded if this argument is supplied.
         * @param progressCallback - Callback invoked when progression change.
         * @param {Number} progressCallback.completedCount - The number of the items that are already completed.
         * @param {Number} progressCallback.totalCount - The total number of the items.
         * @param {Object} progressCallback.item - The latest item which flow out the pipeline.
         * @param completeCallback - A callback which is called when all assets have been loaded, or an error occurs.
         * @param {Error} completeCallback.error - If one of the asset failed, the complete callback is immediately called
         *                                         with the error. If all assets are loaded successfully, error will be null.
         * @param {Asset[]} completeCallback.assets - An array of all loaded assets.
         *                                             If nothing to load, assets will be an empty array.
         * @param {String[]} completeCallback.urls - An array that lists all the URLs of loaded assets.
         * ```typescript
         * // load the texture (resources/imgs/cocos.png) and the corresponding sprite frame
         * loader.loadResDir('imgs/cocos', function (err, assets) {
         *     if (err) {
         *         error(err);
         *         return;
         *     }
         *     let texture = assets[0];
         *     let spriteFrame = assets[1];
         * });
         *
         * // load all textures in "resources/imgs/"
         * loader.loadResDir('imgs', Texture2D, function (err, textures) {
         *     let texture1 = textures[0];
         *     let texture2 = textures[1];
         * });
         *
         * // load all JSONs in "resources/data/"
         * loader.loadResDir('data', function (err, objects, urls) {
         *     let data = objects[0];
         *     let url = urls[0];
         * });
         * ```
         */
        loadResDir<T extends Asset>(url: string, type: __private._types_globals__Constructor<T>, progressCallback: __private._cocos_core_asset_manager_deprecated__LoadProgressCallback, completeCallback: __private._cocos_core_asset_manager_deprecated__LoadDirCompleteCallback<T>): any;
        loadResDir<T extends Asset>(url: string, type: __private._types_globals__Constructor<T>, completeCallback: __private._cocos_core_asset_manager_deprecated__LoadDirCompleteCallback<T>): any;
        loadResDir<T extends Asset>(url: string, progressCallback: __private._cocos_core_asset_manager_deprecated__LoadProgressCallback, completeCallback: __private._cocos_core_asset_manager_deprecated__LoadDirCompleteCallback<T>): any;
        loadResDir<T extends Asset>(url: string, completeCallback: __private._cocos_core_asset_manager_deprecated__LoadDirCompleteCallback<T>): any;
        /**
         * @en
         * Get resource data by id. <br>
         * When you load resources with [[load]] or [[loadRes]],
         * the url will be the unique identity of the resource.
         * After loaded, you can acquire them by passing the url to this API.
         * @zh
         * 根据 ID 获取资源数据。<br>
         * 当使用 [[load]] 或 [[loadRes]] 来加载资源时，<br>
         * URL 将是资源的唯一标识。<br>
         * 在完成加载之后，你可以通过将 URL 传递给此 API 来获取它们。
         *
         * @param url
         * @param type - Only asset of type will be returned if this argument is supplied.
         * @deprecated since v3.0 loader.getRes is deprecated, please use resources.get instead
         */
        getRes<T extends Asset>(url: string, type?: __private._types_globals__Constructor<T>): T | null;
        /**
         * @en Get total resources count in loader.
         * @zh 获取加载的总资源数量
         * @deprecated since v3.0 loader.getResCount is deprecated, please use assetManager.assets.count instead
         */
        getResCount(): number;
        /**
         * @en
         * Get all resource dependencies of the requested asset in an array, including itself.<br>
         * The owner parameter accept the following types: 1. The asset itself; 2. The resource url; 3. The asset's uuid.<br>
         * The returned array stores the dependencies with their uuids, after retrieve dependencies,<br>
         * you can release them, access dependent assets by passing the uuid to [[getRes]], or other stuffs you want.<br>
         * For release all dependencies of an asset, please refer to [[release]]
         * Here is some examples:
         * @zh
         * 获取一个指定资源的所有依赖资源，包含它自身，并保存在数组中返回。<br>
         * owner 参数接收以下几种类型：1. 资源 asset 对象；2. 资源目录下的 url；3. 资源的 uuid。<br>
         * 返回的数组将仅保存依赖资源的 uuid，获取这些 uuid 后，你可以从 loader 释放这些资源；通过 [[getRes]] 获取某个资源或者进行其他你需要的操作。<br>
         * 想要释放一个资源及其依赖资源，可以参考 [[release]]。<br>
         * 下面是一些示例代码：
         * @example
         * ```typescript
         * // Release all dependencies of a loaded prefab
         * let deps = loader.getDependsRecursively(prefab);
         * loader.release(deps);
         * // Retrieve all dependent textures
         * let deps = loader.getDependsRecursively('prefabs/sample');
         * let textures = [];
         * for (let i = 0; i < deps.length; ++i) {
         *     let item = loader.getRes(deps[i]);
         *     if (item instanceof Texture2D) {
         *         textures.push(item);
         *     }
         * }
         * ```
         *
         * @deprecated since v3.0 loader.getDependsRecursively is deprecated, please use use assetManager.dependUtil.getDepsRecursively instead
         * @param owner - The owner asset or the resource url or the asset's uuid
         * @returns the dependencies list
         */
        getDependsRecursively(owner: Asset | string): string[];
        /**
         * @en The md5 pipe in loader's pipeline, it could be absent if the project isn't build with md5 option.<br>
         * It's used to modify the url to the real downloadable url with md5 suffix.
         * @zh loader 中的 md5 加载管道，如果项目没有使用 md5 构建，则此项可能不存在。<br>
         * 用于修改带有 md5 后缀的真实可下载的 URL 。
         *
         * @deprecated since v3.0 loader.md5Pipe is deprecated, assetLoader and md5Pipe were merged into assetManager.transformPipeline
         */
        get md5Pipe(): {
            transformURL(url: string): string;
        };
        /**
         * @en
         * The downloader in loader's pipeline, it's by default the second pipe.<br>
         * It's used to download files with several handlers: pure text, image, script, audio, font, uuid.<br>
         * You can add your own download function with addDownloadHandlers
         * @zh
         * loader 中的资源下载程序，默认情况下是第二个加载的。<br>
         * 它用于下载带有多个处理程序的文件：纯文本，图像，脚本，音频，字体，uuid。<br>
         * 您可以使用 addDownloadHandlers 来添加自己的下载函数
         *
         * @deprecated since v3.0 loader.downloader is deprecated, please use assetManager.downloader instead
         */
        get downloader(): __private._cocos_core_asset_manager_downloader__Downloader;
        /**
         * @en
         * The loader in loader's pipeline, it's by default the third pipe.<br>
         * It's used to parse downloaded content with several handlers: JSON, image, plist, fnt, uuid.<br>
         * You can add your own download function with addLoadHandlers
         * @zh
         * loader 中的资源下载程序，默认情况下是第三个加载的。<br>
         * 它用于解析下载的内容及多个处理程序的文件：纯文本，图像，脚本，音频，字体，uuid。<br>
         * 您可以使用 addLoadHandlers 来添加自己的下载函数
         *
         * @deprecated since v3.0 loader.loader is deprecated, please use assetManager.parser instead
         */
        get loader(): __private._cocos_core_asset_manager_parser__Parser;
        /**
         * @en Add custom supported types handler or modify existing type handler for download process.
         * @zh 为下载程序添加自定义支持的类型处理程序或修改现有的类型处理程序。
         * @example
         * ```typescript
         *  loader.addDownloadHandlers({
         *      // This will match all url with `.scene` extension or all url with `scene` type
         *      'scene' : function (url, callback) {}
         *  });
         * ```
         * @param extMap Handlers for corresponding type in a map
         * @deprecated since v3.0 loader.addDownloadHandlers is deprecated, please use assetManager.downloader.register instead
         */
        addDownloadHandlers(extMap: Record<string, (item: {
            url: string;
        }, cb: __private._cocos_core_asset_manager_shared__CompleteCallback) => void>): void;
        /**
         * @en Add custom supported types handler or modify existing type handler for load process.
         * @zh 为加载程序添加自定义支持的类型处理程序或修改现有的类型处理程序。
         * @example
         * ```typescript
         *  loader.addLoadHandlers({
         *      // This will match all url with `.scene` extension or all url with `scene` type
         *      'scene' : function (url, callback) {}
         *  });
         * ```
         * @param extMap Handlers for corresponding type in a map
         * @deprecated since v3.0 loader.addLoadHandlers is deprecated, please use assetManager.parser.register instead
         */
        addLoadHandlers(extMap: Record<string, ({ content }: {
            content: any;
        }, cb: __private._cocos_core_asset_manager_shared__CompleteCallback) => void>): void;
        /**
         * @en
         * Release the content of an asset or an array of assets by uuid.<br>
         * This method will not only remove the cache of the asset in loader, but also clean up its content.<br>
         * For example, if you release a texture, the texture asset and its gl texture data will be freed up.<br>
         * In complex project, you can use this function with [[getDependsRecursively]] to free up memory in critical circumstances.<br>
         * Notice, this method may cause the texture to be unusable, if there are still other nodes use the same texture, they may turn to black
         * and report gl errors.<br>
         * @zh
         * 通过 id（通常是资源 url）来释放一个资源或者一个资源数组。<br>
         * 这个方法不仅会从 loader 中删除资源的缓存引用，还会清理它的资源内容。<br>
         * 比如说，当你释放一个 texture 资源，这个 texture 和它的 gl 贴图数据都会被释放。<br>
         * 在复杂项目中，我们建议你结合 [[getDependsRecursively]] 来使用，便于在设备内存告急的情况下更快地释放不再需要的资源的内存。<br>
         * 注意，这个函数可能会导致资源贴图或资源所依赖的贴图不可用，如果场景中存在节点仍然依赖同样的贴图，它们可能会变黑并报 GL 错误。<br>
         *
         * @example
         * ```typescript
         * // Release a texture which is no longer need
         * loader.release(texture);
         * // Release all dependencies of a loaded prefab
         * let deps = loader.getDependsRecursively('prefabs/sample');
         * loader.release(deps);
         * // If there is no instance of this prefab in the scene, the prefab and its dependencies like textures, sprite frames, etc, will be freed up.
         * // If you have some other nodes share a texture in this prefab, you can skip it in two ways:
         * // 1. Forbid auto release a texture before release
         * loader.setAutoRelease(texture2d, false);
         * // 2. Remove it from the dependencies array
         * let deps = loader.getDependsRecursively('prefabs/sample');
         * let index = deps.indexOf(texture2d._uuid);
         * if (index !== -1)
         *     deps.splice(index, 1);
         * loader.release(deps);
         * ```
         * @param asset Asset or assets to be released
         * @deprecated since v3.0 loader.release is deprecated, please use assetManager.releaseAsset instead
         */
        release(asset: Asset | string | Array<Asset | string>): void;
        /**
         * @en Release the asset by its object. Refer to [[release]] for detailed informations.
         * @zh 通过资源对象自身来释放资源。详细信息请参考 [[release]]
         * @param asset The asset to be released
         *
         * @deprecated since v3.0 loader.releaseAsset is deprecated, please use assetManager.releaseAsset instead
         */
        releaseAsset(asset: Asset): void;
        /**
         * @en Release the asset loaded by [[loadRes]]. Refer to [[release]] for detailed informations.
         * @zh 释放通过 [[loadRes]] 加载的资源。详细信息请参考 [[release]]
         * @param res The asset url, it should be related path without extension to the `resources` folder.
         * @param type If type is provided, the asset for correspond type will be returned
         *
         * @deprecated since v3.0 loader.releaseRes is deprecated, please use assetManager.releaseRes instead
         */
        releaseRes(res: string, type?: __private._types_globals__Constructor<Asset>): void;
        /**
         *
         * @en Resource all assets. Refer to [[release]] for detailed informations.
         * @zh 释放所有资源。详细信息请参考 [[release]]
         *
         * @deprecated since v3.0 loader.releaseAll is deprecated, please use assetManager.releaseAll instead
         */
        releaseAll(): void;
        /**
         * @en Removes an completed item in pipeline.
         * It will only remove the cache in the pipeline or loader, its dependencies won't be released.
         * loader provided another method to completely cleanup the resource and its dependencies,
         * please refer to [[release]]
         * @zh 移除指定的已完成 item。
         * 这将仅仅从 pipeline 或者 loader 中删除其缓存，并不会释放它所依赖的资源。
         * loader 中提供了另一种删除资源及其依赖的清理方法，请参考 [[release]]
         * @param id The id of the item
         * @return succeed or not
         *
         * @deprecated since 3.0, loader.removeItem is deprecated, please use assetManager.assets.remove instead
         */
        removeItem(id: any): boolean;
        /**
         * @en
         * Indicates whether to release the asset when loading a new scene.<br>
         * By default, when loading a new scene, all assets in the previous scene will be released or preserved<br>
         * according to whether the previous scene checked the "Auto Release Assets" option.<br>
         * On the other hand, assets dynamically loaded by using `loader.loadRes` or `loader.loadResDir`<br>
         * will not be affected by that option, remain not released by default.<br>
         * Use this API to change the default behavior on a single asset, to force preserve or release specified asset when scene switching.<br>
         * <br>
         * See: [[setAutoReleaseRecursively]], [[isAutoRelease]]
         * @zh
         * 设置当场景切换时是否自动释放资源。<br>
         * 默认情况下，当加载新场景时，旧场景的资源根据旧场景是否勾选“Auto Release Assets”，将会被释放或者保留。<br>
         * 而使用 `loader.loadRes` 或 `loader.loadResDir` 动态加载的资源，则不受场景设置的影响，默认不自动释放。<br>
         * 使用这个 API 可以在单个资源上改变这个默认行为，强制在切换场景时保留或者释放指定资源。<br>
         * <br>
         * 参考：[[setAutoReleaseRecursively]]，[[isAutoRelease]]
         *
         * @example
         * ```typescript
         * // auto release the texture event if "Auto Release Assets" disabled in current scene
         * loader.setAutoRelease(texture2d, true);
         * // don't release the texture even if "Auto Release Assets" enabled in current scene
         * loader.setAutoRelease(texture2d, false);
         * // first parameter can be url
         * loader.setAutoRelease(audioUrl, false);
         * ```
         * @param asset - The asset or its url or its uuid
         * @param autoRelease - Whether to release automatically during scene switch
         *
         * @deprecated since v3.0 loader.setAutoRelease is deprecated, if you want to prevent some asset from auto releasing, please use Asset.addRef instead
         */
        setAutoRelease(asset: Asset | string, autoRelease: boolean): void;
        /**
         * @en
         * Indicates whether to release the asset and its referenced other assets when loading a new scene.<br>
         * By default, when loading a new scene, all assets in the previous scene will be released or preserved<br>
         * according to whether the previous scene checked the "Auto Release Assets" option.<br>
         * On the other hand, assets dynamically loaded by using `loader.loadRes` or `loader.loadResDir`<br>
         * will not be affected by that option, remain not released by default.<br>
         * Use this API to change the default behavior on the specified asset and its recursively referenced assets,
         * to force preserve or release specified asset when scene switching.<br>
         * <br>
         * See: [[setAutoRelease]], [[isAutoRelease]]
         * @zh
         * 设置当场景切换时是否自动释放资源及资源引用的其它资源。<br>
         * 默认情况下，当加载新场景时，旧场景的资源根据旧场景是否勾选“Auto Release Assets”，将会被释放或者保留。<br>
         * 而使用 `loader.loadRes` 或 `loader.loadResDir` 动态加载的资源，则不受场景设置的影响，默认不自动释放。<br>
         * 使用这个 API 可以在指定资源及资源递归引用到的所有资源上改变这个默认行为，强制在切换场景时保留或者释放指定资源。<br>
         * <br>
         * 参考：[[setAutoRelease]]，[[isAutoRelease]]
         *
         * @example
         * ```typescript
         * // auto release the SpriteFrame and its Texture event if "Auto Release Assets" disabled in current scene
         * loader.setAutoReleaseRecursively(spriteFrame, true);
         * // don't release the SpriteFrame and its Texture even if "Auto Release Assets" enabled in current scene
         * loader.setAutoReleaseRecursively(spriteFrame, false);
         * // don't release the Prefab and all the referenced assets
         * loader.setAutoReleaseRecursively(prefab, false);
         * ```
         * @param asset - The asset or its url or its uuid
         * @param autoRelease - Whether to release automatically during scene switch
         * @deprecated loader.setAutoReleaseRecursively is deprecated, if you want to prevent some asset from auto releasing, please use Asset.addRef instead
         */
        setAutoReleaseRecursively(asset: Asset | string, autoRelease: boolean): void;
        /**
         * @en Returns whether the asset is configured as auto released, despite how "Auto Release Assets" property is set on scene asset.<br>
         * <br>
         * See: [[setAutoRelease]], [[setAutoReleaseRecursively]]
         * @zh 返回指定的资源是否有被设置为自动释放，不论场景的“Auto Release Assets”如何设置。<br>
         * <br>
         * 参考：[[setAutoRelease]]，[[setAutoReleaseRecursively]]
         *
         * @method isAutoRelease
         * @param {Asset|String} asset - asset object or the raw asset's url
         * @returns {Boolean}
         * @deprecated loader.isAutoRelease is deprecated
         */
        isAutoRelease(asset: Asset | string): boolean;
    }
    /**
     * @deprecated since 3.0, loader is deprecated, please use assetManager instead
     */
    export const loader: CCLoader;
    /**
     * @en
     * Used to load/unload resources in the project
     * @zh
     * 管理项目中加载/卸载资源的资源库。
     *
     * @deprecated since v3.0 AssetLibrary is deprecated, please backup your project and upgrade to assetManager
     */
    export const AssetLibrary: {
        /**
         * @en
         * init the asset library
         * @zh
         * 初始化 AssetLibrary。
         * @method init
         * @param {Object} options
         * @param {String} options.libraryPath - 能接收的任意类型的路径，通常在编辑器里使用绝对的，在网页里使用相对的。
         * @param {Object} options.mountPaths - mount point of actual urls for raw assets (only used in editor)
         * @param {Object} [options.rawAssets] - uuid to raw asset's urls (only used in runtime)
         * @param {String} [options.rawAssetsBase] - base of raw asset's urls (only used in runtime)
         * @param {String} [options.packedAssets] - packed assets (only used in runtime)
         * @deprecated AssetLibrary.init is deprecated, please use assetManager.init instead
         */
        init(options: Record<string, any>): void;
        /**
         * @zh
         * 加载资源。
         * @param {String} uuid
         * @param {loadCallback} callback - @en Callback function to be executed after loading asset. @zh 加载完成后执行的回调函数。
         * @param {Object} options
         * @param {Boolean} options.readMainCache - 默认为true。如果为false，则资源及其所有依赖资源将重新加载并从库中创建新实例。
         * @param {Boolean} options.writeMainCache - 默认为true。如果为true，则结果将缓存到 AssetLibrary，并且必须由用户手动卸载。
         * @param {Asset} options.existingAsset - 加载现有资源，此参数仅在编辑器中可用。
         * @deprecated since v3.0 AssetLibrary.loadAsset is deprecated, please use assetManager.loadAny instead
         */
        loadAsset(uuid: string, callback: __private._cocos_core_asset_manager_shared__CompleteCallback, options?: any): void;
    };
    /**
     *
     * @class url
     * @static
     *
     * @deprecated since v3.0 url is deprecated
     */
    export const url: {};
    /**
     * @en The base class for [[Node]], it:
     * - maintains scene hierarchy and life cycle logic
     * - provides EventTarget ability
     * - emits events if some properties changed, ref: [[Node.EventType]]
     * - manages components
     * @zh [[Node]] 的基类，他会负责：
     * - 维护场景树以及节点生命周期管理
     * - 提供 EventTarget 的事件管理和注册能力
     * - 派发节点状态相关的事件，参考：[[Node.EventType]]
     * - 管理组件
     */
    export class BaseNode extends CCObject implements ISchedulable {
        /**
         * @en Gets all components attached to this node.
         * @zh 获取附加到此节点的所有组件。
         */
        get components(): ReadonlyArray<Component>;
        /**
         * @en If true, the node is an persist node which won't be destroyed during scene transition.
         * If false, the node will be destroyed automatically when loading a new scene. Default is false.
         * @zh 如果为true，则该节点是一个常驻节点，不会在场景转换期间被销毁。
         * 如果为false，节点将在加载新场景时自动销毁。默认为 false。
         * @default false
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        get _persistNode(): boolean;
        set _persistNode(value: boolean);
        /**
         * @en Name of node.
         * @zh 该节点名称。
         */
        get name(): string;
        set name(value: string);
        /**
         * @en The uuid for editor, will be stripped after building project.
         * @zh 主要用于编辑器的 uuid，在编辑器下可用于持久化存储，在项目构建之后将变成自增的 id。
         * @readOnly
         */
        get uuid(): string;
        /**
         * @en All children nodes.
         * @zh 节点的所有子节点。
         * @readOnly
         */
        get children(): ReadonlyArray<Node>;
        /**
         * @en
         * The local active state of this node.
         * Note that a Node may be inactive because a parent is not active, even if this returns true.
         * Use [[activeInHierarchy]]
         * if you want to check if the Node is actually treated as active in the scene.
         * @zh
         * 当前节点的自身激活状态。
         * 值得注意的是，一个节点的父节点如果不被激活，那么即使它自身设为激活，它仍然无法激活。
         * 如果你想检查节点在场景中实际的激活状态可以使用 [[activeInHierarchy]]
         * @default true
         */
        get active(): boolean;
        set active(isActive: boolean);
        /**
         * @en Indicates whether this node is active in the scene.
         * @zh 表示此节点是否在场景中激活。
         */
        get activeInHierarchy(): boolean;
        /**
         * @en The parent node
         * @zh 父节点
         */
        get parent(): this | null;
        set parent(value: this | null);
        /**
         * @en Which scene this node belongs to.
         * @zh 此节点属于哪个场景。
         * @readonly
         */
        get scene(): Scene;
        /**
         * @en The event processor of the current node, it provides EventTarget ability.
         * @zh 当前节点的事件处理器，提供 EventTarget 能力。
         * @readonly
         *
         * @deprecated since v3.4.0
         */
        get eventProcessor(): any;
        /**
         * @internal
         */
        protected static idGenerator: js.IDGenerator;
        /**
         * for walk
         * @internal
         */
        protected static _stacks: Array<Array<(BaseNode | null)>>;
        /**
         * @internal
         */
        protected static _stackId: number;
        /**
         * Call `_updateScene` of specified node.
         * @internal
         * @param node The node.
         */
        protected static _setScene(node: BaseNode): void;
        protected static _findComponent<T extends Component>(node: BaseNode, constructor: __private._types_globals__Constructor<T> | __private._types_globals__AbstractedConstructor<T>): T | null;
        protected static _findComponents<T extends Component>(node: BaseNode, constructor: __private._types_globals__Constructor<T> | __private._types_globals__AbstractedConstructor<T>, components: Component[]): void;
        protected static _findChildComponent<T extends Component>(children: BaseNode[], constructor: __private._types_globals__Constructor<T> | __private._types_globals__AbstractedConstructor<T>): T | null;
        protected static _findChildComponents(children: BaseNode[], constructor: any, components: any): void;
        protected _parent: this | null;
        protected _children: this[];
        protected _active: boolean;
        protected _components: Component[];
        protected _prefab: Prefab._utils.PrefabInfo | null;
        protected _scene: Scene;
        protected _activeInHierarchy: boolean;
        protected _id: string;
        protected _name: string;
        protected _eventProcessor: any;
        protected _eventMask: number;
        protected _siblingIndex: number;
        /**
         * @en
         * record scene's id when set this node as persist node
         * @zh
         * 当设置节点为常驻节点时记录场景的 id
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _originalSceneId: string;
        /**
         * Set `_scene` field of this node.
         * The derived `Scene` overrides this method to behavior differently.
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        protected _updateScene(): void;
        constructor(name?: string);
        /**
         * @en
         * Properties configuration function.
         * All properties in attrs will be set to the node,
         * when the setter of the node is available,
         * the property will be set via setter function.
         * @zh 属性配置函数。在 attrs 的所有属性将被设置为节点属性。
         * @param attrs - Properties to be set to node
         * @example
         * ```
         * var attrs = { name: 'New Name', active: false };
         * node.attr(attrs);
         * ```
         */
        attr(attrs: unknown): void;
        /**
         * @en Get parent of the node.
         * @zh 获取该节点的父节点。
         */
        getParent(): this | null;
        /**
         * @en Set parent of the node.
         * @zh 设置该节点的父节点。
         */
        setParent(value: this | Scene | null, keepWorldTransform?: boolean): void;
        /**
         * @en Returns a child with the same uuid.
         * @zh 通过 uuid 获取节点的子节点。
         * @param uuid - The uuid to find the child node.
         * @return a Node whose uuid equals to the input parameter
         */
        getChildByUuid(uuid: string): Node | null;
        /**
         * @en Returns a child with the same name.
         * @zh 通过名称获取节点的子节点。
         * @param name - A name to find the child node.
         * @return a CCNode object whose name equals to the input parameter
         * @example
         * ```
         * var child = node.getChildByName("Test Node");
         * ```
         */
        getChildByName(name: string): Node | null;
        /**
         * @en Returns a child with the given path.
         * @zh 通过路径获取节点的子节点。
         * @param path - A path to find the child node.
         * @return a Node object whose path equals to the input parameter
         * @example
         * ```
         * var child = node.getChildByPath("subNode/Test Node");
         * ```
         */
        getChildByPath(path: string): Node | null;
        /**
         * @en Add a child to the current node.
         * @zh 添加一个子节点。
         * @param child - the child node to be added
         */
        addChild(child: Node): void;
        /**
         * @en Inserts a child to the node at a specified index.
         * @zh 插入子节点到指定位置
         * @param child - the child node to be inserted
         * @param siblingIndex - the sibling index to place the child in
         * @example
         * ```
         * node.insertChild(child, 2);
         * ```
         */
        insertChild(child: Node, siblingIndex: number): void;
        /**
         * @en Get the sibling index of the current node in its parent's children array.
         * @zh 获取当前节点在父节点的 children 数组中的位置。
         */
        getSiblingIndex(): number;
        /**
         * @en Set the sibling index of the current node in its parent's children array.
         * @zh 设置当前节点在父节点的 children 数组中的位置。
         */
        setSiblingIndex(index: number): void;
        /**
         * @en Walk though the sub children tree of the current node.
         * Each node, including the current node, in the sub tree will be visited two times,
         * before all children and after all children.
         * This function call is not recursive, it's based on stack.
         * Please don't walk any other node inside the walk process.
         * @zh 遍历该节点的子树里的所有节点并按规则执行回调函数。
         * 对子树中的所有节点，包含当前节点，会执行两次回调，preFunc 会在访问它的子节点之前调用，postFunc 会在访问所有子节点之后调用。
         * 这个函数的实现不是基于递归的，而是基于栈展开递归的方式。
         * 请不要在 walk 过程中对任何其他的节点嵌套执行 walk。
         * @param preFunc The callback to process node when reach the node for the first time
         * @param postFunc The callback to process node when re-visit the node after walked all children in its sub tree
         * @example
         * ```
         * node.walk(function (target) {
         *     console.log('Walked through node ' + target.name + ' for the first time');
         * }, function (target) {
         *     console.log('Walked through node ' + target.name + ' after walked all children in its sub tree');
         * });
         * ```
         */
        walk(preFunc: (target: this) => void, postFunc?: (target: this) => void): void;
        /**
         * @en
         * Remove itself from its parent node.
         * If the node have no parent, then nothing happens.
         * @zh
         * 从父节点中删除该节点。
         * 如果这个节点是一个孤立节点，那么什么都不会发生。
         */
        removeFromParent(): void;
        /**
         * @en Removes a child from the container.
         * @zh 移除节点中指定的子节点。
         * @param child - The child node which will be removed.
         */
        removeChild(child: this | Node): void;
        /**
         * @en Removes all children from the container.
         * @zh 移除节点所有的子节点。
         */
        removeAllChildren(): void;
        /**
         * @en Is this node a child of the given node?
         * @zh 是否是指定节点的子节点？
         * @return True if this node is a child, deep child or identical to the given node.
         */
        isChildOf(parent: this | Scene | null): boolean;
        /**
         * @en
         * Returns the component of supplied type if the node has one attached, null if it doesn't.
         * You can also get component in the node by passing in the name of the script.
         * @zh
         * 获取节点上指定类型的组件，如果节点有附加指定类型的组件，则返回，如果没有则为空。
         * 传入参数也可以是脚本的名称。
         * @param classConstructor The class of the target component
         * @example
         * ```
         * // get sprite component.
         * var sprite = node.getComponent(Sprite);
         * ```
         */
        getComponent<T extends Component>(classConstructor: __private._types_globals__Constructor<T> | __private._types_globals__AbstractedConstructor<T>): T | null;
        /**
         * @en
         * Returns the component of supplied type if the node has one attached, null if it doesn't.
         * You can also get component in the node by passing in the name of the script.
         * @zh
         * 获取节点上指定类型的组件，如果节点有附加指定类型的组件，则返回，如果没有则为空。
         * 传入参数也可以是脚本的名称。
         * @param className The class name of the target component
         * @example
         * ```
         * // get custom test class.
         * var test = node.getComponent("Test");
         * ```
         */
        getComponent(className: string): Component | null;
        /**
         * @en Returns all components of given type in the node.
         * @zh 返回节点上指定类型的所有组件。
         * @param classConstructor The class of the target component
         */
        getComponents<T extends Component>(classConstructor: __private._types_globals__Constructor<T> | __private._types_globals__AbstractedConstructor<T>): T[];
        /**
         * @en Returns all components of given type in the node.
         * @zh 返回节点上指定类型的所有组件。
         * @param className The class name of the target component
         */
        getComponents(className: string): Component[];
        /**
         * @en Returns the component of given type in any of its children using depth first search.
         * @zh 递归查找所有子节点中第一个匹配指定类型的组件。
         * @param classConstructor The class of the target component
         * @example
         * ```
         * var sprite = node.getComponentInChildren(Sprite);
         * ```
         */
        getComponentInChildren<T extends Component>(classConstructor: __private._types_globals__Constructor<T> | __private._types_globals__AbstractedConstructor<T>): T | null;
        /**
         * @en Returns the component of given type in any of its children using depth first search.
         * @zh 递归查找所有子节点中第一个匹配指定类型的组件。
         * @param className The class name of the target component
         * @example
         * ```
         * var Test = node.getComponentInChildren("Test");
         * ```
         */
        getComponentInChildren(className: string): Component | null;
        /**
         * @en Returns all components of given type in self or any of its children.
         * @zh 递归查找自身或所有子节点中指定类型的组件
         * @param classConstructor The class of the target component
         * @example
         * ```
         * var sprites = node.getComponentsInChildren(Sprite);
         * ```
         */
        getComponentsInChildren<T extends Component>(classConstructor: __private._types_globals__Constructor<T> | __private._types_globals__AbstractedConstructor<T>): T[];
        /**
         * @en Returns all components of given type in self or any of its children.
         * @zh 递归查找自身或所有子节点中指定类型的组件
         * @param className The class name of the target component
         * @example
         * ```
         * var tests = node.getComponentsInChildren("Test");
         * ```
         */
        getComponentsInChildren(className: string): Component[];
        /**
         * @en Adds a component class to the node. You can also add component to node by passing in the name of the script.
         * @zh 向节点添加一个指定类型的组件类，你还可以通过传入脚本的名称来添加组件。
         * @param classConstructor The class of the component to add
         * @throws `TypeError` if the `classConstructor` does not specify a cc-class constructor extending the `Component`.
         * @example
         * ```
         * var sprite = node.addComponent(Sprite);
         * ```
         */
        addComponent<T extends Component>(classConstructor: __private._types_globals__Constructor<T>): T;
        /**
         * @en Adds a component class to the node. You can also add component to node by passing in the name of the script.
         * @zh 向节点添加一个指定类型的组件类，你还可以通过传入脚本的名称来添加组件。
         * @param className The class name of the component to add
         * @throws `TypeError` if the `className` does not specify a cc-class constructor extending the `Component`.
         * @example
         * ```
         * var test = node.addComponent("Test");
         * ```
         */
        addComponent(className: string): Component;
        /**
         * @en
         * Removes a component identified by the given name or removes the component object given.
         * You can also use component.destroy() if you already have the reference.
         * @zh
         * 删除节点上的指定组件，传入参数可以是一个组件构造函数或组件名，也可以是已经获得的组件引用。
         * 如果你已经获得组件引用，你也可以直接调用 component.destroy()
         * @param classConstructor The class of the component to remove
         * @deprecated please destroy the component to remove it.
         * @example
         * ```
         * node.removeComponent(Sprite);
         * ```
         */
        removeComponent<T extends Component>(classConstructor: __private._types_globals__Constructor<T> | __private._types_globals__AbstractedConstructor<T>): void;
        /**
         * @en
         * Removes a component identified by the given name or removes the component object given.
         * You can also use component.destroy() if you already have the reference.
         * @zh
         * 删除节点上的指定组件，传入参数可以是一个组件构造函数或组件名，也可以是已经获得的组件引用。
         * 如果你已经获得组件引用，你也可以直接调用 component.destroy()
         * @param classNameOrInstance The class name of the component to remove or the component instance to be removed
         * @deprecated please destroy the component to remove it.
         * @example
         * ```
         * import { Sprite } from 'cc';
         * const sprite = node.getComponent(Sprite);
         * if (sprite) {
         *     node.removeComponent(sprite);
         * }
         * node.removeComponent('Sprite');
         * ```
         */
        removeComponent(classNameOrInstance: string | Component): void;
        /**
         * @en
         * Register a callback of a specific event type on Node.
         * Use this method to register touch or mouse event permit propagation based on scene graph,
         * These kinds of event are triggered with dispatchEvent, the dispatch process has three steps:
         * 1. Capturing phase: dispatch in capture targets, e.g. parents in node tree, from root to the real target
         * 2. At target phase: dispatch to the listeners of the real target
         * 3. Bubbling phase: dispatch in bubble targets, e.g. parents in node tree, from the real target to root
         * In any moment of the dispatching process, it can be stopped via `event.stopPropagation()` or `event.stopPropagationImmediate()`.
         * You can also register custom event and use `emit` to trigger custom event on Node.
         * For such events, there won't be capturing and bubbling phase, your event will be dispatched directly to its listeners registered on the same node.
         * You can also pass event callback parameters with `emit` by passing parameters after `type`.
         * @zh
         * 在节点上注册指定类型的回调函数，也可以设置 target 用于绑定响应函数的 this 对象。
         * 鼠标或触摸事件会被系统调用 dispatchEvent 方法触发，触发的过程包含三个阶段：
         * 1. 捕获阶段：派发事件给捕获目标，比如，节点树中注册了捕获阶段的父节点，从根节点开始派发直到目标节点。
         * 2. 目标阶段：派发给目标节点的监听器。
         * 3. 冒泡阶段：派发事件给冒泡目标，比如，节点树中注册了冒泡阶段的父节点，从目标节点开始派发直到根节点。
         * 同时您可以将事件派发到父节点或者通过调用 stopPropagation 拦截它。
         * 你也可以注册自定义事件到节点上，并通过 emit 方法触发此类事件，对于这类事件，不会发生捕获冒泡阶段，只会直接派发给注册在该节点上的监听器
         * 你可以通过在 emit 方法调用时在 type 之后传递额外的参数作为事件回调的参数列表
         * @param type - A string representing the event type to listen for.<br>See [[Node.EventType.POSITION_CHANGED]] for all builtin events.
         * @param callback - The callback that will be invoked when the event is dispatched. The callback is ignored if it is a duplicate (the callbacks are unique).
         * @param target - The target (this object) to invoke the callback, can be null
         * @param useCapture - When set to true, the listener will be triggered at capturing phase which is ahead of the final target emit, otherwise it will be triggered during bubbling phase.
         * @return - Just returns the incoming callback so you can save the anonymous function easier.
         * @example
         * ```ts
         * this.node.on(NodeEventType.TOUCH_START, this.memberFunction, this);  // if "this" is component and the "memberFunction" declared in CCClass.
         * node.on(NodeEventType.TOUCH_START, callback, this);
         * node.on(NodeEventType.TOUCH_MOVE, callback, this);
         * node.on(NodeEventType.TOUCH_END, callback, this);
         * ```
         */
        on(type: string | NodeEventType, callback: __private._types_globals__AnyFunction, target?: unknown, useCapture?: any): void;
        /**
         * @en
         * Removes the callback previously registered with the same type, callback, target and or useCapture.
         * This method is merely an alias to removeEventListener.
         * @zh 删除之前与同类型，回调，目标或 useCapture 注册的回调。
         * @param type - A string representing the event type being removed.
         * @param callback - The callback to remove.
         * @param target - The target (this object) to invoke the callback, if it's not given, only callback without target will be removed
         * @param useCapture - When set to true, the listener will be triggered at capturing phase which is ahead of the final target emit, otherwise it will be triggered during bubbling phase.
         * @example
         * ```ts
         * this.node.off(NodeEventType.TOUCH_START, this.memberFunction, this);
         * node.off(NodeEventType.TOUCH_START, callback, this.node);
         * ```
         */
        off(type: string, callback?: __private._types_globals__AnyFunction, target?: unknown, useCapture?: any): void;
        /**
         * @en
         * Register an callback of a specific event type on the Node,
         * the callback will remove itself after the first time it is triggered.
         * @zh
         * 注册节点的特定事件类型回调，回调会在第一时间被触发后删除自身。
         *
         * @param type - A string representing the event type to listen for.
         * @param callback - The callback that will be invoked when the event is dispatched.
         *                              The callback is ignored if it is a duplicate (the callbacks are unique).
         * @param target - The target (this object) to invoke the callback, can be null
         */
        once(type: string, callback: __private._types_globals__AnyFunction, target?: unknown, useCapture?: any): void;
        /**
         * @en
         * Trigger an event directly with the event name and necessary arguments.
         * @zh
         * 通过事件名发送自定义事件
         * @param type - event type
         * @param arg1 - First argument in callback
         * @param arg2 - Second argument in callback
         * @param arg3 - Third argument in callback
         * @param arg4 - Fourth argument in callback
         * @param arg5 - Fifth argument in callback
         * @example
         * ```ts
         * eventTarget.emit('fire', event);
         * eventTarget.emit('fire', message, emitter);
         * ```
         */
        emit(type: string, arg0?: any, arg1?: any, arg2?: any, arg3?: any, arg4?: any): void;
        /**
         * @en
         * Dispatches an event into the event flow.
         * The event target is the EventTarget object upon which the dispatchEvent() method is called.
         * @zh 分发事件到事件流中。
         * @param event - The Event object that is dispatched into the event flow
         */
        dispatchEvent(event: Event): void;
        /**
         * @en Checks whether the EventTarget object has any callback registered for a specific type of event.
         * @zh 检查事件目标对象是否有为特定类型的事件注册的回调。
         * @param type - The type of event.
         * @param callback - The callback function of the event listener, if absent all event listeners for the given type will be removed
         * @param target - The callback callee of the event listener
         * @return True if a callback of the specified type is registered; false otherwise.
         */
        hasEventListener(type: string, callback?: __private._types_globals__AnyFunction, target?: unknown): any;
        /**
         * @en Removes all callbacks previously registered with the same target.
         * @zh 移除目标上的所有注册事件。
         * @param target - The target to be searched for all related callbacks
         */
        targetOff(target: string | unknown): void;
        destroy(): boolean;
        /**
         * @en
         * Destroy all children from the node, and release all their own references to other objects.
         * Actual destruct operation will delayed until before rendering.
         * @zh
         * 销毁所有子节点，并释放所有它们对其它对象的引用。
         * 实际销毁操作会延迟到当前帧渲染前执行。
         */
        destroyAllChildren(): void;
        /**
         * Do remove component, only used internally.
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _removeComponent(component: Component): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _updateSiblingIndex(): void;
        protected _onSetParent(oldParent: this | null, keepWorldTransform?: boolean): void;
        protected _onPostActivated(active: boolean): void;
        protected _onBatchCreated(dontSyncChildPrefab: boolean): void;
        protected _onPreDestroy(): void;
        protected _onHierarchyChanged(oldParent: this | null): void;
        protected _instantiate(cloned: any, isSyncedNode: any): any;
        protected _onHierarchyChangedBase(oldParent: this | null): void;
        protected _onPreDestroyBase(): boolean;
        protected _onSiblingIndexChanged?(siblingIndex: number): void;
        /**
         * @en
         * Ensures that this node has already had the specified component(s). If not, this method throws.
         * @zh
         * 检查节点已经包含对应的组件，如果没有，则抛出异常
         * @param constructor Constructor of the component.
         * @throws If one or more component of same type have been existed in this node.
         */
        protected _checkMultipleComp?<T extends Component>(constructor: __private._types_globals__Constructor<T>): void;
    }
    /**
     * @zh
     * 场景树中的基本节点，基本特性有：
     * * 具有层级关系
     * * 持有各类组件
     * * 维护空间变换（坐标、旋转、缩放）信息
     */
    /**
     * @en
     * Class of all entities in Cocos Creator scenes.
     * Basic functionalities include:
     * * Hierarchy management with parent and children
     * * Components management
     * * Coordinate system with position, scale, rotation in 3d space
     * @zh
     * Cocos Creator 场景中的所有节点类。
     * 基本特性有：
     * * 具有层级关系
     * * 持有各类组件
     * * 维护 3D 空间左边变换（坐标、旋转、缩放）信息
     */
    export class Node extends BaseNode implements CustomSerializable {
        /**
         * @en Event types emitted by Node
         * @zh 节点可能发出的事件类型
         */
        static EventType: typeof NodeEventType;
        /**
         * @en Coordinates space
         * @zh 空间变换操作的坐标系
         */
        static NodeSpace: typeof NodeSpace;
        /**
         * @en Bit masks for Node transformation parts
         * @zh 节点变换更新的具体部分
         * @deprecated please use [[Node.TransformBit]]
         */
        static TransformDirtyBit: typeof TransformBit;
        /**
         * @en Bit masks for Node transformation parts, can be used to determine which part changed in [[NodeEventType.TRANSFORM_CHANGED]] event
         * @zh 节点变换更新的具体部分，可用于判断 [[NodeEventType.TRANSFORM_CHANGED]] 事件的具体类型
         */
        static TransformBit: typeof TransformBit;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        static reserveContentsForAllSyncablePrefabTag: symbol;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _uiProps: __private._cocos_core_scene_graph_node_ui_properties__NodeUIProperties;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _static: boolean;
        protected _pos: math.Vec3;
        protected _rot: math.Quat;
        protected _scale: math.Vec3;
        protected _mat: math.Mat4;
        protected _lpos: math.Vec3;
        protected _lrot: math.Quat;
        protected _lscale: math.Vec3;
        protected _layer: number;
        protected _euler: math.Vec3;
        protected _eulerDirty: boolean;
        protected _flagChangeVersion: number;
        protected _hasChangedFlags: number;
        constructor(name?: string);
        /**
         * @en Determine whether the given object is a normal Node. Will return false if [[Scene]] given.
         * @zh 指定对象是否是普通的节点？如果传入 [[Scene]] 会返回 false。
         */
        static isNode(obj: unknown): obj is Node;
        protected _onPreDestroy(): boolean;
        /**
         * @en Position in local coordinate system
         * @zh 本地坐标系下的坐标
         */
        get position(): Readonly<math.Vec3>;
        set position(val: Readonly<math.Vec3>);
        /**
         * @en Position in world coordinate system
         * @zh 世界坐标系下的坐标
         */
        get worldPosition(): Readonly<math.Vec3>;
        set worldPosition(val: Readonly<math.Vec3>);
        /**
         * @en Rotation in local coordinate system, represented by a quaternion
         * @zh 本地坐标系下的旋转，用四元数表示
         */
        get rotation(): Readonly<math.Quat>;
        set rotation(val: Readonly<math.Quat>);
        /**
         * @en Rotation in local coordinate system, represented by euler angles
         * @zh 本地坐标系下的旋转，用欧拉角表示
         */
        set eulerAngles(val: Readonly<math.Vec3>);
        get eulerAngles(): Readonly<math.Vec3>;
        /**
         * @en Rotation in local coordinate system, represented by euler angles, but limited on z axis
         * @zh 本地坐标系下的旋转，用欧拉角表示，但是限定在 z 轴上。
         */
        get angle(): number;
        set angle(val: number);
        /**
         * @en Rotation in world coordinate system, represented by a quaternion
         * @zh 世界坐标系下的旋转，用四元数表示
         */
        get worldRotation(): Readonly<math.Quat>;
        set worldRotation(val: Readonly<math.Quat>);
        /**
         * @en Scale in local coordinate system
         * @zh 本地坐标系下的缩放
         */
        get scale(): Readonly<math.Vec3>;
        set scale(val: Readonly<math.Vec3>);
        /**
         * @en Scale in world coordinate system
         * @zh 世界坐标系下的缩放
         */
        get worldScale(): Readonly<math.Vec3>;
        set worldScale(val: Readonly<math.Vec3>);
        /**
         * @en Local transformation matrix
         * @zh 本地坐标系变换矩阵
         */
        set matrix(val: Readonly<math.Mat4>);
        /**
         * @en World transformation matrix
         * @zh 世界坐标系变换矩阵
         */
        get worldMatrix(): Readonly<math.Mat4>;
        /**
         * @en The vector representing forward direction in local coordinate system, it's the minus z direction by default
         * @zh 当前节点面向的前方方向，默认前方为 -z 方向
         */
        get forward(): math.Vec3;
        set forward(dir: math.Vec3);
        /**
         * @en Return the up direction vertor of this node in world space.
         * @zh 返回当前节点在世界空间中朝上的方向向量
         */
        get up(): math.Vec3;
        /**
         * @en Return the right direction vector of this node in world space.
         * @zh 返回当前节点在世界空间中朝右的方向向量
         */
        get right(): math.Vec3;
        /**
         * @en Layer of the current Node, it affects raycast, physics etc, refer to [[Layers]]
         * @zh 节点所属层，主要影响射线检测、物理碰撞等，参考 [[Layers]]
         */
        set layer(l: number);
        get layer(): number;
        /**
         * @en Whether the node's transformation have changed during the current frame.
         * @zh 这个节点的空间变换信息在当前帧内是否有变过？
         */
        get hasChangedFlags(): number;
        set hasChangedFlags(val: number);
        /**
         * @internal
         */
        [serializeTag](serializationOutput: SerializationOutput, context: SerializationContext): void;
        /**
         * @en Set parent of the node.
         * @zh 设置该节点的父节点。
         * @param value Parent node
         * @param keepWorldTransform Whether keep node's current world transform unchanged after this operation
         */
        setParent(value: this | null, keepWorldTransform?: boolean): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _onSetParent(oldParent: this | null, keepWorldTransform: boolean): void;
        protected _onHierarchyChanged(oldParent: this | null): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _onBatchCreated(dontSyncChildPrefab: boolean): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _onBeforeSerialize(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _onPostActivated(active: boolean): void;
        /**
         * @en Perform a translation on the node
         * @zh 移动节点
         * @param trans The increment on position
         * @param ns The operation coordinate space
         */
        translate(trans: math.Vec3, ns?: NodeSpace): void;
        /**
         * @en Perform a rotation on the node
         * @zh 旋转节点
         * @param rot The increment on rotation
         * @param ns The operation coordinate space
         */
        rotate(rot: math.Quat, ns?: NodeSpace): void;
        /**
         * @en Set the orientation of the node to face the target position, the node is facing minus z direction by default
         * @zh 设置当前节点旋转为面向目标位置，默认前方为 -z 方向
         * @param pos Target position
         * @param up Up direction
         */
        lookAt(pos: Readonly<math.Vec3>, up?: Readonly<math.Vec3>): void;
        /**
         * @en Invalidate the world transform information
         * for this node and all its children recursively
         * @zh 递归标记节点世界变换为 dirty
         * @param dirtyBit The dirty bits to setup to children, can be composed with multiple dirty bits
         */
        invalidateChildren(dirtyBit: TransformBit): void;
        /**
         * @en Update the world transform information if outdated
         * @zh 更新节点的世界变换信息
         */
        updateWorldTransform(): void;
        /**
         * @en Set position in local coordinate system
         * @zh 设置本地坐标
         * @param position Target position
         */
        setPosition(position: Readonly<math.Vec3>): void;
        /**
         * @en Set position in local coordinate system
         * @zh 设置本地坐标
         * @param x X axis position
         * @param y Y axis position
         * @param z Z axis position
         */
        setPosition(x: number, y: number, z?: number): void;
        /**
         * @en Get position in local coordinate system, please try to pass `out` vector and reuse it to avoid garbage.
         * @zh 获取本地坐标，注意，尽可能传递复用的 [[Vec3]] 以避免产生垃圾。
         * @param out Set the result to out vector
         * @return If `out` given, the return value equals to `out`, otherwise a new vector will be generated and return
         */
        getPosition(out?: math.Vec3): math.Vec3;
        /**
         * @en Set rotation in local coordinate system with a quaternion representing the rotation.
         * Please make sure the rotation is normalized.
         * @zh 用四元数设置本地旋转, 请确保设置的四元数已归一化。
         * @param rotation Rotation in quaternion
         */
        setRotation(rotation: Readonly<math.Quat>): void;
        /**
         * @en Set rotation in local coordinate system with a quaternion representing the rotation.
         * Please make sure the rotation is normalized.
         * @zh 用四元数设置本地旋转, 请确保设置的四元数已归一化。
         * @param x X value in quaternion
         * @param y Y value in quaternion
         * @param z Z value in quaternion
         * @param w W value in quaternion
         */
        setRotation(x: number, y: number, z: number, w: number): void;
        /**
         * @en Set rotation in local coordinate system with a vector representing euler angles
         * @zh 用欧拉角设置本地旋转
         * @param rotation Rotation in vector
         */
        setRotationFromEuler(rotation: math.Vec3): void;
        /**
         * @en Set rotation in local coordinate system with euler angles
         * @zh 用欧拉角设置本地旋转
         * @param x X axis rotation
         * @param y Y axis rotation
         * @param z Z axis rotation
         */
        setRotationFromEuler(x: number, y: number, zOpt?: number): void;
        /**
         * @en Get rotation as quaternion in local coordinate system, please try to pass `out` quaternion and reuse it to avoid garbage.
         * @zh 获取本地旋转，注意，尽可能传递复用的 [[Quat]] 以避免产生垃圾。
         * @param out Set the result to out quaternion
         * @return If `out` given, the return value equals to `out`, otherwise a new quaternion will be generated and return
         */
        getRotation(out?: math.Quat): math.Quat;
        /**
         * @en Set scale in local coordinate system
         * @zh 设置本地缩放
         * @param scale Target scale
         */
        setScale(scale: Readonly<math.Vec3>): void;
        /**
         * @en Set scale in local coordinate system
         * @zh 设置本地缩放
         * @param x X axis scale
         * @param y Y axis scale
         * @param z Z axis scale
         */
        setScale(x: number, y: number, z?: number): void;
        /**
         * @en Get scale in local coordinate system, please try to pass `out` vector and reuse it to avoid garbage.
         * @zh 获取本地缩放，注意，尽可能传递复用的 [[Vec3]] 以避免产生垃圾。
         * @param out Set the result to out vector
         * @return If `out` given, the return value equals to `out`, otherwise a new vector will be generated and return
         */
        getScale(out?: math.Vec3): math.Vec3;
        /**
         * @en Inversely transform a point from world coordinate system to local coordinate system.
         * @zh 逆向变换一个空间点，一般用于将世界坐标转换到本地坐标系中。
         * @param out The result point in local coordinate system will be stored in this vector
         * @param p A position in world coordinate system
         */
        inverseTransformPoint(out: math.Vec3, p: math.Vec3): math.Vec3;
        /**
         * @en Set position in world coordinate system
         * @zh 设置世界坐标
         * @param position Target position
         */
        setWorldPosition(position: math.Vec3): void;
        /**
         * @en Set position in world coordinate system
         * @zh 设置世界坐标
         * @param x X axis position
         * @param y Y axis position
         * @param z Z axis position
         */
        setWorldPosition(x: number, y: number, z: number): void;
        /**
         * @en Get position in world coordinate system, please try to pass `out` vector and reuse it to avoid garbage.
         * @zh 获取世界坐标，注意，尽可能传递复用的 [[Vec3]] 以避免产生垃圾。
         * @param out Set the result to out vector
         * @return If `out` given, the return value equals to `out`, otherwise a new vector will be generated and return
         */
        getWorldPosition(out?: math.Vec3): math.Vec3;
        /**
         * @en Set rotation in world coordinate system with a quaternion representing the rotation
         * @zh 用四元数设置世界坐标系下的旋转
         * @param rotation Rotation in quaternion
         */
        setWorldRotation(rotation: math.Quat): void;
        /**
         * @en Set rotation in world coordinate system with a quaternion representing the rotation
         * @zh 用四元数设置世界坐标系下的旋转
         * @param x X value in quaternion
         * @param y Y value in quaternion
         * @param z Z value in quaternion
         * @param w W value in quaternion
         */
        setWorldRotation(x: number, y: number, z: number, w: number): void;
        /**
         * @en Set rotation in world coordinate system with euler angles
         * @zh 用欧拉角设置世界坐标系下的旋转
         * @param x X axis rotation
         * @param y Y axis rotation
         * @param z Z axis rotation
         */
        setWorldRotationFromEuler(x: number, y: number, z: number): void;
        /**
         * @en Get rotation as quaternion in world coordinate system, please try to pass `out` quaternion and reuse it to avoid garbage.
         * @zh 获取世界坐标系下的旋转，注意，尽可能传递复用的 [[Quat]] 以避免产生垃圾。
         * @param out Set the result to out quaternion
         * @return If `out` given, the return value equals to `out`, otherwise a new quaternion will be generated and return
         */
        getWorldRotation(out?: math.Quat): math.Quat;
        /**
         * @en Set scale in world coordinate system
         * @zh 设置世界坐标系下的缩放
         * @param scale Target scale
         */
        setWorldScale(scale: math.Vec3): void;
        /**
         * @en Set scale in world coordinate system
         * @zh 设置世界坐标系下的缩放
         * @param x X axis scale
         * @param y Y axis scale
         * @param z Z axis scale
         */
        setWorldScale(x: number, y: number, z: number): void;
        /**
         * @en Get scale in world coordinate system, please try to pass `out` vector and reuse it to avoid garbage.
         * @zh 获取世界缩放，注意，尽可能传递复用的 [[Vec3]] 以避免产生垃圾。
         * @param out Set the result to out vector
         * @return If `out` given, the return value equals to `out`, otherwise a new vector will be generated and return
         */
        getWorldScale(out?: math.Vec3): math.Vec3;
        /**
         * @en Get a world transform matrix
         * @zh 获取世界变换矩阵
         * @param out Set the result to out matrix
         * @return If `out` given, the return value equals to `out`, otherwise a new matrix will be generated and return
         */
        getWorldMatrix(out?: math.Mat4): math.Mat4;
        /**
         * @en Get a world transform matrix with only rotation and scale
         * @zh 获取只包含旋转和缩放的世界变换矩阵
         * @param out Set the result to out matrix
         * @return If `out` given, the return value equals to `out`, otherwise a new matrix will be generated and return
         */
        getWorldRS(out?: math.Mat4): math.Mat4;
        /**
         * @en Get a world transform matrix with only rotation and translation
         * @zh 获取只包含旋转和位移的世界变换矩阵
         * @param out Set the result to out matrix
         * @return If `out` given, the return value equals to `out`, otherwise a new matrix will be generated and return
         */
        getWorldRT(out?: math.Mat4): math.Mat4;
        /**
         * @en Set local transformation with rotation, position and scale separately.
         * @zh 一次性设置所有局部变换（平移、旋转、缩放）信息
         * @param rot The rotation
         * @param pos The position
         * @param scale The scale
         */
        setRTS(rot?: math.Quat | math.Vec3, pos?: math.Vec3, scale?: math.Vec3): void;
        /**
         * @en
         * Pause all system events which is dispatched by [[SystemEvent]].
         * If recursive is set to true, then this API will pause the node system events for the node and all nodes in its sub node tree.
         * @zh
         * 暂停所有 [[SystemEvent]] 派发的系统事件。
         * 如果传递 recursive 为 true，那么这个 API 将暂停本节点和它的子树上所有节点的节点系统事件。
         *
         * @param recursive Whether pause system events recursively for the child node tree
         */
        pauseSystemEvents(recursive: boolean): void;
        /**
         * @en
         * Resume all paused system events which is dispatched by [[SystemEvent]].
         * If recursive is set to true, then this API will resume the node system events for the node and all nodes in its sub node tree.
         *
         * @zh
         * 恢复所有 [[SystemEvent]] 派发的系统事件。
         * 如果传递 recursive 为 true，那么这个 API 将恢复本节点和它的子树上所有节点的节点系统事件。
         *
         * @param recursive Whether resume system events recursively for the child node tree
         */
        resumeSystemEvents(recursive: boolean): void;
        /**
         * @en
         * clear all node dirty state.
         * @zh
         * 清除所有节点的脏标记。
         */
        static resetHasChangedFlags(): void;
        /**
         * @en
         * clear node array
         * @zh
         * 清除节点数组
         */
        static clearNodeArray(): void;
        /**
         * @en
         * Get the complete path of the current node in the hierarchy.
         *
         * @zh
         * 获得当前节点在 hierarchy 中的完整路径。
         */
        getPathInHierarchy(): string;
    }
    /**
     * @en
     * Scene is a subclass of [[BaseNode]], composed by nodes, representing the root of a runnable environment in the game.
     * It's managed by [[Director]] and user can switch from a scene to another using [[Director.loadScene]]
     * @zh
     * Scene 是 [[BaseNode]] 的子类，由节点所构成，代表着游戏中可运行的某一个整体环境。
     * 它由 [[Director]] 管理，用户可以使用 [[Director.loadScene]] 来切换场景
     */
    export class Scene extends BaseNode {
        /**
         * @en The renderer scene, normally user don't need to use it
         * @zh 渲染层场景，一般情况下用户不需要关心它
         */
        get renderScene(): renderer.RenderScene | null;
        get globals(): SceneGlobals;
        /**
         * @en Indicates whether all (directly or indirectly) static referenced assets of this scene are releasable by default after scene unloading.
         * @zh 指示该场景中直接或间接静态引用到的所有资源是否默认在场景切换后自动释放。
         */
        autoReleaseAssets: boolean;
        /**
         * @en Per-scene level rendering info
         * @zh 场景级别的渲染信息
         *
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _globals: SceneGlobals;
        dependAssets: null;
        protected _renderScene: renderer.RenderScene | null;
        protected _inited: boolean;
        protected _prefabSyncedInLiveReload: boolean;
        protected _pos: Readonly<math.Vec3>;
        protected _rot: Readonly<math.Quat>;
        protected _scale: Readonly<math.Vec3>;
        protected _mat: Readonly<math.Mat4>;
        protected _dirtyFlags: number;
        protected _lpos: Readonly<math.Vec3>;
        protected _lrot: Readonly<math.Quat>;
        protected _lscale: Readonly<math.Vec3>;
        protected _updateScene(): void;
        constructor(name: string);
        /**
         * @en Destroy the current scene and all its nodes, this action won't destroy related assets
         * @zh 销毁当前场景中的所有节点，这个操作不会销毁资源
         */
        destroy(): boolean;
        /**
         * @en Only for compatibility purpose, user should not add any component to the scene
         * @zh 仅为兼容性保留，用户不应该在场景上直接添加任何组件
         */
        addComponent(...args: any[]): Component;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _onHierarchyChanged(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _onBatchCreated(dontSyncChildPrefab: boolean): void;
        /**
         * @en
         * Refer to [[Node.getPosition]]
         * @zh
         * 参考 [[Node.getPosition]]
         */
        getPosition(out?: math.Vec3): math.Vec3;
        /**
         * @en
         * Refer to [[Node.getRotation]]
         * @zh
         * 参考 [[Node.getRotation]]
         */
        getRotation(out?: math.Quat): math.Quat;
        /**
         * @en
         * Refer to [[Node.getScale]]
         * @zh
         * 参考 [[Node.getScale]]
         */
        getScale(out?: math.Vec3): math.Vec3;
        /**
         * @en
         * Refer to [[Node.getWorldPosition]]
         * @zh
         * 参考 [[Node.getWorldPosition]]
         */
        getWorldPosition(out?: math.Vec3): math.Vec3;
        /**
         * @en
         * Refer to [[Node.getWorldRotation]]
         * @zh
         * 参考 [[Node.getWorldRotation]]
         */
        getWorldRotation(out?: math.Quat): math.Quat;
        /**
         * @en
         * Refer to [[Node.getWorldScale]]
         * @zh
         * 参考 [[Node.getWorldScale]]
         */
        getWorldScale(out?: math.Vec3): math.Vec3;
        /**
         * @en
         * Refer to [[Node.getWorldMatrix]]
         * @zh
         * 参考 [[Node.getWorldMatrix]]
         */
        getWorldMatrix(out?: math.Mat4): math.Mat4;
        /**
         * @en
         * Refer to [[Node.getWorldRS]]
         * @zh
         * 参考 [[Node.getWorldRS]]
         */
        getWorldRS(out?: math.Mat4): math.Mat4;
        /**
         * @en
         * Refer to [[Node.getWorldRT]]
         * @zh
         * 参考 [[Node.getWorldRT]]
         */
        getWorldRT(out?: math.Mat4): math.Mat4;
        /**
         * @en
         * Refer to [[Node.position]]
         * @zh
         * 参考 [[Node.position]]
         */
        get position(): Readonly<math.Vec3>;
        /**
         * @en
         * Refer to [[Node.worldPosition]]
         * @zh
         * 参考 [[Node.worldPosition]]
         */
        get worldPosition(): Readonly<math.Vec3>;
        /**
         * @en
         * Refer to [[Node.rotation]]
         * @zh
         * 参考 [[Node.rotation]]
         */
        get rotation(): Readonly<math.Quat>;
        /**
         * @en
         * Refer to [[Node.worldRotation]]
         * @zh
         * 参考 [[Node.worldRotation]]
         */
        get worldRotation(): Readonly<math.Quat>;
        /**
         * @en
         * Refer to [[Node.scale]]
         * @zh
         * 参考 [[Node.scale]]
         */
        get scale(): Readonly<math.Vec3>;
        /**
         * @en
         * Refer to [[Node.worldScale]]
         * @zh
         * 参考 [[Node.worldScale]]
         */
        get worldScale(): Readonly<math.Vec3>;
        /**
         * @en
         * Refer to [[Node.eulerAngles]]
         * @zh
         * 参考 [[Node.eulerAngles]]
         */
        get eulerAngles(): Readonly<math.Vec3>;
        /**
         * @en
         * Refer to [[Node.worldMatrix]]
         * @zh
         * 参考 [[Node.worldMatrix]]
         */
        get worldMatrix(): Readonly<math.Mat4>;
        /**
         * @en
         * Refer to [[Node.updateWorldTransform]]
         * @zh
         * 参考 [[Node.updateWorldTransform]]
         */
        updateWorldTransform(): void;
        protected _instantiate(): void;
        protected _load(): void;
        protected _activate(active: boolean): void;
    }
    /**
     * @zh 节点层管理器，层数据是以掩码数据方式存储在 [[Node.layer]] 中，用于射线检测、物理碰撞和用户自定义脚本逻辑。
     * 每个节点可属于一个或多个层，可通过 “包含式” 或 “排除式” 两种检测器进行层检测。
     * @en Node's layer manager, it's stored as bit mask data in [[Node.layer]].
     * Layer information is widely used in raycast, physics and user logic.
     * Every node can be assigned to multiple layers with different bit masks, you can setup layer with inclusive or exclusive operation.
     */
    export class Layers {
        /**
         * @en All layers in an Enum
         * @zh 以 Enum 形式存在的所有层列表
         */
        static Enum: {
            NONE: number;
            IGNORE_RAYCAST: number;
            GIZMOS: number;
            EDITOR: number;
            UI_3D: number;
            SCENE_GIZMO: number;
            UI_2D: number;
            PROFILER: number;
            DEFAULT: number;
            ALL: number;
        };
        /**
         * @en All layers in [[BitMask]] type
         * @zh 包含所有层的 [[BitMask]]
         */
        static BitMask: {
            NONE: number;
            IGNORE_RAYCAST: number;
            GIZMOS: number;
            EDITOR: number;
            UI_3D: number;
            SCENE_GIZMO: number;
            UI_2D: number;
            PROFILER: number;
            DEFAULT: number;
            ALL: number;
        };
        /**
         * @internal
         */
        static init(): void;
        /**
         * @en
         * Make a layer mask accepting nothing but the listed layers
         * @zh
         * 创建一个包含式层检测器，只接受列表中的层
         * @param includes All accepted layers
         * @return A filter which can detect all accepted layers
         */
        static makeMaskInclude(includes: number[]): number;
        /**
         * @en
         * Make a layer mask accepting everything but the listed layers
         * @zh
         * 创建一个排除式层检测器，只拒绝列表中的层
         * @param excludes All excluded layers
         * @return A filter which can detect for excluded layers
         */
        static makeMaskExclude(excludes: number[]): number;
        /**
         * @zh 添加一个新层，用户可编辑 0 - 19 位为用户自定义层
         * @en Add a new layer, user can use layers from bit position 0 to 19, other bits are reserved.
         * @param name Layer's name
         * @param bitNum Layer's bit position
         */
        static addLayer(name: string, bitNum: number): void;
        /**
         * @en Remove a layer, user can remove layers from bit position 0 to 19, other bits are reserved.
         * @zh 移除一个层，用户可编辑 0 - 19 位为用户自定义层
         * @param bitNum Layer's bit position
         */
        static deleteLayer(bitNum: number): void;
        /**
         * @en Given a layer name, returns the layer index as defined by either a Builtin or a User Layer in the Tags and Layers manager.
         * @zh 给定层名称，返回由标记和层管理器中的内置层或用户层定义的层索引。
         * @param name layer's name
         */
        static nameToLayer(name: string): number;
        /**
         * @en Given a layer number, returns the name of the layer as defined in either a Builtin or a User Layer in the Tags and Layers manager.
         * @zh 给定层数，返回在标记和层管理器中的内置层或用户层中定义的层名称。
         * @param bitNum layer's value
         */
        static layerToName(bitNum: number): string;
    }
    export namespace Layers {
        export type Enum = __private._types_globals__EnumAlias<typeof Layers.Enum>;
        export type BitMask = __private._types_globals__EnumAlias<typeof Layers.BitMask>;
    }
    /**
     * @en The class used to perform activating and deactivating operations of node and component.
     * @zh 用于执行节点和组件的激活和停用操作的管理器。
     */
    export class NodeActivator {
        resetComp: any;
        protected _activatingStack: any[];
        constructor();
        /**
         * @en Reset all activation or des-activation tasks
         * @zh 重置所有激活或非激活任务
         */
        reset(): void;
        /**
         * @en Activate or des-activate a node
         * @zh 激活或者停用某个节点
         * @param node Target node
         * @param active Which state to set the node to
         */
        activateNode(node: any, active: any): void;
        /**
         * @en Activate or des-activate a component
         * @zh 激活或者停用某个组件
         * @param comp Target component
         * @param preloadInvoker The invoker for `_preload` method, normally from [[ComponentScheduler]]
         * @param onLoadInvoker The invoker for `onLoad` method, normally from [[ComponentScheduler]]
         * @param onEnableInvoker The invoker for `onEnable` method, normally from [[ComponentScheduler]]
         */
        activateComp(comp: any, preloadInvoker?: any, onLoadInvoker?: any, onEnableInvoker?: any): void;
        /**
         * @en Destroy a component
         * @zh 销毁一个组件
         * @param comp Target component
         */
        destroyComp(comp: any): void;
        protected _activateNodeRecursively(node: any, preloadInvoker: any, onLoadInvoker: any, onEnableInvoker: any): void;
        protected _deactivateNodeRecursively(node: any): void;
    }
    /**
     * @en Node's coordinate space
     * @zh 节点的坐标空间
     */
    export enum NodeSpace {
        LOCAL = 0,
        WORLD = 1
    }
    /**
     * @en Bit masks for node's transformation
     * @zh 节点的空间变换位标记
     */
    export enum TransformBit {
        /**
         * @en No change
         * @zh 无改变
         */
        NONE = 0,
        /**
         * @en Translation changed
         * @zh 节点位置改变
         */
        POSITION = 1,
        /**
         * @en Rotation changed
         * @zh 节点旋转
         */
        ROTATION = 2,
        /**
         * @en Scale changed
         * @zh 节点缩放
         */
        SCALE = 4,
        /**
         * @en Rotation or scale changed
         * @zh 节点旋转及缩放
         */
        RS = 6,
        /**
         * @en Translation, rotation or scale changed
         * @zh 节点平移，旋转及缩放
         */
        TRS = 7,
        /**
         * @en Invert mask of [[TRS]]
         * @zh [[TRS]] 的反向掩码
         */
        TRS_MASK = "Bad expression <-8>"
    }
    /**
     * @en All event types which [[Node]] could emit
     * @zh 所有 [[Node]] 可能派发的事件类型
     */
    export enum NodeEventType {
        /**
         * @en
         * The event type for touch start event
         *
         * @zh
         * 手指开始触摸事件。
         */
        TOUCH_START = "touch-start",
        /**
         * @en
         * The event type for touch move event
         *
         * @zh
         * 当手指在屏幕上移动时。
         */
        TOUCH_MOVE = "touch-move",
        /**
         * @en
         * The event type for touch end event
         *
         * @zh
         * 手指结束触摸事件。
         */
        TOUCH_END = "touch-end",
        /**
         * @en
         * The event type for touch end event
         *
         * @zh
         * 当手指在目标节点区域外离开屏幕时。
         */
        TOUCH_CANCEL = "touch-cancel",
        /**
         * @en
         * The event type for mouse down events
         *
         * @zh
         * 当鼠标按下时触发一次。
         */
        MOUSE_DOWN = "mouse-down",
        /**
         * @en
         * The event type for mouse move events
         *
         * @zh
         * 当鼠标在目标节点在目标节点区域中移动时，不论是否按下。
         */
        MOUSE_MOVE = "mouse-move",
        /**
         * @en
         * The event type for mouse up events
         *
         * @zh
         * 当鼠标从按下状态松开时触发一次。
         */
        MOUSE_UP = "mouse-up",
        /**
         * @en
         * The event type for mouse wheel events
         *
         * @zh 手指开始触摸事件
         */
        MOUSE_WHEEL = "mouse-wheel",
        /**
         * @en
         * The event type for mouse leave target events
         *
         * @zh
         * 当鼠标移入目标节点区域时，不论是否按下.
         */
        MOUSE_ENTER = "mouse-enter",
        /**
         * @en
         * The event type for mouse leave target events
         *
         * @zh
         * 当鼠标移出目标节点区域时，不论是否按下。
         */
        MOUSE_LEAVE = "mouse-leave",
        /**
         * @en The event type for press the key down event, the event will be continuously dispatched in the key pressed state
         * @zh 当按下按键时触发的事件, 该事件在按下状态会持续派发
         * @deprecated since v3.3, please use SystemEvent.EventType.KEY_DOWN instead
         */
        KEY_DOWN = "keydown",
        /**
         * @en The event type for press the key up event
         * @zh 当松开按键时触发的事件
         * @deprecated since v3.3, please use SystemEvent.EventType.KEY_UP instead
         */
        KEY_UP = "keyup",
        /**
         * @en
         * The event type for press the devicemotion event
         *
         * @zh
         * 重力感应
         *
         * @deprecated since v3.3, please use SystemEvent.EventType.DEVICEMOTION instead
         */
        DEVICEMOTION = "devicemotion",
        /**
         * @en
         * The event type for position, rotation, scale changed.Use the type parameter as `Node.TransformBit` to check which part is changed
         *
         * @zh
         * 节点改变位置、旋转或缩放事件。如果具体需要判断是哪一个事件，可通过判断回调的第一个参数类型是 `Node.TransformBit` 中的哪一个来获取
         * @example
         * ```
         * this.node.on(Node.EventType.TRANSFORM_CHANGED, (type)=>{
         *  if (type & Node.TransformBit.POSITION) {
         *       //...
         *   }
         * }, this);
         * ```
         */
        TRANSFORM_CHANGED = "transform-changed",
        /**
         * @en The event type for notifying the host scene has been changed for a persist node.
         * @zh 当场景常驻节点的场景发生改变时触发的事件，一般在切换场景过程中触发。
         */
        SCENE_CHANGED_FOR_PERSISTS = "scene-changed-for-persists",
        /**
         * @en
         * The event type for size change events.
         * Performance note, this event will be triggered every time corresponding properties being changed,
         * if the event callback have heavy logic it may have great performance impact, try to avoid such scenario.
         *
         * @zh
         * 当节点尺寸改变时触发的事件。
         * 性能警告：这个事件会在每次对应的属性被修改时触发，如果事件回调损耗较高，有可能对性能有很大的负面影响，请尽量避免这种情况。
         */
        SIZE_CHANGED = "size-changed",
        /**
         * @en
         * The event type for anchor point change events.
         * Performance note, this event will be triggered every time corresponding properties being changed,
         * if the event callback have heavy logic it may have great performance impact, try to avoid such scenario.
         *
         * @zh
         * 当节点的 UITransform 锚点改变时触发的事件。
         * 性能警告：这个事件会在每次对应的属性被修改时触发，如果事件回调损耗较高，有可能对性能有很大的负面影响，请尽量避免这种情况。
         */
        ANCHOR_CHANGED = "anchor-changed",
        /**
         * @en
         * The event type for color change events.
         * Performance note, this event will be triggered every time corresponding properties being changed,
         * if the event callback have heavy logic it may have great performance impact, try to avoid such scenario.
         *
         * @zh
         * 当节点的 UI 渲染组件颜色属性改变时触发的事件。
         * 性能警告：这个事件会在每次对应的属性被修改时触发，如果事件回调损耗较高，有可能对性能有很大的负面影响，请尽量避免这种情况。
         */
        COLOR_CHANGED = "color-changed",
        /**
         * @en
         * The event type for adding a new child node to the target node.
         *
         * @zh
         * 给目标节点添加子节点时触发的事件。
         */
        CHILD_ADDED = "child-added",
        /**
         * @en
         * The event type for removing a child node from the target node.
         *
         * @zh
         * 给目标节点移除子节点时触发的事件。
         */
        CHILD_REMOVED = "child-removed",
        /**
         * @en The event type for changing the parent of the target node
         * @zh 目标节点的父节点改变时触发的事件。
         */
        PARENT_CHANGED = "parent-changed",
        /**
         * @en The event type for destroying the target node
         * @zh 目标节点被销毁时触发的事件。
         */
        NODE_DESTROYED = "node-destroyed",
        /**
         * @en The event type for node layer change events.
         * @zh 节点 layer 改变时触发的事件。
         */
        LAYER_CHANGED = "layer-changed",
        /**
         * @en The event type for node's sibling order changed.
         * @zh 当节点在兄弟节点中的顺序发生变化时触发的事件。
         */
        SIBLING_ORDER_CHANGED = "sibling-order-changed",
        /**
         * @en
         * Note: This event is only emitted from the top most node whose active value did changed,
         * not including its child nodes.
         * @zh
         * 注意：此节点激活时，此事件仅从最顶部的节点发出。
         */
        ACTIVE_IN_HIERARCHY_CHANGED = "active-in-hierarchy-changed",
        /**
         * @en
         * The event occur when node add a new component.
         * @zh
         * 当节点上增加组件时触发的事件
         */
        COMPONENT_ADDED = "component-added",
        /**
         * @en
         * The event occur when node remove a component.
         * @zh
         * 当节点上移除组件时触发的事件
         */
        COMPONENT_REMOVED = "component-removed"
    }
    /**
     * @en Environment lighting configuration in the Scene
     * @zh 场景的环境光照相关配置
     */
    export class AmbientInfo {
        /**
         * @en The sky color in HDR mode
         * @zh HDR 模式下的天空光照色
         */
        get skyColorHDR(): Readonly<math.Vec4>;
        /**
         * @en The ground color in HDR mode
         * @zh HDR 模式下的地面光照色
         */
        get groundAlbedoHDR(): Readonly<math.Vec4>;
        /**
         * @en Sky illuminance in HDR mode
         * @zh HDR 模式下的天空亮度
         */
        get skyIllumHDR(): number;
        /**
         * @en The sky color in LDR mode
         * @zh LDR 模式下的天空光照色
         */
        get skyColorLDR(): Readonly<math.Vec4>;
        /**
         * @en The ground color in LDR mode
         * @zh LDR 模式下的地面光照色
         */
        get groundAlbedoLDR(): Readonly<math.Vec4>;
        /**
         * @en Sky illuminance in LDR mode
         * @zh LDR 模式下的天空亮度
         */
        get skyIllumLDR(): number;
        /**
         * @en Sky lighting color configurable in editor with color picker
         * @zh 编辑器中可配置的天空光照颜色（通过颜色拾取器）
         */
        set skyLightingColor(val: math.Color);
        get skyLightingColor(): math.Color;
        /**
         * @internal
         */
        set skyColor(val: math.Vec4);
        /**
         * @en Sky illuminance
         * @zh 天空亮度
         */
        set skyIllum(val: number);
        get skyIllum(): number;
        /**
         * @en Ground lighting color configurable in editor with color picker
         * @zh 编辑器中可配置的地面光照颜色（通过颜色拾取器）
         */
        set groundLightingColor(val: math.Color);
        get groundLightingColor(): math.Color;
        /**
         * @internal
         */
        set groundAlbedo(val: math.Vec4);
        protected _skyColorHDR: math.Vec4;
        protected _skyIllumHDR: number;
        protected _groundAlbedoHDR: math.Vec4;
        protected _skyColorLDR: math.Vec4;
        protected _skyIllumLDR: number;
        protected _groundAlbedoLDR: math.Vec4;
        protected _resource: renderer.scene.Ambient | null;
        /**
         * @en Activate the ambient lighting configuration in the render scene, no need to invoke manually.
         * @zh 在渲染场景中启用环境光照设置，不需要手动调用
         * @param resource The ambient configuration object in the render scene
         */
        activate(resource: renderer.scene.Ambient): void;
    }
    /**
     * @en Skybox related configuration
     * @zh 天空盒相关配置
     */
    export class SkyboxInfo {
        /**
         * @en Whether to use diffuse convolution map. Enabled -> Will use map specified. Disabled -> Will revert to hemispheric lighting
         * @zh 是否为IBL启用漫反射卷积图？不启用的话将使用默认的半球光照
         */
        set applyDiffuseMap(val: boolean);
        get applyDiffuseMap(): boolean;
        /**
         * @en Whether activate skybox in the scene
         * @zh 是否启用天空盒？
         */
        set enabled(val: boolean);
        get enabled(): boolean;
        /**
         * @zh 环境反射类型
         * @en environment reflection type
         */
        set envLightingType(val: number);
        get envLightingType(): number;
        /**
         * @en Whether use environment lighting
         * @zh 是否启用环境光照？
         */
        set useIBL(val: boolean);
        get useIBL(): boolean;
        /**
         * @en Toggle HDR (TODO: This SHOULD be moved into it's own subgroup away from skybox)
         * @zh 是否启用HDR？
         */
        set useHDR(val: boolean);
        get useHDR(): boolean;
        /**
         * @en The texture cube used for the skybox
         * @zh 使用的立方体贴图
         */
        set envmap(val: TextureCube | null);
        get envmap(): TextureCube | null;
        /**
         * @en Rotate the skybox
         * @zh 旋转天空盒
         */
        set rotationAngle(val: number);
        get rotationAngle(): number;
        /**
         * @en The optional diffusion convolution map used in tandem with IBL
         * @zh 使用的漫反射卷积图
         */
        set diffuseMap(val: TextureCube | null);
        get diffuseMap(): TextureCube | null;
        /**
         * @en Convolutional map using environmental reflections
         * @zh 使用环境反射卷积图
         */
        set reflectionMap(val: TextureCube | null);
        get reflectionMap(): TextureCube | null;
        /**
         * @en Use custom skybox material
         * @zh 使用自定义的天空盒材质
         */
        set skyboxMaterial(val: Material | null);
        get skyboxMaterial(): Material | null;
        protected _envLightingType: number;
        protected _envmapHDR: TextureCube | null;
        protected _envmapLDR: TextureCube | null;
        protected _diffuseMapHDR: TextureCube | null;
        protected _diffuseMapLDR: TextureCube | null;
        protected _enabled: boolean;
        protected _useHDR: boolean;
        protected _editableMaterial: Material | null;
        protected _reflectionHDR: TextureCube | null;
        protected _reflectionLDR: TextureCube | null;
        protected _rotationAngle: number;
        protected _resource: renderer.scene.Skybox | null;
        /**
         * @en Activate the skybox configuration in the render scene, no need to invoke manually.
         * @zh 在渲染场景中启用天空盒设置，不需要手动调用
         * @param resource The skybox configuration object in the render scene
         */
        activate(resource: renderer.scene.Skybox): void;
    }
    /**
     * @zh 全局雾相关配置
     * @en Global fog configuration
     */
    export class FogInfo {
        static FogType: {
            LINEAR: number;
            EXP: number;
            EXP_SQUARED: number;
            LAYERED: number;
        };
        /**
         * @zh 是否启用全局雾效
         * @en Enable global fog
         */
        set enabled(val: boolean);
        get enabled(): boolean;
        /**
         * @zh 是否启用精确雾效(像素雾)计算
         * @en Enable accurate fog (pixel fog)
         */
        set accurate(val: boolean);
        get accurate(): boolean;
        /**
         * @zh 全局雾颜色
         * @en Global fog color
         */
        set fogColor(val: math.Color);
        get fogColor(): Readonly<math.Color>;
        /**
         * @zh 全局雾类型
         * @en Global fog type
         */
        get type(): number;
        set type(val: number);
        /**
         * @zh 全局雾浓度
         * @en Global fog density
         */
        get fogDensity(): number;
        set fogDensity(val: number);
        /**
         * @zh 雾效起始位置
         * @en Global fog start position
         */
        get fogStart(): number;
        set fogStart(val: number);
        /**
         * @zh 雾效结束位置，只适用于线性雾
         * @en Global fog end position, only for linear fog
         */
        get fogEnd(): number;
        set fogEnd(val: number);
        /**
         * @zh 雾效衰减
         * @en Global fog attenuation
         */
        get fogAtten(): number;
        set fogAtten(val: number);
        /**
         * @zh 雾效顶部范围，只适用于层级雾
         * @en Global fog top range, only for layered fog
         */
        get fogTop(): number;
        set fogTop(val: number);
        /**
         * @zh 雾效范围，只适用于层级雾
         * @en Global fog range, only for layered fog
         */
        get fogRange(): number;
        set fogRange(val: number);
        protected _type: number;
        protected _fogColor: math.Color;
        protected _enabled: boolean;
        protected _fogDensity: number;
        protected _fogStart: number;
        protected _fogEnd: number;
        protected _fogAtten: number;
        protected _fogTop: number;
        protected _fogRange: number;
        protected _accurate: boolean;
        protected _resource: renderer.scene.Fog | null;
        /**
         * @en Activate the fog configuration in the render scene, no need to invoke manually.
         * @zh 在渲染场景中启用雾效设置，不需要手动调用
         * @param resource The fog configuration object in the render scene
         */
        activate(resource: renderer.scene.Fog): void;
    }
    /**
     * @en Scene level shadow related configuration
     * @zh 场景级别阴影相关的配置
     */
    export class ShadowsInfo {
        /**
         * @en Whether activate planar shadow
         * @zh 是否启用平面阴影？
         */
        set enabled(val: boolean);
        get enabled(): boolean;
        /**
         * @en The type of the shadow
         * @zh 阴影渲染的类型
         */
        set type(val: number);
        get type(): number;
        /**
         * @en Shadow color
         * @zh 阴影颜色
         */
        set shadowColor(val: math.Color);
        get shadowColor(): Readonly<math.Color>;
        /**
         * @en The normal of the plane which receives shadow
         * @zh 阴影接收平面的法线
         */
        set planeDirection(val: math.Vec3);
        get planeDirection(): Readonly<math.Vec3>;
        /**
         * @en The distance from coordinate origin to the receiving plane.
         * @zh 阴影接收平面与原点的距离
         */
        set planeHeight(val: number);
        get planeHeight(): number;
        /**
         * @en get or set shadow max received
         * @zh 获取或者设置阴影接收的最大光源数量
         */
        set maxReceived(val: number);
        get maxReceived(): number;
        /**
         * @en get or set shadow map size
         * @zh 获取或者设置阴影纹理大小
         */
        set shadowMapSize(value: number);
        get shadowMapSize(): number;
        protected _enabled: boolean;
        protected _type: number;
        protected _normal: math.Vec3;
        protected _distance: number;
        protected _shadowColor: math.Color;
        protected _maxReceived: number;
        protected _size: math.Vec2;
        protected _resource: renderer.scene.Shadows | null;
        /**
         * @en Set plane which receives shadow with the given node's world transformation
         * @zh 根据指定节点的世界变换设置阴影接收平面的信息
         * @param node The node for setting up the plane
         */
        setPlaneFromNode(node: Node): void;
        /**
         * @en Activate the shadow configuration in the render scene, no need to invoke manually.
         * @zh 在渲染场景中启用阴影设置，不需要手动调用
         * @param resource The shadow configuration object in the render scene
         */
        activate(resource: renderer.scene.Shadows): void;
    }
    export const DEFAULT_WORLD_MIN_POS: math.Vec3;
    export const DEFAULT_WORLD_MAX_POS: math.Vec3;
    export const DEFAULT_OCTREE_DEPTH = 8;
    /**
     * @en Scene management and culling configuration based on octree
     * @zh 基于八叉树的场景剔除配置
     */
    export class OctreeInfo {
        /**
         * @en Whether activate scene culling based on octree
         * @zh 是否启用八叉树加速剔除？
         */
        set enabled(val: boolean);
        get enabled(): boolean;
        /**
         * @en The minimal position of the scene bounding box.
         * Objects entirely outside the bounding box will be culled, other objects will be managed dynamically.
         * @zh 场景包围盒的最小位置，完全超出包围盒的物体会被剔除，其他物体根据情况被动态剔除。
         */
        set minPos(val: math.Vec3);
        get minPos(): math.Vec3;
        /**
         * @en The maximum position of the scene bounding box.
         * Objects entirely outside the bounding box will be culled, other objects will be managed dynamically.
         * @zh 场景包围盒的最大位置，完全超出包围盒的物体会被剔除，其他物体根据情况被动态剔除。
         */
        set maxPos(val: math.Vec3);
        get maxPos(): math.Vec3;
        /**
         * @en The depth of the octree.
         * @zh 八叉树的深度。
         */
        set depth(val: number);
        get depth(): number;
        protected _enabled: boolean;
        protected _minPos: math.Vec3;
        protected _maxPos: math.Vec3;
        protected _depth: number;
        protected _resource: renderer.scene.Octree | null;
        /**
         * @en Activate the octree configuration in the render scene, no need to invoke manually.
         * @zh 在渲染场景中启用八叉树设置，不需要手动调用
         * @param resource The octree configuration object in the render scene
         */
        activate(resource: renderer.scene.Octree): void;
    }
    /**
     * @en All scene related global parameters, it affects all content in the corresponding scene
     * @zh 各类场景级别的渲染参数，将影响全场景的所有物体
     */
    export class SceneGlobals {
        /**
         * @en The environment lighting configuration
         * @zh 场景的环境光照相关配置
         */
        ambient: AmbientInfo;
        /**
         * @en Scene level shadow related configuration
         * @zh 平面阴影相关配置
         */
        shadows: ShadowsInfo;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _skybox: SkyboxInfo;
        /**
         * @en Global fog configuration
         * @zh 全局雾相关配置
         */
        fog: FogInfo;
        /**
         * @en Skybox related configuration
         * @zh 天空盒相关配置
         */
        get skybox(): SkyboxInfo;
        set skybox(value: SkyboxInfo);
        /**
         * @en Octree related configuration
         * @zh 八叉树相关配置
         */
        octree: OctreeInfo;
        /**
         * @en Activate and initialize the global configurations of the scene, no need to invoke manually.
         * @zh 启用和初始化场景全局配置，不需要手动调用
         */
        activate(): void;
    }
    /**
     * @internal
     * @deprecated since v3.5
     */
    export class PrivateNode extends Node {
        constructor(name?: string);
    }
    /**
     * @en Base class for all functional system managed by [[Director]].
     * @zh 功能系统的基类，由 [[Director]] 管理。
     */
    export class System implements ISchedulable {
        static Priority: {
            LOW: number;
            MEDIUM: number;
            HIGH: number;
            SCHEDULER: number;
        };
        protected _id: string;
        protected _priority: number;
        protected _executeInEditMode: boolean;
        set priority(value: number);
        get priority(): number;
        set id(id: string);
        get id(): string;
        /**
         * @en Sorting between different systems.
         * @zh 不同系统间排序。
         * @param a System a
         * @param b System b
         */
        static sortByPriority(a: System, b: System): 0 | 1 | -1;
        /**
         * @en Init the system, will be invoked by [[Director]] when registered, should be implemented if needed.
         * @zh 系统初始化函数，会在注册时被 [[Director]] 调用，如果需要的话应该由子类实现
         */
        init(): void;
        /**
         * @en Update function of the system, it will be invoked between all components update phase and late update phase.
         * @zh 系统的帧更新函数，它会在所有组件的 update 和 lateUpdate 之间被调用
         * @param dt Delta time after the last frame
         */
        update(dt: number): void;
        /**
         * @en Post update function of the system, it will be invoked after all components late update phase and before the rendering process.
         * @zh 系统的帧后处理函数，它会在所有组件的 lateUpdate 之后以及渲染之前被调用
         * @param dt Delta time after the last frame
         */
        postUpdate(dt: number): void;
        destroy(): void;
    }
    /**
     * @en
     * A temp fallback to contain the original component which can not be loaded.
     * @zh
     * 包含无法加载的原始组件的临时回退。
     */
    export class MissingScript extends Component {
        static safeFindClass(id: string): __private._types_globals__Constructor<unknown> | undefined;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _$erialized: null;
        constructor();
        onLoad(): void;
    }
    /**
     * @en
     * The EventHandler class sets the event callback in the scene.
     * This class allows the user to set the callback target node, target component name, component method name, and call the target method through the `emit` method.
     * @zh
     * “EventHandler” 类用来设置场景中的事件回调，该类允许用户设置回调目标节点，目标组件名，组件方法名，并可通过 emit 方法调用目标函数。
     *
     * @example
     * ```ts
     * // Let's say we have a MainMenu component on newTarget
     * // file: MainMenu.ts
     * @ccclass('MainMenu')
     * export class MainMenu extends Component {
     *     // sender: the node MainMenu.ts belongs to
     *     // eventType: CustomEventData
     *     onClick (sender, eventType) {
     *         cc.log('click');
     *     }
     * }
     *
     * import { Component } from 'cc';
     * const eventHandler = new Component.EventHandler();
     * eventHandler.target = newTarget;
     * eventHandler.component = "MainMenu";
     * eventHandler.handler = "OnClick";
     * eventHandler.customEventData = "my data";
     * ```
     */
    export class EventHandler {
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        get _componentName(): any;
        set _componentName(value: any);
        /**
         * @en
         * Dispatching component events.
         * @zh
         * 组件事件派发。
         *
         * @param events - The event list to be emitted
         * @param args - The callback arguments
         */
        static emitEvents(events: EventHandler[], ...args: any[]): void;
        /**
         * @en
         * The node that contains target component
         * @zh
         * 事件响应组件和函数所在节点
         */
        target: Node | null;
        /**
         * @en
         * The name of the component(script) that contains target callback, such as the name 'MainMenu' of the script in the example
         * @zh
         * 事件响应函数所在组件名（脚本名）, 比如例子中的脚本名 'MainMenu'
         */
        component: string;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _componentId: string;
        /**
         * @en
         * Event handler, such as the callback function name 'onClick' in the example
         * @zh
         * 响应事件函数名，比如例子中的 'onClick' 方法名
         */
        handler: string;
        /**
         * @en
         * Custom Event Data
         * @zh
         * 自定义事件数据
         */
        customEventData: string;
        /**
         * @en Trigger the target callback with given arguments
         * @zh 触发目标组件上的指定 handler 函数，可以选择传递参数。
         * @param params - The arguments for invoking the callback
         * @example
         * ```ts
         * import { Component } from 'cc';
         * const eventHandler = new Component.EventHandler();
         * eventHandler.target = newTarget;
         * eventHandler.component = "MainMenu";
         * eventHandler.handler = "OnClick"
         * eventHandler.emit(["param1", "param2", ....]);
         * ```
         */
        emit(params: any[]): void;
    }
    /**
     * @en
     * Base class for everything attached to Node(Entity).<br/>
     * <br/>
     * NOTE: Not allowed to use construction parameters for Component's subclasses,
     *       because Component is created by the engine.
     * @zh
     * 所有附加到节点的基类。<br/>
     * <br/>
     * 注意：不允许使用组件的子类构造参数，因为组件是由引擎创建的。
     */
    export class Component extends CCObject {
        static EventHandler: typeof EventHandler;
        get name(): string;
        set name(value: string);
        /**
         * @en The uuid for editor.
         * @zh 组件的 uuid，用于编辑器。
         * @readOnly
         * @example
         * ```ts
         * import { log } from 'cc';
         * log(comp.uuid);
         * ```
         */
        get uuid(): string;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        get __scriptAsset(): null;
        /**
         * @en Indicates whether this component is enabled or not.
         * @zh 表示该组件自身是否启用。
         * @default true
         * @example
         * ```ts
         * import { log } from 'cc';
         * comp.enabled = true;
         * log(comp.enabled);
         * ```
         */
        get enabled(): boolean;
        set enabled(value: boolean);
        /**
         * @en Indicates whether this component is enabled and its node is also active in the hierarchy.
         * @zh 表示该组件是否被启用并且所在的节点也处于激活状态。
         * @readOnly
         * @example
         * ```ts
         * import { log } from 'cc';
         * log(comp.enabledInHierarchy);
         * ```
         */
        get enabledInHierarchy(): boolean;
        /**
         * @en Returns a value which used to indicate the onLoad get called or not.
         * @zh 返回一个值用来判断 onLoad 是否被调用过，不等于 0 时调用过，等于 0 时未调用。
         * @readOnly
         * @example
         * ```ts
         * import { log } from 'cc';
         * log(this._isOnLoadCalled > 0);
         * ```
         *
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        get _isOnLoadCalled(): number;
        static system: null;
        /**
         * @en The node this component is attached to. A component is always attached to a node.
         * @zh 该组件被附加到的节点。组件总会附加到一个节点。
         * @example
         * ```ts
         * import { log } from 'cc';
         * log(comp.node);
         * ```
         */
        node: Node;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _enabled: boolean;
        /**
         * @internal
         */
        __prefab: Prefab._utils.CompPrefabInfo | null;
        /**
         * @internal
         */
        _sceneGetter: null | (() => renderer.RenderScene);
        /**
         * For internal usage.
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _id: string;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _getRenderScene(): renderer.RenderScene;
        /**
         * @en Adds a component class to the node. You can also add component to node by passing in the name of the script.
         * @zh 向节点添加一个指定类型的组件类，你还可以通过传入脚本的名称来添加组件。
         * @param classConstructor The class of component to be retrieved or to be created
         * @example
         * ```ts
         * import { Sprite } from 'cc';
         * const sprite = node.addComponent(Sprite);
         * ```
         */
        addComponent<T extends Component>(classConstructor: __private._types_globals__Constructor<T>): T | null;
        /**
         * @en Adds a component class to the node. You can also add component to node by passing in the name of the script.
         * @zh 向节点添加一个指定类型的组件类，你还可以通过传入脚本的名称来添加组件。
         * @param className A string for the class name of the component
         * @example
         * ```ts
         * const test = node.addComponent("Test");
         * ```
         */
        addComponent(className: string): Component | null;
        /**
         * @en
         * Returns the component of supplied type if the node has one attached, null if it doesn't.<br/>
         * You can also get component in the node by passing in the name of the script.
         * @zh
         * 获取节点上指定类型的组件，如果节点有附加指定类型的组件，则返回，如果没有则为空。<br/>
         * 传入参数也可以是脚本的名称。
         * @param classConstructor The class of component to be retrieved or to be created
         * @example
         * ```ts
         * import { Sprite } from 'cc';
         * // get sprite component.
         * var sprite = node.getComponent(Sprite);
         * ```
         */
        getComponent<T extends Component>(classConstructor: __private._types_globals__Constructor<T>): T | null;
        /**
         * @en
         * Returns the component of supplied type if the node has one attached, null if it doesn't.<br/>
         * You can also get component in the node by passing in the name of the script.
         * @zh
         * 获取节点上指定类型的组件，如果节点有附加指定类型的组件，则返回，如果没有则为空。<br/>
         * 传入参数也可以是脚本的名称。
         * @param className A string for the class name of the component
         * @example
         * ```ts
         * // get custom test calss.
         * var test = node.getComponent("Test");
         * ```
         */
        getComponent(className: string): Component | null;
        /**
         * @en Returns all components of supplied type in the node.
         * @zh 返回节点上指定类型的所有组件。
         * @param classConstructor The class of components to be retrieved
         * @example
         * ```ts
         * import { Sprite } from 'cc';
         * const sprites = node.getComponents(Sprite);
         * ```
         */
        getComponents<T extends Component>(classConstructor: __private._types_globals__Constructor<T>): T[];
        /**
         * @en Returns all components of supplied type in the node.
         * @zh 返回节点上指定类型的所有组件。
         * @param className A string for the class name of the components
         * @example
         * ```ts
         * const tests = node.getComponents("Test");
         * ```
         */
        getComponents(className: string): Component[];
        /**
         * @en Returns the component of supplied type in any of its children using depth first search.
         * @zh 递归查找所有子节点中第一个匹配指定类型的组件。
         * @param classConstructor The class of component to be retrieved
         * @example
         * ```ts
         * import { Sprite } from 'cc';
         * const sprite = node.getComponentInChildren(Sprite);
         * ```
         */
        getComponentInChildren<T extends Component>(classConstructor: __private._types_globals__Constructor<T>): T | null;
        /**
         * @en Returns the component of supplied type in any of its children using depth first search.
         * @zh 递归查找所有子节点中第一个匹配指定类型的组件。
         * @param className A string for the class name of the component
         * @example
         * ```ts
         * var Test = node.getComponentInChildren("Test");
         * ```
         */
        getComponentInChildren(className: string): Component | null;
        /**
         * @en Returns all components of supplied type in self or any of its children.
         * @zh 递归查找自身或所有子节点中指定类型的组件。
         * @param classConstructor The class of components to be retrieved
         * @example
         * ```ts
         * import { Sprite } from 'cc';
         * const sprites = node.getComponentsInChildren(Sprite);
         * ```
         */
        getComponentsInChildren<T extends Component>(classConstructor: __private._types_globals__Constructor<T>): T[];
        /**
         * @en Returns all components of supplied type in self or any of its children.
         * @zh 递归查找自身或所有子节点中指定类型的组件。
         * @param className A string for the class name of the components
         * @example
         * ```ts
         * const tests = node.getComponentsInChildren("Test");
         * ```
         */
        getComponentsInChildren(className: string): Component[];
        destroy(): boolean;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _onPreDestroy(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _instantiate(cloned?: Component): Component | undefined;
        /**
         * @en
         * Use Scheduler system to schedule a custom task.<br/>
         * If the task is already scheduled, then the interval parameter will be updated without scheduling it again.
         * @zh
         * 使用定时器系统调度一个自定义的回调任务。<br/>
         * 如果回调任务已调度，那么将不会重复调度它，只会更新时间间隔参数。
         * @param callback  The callback function of the task
         * @param interval  The time interval between each invocation
         * @param repeat    The repeat count of this task, the task will be invoked (repeat + 1) times, use [[macro.REPEAT_FOREVER]] to repeat a task forever
         * @param delay     The delay time for the first invocation, Unit: s
         * @example
         * ```ts
         * import { log } from 'cc';
         * this.schedule((dt) => void log(`time: ${dt}`), 1);
         * ```
         */
        schedule(callback: any, interval?: number, repeat?: number, delay?: number): void;
        /**
         * @en Use Scheduler system to schedule a task that runs only once, with a delay of 0 or larger.
         * @zh 使用定时器系统调度一个只运行一次的回调任务，可以指定 0 让回调函数在下一帧立即执行或者在一定的延时之后执行。
         * @method scheduleOnce
         * @see [[schedule]]
         * @param callback  The callback function of the task
         * @param delay  The delay time for the first invocation, Unit: s
         * @example
         * ```ts
         * import { log } from 'cc';
         * this.scheduleOnce((dt) => void log(`time: ${dt}`), 2);
         * ```
         */
        scheduleOnce(callback: any, delay?: number): void;
        /**
         * @en Un-schedules a custom task.
         * @zh 取消调度一个自定义的回调任务。
         * @param callback_fn  The callback function of the task
         * @example
         * ```ts
         * this.unschedule(_callback);
         * ```
         */
        unschedule(callback_fn: any): void;
        /**
         * @en unschedule all scheduled tasks.
         * @zh 取消调度所有已调度的回调函数。
         * @example
         * ```ts
         * this.unscheduleAllCallbacks();
         * ```
         */
        unscheduleAllCallbacks(): void;
        /**
         * @en Update is called every frame, if the Component is enabled.<br/>
         * This is a lifecycle method. It may not be implemented in the super class.<br/>
         * You can only call its super class method inside it. It should not be called manually elsewhere.
         * @zh 如果该组件启用，则每帧调用 update。<br/>
         * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
         * @param dt - the delta time in seconds it took to complete the last frame
         */
        protected update?(dt: number): void;
        /**
         * @en LateUpdate is called every frame, if the Component is enabled.<br/>
         * This is a lifecycle method. It may not be implemented in the super class.<br/>
         * You can only call its super class method inside it. It should not be called manually elsewhere.
         * @zh 如果该组件启用，则每帧调用 LateUpdate。<br/>
         * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
         * @param dt - the delta time in seconds it took to complete the last frame
         */
        protected lateUpdate?(dt: number): void;
        /**
         * @en `__preload` is called before every onLoad.<br/>
         * It is used to initialize the builtin components internally,<br/>
         * to avoid checking whether onLoad is called before every public method calls.<br/>
         * This method should be removed if script priority is supported.
         * @zh `__preload` 在每次onLoad之前调用。<br/>
         * 它用于在内部初始化内置组件，<br/>
         * 以避免在每次公有方法调用之前检查是否调用了onLoad。<br/>
         * 如果支持脚本优先级，则应删除此方法。
         * @private
         */
        protected __preload?(): void;
        /**
         * @en
         * When attaching to an active node or its node first activated.<br/>
         * onLoad is always called before any start functions, this allows you to order initialization of scripts.<br/>
         * This is a lifecycle method. It may not be implemented in the super class.<br/>
         * You can only call its super class method inside it. It should not be called manually elsewhere.
         * @zh
         * 当附加到一个激活的节点上或者其节点第一次激活时候调用。onLoad 总是会在任何 start 方法调用前执行，这能用于安排脚本的初始化顺序。<br/>
         * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
         */
        protected onLoad?(): void;
        /**
         * @en
         * Called before all scripts' update if the Component is enabled the first time.<br/>
         * Usually used to initialize some logic which need to be called after all components' `onload` methods called.<br/>
         * This is a lifecycle method. It may not be implemented in the super class.<br/>
         * You can only call its super class method inside it. It should not be called manually elsewhere.
         * @zh
         * 如果该组件第一次启用，则在所有组件的 update 之前调用。通常用于需要在所有组件的 onLoad 初始化完毕后执行的逻辑。<br/>
         * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
         */
        protected start?(): void;
        /**
         * @en Called when this component becomes enabled and its node is active.<br/>
         * This is a lifecycle method. It may not be implemented in the super class.
         * You can only call its super class method inside it. It should not be called manually elsewhere.
         * @zh 当该组件被启用，并且它的节点也激活时。<br/>
         * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
         */
        protected onEnable?(): void;
        /**
         * @en Called when this component becomes disabled or its node becomes inactive.<br/>
         * This is a lifecycle method. It may not be implemented in the super class.
         * You can only call its super class method inside it. It should not be called manually elsewhere.
         * @zh 当该组件被禁用或节点变为无效时调用。<br/>
         * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
         */
        protected onDisable?(): void;
        /**
         * @en Called when this component will be destroyed.<br/>
         * This is a lifecycle method. It may not be implemented in the super class.<br/>
         * You can only call its super class method inside it. It should not be called manually elsewhere.
         * @zh 当该组件被销毁时调用<br/>
         * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
         */
        protected onDestroy?(): void;
        onFocusInEditor?(): void;
        onLostFocusInEditor?(): void;
        /**
         * @en Called to initialize the component or node’s properties when adding the component the first time or when the Reset command is used.
         * This function is only called in editor.<br/>
         * @zh 用来初始化组件或节点的一些属性，当该组件被第一次添加到节点上或用户点击了它的 Reset 菜单时调用。这个回调只会在编辑器下调用。
         */
        resetInEditor?(): void;
        /**
         * @en
         * If the component's bounding box is different from the node's, you can implement this method to supply
         * a custom axis aligned bounding box (AABB), so the editor's scene view can perform hit test properly.
         * @zh
         * 如果组件的包围盒与节点不同，您可以实现该方法以提供自定义的轴向对齐的包围盒（AABB），
         * 以便编辑器的场景视图可以正确地执行点选测试。
         * @param out_rect - The rect to store the result bounding rect
         * @private
         */
        protected _getLocalBounds?(out_rect: math.Rect): void;
        /**
         * @en
         * onRestore is called after the user clicks the Reset item in the Inspector's context menu or performs
         * an undo operation on this component.<br/>
         * <br/>
         * If the component contains the "internal state", short for "temporary member variables which not included<br/>
         * in its CCClass properties", then you may need to implement this function.<br/>
         * <br/>
         * The editor will call the getset accessors of your component to record/restore the component's state<br/>
         * for undo/redo operation. However, in extreme cases, it may not works well. Then you should implement<br/>
         * this function to manually synchronize your component's "internal states" with its public properties.<br/>
         * Once you implement this function, all the getset accessors of your component will not be called when<br/>
         * the user performs an undo/redo operation. Which means that only the properties with default value<br/>
         * will be recorded or restored by editor.<br/>
         * <br/>
         * Similarly, the editor may failed to reset your component correctly in extreme cases. Then if you need<br/>
         * to support the reset menu, you should manually synchronize your component's "internal states" with its<br/>
         * properties in this function. Once you implement this function, all the getset accessors of your component<br/>
         * will not be called during reset operation. Which means that only the properties with default value<br/>
         * will be reset by editor.
         *
         * This function is only called in editor mode.
         * @zh
         * onRestore 是用户在检查器菜单点击 Reset 时，对此组件执行撤消操作后调用的。<br/>
         * <br/>
         * 如果组件包含了“内部状态”（不在 CCClass 属性中定义的临时成员变量），那么你可能需要实现该方法。<br/>
         * <br/>
         * 编辑器执行撤销/重做操作时，将调用组件的 get set 来录制和还原组件的状态。
         * 然而，在极端的情况下，它可能无法良好运作。<br/>
         * 那么你就应该实现这个方法，手动根据组件的属性同步“内部状态”。
         * 一旦你实现这个方法，当用户撤销或重做时，组件的所有 get set 都不会再被调用。
         * 这意味着仅仅指定了默认值的属性将被编辑器记录和还原。<br/>
         * <br/>
         * 同样的，编辑可能无法在极端情况下正确地重置您的组件。<br/>
         * 于是如果你需要支持组件重置菜单，你需要在该方法中手工同步组件属性到“内部状态”。<br/>
         * 一旦你实现这个方法，组件的所有 get set 都不会在重置操作时被调用。
         * 这意味着仅仅指定了默认值的属性将被编辑器重置。
         * <br/>
         * 此方法仅在编辑器下会被调用。
         */
        protected onRestore?(): void;
    }
    /**
     * @en The Camera Component.
     * @zh 相机组件。
     */
    export class Camera extends Component {
        /**
         * @en The projection type enumeration of the camera.
         * @zh 相机的投影类型枚举。
         */
        static ProjectionType: typeof renderer.scene.CameraProjection;
        /**
         * @en The axis type of the fov
         * @zh FOV 的轴向枚举
         */
        static FOVAxis: typeof renderer.scene.CameraFOVAxis;
        /**
         * @en The clear flag enumeration of the camera.
         * @zh 相机的清除标志位枚举。
         */
        static ClearFlag: {
            SKYBOX: number;
            SOLID_COLOR: gfx.ClearFlagBit;
            DEPTH_ONLY: gfx.ClearFlagBit;
            DONT_CLEAR: gfx.ClearFlagBit;
        };
        /**
         * @en The aperture value's enumeration of the camera.
         * @zh 相机的光圈值枚举。
         */
        static Aperture: typeof renderer.scene.CameraAperture;
        /**
         * @en The shutter value's enumeration of the camera.
         * @zh 相机的快门值枚举。
         */
        static Shutter: typeof renderer.scene.CameraShutter;
        /**
         * @en The ISO value's enumeration of the camera.
         * @zh 相机的感光度值枚举。
         */
        static ISO: typeof renderer.scene.CameraISO;
        /**
         * @en The event for target texture changing.
         * @zh 目标贴图修改的事件。
         */
        static TARGET_TEXTURE_CHANGE: string;
        protected _projection: renderer.scene.CameraProjection;
        protected _priority: number;
        protected _fov: number;
        protected _fovAxis: renderer.scene.CameraFOVAxis;
        protected _orthoHeight: number;
        protected _near: number;
        protected _far: number;
        protected _color: math.Color;
        protected _depth: number;
        protected _stencil: number;
        protected _clearFlags: gfx.ClearFlagBit;
        protected _rect: math.Rect;
        protected _aperture: renderer.scene.CameraAperture;
        protected _shutter: renderer.scene.CameraShutter;
        protected _iso: renderer.scene.CameraISO;
        protected _screenScale: number;
        protected _visibility: number;
        protected _targetTexture: RenderTexture | null;
        protected _camera: renderer.scene.Camera | null;
        protected _inEditorMode: boolean;
        protected _flows: string[] | undefined;
        protected _cameraType: renderer.scene.CameraType;
        protected _trackingType: renderer.scene.TrackingType;
        /**
         * @en The render camera representation.
         * @zh 渲染场景中的相机对象。
         */
        get camera(): renderer.scene.Camera;
        /**
         * @en Render priority of the camera. Cameras with higher depth are rendered after cameras with lower depth.
         * @zh 相机的渲染优先级，值越小越优先渲染。
         */
        get priority(): number;
        set priority(val: number);
        /**
         * @en Visibility mask, declaring a set of node layers that will be visible to this camera.
         * @zh 可见性掩码，声明在当前相机中可见的节点层级集合。
         */
        get visibility(): number;
        set visibility(val: number);
        /**
         * @en Clearing flags of the camera, specifies which part of the framebuffer will be actually cleared every frame.
         * @zh 相机的缓冲清除标志位，指定帧缓冲的哪部分要每帧清除。
         */
        get clearFlags(): gfx.ClearFlagBit;
        set clearFlags(val: gfx.ClearFlagBit);
        /**
         * @en Clearing color of the camera.
         * @zh 相机的颜色缓冲默认值。
         */
        get clearColor(): Readonly<math.Color>;
        set clearColor(val: Readonly<math.Color>);
        /**
         * @en Clearing depth of the camera.
         * @zh 相机的深度缓冲默认值。
         */
        get clearDepth(): number;
        set clearDepth(val: number);
        /**
         * @en Clearing stencil of the camera.
         * @zh 相机的模板缓冲默认值。
         */
        get clearStencil(): number;
        set clearStencil(val: number);
        /**
         * @en Projection type of the camera.
         * @zh 相机的投影类型。
         */
        get projection(): renderer.scene.CameraProjection;
        set projection(val: renderer.scene.CameraProjection);
        /**
         * @en The axis on which the FOV would be fixed regardless of screen aspect changes.
         * @zh 指定视角的固定轴向，在此轴上不会跟随屏幕长宽比例变化。
         */
        get fovAxis(): renderer.scene.CameraFOVAxis;
        set fovAxis(val: renderer.scene.CameraFOVAxis);
        /**
         * @en Field of view of the camera.
         * @zh 相机的视角大小。
         */
        get fov(): number;
        set fov(val: number);
        /**
         * @en Viewport height in orthographic mode.
         * @zh 正交模式下的相机视角高度。
         */
        get orthoHeight(): number;
        set orthoHeight(val: number);
        /**
         * @en Near clipping distance of the camera, should be as large as possible within acceptable range.
         * @zh 相机的近裁剪距离，应在可接受范围内尽量取最大。
         */
        get near(): number;
        set near(val: number);
        /**
         * @en Far clipping distance of the camera, should be as small as possible within acceptable range.
         * @zh 相机的远裁剪距离，应在可接受范围内尽量取最小。
         */
        get far(): number;
        set far(val: number);
        /**
         * @en Camera aperture, controls the exposure parameter.
         * @zh 相机光圈，影响相机的曝光参数。
         */
        get aperture(): renderer.scene.CameraAperture;
        set aperture(val: renderer.scene.CameraAperture);
        /**
         * @en Camera shutter, controls the exposure parameter.
         * @zh 相机快门，影响相机的曝光参数。
         */
        get shutter(): renderer.scene.CameraShutter;
        set shutter(val: renderer.scene.CameraShutter);
        /**
         * @en Camera ISO, controls the exposure parameter.
         * @zh 相机感光度，影响相机的曝光参数。
         */
        get iso(): renderer.scene.CameraISO;
        set iso(val: renderer.scene.CameraISO);
        /**
         * @en Screen viewport of the camera wrt. the sceen size.
         * @zh 此相机最终渲染到屏幕上的视口位置和大小。
         */
        get rect(): math.Rect;
        set rect(val: math.Rect);
        /**
         * @en Output render texture of the camera. Default to null, which outputs directly to screen.
         * @zh 指定此相机的渲染输出目标贴图，默认为空，直接渲染到屏幕。
         */
        get targetTexture(): RenderTexture | null;
        set targetTexture(value: RenderTexture | null);
        /**
         * @en Scale of the internal buffer size,
         * set to 1 to keep the same with the canvas size.
         * @zh 相机内部缓冲尺寸的缩放值, 1 为与 canvas 尺寸相同。
         */
        get screenScale(): number;
        set screenScale(val: number);
        /**
         * @internal
         */
        get inEditorMode(): boolean;
        set inEditorMode(value: boolean);
        get cameraType(): renderer.scene.CameraType;
        set cameraType(val: renderer.scene.CameraType);
        get trackingType(): renderer.scene.TrackingType;
        set trackingType(val: renderer.scene.TrackingType);
        onLoad(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        /**
         * @en Convert a screen space (left-top origin) point to a ray.
         * @zh 将一个屏幕空间（左上角为原点）坐标转换为射线。
         * @param x The x axis position on screen.
         * @param y The y axis position on screen.
         * @param out The output ray object.
         * @returns Return the output ray object.
         */
        screenPointToRay(x: number, y: number, out?: geometry.Ray): geometry.Ray;
        /**
         * @en Convert a world position to a screen space (left-top origin) position.
         * @zh 将一个世界空间坐标转换为屏幕空间（左上角为原点）坐标。
         * @param worldPos The position in world space coordinates
         * @param out The output position in screen space coordinates.
         * @returns Return the output position object.
         */
        worldToScreen(worldPos: math.Vec3 | Readonly<math.Vec3>, out?: math.Vec3): math.Vec3;
        /**
         * @en Convert a screen space (left-top origin) position to a world space position.
         * @zh 将一个屏幕空间（左上角为原点）转换为世界空间坐标。
         * @param screenPos The position in screen space coordinates
         * @param out The output position in world space coordinates
         * @returns Return the output position object.
         */
        screenToWorld(screenPos: math.Vec3, out?: math.Vec3): math.Vec3;
        /**
         * @en Convert a 3D world position to the local coordinates system of the given UI node.
         * The converted position will be related to the given UI node under local space.
         * @zh 将一个 3D 空间世界坐标转换到指定的 UI 本地节点坐标系下。转换后的位置是指定 UI 节点坐标系下的局部偏移。
         * @param wpos @en The world position to convert @zh 需要转换的世界坐标
         * @param uiNode @en The UI node coordinates in which the world position will be convert to @zh 用于同步位置的 UI 节点
         * @param out @en Return the corresponding position of the given world position in the UI node's local coordinates @zh 返回传入的世界坐标在 UI 节点本地坐标系下的局部坐标
         *
         * @example
         * ```ts
         * this.convertToUINode(target.worldPosition, uiNode.parent, out);
         * uiNode.position = out;
         * ```
         */
        convertToUINode(wpos: math.Vec3 | Readonly<math.Vec3>, uiNode: Node, out?: math.Vec3): math.Vec3;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _createCamera(): void;
        protected _attachToScene(): void;
        protected _detachFromScene(): void;
        protected _checkTargetTextureEvent(old: RenderTexture | null): void;
        protected _updateTargetTexture(): void;
    }
    export namespace Camera {
        export type ProjectionType = __private._types_globals__EnumAlias<typeof __private._cocos_core_components_camera_component__ProjectionType>;
        export type FOVAxis = __private._types_globals__EnumAlias<typeof __private._cocos_core_components_camera_component__FOVAxis>;
        export type ClearFlag = __private._types_globals__EnumAlias<typeof __private._cocos_core_components_camera_component__ClearFlag>;
        export type Aperture = __private._types_globals__EnumAlias<typeof __private._cocos_core_components_camera_component__Aperture>;
        export type Shutter = __private._types_globals__EnumAlias<typeof __private._cocos_core_components_camera_component__Shutter>;
        export type ISO = __private._types_globals__EnumAlias<typeof __private._cocos_core_components_camera_component__ISO>;
    }
    /**
     * @en Base class for all rendering components containing model.
     * @zh 所有包含 model 的渲染组件基类。
     */
    export class ModelRenderer extends Renderer {
        /**
         * @en The visibility which will be applied to the committed models.
         * @zh 应用于所有提交渲染的 Model 的可见性
         */
        get visibility(): number;
        set visibility(val: number);
        /**
         * @en The priority which will be applied to the committed models.(Valid only in transparent queues)
         * @zh 应用于所有提交渲染的 Model 的排序优先级（只在半透明渲染队列中起效）
         */
        get priority(): number;
        set priority(val: number);
        protected _visFlags: number;
        protected _models: renderer.scene.Model[];
        protected _priority: number;
        /**
         * @zh 收集组件中的 models
         * @en Collect the models in this component.
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _collectModels(): renderer.scene.Model[];
        protected onEnable(): void;
        protected _attachToScene(): void;
        protected _detachFromScene(): void;
        protected _onVisibilityChange(val: any): void;
        protected _updatePriority(): void;
    }
    /**
     * @en Base class for all components which can submit contents for the rendering process.
     * It manages a series of [[renderer.Model]]s and the visibility, the materials and the material instances of the models.
     * There are several different material properties that must be distinguished clearly and used with caution:
     * - [[sharedMaterials]] are shared for all component instances that are using the same material asset, modification will be applied universally.
     * - [[materials]] are instances created independently for the component instance, modification will only be applied for the component instance.
     * - Render Materials retrieved by [[getRenderMaterial]] are materials used for the actual rendering process, material instances are used if exist.
     * By default, shared materials are used for rendering.
     * Material instances are created only when user try to retrieve a material instance with [[material]], [[materials]] and [[getMaterialInstance]].
     * @zh 所有可以提交内容到渲染流程的可渲染类的基类，它管理着一组 [[renderer.Model]]，以及它们的可见性、材质和材质实例。
     * 下面是这个组件所管理的各种材质属性的解释，需要正确区分并小心使用：
     * - [[sharedMaterials]] 是共享材质，所有使用此材质资源的组件实例都默认使用材质的共享实例对象，所有修改都会影响所有使用它的组件实例。
     * - [[materials]] 是专为组件对象创建的独立材质实例，所有修改仅会影响当前组件对象。
     * - 使用 [[getRenderMaterial]] 获取的渲染材质是用于实际渲染流程的材质对象，当存在材质实例的时候，永远使用材质实例。
     * 默认情况下，渲染组件使用共享材质进行渲染，材质实例也不会被创建出来。仅在用户通过 [[material]]，[[materials]] 和 [[getMaterialInstance]] 接口获取材质时才会创建材质实例。
     */
    export class Renderer extends Component {
        /**
         * @en Get the default shared material
         * @zh 获取默认的共享材质
         */
        get sharedMaterial(): Material | null;
        /**
         * @en All shared materials of model
         * @zh 模型的所有共享材质
         */
        get sharedMaterials(): (Material | null)[];
        set sharedMaterials(val: (Material | null)[]);
        /**
         * @en The default material instance, it will create a new instance from the default shared material if not created yet.
         * @zh 获取默认的材质实例，如果还没有创建，将会根据默认共享材质创建一个新的材质实例
         */
        get material(): renderer.MaterialInstance | null;
        set material(val: Material | renderer.MaterialInstance | null);
        /**
         * @en The materials of the model.
         * @zh 所有模型材质。
         */
        get materials(): (renderer.MaterialInstance | null)[];
        set materials(val: (Material | renderer.MaterialInstance | null)[]);
        protected _materials: (Material | null)[];
        protected _materialInstances: (renderer.MaterialInstance | null)[];
        /**
         * @en Get the shared material asset of the specified sub-model.
         * @zh 获取指定子模型的共享材质资源。
         */
        getMaterial(idx: number): Material | null;
        /**
         * @en Set the shared material asset of the specified sub-model,
         * new material instance will be created automatically if the sub-model is already using one.
         * @zh 设置指定子模型的 sharedMaterial，如果对应位置有材质实例则会创建一个对应的材质实例。
         */
        setMaterial(material: Material | null, index: number): void;
        /**
         * @en Get the material instance of the specified sub-model.
         * It will create a new instance from the corresponding shared material if not created yet.
         * @zh 获取指定子模型的材质实例。如果还没有创建，将会根据对应的共享材质创建一个新的材质实例
         */
        getMaterialInstance(idx: number): renderer.MaterialInstance | null;
        /**
         * @en Set the material instance of the specified sub-model.
         * @zh 获取指定子模型的材质实例。
         */
        setMaterialInstance(matInst: Material | renderer.MaterialInstance | null, index: number): void;
        /**
         * @en Get the actual rendering material of the specified sub-model.
         * (material instance if there is one, or the shared material asset)
         * @zh 获取指定位置可供渲染的材质，如果有材质实例则使用材质实例，如果没有则使用材质资源
         */
        getRenderMaterial(index: number): Material | null;
        protected _onMaterialModified(index: number, material: Material | null): void;
        protected _onRebuildPSO(index: number, material: Material | null): void;
        protected _clearMaterials(): void;
    }
    export const builtinResMgr: __private._cocos_core_builtin_builtin_res_mgr__BuiltinResMgr;
    /**
     * @en
     * Real curve.
     *
     * The real curve is a kind of keyframe curve.
     * When evaluating a real curve:
     * - If the input is just the time of a keyframe,
     *   keyframe value's numeric value is used as result.
     * - Otherwise, if the input is less than the time of the first keyframe or
     *   is greater than the time of the last keyframe time, it performs so-called extrapolation.
     * - Otherwise, the input falls between two keyframes and then it interpolates between the two keyframes.
     *
     * Every keyframe may specify an interpolation mode
     * to indicates how to perform the interpolation
     * from current keyframe to next keyframe.
     * Interpolation modes of keyframes may differ from each other.
     *
     * Real curve allows three interpolation modes: constant, linear and cubic.
     * The constant and linear mode is easy.
     * In case of cubic interpolation,
     * the interpolation algorithm is effectively equivalent to cubic bezier(or cubic hermite) interpolation.
     *
     * Related quantities related to cubic interpolation are:
     * - Keyframe times and numeric values.
     * - The tangent and tangent weight of the previous keyframe and next keyframe.
     *
     * While performing the cubic bezier interpolation,
     * The first control point is calculated from right tangent and right tangent weight of previous keyframe,
     * the second control point is calculated from left tangent and left tangent weight of next keyframe.
     *
     * In equivalent bezier representation,
     * the tangent is the line slope between sample point and control point
     * and the tangent weight is the distance between sample point and control point.
     * The tangent weight on either side can be marked as "not specified" through tangent weight mode.
     * If either side weight is not specified,
     * the tangent weight is treated at `sqrt(d_t^2 + (d_t * tangent)^2) * (1 / 3)`
     * where `d_t` is the difference between two keyframes 's time and `tangent` is the tangent of that side.
     *
     * Note, in some cases, tangent/tangent weight/tangent weight mode may be "meaningless".
     * The meaningless means that value can may not be stored(or serialized).
     * @zh
     * 实数曲线。
     *
     * 实数曲线是关键帧曲线的一种。
     * 在求值实数曲线时：
     * - 若输入正好就是关键帧上的时间，关键帧上的数值就作为结果。
     * - 否则，如果输入小于第一个关键帧上的时间或大于最后一个关键帧上的时间，它会进行所谓的外推。
     * - 否则，输入落于两帧之间，将通过插值两帧得到结果。
     *
     * 每个关键帧都可以指定插值模式，
     * 以表示从当前帧数值变化到下一帧数值所采用的插值算法，
     * 每个关键帧的插值模式都可以是各不相同的。
     *
     * 实数曲线允许三种插值模式：常量、线性和三次方的（也称立方）。
     * 常量和线性模式都比较简单。
     * 在三次插值的情况下，插值算法实质上等价于三次贝塞尔（或三次埃尔米特）插值。
     *
     * 三次插值的相关量有：
     * - 关键帧上的时间和数值；
     * - 前一关键帧和后一关键帧上的切线和切线权重。
     *
     * 当两帧之间进行三次贝塞尔曲线插值时，
     * 会取前一帧的右切线、右切线权重来计算出第一个控制点，
     * 会取后一帧的左切线、左切线权重来计算出第二个控制点。
     *
     * 在等效的贝塞尔表示中，
     * 切线就是样本点和控制点之间的切线斜率，而切线权重就是样本点和控制点之间的距离。
     * 任意一端的切线权重都可以通过切线权重模式来标记为“未指定的”。
     * 若任意一端的切线权重是未指定的，
     * 此端上的切线权重将被视为 `sqrt(d_t^2 + (d_t * tangent)^2) * (1 / 3)`，其中，
     * `d_t` 是两帧时间的差，`tangent` 是此端上的切线。
     *
     * 注意，切线/切线权重/切线权重模式在某些情况下可能是“无意义的”。
     * 无意义意味着这些值可能不会被存储或序列化。
     */
    export class RealCurve extends __private._cocos_core_curves_keyframe_curve__KeyframeCurve<RealKeyframeValue> {
        /**
         * @en
         * Gets or sets the pre-extrapolation-mode of this curve.
         * Defaults to `ExtrapolationMode.CLAMP`.
         * @zh
         * 获取或设置此曲线的前向外推模式。
         * 默认为 `ExtrapolationMode.CLAMP`。
         */
        preExtrapolation: ExtrapolationMode;
        /**
         * @en
         * Gets or sets the post-extrapolation-mode of this curve.
         * Defaults to `ExtrapolationMode.CLAMP`.
         * @zh
         * 获取或设置此曲线的后向外推模式。
         * 默认为 `ExtrapolationMode.CLAMP`。
         */
        postExtrapolation: ExtrapolationMode;
        /**
         * @en
         * Evaluates this curve at specified time.
         * @zh
         * 计算此曲线在指定时间上的值。
         * @param time Input time.
         * @returns Result value.
         */
        evaluate(time: number): number;
        /**
         * @en
         * Adds a keyframe into this curve.
         * @zh
         * 添加一个关键帧到此曲线。
         * @param time Time of the keyframe.
         * @param value Value of the keyframe.
         * @returns The index to the new keyframe.
         */
        addKeyFrame(time: number, value: __private._cocos_core_curves_curve__RealKeyframeValueParameters): number;
        /**
         * @en
         * Assigns all keyframes.
         * @zh
         * 赋值所有关键帧。
         * @param keyframes An iterable to keyframes. The keyframes should be sorted by their time.
         */
        assignSorted(keyframes: Iterable<[
            number,
            __private._cocos_core_curves_curve__RealKeyframeValueParameters
        ]>): void;
        /**
         * Assigns all keyframes.
         * @param times Times array. Should be sorted.
         * @param values Values array. Corresponding to each time in `times`.
         */
        assignSorted(times: readonly number[], values: __private._cocos_core_curves_curve__RealKeyframeValueParameters[]): void;
        /**
         * @en
         * Returns if this curve is constant.
         * @zh
         * 返回此曲线是否是常量曲线。
         * @param tolerance The tolerance.
         * @returns Whether it is constant.
         */
        isConstant(tolerance: number): boolean;
        /**
         * @internal
         */
        [serializeTag](output: SerializationOutput, context: SerializationContext): void;
        /**
         * @internal
         */
        [deserializeTag](input: SerializationInput, context: __private._cocos_core_data_custom_serializable__DeserializationContext): void;
    }
    /**
     * @en
     * The method used for interpolation method between value of a keyframe and its next keyframe.
     * @zh
     * 在某关键帧（前一帧）和其下一帧之间插值时使用的插值方式。
     */
    export enum RealInterpolationMode {
        /**
         * @en
         * Perform linear interpolation between previous keyframe value and next keyframe value.
         * @zh
         * 在前一帧和后一帧之间执行线性插值。
         */
        LINEAR = 0,
        /**
         * @en
         * Always use the value from this keyframe.
         * @zh
         * 永远使用前一帧的值。
         */
        CONSTANT = 1,
        /**
         * @en
         * Perform cubic(hermite) interpolation between previous keyframe value and next keyframe value.
         * @zh
         * 在前一帧和后一帧之间执行立方插值。
         */
        CUBIC = 2
    }
    /**
     * @en
     * Specifies how to extrapolate the value
     * if input time is underflow(less than the the first frame time) or
     * overflow(greater than the last frame time) when evaluating an curve.
     * @zh
     * 在求值曲线时，指定当输入时间下溢（小于第一帧的时间）或上溢（大于最后一帧的时间）时应该如何推断结果值。
     */
    export enum ExtrapolationMode {
        /**
         * @en
         * Compute the result
         * according to the first two frame's linear trend in the case of underflow and
         * according to the last two frame's linear trend in the case of overflow.
         * If there are less than two frames, fallback to `CLAMP`.
         * @zh
         * 下溢时，根据前两帧的线性趋势计算结果；上溢时，根据最后两帧的线性趋势计算结果。
         * 如果曲线帧数小于 2，回退到  `CLAMP`。
         */
        LINEAR = 0,
        /**
         * @en
         * Use first frame's value in the case of underflow,
         * use last frame's value in the case of overflow.
         * @zh
         * 下溢时，使用第一帧的值；上溢时，使用最后一帧的值。
         */
        CLAMP = 1,
        /**
         * @en
         * Computes the result as if the curve is infinitely and continuously looped.
         * @zh
         * 求值时将该曲线视作是无限连续循环的。
         */
        LOOP = 2,
        /**
         * @en
         * Computes the result as if the curve is infinitely and continuously looped in a ping-pong manner.
         * @zh
         * 求值时将该曲线视作是以“乒乓”的形式无限连续循环的。
         */
        PING_PONG = 3
    }
    /**
     * @en
     * Specifies both side tangent weight mode of a keyframe value.
     * @zh
     * 指定关键帧两侧的切线权重模式。
     */
    export enum TangentWeightMode {
        /**
         * @en
         * Neither side of the keyframe carries tangent weight information.
         * @zh
         * 关键帧的两侧都不携带切线权重信息。
         */
        NONE = 0,
        /**
         * @en
         * Only left side of the keyframe carries tangent weight information.
         * @zh
         * 仅关键帧的左侧携带切线权重信息。
         */
        LEFT = 1,
        /**
         * @en
         * Only right side of the keyframe carries tangent weight information.
         * @zh
         * 仅关键帧的右侧携带切线权重信息。
         */
        RIGHT = 2,
        /**
         * @en
         * Both sides of the keyframe carries tangent weight information.
         * @zh
         * 关键帧的两侧都携带切线权重信息。
         */
        BOTH = 3
    }
    /**
     * @en View to a real frame value.
     * Note, the view may be invalidated due to keyframe change/add/remove.
     * @zh 实数帧值的视图。
     * 注意，该视图可能因关键帧的添加、改变、移除而失效。
     */
    export class RealKeyframeValue extends __private._cocos_core_data_editor_extendable__EditorExtendable {
        /**
         * @en
         * When perform interpolation, the interpolation method should be taken
         * when for this keyframe is used as starting keyframe.
         * @zh
         * 在执行插值时，当以此关键帧作为起始关键帧时应当使用的插值方式。
         */
        get interpolationMode(): RealInterpolationMode;
        set interpolationMode(value: RealInterpolationMode);
        /**
         * @en
         * Tangent weight mode when perform cubic interpolation
         * This field is regarded if current interpolation mode is not cubic.
         * @zh
         * 当执行三次插值时，此关键帧使用的切线权重模式。
         * 若当前的插值模式不是三次插值时，该字段无意义。
         */
        get tangentWeightMode(): TangentWeightMode;
        set tangentWeightMode(value: TangentWeightMode);
        /**
         * @en
         * Value of the keyframe.
         * @zh
         * 该关键帧的值。
         */
        value: number;
        /**
         * @en
         * The tangent of this keyframe
         * when it's used as starting point during cubic interpolation.
         * Regarded otherwise.
         * @zh
         * 当此关键帧作为三次插值的起始点时，此关键帧的切线。其他情况下该字段无意义。
         */
        rightTangent: number;
        /**
         * @en
         * The tangent weight of this keyframe
         * when it's used as starting point during weighted cubic interpolation.
         * Regarded otherwise.
         * @zh
         * 当此关键帧作为三次插值的起始点时，此关键帧的切线权重。其他情况下该字段无意义。
         */
        rightTangentWeight: number;
        /**
         * @en
         * The tangent of this keyframe
         * when it's used as ending point during cubic interpolation.
         * Regarded otherwise.
         * @zh
         * 当此关键帧作为三次插值的目标点时，此关键帧的切线。其他情况下该字段无意义。
         */
        leftTangent: number;
        /**
         * @en
         * The tangent weight of this keyframe
         * when it's used as ending point during weighted cubic interpolation.
         * Regarded otherwise.
         * @zh
         * 当此关键帧作为三次插值的目标点时，此关键帧的切线权重。其他情况下该字段无意义。
         */
        leftTangentWeight: number;
        /**
         * @deprecated Reserved for backward compatibility. Will be removed in future.
         */
        get easingMethod(): __private._cocos_core_curves_easing_method__EasingMethod;
        set easingMethod(value: __private._cocos_core_curves_easing_method__EasingMethod);
    }
    /**
     * @en
     * Quaternion curve.
     * @zh
     * 四元数曲线
     */
    export class QuatCurve extends __private._cocos_core_curves_keyframe_curve__KeyframeCurve<QuatKeyframeValue> {
        /**
         * @en
         * Gets or sets the pre-extrapolation-mode of this curve.
         * Defaults to `ExtrapolationMode.CLAMP`.
         * @zh
         * 获取或设置此曲线的前向外推模式。
         * 默认为 `ExtrapolationMode.CLAMP`。
         */
        preExtrapolation: ExtrapolationMode;
        /**
         * @en
         * Gets or sets the post-extrapolation-mode of this curve.
         * Defaults to `ExtrapolationMode.CLAMP`.
         * @zh
         * 获取或设置此曲线的后向外推模式。
         * 默认为 `ExtrapolationMode.CLAMP`。
         */
        postExtrapolation: ExtrapolationMode;
        /**
         * @en
         * Evaluates this curve at specified time.
         * @zh
         * 计算此曲线在指定时间上的值。
         * @param time Input time.
         * @param quat If specified, this value will be filled and returned.
         * Otherwise a new quaternion object will be filled and returned.
         * @returns Result value.
         */
        evaluate(time: number, quat?: math.Quat): math.Quat;
        /**
         * Adds a keyframe into this curve.
         * @param time Time of the keyframe.
         * @param value Value of the keyframe.
         * @returns The index to the new keyframe.
         */
        addKeyFrame(time: number, value: __private._cocos_core_curves_quat_curve__QuatKeyframeValueParameters): number;
        /**
         * Assigns all keyframes.
         * @param keyframes An iterable to keyframes. The keyframes should be sorted by their time.
         */
        assignSorted(keyframes: Iterable<[
            number,
            __private._cocos_core_curves_quat_curve__QuatKeyframeValueParameters
        ]>): void;
        /**
         * Assigns all keyframes.
         * @param times Times array. Should be sorted.
         * @param values Values array. Corresponding to each time in `times`.
         */
        assignSorted(times: readonly number[], values: __private._cocos_core_curves_quat_curve__QuatKeyframeValueParameters[]): void;
        /**
         * @internal
         */
        [serializeTag](output: SerializationOutput, context: SerializationContext): void;
        /**
         * @internal
         */
        [deserializeTag](input: SerializationInput, context: __private._cocos_core_data_custom_serializable__DeserializationContext): void;
    }
    /**
     * @en
     * The method used for interpolation between values of a quaternion keyframe and its next keyframe.
     * @zh
     * 在某四元数关键帧（前一帧）和其下一帧之间插值时使用的插值方式。
     */
    export enum QuatInterpolationMode {
        /**
         * @en
         * Perform spherical linear interpolation between previous keyframe value and next keyframe value.
         * @zh
         * 在前一帧和后一帧之间执行球面线性插值。
         */
        SLERP = 0,
        /**
         * @en
         * Always use the value from this keyframe.
         * @zh
         * 永远使用前一帧的值。
         */
        CONSTANT = 1
    }
    /**
     * View to a quaternion frame value.
     * Note, the view may be invalidated due to keyframe change/add/remove.
     */
    export class QuatKeyframeValue {
        /**
         * @en
         * When perform interpolation, the interpolation method should be taken
         * when for this keyframe is used as starting keyframe.
         * @zh
         * 在执行插值时，当以此关键帧作为起始关键帧时应当使用的插值方式。
         */
        interpolationMode: QuatInterpolationMode;
        /**
         * @en
         * Value of the keyframe.
         * @zh
         * 该关键帧的值。
         */
        value: math.IQuatLike;
        /**
         * @internal Reserved for backward compatibility. Will be removed in future.
         */
        easingMethod: __private._cocos_core_curves_easing_method__EasingMethod | [
            number,
            number,
            number,
            number
        ];
        constructor({ value, interpolationMode, easingMethod, }?: Partial<QuatKeyframeValue>);
    }
    export class ObjectCurve<T> extends __private._cocos_core_curves_keyframe_curve__KeyframeCurve<ObjectCurveKeyframe<T>> {
        evaluate(time: number): T;
    }
    export type ObjectCurveKeyframe<T> = T;
    /**
     * @zh
     * 配置模块用于获取 settings.json 配置文件中的配置信息，同时你可以覆盖一些配置从而影响引擎的启动和运行，可参考 [game.init] 的参数选项说明。你可以通过 [settings] 访问此模块单例。
     * @en
     * The Settings module is used to get the configuration information in the settings.json configuration file,
     * and you can override some of the configuration to affect the launch and running of the engine, as described in the [game.init] parameter options.
     * You can access this single instance of the module via [settings].
     */
    export class Settings {
        static Category: typeof __private._cocos_core_settings__Category;
        /**
         * Initialization
         * @internal
         */
        init(path?: string, overrides?: Record<string, any>): Promise<void>;
        /**
         * @zh
         * 覆盖一部分配置数据。
         *
         * @en
         * Override some configuration info in Settings module.
         *
         * @param category @en The category you want to override. @zh 想要覆盖的分组。
         * @param name @en The name of the configuration in the category you want to override. @zh 分组中想要覆盖的具体配置名称。
         * @param value @en The value of the configuration you want to override. @zh 想要覆盖的具体值。
         *
         * @example
         * ```ts
         * console.log(settings.querySettings(Settings.Category.ASSETS, 'server')); // print https://www.cocos.com
         * settings.overrideSettings(Settings.Category.ASSETS, 'server', 'http://www.test.com');
         * console.log(settings.querySettings(Settings.Category.ASSETS, 'server')); // print http://www.test.com
         * ```
         */
        overrideSettings<T = any>(category: __private._cocos_core_settings__Category | string, name: string, value: T): void;
        /**
         * @zh
         * 查询配置模块中具体分组中的具体配置值。
         *
         * @en
         * Query specific configuration values in specific category in the settings module.
         *
         * @param category @en The name of category to query. @zh 想要查询的分组名称。
         * @param name @en The name of configuration in category to query. @zh 分组中想要查询的具体的配置名称。
         * @returns @en The value of configuration to query. @zh 想要查询的具体配置值。
         *
         * @example
         * ```ts
         * console.log(settings.querySettings(Settings.Category.ENGINE, 'debug')); // print false
         * ```
         */
        querySettings<T = any>(category: __private._cocos_core_settings__Category | string, name: string): T | null;
    }
    export namespace Settings {
        export type Category = typeof __private._cocos_core_settings__Category;
    }
    /**
     * @zh
     * Settings 模块单例，你能通过此单例访问 settings.json 中的配置数据。
     * @en
     * Settings module singleton, through this you can access the configuration data in settings.json.
     */
    export const settings: Settings;
    export function getRenderArea(camera: renderer.scene.Camera, width: number, height: number, light?: renderer.scene.Light | null, level?: number): gfx.Rect;
    export function buildShadowPass(passName: Readonly<string>, ppl: __private._cocos_core_pipeline_custom_pipeline__Pipeline, camera: renderer.scene.Camera, light: renderer.scene.Light, level: number, width: Readonly<number>, height: Readonly<number>): void;
    export function buildShadowPasses(cameraName: string, camera: renderer.scene.Camera, ppl: __private._cocos_core_pipeline_custom_pipeline__Pipeline): __private._cocos_core_pipeline_custom_builtin_pipelines__CameraInfo;
    export function getCameraUniqueID(camera: renderer.scene.Camera): number;
    export function getLoadOpOfClearFlag(clearFlag: gfx.ClearFlagBit, attachment: __private._cocos_core_pipeline_custom_types__AttachmentType): gfx.LoadOp;
    export function validPunctualLightsCulling(pipeline: __private._cocos_core_pipeline_custom_pipeline__Pipeline, camera: renderer.scene.Camera): void;
    export class ForwardPipelineBuilder extends __private._cocos_core_pipeline_custom_pipeline__PipelineBuilder {
        setup(cameras: renderer.scene.Camera[], ppl: __private._cocos_core_pipeline_custom_pipeline__Pipeline): void;
    }
    export enum AntiAliasing {
        NONE = 0,
        FXAA = 1
    }
    export class DeferredPipelineBuilder extends __private._cocos_core_pipeline_custom_pipeline__PipelineBuilder {
        setup(cameras: renderer.scene.Camera[], ppl: __private._cocos_core_pipeline_custom_pipeline__Pipeline): void;
        readonly _deferredData: __private._cocos_core_pipeline_custom_builtin_pipelines__DeferredData;
    }
    /**
     * @en
     *  `NodePool` is the cache pool designed for node type.<br/>
     *  It can helps you to improve your game performance for objects which need frequent release and recreate operations<br/>
     *
     * It's recommended to create `NodePool` instances by node type, the type corresponds to node type in game design, not the class,
     * for example, a prefab is a specific node type. <br/>
     * When you create a node pool, you can pass a Component which contains `unuse`, `reuse` functions to control the content of node.<br/>
     *
     * Some common use case is :<br/>
     *      1. Bullets in game (die very soon, massive creation and recreation, no side effect on other objects)<br/>
     *      2. Blocks in candy crash (massive creation and recreation)<br/>
     *      etc...
     * @zh
     * `NodePool` 是用于管理节点对象的对象缓存池。<br/>
     * 它可以帮助您提高游戏性能，适用于优化对象的反复创建和销毁<br/>
     * 以前 cocos2d-x 中的 pool 和新的节点事件注册系统不兼容，因此请使用 `NodePool` 来代替。
     *
     * 新的 NodePool 需要实例化之后才能使用，每种不同的节点对象池需要一个不同的对象池实例，这里的种类对应于游戏中的节点设计，一个 prefab 相当于一个种类的节点。<br/>
     * 在创建缓冲池时，可以传入一个包含 unuse, reuse 函数的组件类型用于节点的回收和复用逻辑。<br/>
     *
     * 一些常见的用例是：<br/>
     *      1.在游戏中的子弹（死亡很快，频繁创建，对其他对象无副作用）<br/>
     *      2.糖果粉碎传奇中的木块（频繁创建）。
     *      等等....
     */
    export class NodePool {
        /**
         * @en The pool handler component, it could be the class name or the constructor.
         * @zh 缓冲池处理组件，用于节点的回收和复用逻辑，这个属性可以是组件类名或组件的构造函数。
         */
        poolHandlerComp?: __private._extensions_ccpool_node_pool__Constructor<__private._extensions_ccpool_node_pool__IPoolHandlerComponent> | string;
        /**
         * @en
         * Constructor for creating a pool for a specific node template (usually a prefab).
         * You can pass a component (type or name) argument for handling event for reusing and recycling node.
         * @zh
         * 使用构造函数来创建一个节点专用的对象池，您可以传递一个组件类型或名称，用于处理节点回收和复用时的事件逻辑。
         * @param poolHandlerComp @en The constructor or the class name of the component to control the unuse/reuse logic. @zh 处理节点回收和复用事件逻辑的组件类型或名称。
         * @example
         * import { NodePool, Prefab } from 'cc';
         *  properties: {
         *      template: Prefab
         *     },
         *     onLoad () {
         *       // MyTemplateHandler is a component with 'unuse' and 'reuse' to handle events when node is reused or recycled.
         *       this.myPool = new NodePool('MyTemplateHandler');
         *     }
         *  }
         */
        constructor(poolHandlerComp?: __private._extensions_ccpool_node_pool__Constructor<__private._extensions_ccpool_node_pool__IPoolHandlerComponent> | string);
        /**
         * @en The current available size in the pool
         * @zh 获取当前缓冲池的可用对象数量
         */
        size(): number;
        /**
         * @en Destroy all cached nodes in the pool
         * @zh 销毁对象池中缓存的所有节点
         */
        clear(): void;
        /**
         * @en Put a new Node into the pool.
         * It will automatically remove the node from its parent without cleanup.
         * It will also invoke unuse method of the poolHandlerComp if exist.
         * @zh 向缓冲池中存入一个不再需要的节点对象。
         * 这个函数会自动将目标节点从父节点上移除，但是不会进行 cleanup 操作。
         * 这个函数会调用 poolHandlerComp 的 unuse 函数，如果组件和函数都存在的话。
         * @example
         * import { instantiate } from 'cc';
         * const myNode = instantiate(this.template);
         * this.myPool.put(myNode);
         */
        put(obj: Node): void;
        /**
         * @en Get a obj from pool, if no available object in pool, null will be returned.
         * This function will invoke the reuse function of poolHandlerComp if exist.
         * @zh 获取对象池中的对象，如果对象池没有可用对象，则返回空。
         * 这个函数会调用 poolHandlerComp 的 reuse 函数，如果组件和函数都存在的话。
         * @param args - 向 poolHandlerComp 中的 'reuse' 函数传递的参数
         * @example
         *   let newNode = this.myPool.get();
         */
        get(...args: any[]): Node | null;
    }
    /**
     * @en The event type supported by SystemEvent and Node events
     * @zh SystemEvent 支持的事件类型以及节点事件类型
     *
     * @deprecated since v3.3.0, please use Input.EventType instead
     */
    export enum SystemEventType {
        /**
         * @en
         * The event type for touch start event
         *
         * @zh
         * 手指开始触摸事件。
         */
        TOUCH_START = "touch-start",
        /**
         * @en
         * The event type for touch move event
         *
         * @zh
         * 当手指在屏幕上移动时。
         */
        TOUCH_MOVE = "touch-move",
        /**
         * @en
         * The event type for touch end event
         *
         * @zh
         * 手指结束触摸事件。
         */
        TOUCH_END = "touch-end",
        /**
         * @en
         * The event type for touch end event
         *
         * @zh
         * 当手指在目标节点区域外离开屏幕时。
         */
        TOUCH_CANCEL = "touch-cancel",
        /**
         * @en
         * The event type for mouse down events
         *
         * @zh
         * 当鼠标按下时触发一次。
         */
        MOUSE_DOWN = "mouse-down",
        /**
         * @en
         * The event type for mouse move events
         *
         * @zh
         * 当鼠标在目标节点在目标节点区域中移动时，不论是否按下。
         */
        MOUSE_MOVE = "mouse-move",
        /**
         * @en
         * The event type for mouse up events
         *
         * @zh
         * 当鼠标从按下状态松开时触发一次。
         */
        MOUSE_UP = "mouse-up",
        /**
         * @en
         * The event type for mouse wheel events
         *
         * @zh 当滚动鼠标滚轮或操作其它类似输入设备时会触发滚轮事件。
         */
        MOUSE_WHEEL = "mouse-wheel",
        /**
         * @en
         * The event type for mouse leave target events
         *
         * @zh
         * 当鼠标移入目标节点区域时，不论是否按下.
         *
         * @deprecated since v3.3, please use Node.EventType.MOUSE_ENTER instead.
         */
        MOUSE_ENTER = "mouse-enter",
        /**
         * @en
         * The event type for mouse leave target events
         *
         * @zh
         * 当鼠标移出目标节点区域时，不论是否按下。
         *
         * @deprecated since v3.3, please use Node.EventType.MOUSE_LEAVE instead.
         */
        MOUSE_LEAVE = "mouse-leave",
        /**
         * @en The event type for the key down event, the event will be continuously dispatched in the key pressed state
         * @zh 当按下按键时触发的事件, 该事件在按下状态会持续派发
         */
        KEY_DOWN = "keydown",
        /**
         * @en The event type for the key up event
         * @zh 当松开按键时触发的事件
         */
        KEY_UP = "keyup",
        /**
         * @en
         * The event type for the devicemotion event
         *
         * @zh
         * 重力感应
         */
        DEVICEMOTION = "devicemotion",
        /**
         * @en
         * The event type for position, rotation, scale changed.Use the type parameter as [[Node.TransformBit]] to check which part is changed
         *
         * @zh
         * 节点改变位置、旋转或缩放事件。如果具体需要判断是哪一个事件，可通过判断回调的第一个参数类型是 [[Node.TransformBit]] 中的哪一个来获取
         * @example
         * ```
         * this.node.on(Node.EventType.TRANSFORM_CHANGED, (type)=>{
         *  if (type & Node.TransformBit.POSITION) {
         *       //...
         *   }
         * }, this);
         * ```
         *
         * @deprecated since v3.3, please use Node.EventType.TRANSFORM_CHANGED instead
         */
        TRANSFORM_CHANGED = "transform-changed",
        /**
         * @en The event type for notifying the host scene has been changed for a persist node.
         * @zh 当场景常驻节点的场景发生改变时触发的事件，一般在切换场景过程中触发。
         *
         * @deprecated since v3.3, please use Node.EventType.SCENE_CHANGED_FOR_PERSISTS instead
         */
        SCENE_CHANGED_FOR_PERSISTS = "scene-changed-for-persists",
        /**
         * @en
         * The event type for size change events.
         * Performance note, this event will be triggered every time corresponding properties being changed,
         * if the event callback have heavy logic it may have great performance impact, try to avoid such scenario.
         *
         * @zh
         * 当节点尺寸改变时触发的事件。
         * 性能警告：这个事件会在每次对应的属性被修改时触发，如果事件回调损耗较高，有可能对性能有很大的负面影响，请尽量避免这种情况。
         *
         * @deprecated since v3.3, please use Node.EventType.SIZE_CHANGED instead
         */
        SIZE_CHANGED = "size-changed",
        /**
         * @en
         * The event type for anchor point change events.
         * Performance note, this event will be triggered every time corresponding properties being changed,
         * if the event callback have heavy logic it may have great performance impact, try to avoid such scenario.
         *
         * @zh
         * 当节点的 UITransform 锚点改变时触发的事件。
         * 性能警告：这个事件会在每次对应的属性被修改时触发，如果事件回调损耗较高，有可能对性能有很大的负面影响，请尽量避免这种情况。
         *
         * @deprecated since v3.3, please use Node.EventType.ANCHOR_CHANGED instead
         */
        ANCHOR_CHANGED = "anchor-changed",
        /**
         * @en
         * The event type for color change events.
         * Performance note, this event will be triggered every time corresponding properties being changed,
         * if the event callback have heavy logic it may have great performance impact, try to avoid such scenario.
         *
         * @zh
         * 当节点的 UI 渲染组件颜色属性改变时触发的事件。
         * 性能警告：这个事件会在每次对应的属性被修改时触发，如果事件回调损耗较高，有可能对性能有很大的负面影响，请尽量避免这种情况。
         *
         * @deprecated since v3.3, please use Node.EventType.COLOR_CHANGED instead
         */
        COLOR_CHANGED = "color-changed",
        /**
         * @en
         * The event type for adding a new child node to the target node.
         *
         * @zh
         * 给目标节点添加子节点时触发的事件。
         *
         * @deprecated since v3.3, please use Node.EventType.CHILD_ADDED instead
         */
        CHILD_ADDED = "child-added",
        /**
         * @en
         * The event type for removing a child node from the target node.
         *
         * @zh
         * 给目标节点移除子节点时触发的事件。
         *
         * @deprecated since v3.3, please use Node.EventType.CHILD_REMOVED instead
         */
        CHILD_REMOVED = "child-removed",
        /**
         * @en The event type for changing the parent of the target node
         * @zh 目标节点的父节点改变时触发的事件。
         *
         * @deprecated since v3.3, please use Node.EventType.PARENT_CHANGED instead
         */
        PARENT_CHANGED = "parent-changed",
        /**
         * @en The event type for destroying the target node
         * @zh 目标节点被销毁时触发的事件。
         *
         * @deprecated since v3.3, please use Node.EventType.NODE_DESTROYED instead
         */
        NODE_DESTROYED = "node-destroyed",
        /**
         * @en The event type for node layer change events.
         * @zh 节点 layer 改变时触发的事件。
         *
         * @deprecated since v3.3, please use Node.EventType.LAYER_CHANGED instead
         */
        LAYER_CHANGED = "layer-changed",
        /**
         * @en The event type for node's sibling order changed.
         * @zh 当节点在兄弟节点中的顺序发生变化时触发的事件。
         *
         * @deprecated since v3.3, please use Node.EventType.SIBLING_ORDER_CHANGED instead
         */
        SIBLING_ORDER_CHANGED = "sibling-order-changed"
    }
    /**
     * @en
     * Base class of all kinds of events.
     *
     * @zh
     * 所有事件对象的基类，包含事件相关基本信息。
     */
    export class Event {
        /**
         * @en
         * Code for event without type.
         *
         * @zh
         * 没有类型的事件。
         */
        static NO_TYPE: string;
        /**
         * @en
         * The type code of Touch event.
         *
         * @zh
         * 触摸事件类型。
         *
         * @deprecated since v3.3, please use SystemEvent.EventType.TOUCH_START, SystemEvent.EventType.TOUCH_MOVE, SystemEvent.EventType.TOUCH_END and SystemEvent.EventType.TOUCH_CANCEL instead
         */
        static TOUCH: string;
        /**
         * @en
         * The type code of Mouse event.
         *
         * @zh
         * 鼠标事件类型。
         *
         * @deprecated since v3.3, please use SystemEvent.EventType.MOUSE_DOWN, SystemEvent.EventType.MOUSE_MOVE, SystemEvent.EventType.MOUSE_UP, SystemEvent.EventType.MOUSE_WHEEL, Node.EventType.MOUSE_ENTER and Node.EventType.MOUSE_LEAVE instead
         */
        static MOUSE: string;
        /**
         * @en
         * The type code of Keyboard event.
         *
         * @zh
         * 键盘事件类型。
         *
         * @deprecated since v3.3, please use SystemEvent.EventType.KEY_DOWN and SystemEvent.EventType.KEY_UP instead
         */
        static KEYBOARD: string;
        /**
         * @en
         * The type code of Acceleration event.
         *
         * @zh
         * 加速器事件类型。
         *
         * @deprecated since v3.3, please use SystemEvent.EventType.DEVICEMOTION instead
         */
        static ACCELERATION: string;
        /**
         * @en
         * Events not currently dispatched are in this phase.
         *
         * @zh
         * 尚未派发事件阶段。
         */
        static NONE: number;
        /**
         * @en
         * The capturing phase comprises the journey from the root to the last node before the event target's node
         * [markdown](http://www.w3.org/TR/DOM-Level-3-Events/#event-flow)
         *
         * @zh
         * 捕获阶段，包括事件目标节点之前从根节点到最后一个节点的过程。
         */
        static CAPTURING_PHASE: number;
        /**
         * @en
         * The target phase comprises only the event target node
         * [markdown] (http://www.w3.org/TR/DOM-Level-3-Events/#event-flow)
         *
         * @zh
         * 目标阶段仅包括事件目标节点。
         */
        static AT_TARGET: number;
        /**
         * @en
         * The bubbling phase comprises any subsequent nodes encountered on the return trip to the root of the hierarchy
         * [markdown] (http://www.w3.org/TR/DOM-Level-3-Events/#event-flow)
         *
         * @zh
         * 冒泡阶段， 包括回程遇到到层次根节点的任何后续节点。
         */
        static BUBBLING_PHASE: number;
        /**
         * @en
         * The name of the event
         *
         * @zh
         * 事件类型。
         */
        type: __private._cocos_input_types_event_enum__SystemEventTypeUnion;
        /**
         * @en
         * Indicate whether the event bubbles up through the hierarchy or not.
         *
         * @zh
         * 表示该事件是否进行冒泡。
         */
        bubbles: boolean;
        /**
         * @en
         * A reference to the target to which the event was originally dispatched.
         *
         * @zh
         * 最初事件触发的目标。
         */
        target: any;
        /**
         * @en
         * A reference to the currently registered target for the event.
         *
         * @zh
         * 当前目标。
         */
        currentTarget: any;
        /**
         * @en
         * Indicates which phase of the event flow is currently being evaluated.
         * Returns an integer value represented by 4 constants:
         *  - Event.NONE = 0
         *  - Event.CAPTURING_PHASE = 1
         *  - Event.AT_TARGET = 2
         *  - Event.BUBBLING_PHASE = 3
         * The phases are explained in the [section 3.1, Event dispatch and DOM event flow]
         * [markdown](http://www.w3.org/TR/DOM-Level-3-Events/#event-flow), of the DOM Level 3 Events specification.
         *
         * @zh
         * 事件阶段。
         */
        eventPhase: number;
        /**
         * @en
         * Stops propagation for current event.
         *
         * @zh
         * 停止传递当前事件。
         */
        propagationStopped: boolean;
        /**
         * @en
         * Stops propagation for current event immediately,
         * the event won't even be dispatched to the listeners attached in the current target.
         *
         * @zh
         * 立即停止当前事件的传递，事件甚至不会被分派到所连接的当前目标。
         */
        propagationImmediateStopped: boolean;
        /**
         * @param type - The name of the event (case-sensitive), e.g. "click", "fire", or "submit"
         * @param bubbles - A boolean indicating whether the event bubbles up through the tree or not
         */
        constructor(type: __private._cocos_input_types_event_enum__SystemEventTypeUnion, bubbles?: boolean);
        /**
         * @en
         * Reset the event for being stored in the object pool.
         *
         * @zh
         * 重置事件对象以便在对象池中存储。
         */
        unuse(): void;
        /**
         * @en
         * Reinitialize the event for being used again after retrieved from the object pool.
         * @zh
         * 重新初始化让对象池中取出的事件可再次使用。
         * @param type - The name of the event (case-sensitive), e.g. "click", "fire", or "submit"
         * @param bubbles - A boolean indicating whether the event bubbles up through the tree or not
         */
        reuse(type: __private._cocos_input_types_event_enum__SystemEventTypeUnion, bubbles?: boolean): void;
        /**
         * @en
         * Checks whether the event has been stopped.
         *
         * @zh
         * 检查该事件是否已经停止传递。
         */
        isStopped(): boolean;
        /**
         * @en
         * Gets current target of the event                                                            <br/>
         * note: It only be available when the event listener is associated with node.                <br/>
         * It returns 0 when the listener is associated with fixed priority.
         * @zh
         * 获取当前目标节点
         * @returns - The target with which the event associates.
         */
        getCurrentTarget(): any;
        /**
         * @en
         * Gets the event type.
         * @zh
         * 获取事件类型。
         */
        getType(): string;
    }
    /**
     * @en
     * The acceleration event.
     * @zh
     * 加速计事件。
     */
    export class EventAcceleration extends Event {
        /**
         * @en The acceleration object
         * @zh 加速度对象
         */
        acc: Acceleration;
        /**
         * @param acc - The acceleration
         * @param bubbles - Indicate whether the event bubbles up through the hierarchy or not.
         */
        constructor(acc: Acceleration, bubbles?: boolean);
    }
    /**
     * @en
     * The keyboard event.
     * @zh
     * 键盘事件。
     */
    export class EventKeyboard extends Event {
        /**
         * @en The KeyCode enum value of current keyboard event.
         * @zh 当前键盘事件的 KeyCode 枚举值
         */
        keyCode: KeyCode;
        /**
         * @en Raw DOM KeyboardEvent.
         * @zh 原始 DOM KeyboardEvent 事件对象
         *
         * @deprecated since v3.3, can't access rawEvent anymore
         */
        rawEvent?: KeyboardEvent;
        /**
         * @en Indicates whether the current key is being pressed
         * @zh 表示当前按键是否正在被按下
         */
        get isPressed(): boolean;
        /**
         * @param keyCode - The key code of the current key or the DOM KeyboardEvent
         * @param isPressed - Indicates whether the current key is being pressed, this is the DEPRECATED parameter.
         * @param bubbles - Indicates whether the event bubbles up through the hierarchy or not.
         */
        constructor(keyCode: number | KeyboardEvent, isPressed: boolean, bubbles?: boolean);
        /**
         * @param keyCode - The key code of the current key or the DOM KeyboardEvent
         * @param eventType - The type of the event
         * @param bubbles - Indicates whether the event bubbles up through the hierarchy or not.
         */
        constructor(keyCode: KeyCode | KeyboardEvent, eventType: __private._cocos_input_types_event_enum__SystemEventTypeUnion, bubbles?: boolean);
    }
    /**
     * @en The mouse event
     * @zh 鼠标事件类型
     */
    export class EventMouse extends Event {
        /**
         * @en The default tag when no button is pressed
         * @zh 按键默认的缺省状态
         */
        static BUTTON_MISSING: number;
        /**
         * @en The tag of mouse's left button.
         * @zh 鼠标左键的标签。
         */
        static BUTTON_LEFT: number;
        /**
         * @en The tag of mouse's right button  (The right button number is 2 on browser).
         * @zh 鼠标右键的标签。
         */
        static BUTTON_RIGHT: number;
        /**
         * @en The tag of mouse's middle button.
         * @zh 鼠标中键的标签。
         */
        static BUTTON_MIDDLE: number;
        /**
         * @en The tag of mouse's button 4.
         * @zh 鼠标按键 4 的标签。
         */
        static BUTTON_4: number;
        /**
         * @en The tag of mouse's button 5.
         * @zh 鼠标按键 5 的标签。
         */
        static BUTTON_5: number;
        /**
         * @en The tag of mouse's button 6.
         * @zh 鼠标按键 6 的标签。
         */
        static BUTTON_6: number;
        /**
         * @en The tag of mouse's button 7.
         * @zh 鼠标按键 7 的标签。
         */
        static BUTTON_7: number;
        /**
         * @en The tag of mouse's button 8.
         * @zh 鼠标按键 8 的标签。
         */
        static BUTTON_8: number;
        /**
         * @en Mouse movement on x axis of the UI coordinate system.
         * @zh 鼠标在 UI 坐标系下 X 轴上的移动距离
         */
        movementX: number;
        /**
         * @en Mouse movement on y axis of the UI coordinate system.
         * @zh 鼠标在 UI 坐标系下 Y 轴上的移动距离
         */
        movementY: number;
        /**
         * @en Set whether to prevent events from being swallowed by nodes, which is false by default.
         * If set to true, the event is allowed to be dispatched to nodes at the bottom layer.
         * NOTE: Setting to true will reduce the efficiency of event dispatching.
         *
         * @zh 设置是否阻止事件被节点吞噬, 默认为 false 。
         * 如果设置为 true，则事件允许派发给渲染在下一层级的节点。
         * 注意：设置为 true 会降低事件派发的效率。
         *
         * @experimental May be optimized in the future.
         */
        preventSwallow: boolean;
        /**
         * @en The type of the event
         * @zh 鼠标事件类型
         *
         * @deprecated since v3.3, please use EventMouse.prototype.type instead.
         */
        get eventType(): string;
        /**
         * @param eventType - The type of the event
         * @param bubbles - Indicate whether the event bubbles up through the hierarchy or not.
         */
        constructor(eventType: __private._cocos_input_types_event_enum__SystemEventTypeUnion, bubbles?: boolean, prevLoc?: math.Vec2);
        /**
         * @en Sets scroll data of the mouse.
         * @zh 设置鼠标滚轮的滚动数据。
         * @param scrollX - The scroll value on x axis
         * @param scrollY - The scroll value on y axis
         */
        setScrollData(scrollX: number, scrollY: number): void;
        /**
         * @en Returns the scroll value on x axis.
         * @zh 获取鼠标滚动的 X 轴距离，只有滚动时才有效。
         */
        getScrollX(): number;
        /**
         * @en Returns the scroll value on y axis.
         * @zh 获取滚轮滚动的 Y 轴距离，只有滚动时才有效。
         */
        getScrollY(): number;
        /**
         * @en Sets cursor location.
         * @zh 设置当前鼠标位置。
         * @param x - The location on x axis
         * @param y - The location on y axis
         */
        setLocation(x: number, y: number): void;
        /**
         * @en Returns cursor location.
         * @zh 获取鼠标相对于左下角位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getLocation(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the current cursor location in game view coordinates.
         * @zh 获取当前事件在游戏窗口内的坐标位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getLocationInView(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the current cursor location in ui coordinates.
         * @zh 获取当前事件在 UI 窗口内的坐标位置，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getUILocation(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the previous touch location.
         * @zh 获取鼠标点击在上一次事件时的位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getPreviousLocation(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the previous touch location.
         * @zh 获取鼠标点击在上一次事件时的位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getUIPreviousLocation(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the delta distance from the previous location to current location.
         * @zh 获取鼠标距离上一次事件移动的距离对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getDelta(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the X axis delta distance from the previous location to current location.
         * @zh 获取鼠标距离上一次事件移动的 X 轴距离。
         */
        getDeltaX(): number;
        /**
         * @en Returns the Y axis delta distance from the previous location to current location.
         * @zh 获取鼠标距离上一次事件移动的 Y 轴距离。
         */
        getDeltaY(): number;
        /**
         * @en Returns the delta distance from the previous location to current location in the UI coordinates.
         * @zh 获取鼠标距离上一次事件移动在 UI 坐标系下的距离对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getUIDelta(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the X axis delta distance from the previous location to current location in the UI coordinates.
         * @zh 获取鼠标距离上一次事件移动在 UI 坐标系下的 X 轴距离。
         */
        getUIDeltaX(): number;
        /**
         * @en Returns the Y axis delta distance from the previous location to current location in the UI coordinates.
         * @zh 获取鼠标距离上一次事件移动在 UI 坐标系下的 Y 轴距离。
         */
        getUIDeltaY(): number;
        /**
         * @en Sets mouse button code.
         * @zh 设置鼠标按键。
         * @param button - The button code
         */
        setButton(button: number): void;
        /**
         * @en Returns mouse button code.
         * @zh 获取鼠标按键。
         */
        getButton(): number;
        /**
         * @en Returns location data on X axis.
         * @zh 获取鼠标当前 X 轴位置。
         */
        getLocationX(): number;
        /**
         * @en Returns location data on Y axis.
         * @zh 获取鼠标当前 Y 轴位置。
         */
        getLocationY(): number;
        /**
         * @en Returns location data on X axis.
         * @zh 获取鼠标当前 X 轴位置。
         */
        getUILocationX(): number;
        /**
         * @en Returns location data on Y axis.
         * @zh 获取鼠标当前 Y 轴位置。
         */
        getUILocationY(): number;
    }
    /**
     * @en
     * The touch event.
     *
     * @zh
     * 触摸事件。
     */
    export class EventTouch extends Event {
        /**
         * @en The maximum touch point numbers simultaneously
         * @zh 同时存在的最大触点数量。
         */
        static MAX_TOUCHES: number;
        /**
         * @en The current touch object
         * @zh 当前触点对象
         */
        touch: Touch | null;
        /**
         * @en Indicate whether the touch event is simulated or real
         * @zh 表示触摸事件是真实触点触发的还是模拟的
         */
        simulate: boolean;
        /**
         * @en Set whether to prevent events from being swallowed by nodes, which is false by default.
         * If set to true, the event is allowed to be dispatched to nodes at the bottom layer.
         * NOTE: Setting to true will reduce the efficiency of event dispatching.
         *
         * @zh 设置是否阻止事件被节点吞噬, 默认为 false 。
         * 如果设置为 true，则事件允许派发给渲染在下一层级的节点。
         * 注意：设置为 true 会降低事件派发的效率。
         *
         * @experimental May be optimized in the future.
         */
        preventSwallow: boolean;
        /**
         * @param touches - An array of current touches
         * @param bubbles - Indicate whether the event bubbles up through the hierarchy or not.
         * @param eventType - The type of the event
         */
        constructor(changedTouches: Touch[], bubbles: boolean, eventType: __private._cocos_input_types_event_enum__SystemEventTypeUnion, touches?: Touch[]);
        /**
         * @en Returns event type code.
         * @zh 获取触摸事件类型。
         *
         * @deprecated since v3.3, please use EventTouch.prototype.type instead.
         */
        getEventCode(): string;
        /**
         * @en Returns touches of event.
         * @zh 获取有变动的触摸点的列表。
         * 注意：第一根手指按下不动，接着按第二根手指，这时候触点信息就只有变动的这根手指（第二根手指）的信息。
         * 如果需要获取全部手指的信息，请使用 `getAllTouches`。
         */
        getTouches(): Touch[];
        /**
         * @en Returns touches of event.
         * @zh 获取所有触摸点的列表。
         * 注意：如果手指行为是 touch end，这个时候列表是没有该手指信息的。如需知道该手指信息，可通过 `getTouches` 获取识别。
         */
        getAllTouches(): Touch[];
        /**
         * @en Sets touch location.
         * @zh 设置当前触点位置
         * @param x - The current touch location on the x axis
         * @param y - The current touch location on the y axis
         */
        setLocation(x: number, y: number): void;
        /**
         * @en Returns the current touch location.
         * @zh 获取触点位置。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getLocation(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the current touch location in UI coordinates.
         * @zh 获取 UI 坐标系下的触点位置。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getUILocation(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the current touch location in game screen coordinates.
         * @zh 获取当前触点在游戏窗口中的位置。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getLocationInView(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the previous touch location.
         * @zh 获取触点在上一次事件时的位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getPreviousLocation(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the start touch location.
         * @zh 获取触点落下时的位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getStartLocation(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the start touch location in UI coordinates.
         * @zh 获取触点落下时的 UI 世界下位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getUIStartLocation(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the id of the current touch point.
         * @zh 获取触点的标识 ID，可以用来在多点触摸中跟踪触点。
         */
        getID(): number | null;
        /**
         * @en Returns the delta distance from the previous location to current location.
         * @zh 获取触点距离上一次事件移动的距离对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getDelta(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the delta distance from the previous location to current location.
         * @zh 获取触点距离上一次事件 UI 世界下移动的距离对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getUIDelta(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the X axis delta distance from the previous location to current location.
         * @zh 获取触点距离上一次事件移动的 x 轴距离。
         */
        getDeltaX(): number;
        /**
         * @en Returns the Y axis delta distance from the previous location to current location.
         * @zh 获取触点距离上一次事件移动的 y 轴距离。
         */
        getDeltaY(): number;
        /**
         * @en Returns location X axis data.
         * @zh 获取当前触点 X 轴位置。
         */
        getLocationX(): number;
        /**
         * @en Returns location Y axis data.
         * @zh 获取当前触点 Y 轴位置。
         */
        getLocationY(): number;
    }
    /**
     * @en
     * The gamepad event.
     * @zh
     * 手柄事件。
     */
    export class EventGamepad extends Event {
        /**
         * @en The gamepad device which trigger the current gamepad event
         * @zh 触发当前手柄事件的手柄设备
         */
        gamepad: __private._pal_input__GamepadInputDevice;
        constructor(type: string, gamepad: __private._pal_input__GamepadInputDevice);
    }
    /**
     * @en
     * The 6DOF handle event.
     *
     * @zh
     * 6DOF手柄事件。
     */
    export class EventHandle extends Event {
        /**
         * @en The handle device which trigger the current handle event
         * @zh 触发当前手柄事件的手柄设备
         */
        handleInputDevice: __private._pal_input__HandleInputDevice;
        /**
         * @param eventType - The type of the event
         * @param handleInputDevice - The handle device which trigger the current handle event
         */
        constructor(eventType: __private._cocos_input_types_event_enum__SystemEventTypeUnion, handleInputDevice: __private._pal_input__HandleInputDevice);
    }
    /**
     * @en
     * The HMD event.
     *
     * @zh
     * 头戴显示器事件。
     */
    export class EventHMD extends Event {
        /**
         * @en The hmd device which trigger the current hmd event
         * @zh 触发当前头戴显示器事件的头戴显示器设备
         */
        hmdInputDevice: __private._pal_input__HMDInputDevice;
        /**
         * @param eventType - The type of the event
         * @param hmdInputDevice - The hmd device which trigger the current hmd event
         */
        constructor(eventType: __private._cocos_input_types_event_enum__SystemEventTypeUnion, hmdInputDevice: __private._pal_input__HMDInputDevice);
    }
    /**
     * @en the device accelerometer reports values for each axis in units of g-force.
     * @zh 设备重力传感器传递的各个轴的数据。
     */
    export class Acceleration {
        x: number;
        y: number;
        z: number;
        timestamp: number;
        constructor(x?: number, y?: number, z?: number, timestamp?: number);
    }
    /**
     * @en Enum type of keyCode for key event
     * @zh 按键事件的按键码
     */
    export enum KeyCode {
        /**
         * @en None
         * @zh 没有分配
         */
        NONE = 0,
        /**
         * @en The back key on mobile phone
         * @zh 移动端返回键
         */
        MOBILE_BACK = 6,
        /**
         * @en The backspace key
         * @zh 退格键
         */
        BACKSPACE = 8,
        /**
         * @en The tab key
         * @zh Tab 键
         */
        TAB = 9,
        /**
         * @en The enter key
         * @zh 回车键
         */
        ENTER = 13,
        /**
         * @en The left shift key
         * @zh 左 Shift 键
         */
        SHIFT_LEFT = 16,
        /**
         * @en The left ctrl key
         * @zh 左 Ctrl 键
         */
        CTRL_LEFT = 17,
        /**
         * @en The left alt key
         * @zh 左 Alt 键
         */
        ALT_LEFT = 18,
        /**
         * @en The pause key
         * @zh 暂停键
         */
        PAUSE = 19,
        /**
         * @en The caps lock key
         * @zh 大写锁定键
         */
        CAPS_LOCK = 20,
        /**
         * @en The esc key
         * @zh ESC 键
         */
        ESCAPE = 27,
        /**
         * @en The space key
         * @zh 空格键
         */
        SPACE = 32,
        /**
         * @en The page up key
         * @zh 向上翻页键
         */
        PAGE_UP = 33,
        /**
         * @en The page down key
         * @zh 向下翻页键
         */
        PAGE_DOWN = 34,
        /**
         * @en The end key
         * @zh 结束键
         */
        END = 35,
        /**
         * @en The home key
         * @zh 主菜单键
         */
        HOME = 36,
        /**
         * @en The left key
         * @zh 向左箭头键
         */
        ARROW_LEFT = 37,
        /**
         * @en The up key
         * @zh 向上箭头键
         */
        ARROW_UP = 38,
        /**
         * @en The right key
         * @zh 向右箭头键
         */
        ARROW_RIGHT = 39,
        /**
         * @en The down key
         * @zh 向下箭头键
         */
        ARROW_DOWN = 40,
        /**
         * @en The insert key
         * @zh 插入键
         */
        INSERT = 45,
        /**
         * @en The Delete key
         * @zh 删除键
         */
        DELETE = 46,
        /**
         * @en The '0' key on the top of the alphanumeric keyboard.
         * @zh 字母键盘上的 0 键
         */
        DIGIT_0 = 48,
        /**
         * @en The '1' key on the top of the alphanumeric keyboard.
         * @zh 字母键盘上的 1 键
         */
        DIGIT_1 = 49,
        /**
         * @en The '2' key on the top of the alphanumeric keyboard.
         * @zh 字母键盘上的 2 键
         */
        DIGIT_2 = 50,
        /**
         * @en The '3' key on the top of the alphanumeric keyboard.
         * @zh 字母键盘上的 3 键
         */
        DIGIT_3 = 51,
        /**
         * @en The '4' key on the top of the alphanumeric keyboard.
         * @zh 字母键盘上的 4 键
         */
        DIGIT_4 = 52,
        /**
         * @en The '5' key on the top of the alphanumeric keyboard.
         * @zh 字母键盘上的 5 键
         */
        DIGIT_5 = 53,
        /**
         * @en The '6' key on the top of the alphanumeric keyboard.
         * @zh 字母键盘上的 6 键
         */
        DIGIT_6 = 54,
        /**
         * @en The '7' key on the top of the alphanumeric keyboard.
         * @zh 字母键盘上的 7 键
         */
        DIGIT_7 = 55,
        /**
         * @en The '8' key on the top of the alphanumeric keyboard.
         * @zh 字母键盘上的 8 键
         */
        DIGIT_8 = 56,
        /**
         * @en The '9' key on the top of the alphanumeric keyboard.
         * @zh 字母键盘上的 9 键
         */
        DIGIT_9 = 57,
        /**
         * @en The a key
         * @zh A 键
         */
        KEY_A = 65,
        /**
         * @en The b key
         * @zh B 键
         */
        KEY_B = 66,
        /**
         * @en The c key
         * @zh C 键
         */
        KEY_C = 67,
        /**
         * @en The d key
         * @zh D 键
         */
        KEY_D = 68,
        /**
         * @en The e key
         * @zh E 键
         */
        KEY_E = 69,
        /**
         * @en The f key
         * @zh F 键
         */
        KEY_F = 70,
        /**
         * @en The g key
         * @zh G 键
         */
        KEY_G = 71,
        /**
         * @en The h key
         * @zh H 键
         */
        KEY_H = 72,
        /**
         * @en The i key
         * @zh I 键
         */
        KEY_I = 73,
        /**
         * @en The j key
         * @zh J 键
         */
        KEY_J = 74,
        /**
         * @en The k key
         * @zh K 键
         */
        KEY_K = 75,
        /**
         * @en The l key
         * @zh L 键
         */
        KEY_L = 76,
        /**
         * @en The m key
         * @zh M 键
         */
        KEY_M = 77,
        /**
         * @en The n key
         * @zh N 键
         */
        KEY_N = 78,
        /**
         * @en The o key
         * @zh O 键
         */
        KEY_O = 79,
        /**
         * @en The p key
         * @zh P 键
         */
        KEY_P = 80,
        /**
         * @en The q key
         * @zh Q 键
         */
        KEY_Q = 81,
        /**
         * @en The r key
         * @zh R 键
         */
        KEY_R = 82,
        /**
         * @en The s key
         * @zh S 键
         */
        KEY_S = 83,
        /**
         * @en The t key
         * @zh T 键
         */
        KEY_T = 84,
        /**
         * @en The u key
         * @zh U 键
         */
        KEY_U = 85,
        /**
         * @en The v key
         * @zh V 键
         */
        KEY_V = 86,
        /**
         * @en The w key
         * @zh W 键
         */
        KEY_W = 87,
        /**
         * @en The x key
         * @zh X 键
         */
        KEY_X = 88,
        /**
         * @en The y key
         * @zh Y 键
         */
        KEY_Y = 89,
        /**
         * @en The z key
         * @zh Z 键
         */
        KEY_Z = 90,
        /**
         * @en The numeric keypad 0
         * @zh 数字键盘 0
         */
        NUM_0 = 96,
        /**
         * @en The numeric keypad 1
         * @zh 数字键盘 1
         */
        NUM_1 = 97,
        /**
         * @en The numeric keypad 2
         * @zh 数字键盘 2
         */
        NUM_2 = 98,
        /**
         * @en The numeric keypad 3
         * @zh 数字键盘 3
         */
        NUM_3 = 99,
        /**
         * @en The numeric keypad 4
         * @zh 数字键盘 4
         */
        NUM_4 = 100,
        /**
         * @en The numeric keypad 5
         * @zh 数字键盘 5
         */
        NUM_5 = 101,
        /**
         * @en The numeric keypad 6
         * @zh 数字键盘 6
         */
        NUM_6 = 102,
        /**
         * @en The numeric keypad 7
         * @zh 数字键盘 7
         */
        NUM_7 = 103,
        /**
         * @en The numeric keypad 8
         * @zh 数字键盘 8
         */
        NUM_8 = 104,
        /**
         * @en The numeric keypad 9
         * @zh 数字键盘 9
         */
        NUM_9 = 105,
        /**
         * @en The numeric keypad '*'
         * @zh 数字键盘 *
         */
        NUM_MULTIPLY = 106,
        /**
         * @en The numeric keypad '+'
         * @zh 数字键盘 +
         */
        NUM_PLUS = 107,
        /**
         * @en The numeric keypad '-'
         * @zh 数字键盘 -
         */
        NUM_SUBTRACT = 109,
        /**
         * @en The numeric keypad '.'
         * @zh 数字键盘小数点 '.'
         */
        NUM_DECIMAL = 110,
        /**
         * @en The numeric keypad '/'
         * @zh 数字键盘 /
         */
        NUM_DIVIDE = 111,
        /**
         * @en The F1 function key
         * @zh F1 功能键
         */
        F1 = 112,
        /**
         * @en The F2 function key
         * @zh F2 功能键
         */
        F2 = 113,
        /**
         * @en The F3 function key
         * @zh F3 功能键
         */
        F3 = 114,
        /**
         * @en The F4 function key
         * @zh F4 功能键
         */
        F4 = 115,
        /**
         * @en The F5 function key
         * @zh F5 功能键
         */
        F5 = 116,
        /**
         * @en The F6 function key
         * @zh F6 功能键
         */
        F6 = 117,
        /**
         * @en The F7 function key
         * @zh F7 功能键
         */
        F7 = 118,
        /**
         * @en The F8 function key
         * @zh F8 功能键
         */
        F8 = 119,
        /**
         * @en The F9 function key
         * @zh F9 功能键
         */
        F9 = 120,
        /**
         * @en The F10 function key
         * @zh F10 功能键
         */
        F10 = 121,
        /**
         * @en The F11 function key
         * @zh F11 功能键
         */
        F11 = 122,
        /**
         * @en The F12 function key
         * @zh F12 功能键
         */
        F12 = 123,
        /**
         * @en The numlock key
         * @zh 数字锁定键
         */
        NUM_LOCK = 144,
        /**
         * @en The scroll lock key
         * @zh 滚动锁定键
         */
        SCROLL_LOCK = 145,
        /**
         * @en The ';' key.
         * @zh 分号键
         */
        SEMICOLON = 186,
        /**
         * @en The '=' key.
         * @zh 等于号键
         */
        EQUAL = 187,
        /**
         * @en The ',' key.
         * @zh 逗号键
         */
        COMMA = 188,
        /**
         * @en The dash '-' key.
         * @zh 中划线键
         */
        DASH = 189,
        /**
         * @en The '.' key
         * @zh 句号键
         */
        PERIOD = 190,
        /**
         * @en The slash key '/'
         * @zh 正斜杠键 '/'
         */
        SLASH = 191,
        /**
         * @en The back quote key `
         * @zh 按键 `
         */
        BACK_QUOTE = 192,
        /**
         * @en The '[' key
         * @zh 按键 [
         */
        BRACKET_LEFT = 219,
        /**
         * @en The back slash key '\'
         * @zh 反斜杠键 '\'
         */
        BACKSLASH = 220,
        /**
         * @en The ']' key
         * @zh 按键 ]
         */
        BRACKET_RIGHT = 221,
        /**
         * @en The quote key
         * @zh 单引号键
         */
        QUOTE = 222,
        /**
         * @en The right shift key
         * @zh 右 Shift 键
         */
        SHIFT_RIGHT = 2000,
        /**
         * @en The right ctrl key
         * @zh 右 Ctrl 键
         */
        CTRL_RIGHT = 2001,
        /**
         * @en The right alt key
         * @zh 右 Alt 键
         */
        ALT_RIGHT = 2002,
        /**
         * @en The numeric keypad enter
         * @zh 数字键盘 enter
         */
        NUM_ENTER = 2003
    }
    /**
     * @en The touch point class
     * @zh 封装了触点相关的信息。
     */
    export class Touch {
        get lastModified(): number;
        /**
         * @param x - x position of the touch point
         * @param y - y position of the touch point
         * @param id - The id of the touch point
         */
        constructor(x: number, y: number, id?: number);
        /**
         * @en Returns the current touch location in OpenGL coordinates.、
         * @zh 获取当前触点位置。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getLocation(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns X axis location value.
         * @zh 获取当前触点 X 轴位置。
         */
        getLocationX(): number;
        /**
         * @en Returns Y axis location value.
         * @zh 获取当前触点 Y 轴位置。
         */
        getLocationY(): number;
        /**
         * @en Returns the current touch location in UI coordinates.、
         * @zh 获取当前触点在 UI 坐标系中的位置。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getUILocation(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns X axis location value in UI coordinates.
         * @zh 获取当前触点在 UI 坐标系中 X 轴位置。
         */
        getUILocationX(): number;
        /**
         * @en Returns Y axis location value in UI coordinates.
         * @zh 获取当前触点在 UI 坐标系中 Y 轴位置。
         */
        getUILocationY(): number;
        /**
         * @en Returns the previous touch location.
         * @zh 获取触点在上一次事件时的位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getPreviousLocation(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the previous touch location in UI coordinates.
         * @zh 获取触点在上一次事件时在 UI 坐标系中的位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getUIPreviousLocation(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the start touch location.
         * @zh 获取触点落下时的位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getStartLocation(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the start touch location in UI coordinates.
         * @zh 获取触点落下时在 UI 坐标系中的位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getUIStartLocation(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the delta distance from the previous touche to the current one.
         * @zh 获取触点距离上一次事件移动的距离对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getDelta(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the delta distance from the previous touche to the current one in UI coordinates.
         * @zh 获取触点距离上一次事件移动在 UI 坐标系中的距离对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getUIDelta(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the current touch location in screen coordinates.
         * @zh 获取当前事件在游戏窗口内的坐标位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getLocationInView(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the previous touch location in screen coordinates.
         * @zh 获取触点在上一次事件时在游戏窗口中的位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getPreviousLocationInView(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the start touch location in screen coordinates.
         * @zh 获取触点落下时在游戏窗口中的位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getStartLocationInView(out?: math.Vec2): math.Vec2;
        /**
         * @en Returns the id of the touch point.
         * @zh 触点的标识 ID，可以用来在多点触摸中跟踪触点。
         */
        getID(): number;
        /**
         * @en Resets touch point information.
         * @zh 重置触点相关的信息。
         * @param id - The id of the touch point
         * @param x - x position of the touch point
         * @param y - y position of the touch point
         */
        setTouchInfo(id?: number, x?: number, y?: number): void;
        /**
         * @en Sets touch point location.
         * @zh 设置触点位置。
         * @param point - The location
         */
        setPoint(point: math.Vec2): void;
        /**
         * @en Sets touch point location.
         * @zh 设置触点位置。
         * @param x - x position
         * @param y - y position
         */
        setPoint(x: number, y: number): void;
        /**
         * @en Sets the location previously registered for the current touch.
         * @zh 设置触点在前一次触发时收集的位置。
         * @param point - The location
         */
        setPrevPoint(point: math.Vec2): void;
        /**
         * @en Sets the location previously registered for the current touch.
         * @zh 设置触点在前一次触发时收集的位置。
         * @param x - x position
         * @param y - y position
         */
        setPrevPoint(x: number, y: number): void;
    }
    /**
     * @en
     * The singleton of the Input class, this singleton manages all events of input. include: touch, mouse, accelerometer, gamepad, handle, hmd and keyboard.
     *
     * @zh
     * 输入类单例，该单例管理所有的输入事件，包括：触摸、鼠标、加速计、游戏手柄、6DOF手柄、头戴显示器 和 键盘。
     *
     * @example
     * ```
     * input.on(Input.EventType.DEVICEMOTION, this.onDeviceMotionEvent, this);
     * input.off(Input.EventType.DEVICEMOTION, this.onDeviceMotionEvent, this);
     * ```
     */
    export const input: Input;
    /**
     * @en
     * This Input class manages all events of input. include: touch, mouse, accelerometer, gamepad, handle, hmd and keyboard.
     * You can get the `Input` instance with `input`.
     *
     * @zh
     * 该输入类管理所有的输入事件，包括：触摸、鼠标、加速计、游戏手柄、6DOF手柄、头戴显示器 和 键盘。
     * 你可以通过 `input` 获取到 `Input` 的实例。
     *
     * @example
     * ```
     * input.on(Input.EventType.DEVICEMOTION, this.onDeviceMotionEvent, this);
     * input.off(Input.EventType.DEVICEMOTION, this.onDeviceMotionEvent, this);
     * ```
     */
    export class Input {
        /**
         * @en The input event type
         * @zh 输入事件类型
         */
        static EventType: typeof __private._cocos_input_types_event_enum__InputEventType;
        constructor();
        /**
         * @en
         * Register a callback of a specific input event type.
         * @zh
         * 注册特定的输入事件回调。
         *
         * @param eventType - The event type
         * @param callback - The event listener's callback
         * @param target - The event listener's target and callee
         */
        on<K extends keyof __private._cocos_input_input__InputEventMap>(eventType: K, callback: __private._cocos_input_input__InputEventMap[K], target?: any): __private._cocos_input_input__InputEventMap[K];
        /**
         * @en
         * Register a callback of a specific input event type once.
         * @zh
         * 注册单次的输入事件回调。
         *
         * @param eventType - The event type
         * @param callback - The event listener's callback
         * @param target - The event listener's target and callee
         */
        once<K extends keyof __private._cocos_input_input__InputEventMap>(eventType: K, callback: __private._cocos_input_input__InputEventMap[K], target?: any): __private._cocos_input_input__InputEventMap[K];
        /**
         * @en
         * Unregister a callback of a specific input event type.
         * @zh
         * 取消注册特定的输入事件回调。
         *
         * @param eventType - The event type
         * @param callback - The event listener's callback
         * @param target - The event listener's target and callee
         */
        off<K extends keyof __private._cocos_input_input__InputEventMap>(eventType: K, callback?: __private._cocos_input_input__InputEventMap[K], target?: any): void;
        /**
         * @en
         * Sets whether to enable the accelerometer event listener or not.
         *
         * @zh
         * 是否启用加速度计事件。
         */
        setAccelerometerEnabled(isEnable: boolean): void;
        /**
         * @en
         * Sets the accelerometer interval value.
         *
         * @zh
         * 设置加速度计间隔值。
         */
        setAccelerometerInterval(intervalInMileSeconds: number): void;
    }
    export namespace Input {
        export type EventType = __private._types_globals__EnumAlias<typeof __private._cocos_input_types_event_enum__InputEventType>;
    }
    /**
     * @module cc
     */
    /**
     * @en The singleton of the SystemEvent, there should only be one instance to be used globally
     * @zh 系统事件单例，方便全局使用。
     *
     * @deprecated since v3.4.0, please use input instead.
     */
    export const systemEvent: SystemEvent;
    /**
     * @en
     * The System event, it currently supports keyboard events and accelerometer events.<br/>
     * You can get the `SystemEvent` instance with `systemEvent`.<br/>
     * @zh
     * 系统事件，它目前支持按键事件和重力感应事件。<br/>
     * 你可以通过 `systemEvent` 获取到 `SystemEvent` 的实例。<br/>
     *
     * @deprecated since v3.4.0, please use Input class instead.
     *
     * @example
     * ```
     * import { systemEvent, SystemEvent } from 'cc';
     * systemEvent.on(SystemEvent.EventType.DEVICEMOTION, this.onDeviceMotionEvent, this);
     * systemEvent.off(SystemEvent.EventType.DEVICEMOTION, this.onDeviceMotionEvent, this);
     * ```
     */
    export class SystemEvent extends EventTarget {
        static EventType: typeof SystemEventType;
        constructor();
        /**
         * @en
         * Sets whether to enable the accelerometer event listener or not.
         *
         * @zh
         * 是否启用加速度计事件。
         */
        setAccelerometerEnabled(isEnabled: boolean): void;
        /**
         * @en
         * Sets the accelerometer interval value.
         *
         * @zh
         * 设置加速度计间隔值。
         */
        setAccelerometerInterval(interval: number): void;
        /**
         * @en
         * Register an callback of a specific system event type.
         * @zh
         * 注册特定事件类型回调。
         *
         * @param type - The event type
         * @param callback - The event listener's callback
         * @param target - The event listener's target and callee
         * @param once - Register the event listener once
         */
        on<K extends keyof __private._cocos_input_system_event__SystemEventMap>(type: K, callback: __private._cocos_input_system_event__SystemEventMap[K], target?: any, once?: boolean): __private._cocos_input_system_event__SystemEventMap[K];
        /**
         * @en
         * Removes the listeners previously registered with the same type, callback, target and or useCapture,
         * if only type is passed as parameter, all listeners registered with that type will be removed.
         * @zh
         * 删除之前用同类型，回调，目标或 useCapture 注册的事件监听器，如果只传递 type，将会删除 type 类型的所有事件监听器。
         *
         * @param type - A string representing the event type being removed.
         * @param callback - The callback to remove.
         * @param target - The target (this object) to invoke the callback, if it's not given, only callback without target will be removed
         */
        off<K extends keyof __private._cocos_input_system_event__SystemEventMap>(type: K, callback?: __private._cocos_input_system_event__SystemEventMap[K], target?: any): void;
    }
    export namespace SystemEvent {
        /**
         * @en The event type supported by SystemEvent and Node events
         * @zh SystemEvent 支持的事件类型以及节点事件类型
         */
        export type EventType = __private._types_globals__EnumAlias<typeof SystemEventType>;
    }
    /**
     * @zh 该对象提供由原生绑定出来的 JavaScript 接口。
     * 注意：全局作用域下的 `jsb` 对象已经废弃，我们更推荐使用由 `cc` 模块下导出的 `native` 对象。
     * 该对象是前者的子集，我们开放了一些开发者真正需要的原生接口，例如文件，反射等接口。
     * 使用之前需要先通过 `NATIVE` 宏判断该接口在平台上是否支持。
     *
     * @en This object provides the JavaScript interface bound from the native.
     * Note: `jsb` object in global scope is deprecated, we recommend using the exported `native` object from `cc` module.
     * This object is a subset of the former, we open some interfaces that the developer really needs, such as file, reflection, etc.
     * Before using, you need to check whether the interface is supported on the platform with the `NATIVE` constant.
     *
     * @example
     * ```ts
     * import { native } from 'cc';
     * import { NATIVE } from 'cc/env';
     *
     * if (NATIVE) {
     *    native.reflection.callStaticMethod( ...args );
     * }
     * ```
     */
    export namespace native {
        /**
         * @en Copy text to clipboard @zh 拷贝字符串到剪切板
         * @param text
         */
        function copyTextToClipboard(text: string): void;
        /**
         * @en Trigger garbage collection of ScriptEngine @zh 触发 ScriptEngine 的 GC
         */
        function garbageCollect(): void;
        /**
         * @en Save the image to the path indicated.
         * @zh 保存图片到指定路径。
         * @param data : @en the image data, should be raw data array with uint8 @zh 图片数据, 应为原始数据数组，uint8 格式。
         * @param path : @en the path to save @zh 保存路径
         * @param width : @en the width of the image @zh 图片宽度
         * @param height : @en the height of the image @zh 图片高度
         * @param filePath : @en the file path of the image @zh 图片文件路径
         * @example
         * ```ts
                let renderTexture = new RenderTexture();
                let renderWindowInfo = {
                width: this._width,
                height: this._height
                };
                renderTexture.reset(renderWindowInfo);
                cameras.forEach((camera: any) => {
                camera.targetTexture = renderTexture;
                });
                await this.waitForNextFrame();
                cameras.forEach((camera: any) => {
                    camera.targetTexture = null;
                });
                let pixelData = renderTexture.readPixels();
                native.saveImageData(pixelData, path, width, height, filePath).then(()=>{
                    console.log("Save image data success");
                }).catch(()=>{
                    console.log("Fail to save image data");
                });
         */
        function saveImageData(data: Uint8Array, width: number, height: number, filePath: string): Promise<void>;
        /**
         * @en DownloaderTask @zh 下载任务对象
         * @param requestURL @en Request download resource URL  @zh 请求下载资源的URL
         * @param storagePath @en Storage path for downloaded file @zh 下载文件存储路径
         * @param identifier  @en identifier @zh 标识符
         */
        export type DownloaderTask = {
            requestURL: string;
            storagePath: string;
            identifier: string;
        };
        export class EventAssetsManager {
            getEventCode(): number;
            getCURLECode(): number;
            getCURLMCode(): number;
            getMessage(): string;
            getAssetId(): string;
            getAssetsManagerEx(): AssetsManager;
            isResuming(): boolean;
            getPercent(): number;
            getPercentByFile(): number;
            getDownloadedBytes(): number;
            getTotalBytes(): number;
            getDownloadedFiles(): number;
            getTotalFiles(): number;
            constructor(eventName: string, manager: AssetsManager, code: number, assetId: string, message: string, curleCode: number, curlmCode: number);
        }
        export namespace EventAssetsManager {
            export const ERROR_NO_LOCAL_MANIFEST: number;
            export const ERROR_DOWNLOAD_MANIFEST: number;
            export const ERROR_PARSE_MANIFEST: number;
            export const NEW_VERSION_FOUND: number;
            export const ALREADY_UP_TO_DATE: number;
            export const UPDATE_PROGRESSION: number;
            export const ASSET_UPDATED: number;
            export const ERROR_UPDATING: number;
            export const UPDATE_FINISHED: number;
            export const UPDATE_FAILED: number;
            export const ERROR_DECOMPRESS: number;
        }
        export interface ManifestAsset {
            md5: string;
            path: string;
            compressed: boolean;
            size: number;
            downloadState: number;
        }
        export class Manifest {
            /**
             * @en Check whether the version informations have been fully loaded
             * @zh 检查是否已加载版本信息
             */
            isVersionLoaded(): boolean;
            /**
             * @en Check whether the manifest have been fully loaded
             * @zh 检查是否已加载 manifest
             */
            isLoaded(): boolean;
            /**
             * @en Gets remote package url.
             * @zh 获取远程包的 URL
             */
            getPackageUrl(): string;
            /**
             * @en Gets remote manifest file url.
             * @zh 获取远程 manifest 文件的 URL
             */
            getManifestFileUrl(): string;
            /**
             * @en Gets remote version file url.
             * @zh 获取远程版本文件的 URL
             */
            getVersionFileUrl(): string;
            /**
             * @en Gets manifest version.
             * @zh 获取远程 manifest 文件的版本
             */
            getVersion(): string;
            /**
             * @en Get the search paths list related to the Manifest.
             * @zh 返回 Manifest 相关的搜索路径
             */
            getSearchPaths(): string[];
            /**
             * @en Get the manifest root path, normally it should also be the local storage path.
             * @zh 获取 manifest 的根路径, 一般为本地存储目录.
             */
            getManifestRoot(): string;
            constructor(content: string, manifestRoot: string);
            constructor(manifestUrl: string);
            /**
             * @en Parse the manifest file information into this manifest
             * @zh 解析 manifest 文件
             * @param manifestUrl @en Url of the local manifest @zh 文件路径
             */
            parseFile(manifestUrl: string): void;
            /**
             * @en Parse the manifest from json string into this manifest
             * @zh 解析 manifest 的 JSON 文件
             * @param content @en Json string content @zh JSON 文本
             * @param manifestRoot @en The root path of the manifest file (It should be local path,
             * so that we can find assets path relative to the root path) @zh manifest 根路径
             */
            parseJSONString(content: string, manifestRoot: string): void;
            /**
             * @en Get whether the manifest is being updating
             * @en 是否在更新
             * @return @en Updating or not @zh 是否在更新
             */
            isUpdating(): boolean;
            /**
             * @en Set whether the manifest is being updating
             * @zh 设置更新状态
             * @param updating @en Updating or not @zh 是否更新
             */
            setUpdating(updating: boolean): void;
        }
        export namespace Manifest {
            export enum DownloadState {
                UNSTARTED,
                DOWNLOADING,
                SUCCESSED,
                UNMARKED
            }
        }
        export class AssetsManager {
            /**
             * @en Create function for creating a new AssetsManagerEx
             *
             * warning   The cached manifest in your storage path have higher priority and will be searched first,
             * only if it doesn't exist, AssetsManagerEx will use the given manifestUrl.
             *
             * @zh 创建 AssetManager
             *
             * @param manifestUrl  @en The url for the local manifest file @zh manifest 文件路径
             * @param storagePath  @en The storage path for downloaded assets @zh 存储路径
             */
            static create(manifestUrl: string, storagePath: string): AssetsManager;
            constructor(manifestUrl: string, storagePath: string, handle: (arg1: string, arg2: string) => number);
            constructor(manifestUrl: string, storagePath: string);
            /**
             * @en  Check out if there is a new version of manifest.
             * You may use this method before updating, then let user determine whether
             * he wants to update resources.
             * @zh 检查更新
             */
            checkUpdate(): void;
            /**
             * @en Prepare the update process, this will cleanup download process flags,
             * fill up download units with temporary manifest or remote manifest
             * @zh 准备更新
             */
            prepareUpdate(): void;
            /**
             * @en Update with the current local manifest.
             * @zh 执行更新
             */
            update(): void;
            /**
             * @en Reupdate all failed assets under the current AssetsManagerEx context
             * @zh 重新下载之前失败的资源
             */
            downloadFailedAssets(): void;
            /**
             * @en Gets the current update state.
             * @zh 返回当前的状态码
             */
            getState(): number;
            /**
             * @en Gets storage path.
             * @zh 获取存储路径
             */
            getStoragePath(): string;
            /**
             * @en Function for retrieving the local manifest object
             * @zh 获取本地 manifest 路径
             */
            getLocalManifest(): Manifest;
            /**
             * @en Load a local manifest from url.
             *
             * You can only manually load local manifest when the update state is UNCHECKED, it will fail once the update process is began.
             *
             * This API will do the following things:
             *
             * 1. Reset storage path
             *
             * 2. Set local storage
             *
             * 3. Search for cached manifest and compare with the local manifest
             *
             * 4. Init temporary manifest and remote manifest
             *
             * If successfully load the given local manifest and inited other manifests, it will return true, otherwise it will return false
             * @zh 加载本地的 manifest
             * @param manifestUrl  @en The local manifest url @zh manifest 路径
             */
            loadLocalManifest(manifestUrl: string): boolean;
            /**
             * @en Load a custom local manifest object, the local manifest must be loaded already.
             *
             * You can only manually load local manifest when the update state is UNCHECKED, it will fail once the update process is began.
             *
             * This API will do the following things:
             *
             * 1. Reset storage path
             *
             * 2. Set local storage
             *
             * 3. Search for cached manifest and compare with the local manifest
             *
             * 4. Init temporary manifest and remote manifest
             *
             * If successfully load the given local manifest and inited other manifests, it will return true, otherwise it will return false
             * @zh 加载本地的 manifest
             *
             * @param localManifest @en The local manifest object to be set @zh manifest 对象
             *
             * @param storagePath  @en The local storage path @zh 存储路径
             */
            loadLocalManifest(localManifest: Manifest, storagePath: string): boolean;
            /**
             * @en Function for retrieving the remote manifest object
             * @zh 获取远程的 manifest 对象
             */
            getRemoteManifest(): Manifest;
            /**
             * @en Load a custom remote manifest object, the manifest must be loaded already.
             *
             * You can only manually load remote manifest when the update state is UNCHECKED and local manifest is already inited,
             * it will fail once the update process is began.
             * @zh 加载自定义i的远程 manifest 对象
             * @param remoteManifest   @en The remote manifest object to be set @zh manifest 对象
             */
            loadRemoteManifest(remoteManifest: Manifest): boolean;
            /**
             * @en Gets whether the current download is resuming previous unfinished job,
             * this will only be available after READY_TO_UPDATE state,
             * under unknown states it will return false by default.
             * @zh 是否在恢复状态
             */
            isResuming(): boolean;
            /**
             * @en Gets the total byte size to be downloaded of the update, this will only be available
             * after READY_TO_UPDATE state, under unknown states it will return 0 by default.
             * @zh 需要下载或者更新的总字节数
             */
            getTotalBytes(): number;
            /**
             * @en Gets the current downloaded byte size of the update, this will only be available
             * after READY_TO_UPDATE state, under unknown states it will return 0 by default.
             * @zh 已下载的字节数
             */
            getDownloadedBytes(): number;
            /**
             * @en Gets the total files count to be downloaded of the update, this will only be available
             *  after READY_TO_UPDATE state, under unknown states it will return 0 by default.
             * @zh 需要下载的总的文件数目
             */
            getTotalFiles(): number;
            /**
             * @en Gets the current downloaded files count of the update, this will only be available
             *  after READY_TO_UPDATE state, under unknown states it will return 0 by default.
             * @zh 已下载的文件数目
             */
            getDownloadedFiles(): number;
            /**
             * @en Function for retrieving the max concurrent task count
             * @zh 下载的最大并发数
             */
            getMaxConcurrentTask(): number;
            /**
             * @en Function for setting the max concurrent task count
             * @zh 设置下载的最大并发数目
             */
            setMaxConcurrentTask(max: number): void;
            /**
             * @en Set the handle function for comparing manifests versions
             * @zh 设置版本比对函数
             *
             * @param handle  @en  The compare function @zh 比较函数
             */
            setVersionCompareHandle(handle: (arg1: string, arg2: string) => number): void;
            /**
             * @en Set the verification function for checking whether downloaded asset is correct, e.g. using md5 verification
             * @zh 设置内容校验函数
             * @param callback  @en The verify callback function @zh 校验函数
             */
            setVerifyCallback(callback: (arg1: string, arg: ManifestAsset) => boolean): void;
            /**
             * @en Set the event callback for receiving update process events
             * @zh 设置更新事件处理回调
             * @param callback @en The event callback function @zh 事件处理回调
             */
            setEventCallback(callback: (arg: EventAssetsManager) => void): void;
        }
        export namespace AssetsManager {
            export enum State {
                UNINITED,
                UNCHECKED,
                PREDOWNLOAD_VERSION,
                DOWNLOADING_VERSION,
                VERSION_LOADED,
                PREDOWNLOAD_MANIFEST,
                DOWNLOADING_MANIFEST,
                MANIFEST_LOADED,
                NEED_UPDATE,
                READY_TO_UPDATE,
                UPDATING,
                UNZIPPING,
                UP_TO_DATE,
                FAIL_TO_UPDATE
            }
        }
        /**
         * @en DownloaderHints @zh 下载任务的配置接口
         * @param countOfMaxProcessingTasks
         * @en Maximum number of download tasks processed at the same time, optional, default is 6
         * @zh 同时处理的最大下载任务数量, 可选, 默认值为6
         * @param timeoutInSeconds @en Download request timeout, optional, default is 45 seconds @zh 下载请求的超时时间, 可选, 默认值为45秒
         * @param tempFileNameSuffix  @en Temporary file suffix generated during download, optional, default is .tmp @zh 下载时产生的临时文件后缀, 可选, 默认值为.tmp
         */
        export interface DownloaderHints {
            countOfMaxProcessingTasks?: number;
            timeoutInSeconds?: number;
            tempFileNameSuffix?: string;
        }
        /**
         * @en Downloader class for task download
         * @zh Downloader 任务下载类
         */
        export class Downloader {
            /**
             * @en Downloader default constructor, constructed by the default value of DownloaderHints.
             * @zh Downloader的默认构造函数, 通过DownloaderHints的默认值构造.
             * @example
             * ```ts
             * let downloader = new native.Downloader(); // create a Downloader object by default constructor
             * ```
             */
            constructor();
            /**
             * @en Downloader constructor with parameter, constructed by DownloaderHints.
             * @zh Downloader的有参构造函数, 通过传递的DownloaderHints去构造.
             * @example
             * ```ts
             * const hints: native.DownloaderHints = { // create a DownloaderHints interface
             *     countOfMaxProcessingTasks: 6,
             *     timeoutInSeconds: 100,
             *     tempFileNameSuffix: ".tmp"
             * };
             * let downloader = new native.Downloader(hints); // create a Downloader object with DownloaderHints
             * ```
             */
            constructor(hints: DownloaderHints);
            /**
             * @en create a download task. The maximum size for a single download file is 4GB.
             * @zh 创建一个下载任务. 单个下载文件最大为4GB.
             * @param requestURL
             * @en Request download resource URL. Node: Users need to encode the URL containing special characters except spaces (such as Chinese, etc.)
             * @zh 请求下载资源的URL. 注意: 当URL中包含除空格外特殊字符(如:中文等)时需要用户自行编码后传入.
             * @param storagePath @en Storage path for downloaded file @zh 下载文件存储路径
             * @param identifier  @en identifier @zh 标识符
             * @return @en DownloaderTask @zh 下载任务对象
             * @example
             * ```ts
             * let task = downloader.createDownloadTask('https://example.com/exampleFile.zip', native.fileUtils.getWritablePath());
             * ```
             */
            createDownloadTask(requestURL: string, storagePath: string, identifier?: string): DownloaderTask;
            /**
             * @en setter for the callback function after download success
             * @zh 任务成功下载后的回调函数的修改器
             * @param task @en download task @zh 下载的任务
             * @example
             * ```ts
             *  // set a download success callback
             *  downloader.onSuccess = (task) => {
             *      console.log('Success!'); // call when task download success
             * };
             * ```
             */
            onSuccess: (task: DownloaderTask) => void | undefined;
            /**
             * @en setter for the callback function while download.
             * @zh 任务下载过程中的回调函数的修改器.
             * @param task @en download task @zh 下载任务
             * @param bytesReceived @en received bytes in current call @zh 此次接收到的字节
             * @param totalBytesReceived @en total bytes have been received @zh 已接收到的所有字节
             * @param totalBytesExpected @en total bytes expected to receive  @zh 预计接收的所有字节
             * @example
             * ```ts
             *  // setter for the callback for download progress prompt
             *  downloader.onProgress = (task, bytesReceived, totalBytesReceived, totalBytesExpected) => {
             *      console.log(bytesReceived, totalBytesReceived); // download data info
             *      console.log(totalBytesReceived / totalBytesExpected * 100).toFixed(1) + '%'); // progress prompt
             * };
             * ```
             */
            onProgress: (task: DownloaderTask, bytesReceived: number, totalBytesReceived: number, totalBytesExpected: number) => void | undefined;
            /**
             * @en setter for the callback function when download error
             * @zh 任务下载发生错误时的回调函数的修改器
             * @param task @en download task @zh 下载任务
             * @param errorCode @en  error code  @zh 错误码
             * @param errorCodeInternal @en internal error code @zh 内部错误码
             * @param errorStr @en error info string @zh 错误信息
             * @example
             * ```ts
             * // set a download error callback
             *  downloader.onError = (task, errorCode, errorCodeInternal, errorStr) => {
             *  console.log('Error:', errorStr);
             * };
             */
            onError: (task: DownloaderTask, errorCode: number, errorCodeInternal: number, errorStr: string) => void | undefined;
            /**
             * @deprecated since v3.6.0, please use `createDownloadTask` to instead.
             * @en create a download task. The maximum size for a single download file is 4GB.
             * @zh 创建一个下载任务. 单个下载文件最大为4GB.
             * @param requestURL
             * @en Request download resource URL. Node: Users need to encode the URL containing special characters except spaces (such as Chinese, etc.)
             * @zh 请求下载资源的URL. 注意: 当URL中包含除空格外特殊字符(如:中文等)时需要用户自行编码后传入.
             * @param storagePath @en Storage path for downloaded file @zh 下载文件存储路径
             * @param identifier  @en identifier @zh 标识符
             * @return @en DownloaderTask @zh 下载任务对象
             * @example
             * ```ts
             * let task = downloader.createDownloadFileTask('https://example.com/exampleFile.zip', native.fileUtils.getWritablePath());
             * ```
             */
            createDownloadFileTask(requestURL: string, storagePath: string, identifier?: string): DownloaderTask;
            /**
             * @deprecated since v3.6.0, please use setter `onSuccess` to instead.
             * @en set callback function after download success
             * @zh 设置任务成功下载后的回调函数
             * @param onSucceed @en Download success callback @zh 下载成功后的回调函数
             * @example
             * ```ts
             *  // set a download success callback
             *  downloader.setOnFileTaskSuccess((task)=>{
             *  console.log('Success!'); // call when task download success
             * });
             * ```
             */
            setOnFileTaskSuccess(onSucceed: (task: DownloaderTask) => void): void;
            /**
             * @deprecated since v3.6.0, please use setter `onProgress` to instead.
             * @en set callback function while download.
             * @zh 设置任务下载过程中的回调函数.
             * @param onProgress @en Download progress callback @zh 下载过程中的回调函数
             * @example
             * ```ts
             *  // set a callback for download progress prompt
             *  downloader.setOnTaskProgress((task, bytesReceived, totalBytesReceived, totalBytesExpected)=>{
             *  console.log(bytesReceived, totalBytesReceived); // download data info
             *  console.log(totalBytesReceived / totalBytesExpected * 100).toFixed(1) + '%'); // progress prompt
             * });
             * ```
             */
            setOnTaskProgress(onProgress: (task: DownloaderTask, bytesReceived: number, totalBytesReceived: number, totalBytesExpected: number) => void): void;
            /**
             * @deprecated since v3.6.0, please use setter `onError` to instead.
             * @en set callback function when download error
             * @zh 设置任务下载发生错误时的回调函数
             * @param onError @en Download error callback @zh 下载发生错误时的回调函数
             * @example
             * ```ts
             * // set a download error callback
             *  downloader.setOnTaskError((task, errorCode, errorCodeInternal, errorStr)=>{
             *  console.log('Error:', errorStr);
             * });
             * ```
             */
            setOnTaskError(onError: (task: DownloaderTask, errorCode: number, errorCodeInternal: number, errorStr: string) => void): void;
        }
        /**
         * @en ZipUtils  Helper class to handle unzip related operations.
         * @zh ZipUtils  对解压操作的辅助类。
         */
        export namespace zipUtils {
            /**
             * @en
             * Inflates either zlib or gzip deflated memory. The inflated memory is expected to be freed by the caller.
             * It will allocate 256k for the destination buffer.
             * If it is not enough it will multiply the previous buffer size per 2, until there is enough memory.
             *
             * @zh
             * 对 zlib 或 gzip 压缩的内存进行解压缩。解压后的数据需要在调用方中进行内存释放。
             * 它会给目标内存分配 256k 大小的空间。如果不足以解压，它将会将目标空间扩大 2 倍直到足够大。
             *
             * @param input @en input data @zh 要解压的数据
             * @param outLengthHint @en It is assumed to be the needed room to allocate the inflated buffer, which is optional. @zh 预计解压后的数据长度，可选。
             *
             * @return @en The deflated buffer. @zh 解压后的数据缓存区
             */
            function inflateMemory(input: string | ArrayBuffer | __private._types_globals__TypedArray, outLengthHint?: number): ArrayBuffer | null;
            /**
             * @en Inflates a GZip file into memory.
             * @zh 将 GZip 压缩文件解压缩到内存中。
             *
             * @param path @en The GZip file path. @zh GZip 文件的路径
             *
             * @return @en The deflated buffer. @zh 解压后的数据缓存区
             */
            function inflateGZipFile(path: string): ArrayBuffer | null;
            /**
             * @en Test a file is a GZip format file or not.
             * @zh 判断一个文件是否是 GZip 格式。
             *
             * @param path @en The file path. @zh 文件的路径
             *
             * @return @en True is a GZip format file. false is not. @zh true GZip 格式文件，否则不是。
             */
            function isGZipFile(path: string): boolean;
            /**
             * @en Test the buffer is GZip format or not.
             * @zh 判断一个缓存区的数据是否是 GZip 格式。
             *
             * @param buffer @en The buffer. @zh 数据缓存区
             *
             * @return @en True is GZip format. false is not. @zh 返回true表示是 GZip 格式，否则不是。
             */
            function isGZipBuffer(buffer: string | ArrayBuffer | __private._types_globals__TypedArray): boolean;
            /**
             * @en Inflates a CCZ file into memory.
             * @zh 将 CCZ 格式压缩文件解压缩到内存中。
             *
             * @param path @en The CCZ file path. @zh CCZ 文件的路径
             * @return @en The deflated buffer. @zh 解压后的数据缓存区
             */
            function inflateCCZFile(path: string): ArrayBuffer | null;
            /**
             * @en Inflates a buffer with CCZ format into memory.
             * @zh 将 CCZ 格式的内存块解压到内存中。
             *
             * @param buffer @en The buffer. @zh 数据缓存区
             *
             * @return @en The deflated buffer. @zh 解压后的数据缓存区
             */
            function inflateCCZBuffer(buffer: string | ArrayBuffer | __private._types_globals__TypedArray): ArrayBuffer | null;
            /**
             * @en Test a file is a CCZ format file or not.
             * @zh 判断一个文件是否是 CCZ 格式。
             *
             * @return @en True is a CCZ format file. false is not. @zh 返回true表示是 CCZ 格式，否则不是。
             */
            function isCCZFile(path: string): boolean;
            /**
             * @en Test the buffer is CCZ format or not.
             * @zh 判断一个缓存区的数据是否是 CCZ 格式。
             *
             * @ param @en The buffer. @zh 数据缓存区
             *
             * @return @en True is CCZ format. false is not. @zh 返回true表示是 CCZ 格式，否则不是。
             */
            function isCCZBuffer(buffer: string | ArrayBuffer | __private._types_globals__TypedArray): boolean;
            /**
             * @en
             * Sets the pvr.ccz encryption key parts separately for added security.
             *
             * Example: If the key used to encrypt the pvr.ccz file is
             * 0xaaaaaaaabbbbbbbbccccccccdddddddd you will call this function 4
             * different times, preferably from 4 different source files, as follows
             *
             * setPvrEncryptionKeyPart(0, 0xaaaaaaaa);
             * setPvrEncryptionKeyPart(1, 0xbbbbbbbb);
             * setPvrEncryptionKeyPart(2, 0xcccccccc);
             * setPvrEncryptionKeyPart(3, 0xdddddddd);
             *
             * Splitting the key into 4 parts and calling the function from 4 different source
             * files increases the difficulty to reverse engineer the encryption key.
             * Be aware that encryption is *never* 100% secure and the key code
             * can be cracked by knowledgeable persons.
             *
             * IMPORTANT: Be sure to call setPvrEncryptionKey or
             * setPvrEncryptionKeyPart with all of the key parts *before* loading
             * the sprite sheet or decryption will fail and the sprite sheet
             * will fail to load.
             *
             * @zh
             * 设置 pvr.ccz 加密密钥的部分，以增加安全性。
             *
             * 例如：如果使用来加密 pvr.ccz 文件的密钥为 0xaaaaaaaabbbbbbbbccccccccdddddddd，
             * 则你可以调用此函数 4 次，至少来自 4 个不同的源文件，如下所示：
             *
             * setPvrEncryptionKeyPart(0, 0xaaaaaaaa);
             * setPvrEncryptionKeyPart(1, 0xbbbbbbbb);
             * setPvrEncryptionKeyPart(2, 0xcccccccc);
             * setPvrEncryptionKeyPart(3, 0xdddddddd);
             *
             * 将密钥分成 4 个部分并调用此函数来自 4 个不同的源文件增加解密密钥的难度。
             * 请注意，加密是从不完全安全的，密钥码可以被知道的人破解。
             *
             * 注意：调用 setPvrEncryptionKey 或 setPvrEncryptionKeyPart 函数之前，
             * 请确保已经调用了 setPvrEncryptionKeyPart 函数，否则解密将失败，并且加载精灵图集将失败。
             *
             * @param index @en Part of the key [0..3]. @zh 密钥[0..3]的部分。
             * @param value @en Value of the key part. @zh 密钥部分的值。
             */
            function setPvrEncryptionKeyPart(index: number, value: number): void;
            /**
             * @en
             * Sets the pvr.ccz encryption key.
             * Example: If the key used to encrypt the pvr.ccz file is
             * 0xaaaaaaaabbbbbbbbccccccccdddddddd you will call this function with
             * the key split into 4 parts as follows
             *
             * setPvrEncryptionKey(0xaaaaaaaa, 0xbbbbbbbb, 0xcccccccc, 0xdddddddd);
             *
             * Note that using this function makes it easier to reverse engineer and discover
             * the complete key because the key parts are present in one function call.
             *
             * IMPORTANT: Be sure to call setPvrEncryptionKey or setPvrEncryptionKeyPart
             * with all of the key parts *before* loading the sprite sheet or decryption
             * will fail and the sprite sheet will fail to load.
             *
             * @zh
             * 设置 pvr.ccz 加密密钥。
             * 例如：如果使用来加密 pvr.ccz 文件的密钥为 0xaaaaaaaabbbbbbbbccccccccdddddddd，
             * 则你可以调用此函数，将密钥分成 4 个部分如下：
             *
             * setPvrEncryptionKey(0xaaaaaaaa, 0xbbbbbbbb, 0xcccccccc, 0xdddddddd);
             *
             * 注意：确保在加载精灵图集之前通过所有的密钥部分调用 setPvrEncryptionKey 或 setPvrEncryptionKeyPart，否则解密将失败，并且加载精灵图集将失败。
             *
             * @param keyPart1 @en The key value part 1. @zh 密钥部分 1 的值。
             * @param keyPart2 @en The key value part 2. @zh 密钥部分 2 的值。
             * @param keyPart3 @en The key value part 3. @zh 密钥部分 3 的值。
             * @param keyPart4 @en The key value part 4. @zh 密钥部分 4 的值。
             */
            function setPvrEncryptionKey(keyPart1: number, keyPart2: number, keyPart3: number, keyPart4: number): void;
        }
        /**
         * FileUtils  Helper class to handle file operations.
         */
        export namespace fileUtils {
            /**
             *  @en
             *  Checks whether the path is an absolute path.
             *
             *  @zh
             *  判断文件是否是绝对路径
             *  @note On Android, if the parameter passed in is relative to "@assets/", this method will treat it as an absolute path.
             *        Also on Blackberry, path starts with "app/native/Resources/" is treated as an absolute path.
             *
             *  @param path The path that needs to be checked.
             *  @return True if it's an absolute path, false if not.
             */
            function isAbsolutePath(path: string): boolean;
            /**
             *  @en
             *  Returns the fullpath for a given filename.
             *
                    First it will try to get a new filename from the "filenameLookup" dictionary.
                    If a new filename can't be found on the dictionary, it will use the original filename.
                    Then it will try to obtain the full path of the filename using the FileUtils search rules: resolutions, and search paths.
                    The file search is based on the array element order of search paths and resolution directories.
            
                    For instance:
            
                        We set two elements("/mnt/sdcard/", "internal_dir/") to search paths vector by setSearchPaths,
                        and set three elements("resources-ipadhd/", "resources-ipad/", "resources-iphonehd")
                        to resolutions vector by setSearchResolutionsOrder. The "internal_dir" is relative to "Resources/".
            
                        If we have a file named 'sprite.png', the mapping in fileLookup dictionary contains `key: sprite.png -> value: sprite.pvr.gz`.
                        Firstly, it will replace 'sprite.png' with 'sprite.pvr.gz', then searching the file sprite.pvr.gz as follows:
            
                            /mnt/sdcard/resources-ipadhd/sprite.pvr.gz      (if not found, search next)
                            /mnt/sdcard/resources-ipad/sprite.pvr.gz        (if not found, search next)
                            /mnt/sdcard/resources-iphonehd/sprite.pvr.gz    (if not found, search next)
                            /mnt/sdcard/sprite.pvr.gz                       (if not found, search next)
                            internal_dir/resources-ipadhd/sprite.pvr.gz     (if not found, search next)
                            internal_dir/resources-ipad/sprite.pvr.gz       (if not found, search next)
                            internal_dir/resources-iphonehd/sprite.pvr.gz   (if not found, search next)
                            internal_dir/sprite.pvr.gz                      (if not found, return "sprite.png")
            
                        If the filename contains relative path like "gamescene/uilayer/sprite.png",
                        and the mapping in fileLookup dictionary contains `key: gamescene/uilayer/sprite.png -> value: gamescene/uilayer/sprite.pvr.gz`.
                        The file search order will be:
            
                            /mnt/sdcard/gamescene/uilayer/resources-ipadhd/sprite.pvr.gz      (if not found, search next)
                            /mnt/sdcard/gamescene/uilayer/resources-ipad/sprite.pvr.gz        (if not found, search next)
                            /mnt/sdcard/gamescene/uilayer/resources-iphonehd/sprite.pvr.gz    (if not found, search next)
                            /mnt/sdcard/gamescene/uilayer/sprite.pvr.gz                       (if not found, search next)
                            internal_dir/gamescene/uilayer/resources-ipadhd/sprite.pvr.gz     (if not found, search next)
                            internal_dir/gamescene/uilayer/resources-ipad/sprite.pvr.gz       (if not found, search next)
                            internal_dir/gamescene/uilayer/resources-iphonehd/sprite.pvr.gz   (if not found, search next)
                            internal_dir/gamescene/uilayer/sprite.pvr.gz                      (if not found, return "gamescene/uilayer/sprite.png")
            
                    If the new file can't be found on the file system, it will return the parameter filename directly.
            
                    This method was added to simplify multiplatform support.
                    Whether you are using cocos2d-js or any cross-compilation toolchain like StellaSDK or Apportable,
                    you might need to load different resources for a given file in the different platforms.
             *  @zh
             *  通过文件名获取绝对路径
             *  @since v2.1
             */
            function fullPathForFilename(filename: string): string;
            /**
             *
             *  @en
             *  Gets string from a file.
             *
             *  @zh
             *  读取文件里的字符串
             *
             */
            function getStringFromFile(filename: string): string;
            /**
             *  @en
             *  Removes a file.
             *
             *  @zh
             *  删除文件
             *
             *  @param filepath The full path of the file, it must be an absolute path.
             *  @return True if the file have been removed successfully, false if not.
             */
            function removeFile(filepath: string): boolean;
            /**
             *  @en
             *  Checks whether the path is a directory.
             *
             *  @zh
             *  检测目录是否存在
             *
             *  @param dirPath The path of the directory, it could be a relative or an absolute path.
             *  @return True if the directory exists, false if not.
             */
            function isDirectoryExist(dirPath: string): boolean;
            /**
             *  @en
             *  Normalize: remove . and ..
             *
             *  @zh
             *  标准化：去除'.' 和 '..'
             *
             * @param filepath
             */
            function normalizePath(filepath: string): string;
            /**
             *  @en
             *  Gets the array of search paths.
             *
             *  @zh
             *  获取默认资源根路径
             *
             */
            function getDefaultResourceRootPath(): string;
            /**
             *  @en
             *  Converts the contents of a file to a ValueVector.
             *  This method is used internally.
             *
             *  @zh
             *  将文件的内容转换为 ValueVector
             *  这个方法是内部使用的
             */
            function getValueVectorFromFile(filepath: string): Array<any>;
            /**
             *  @en
             *  Gets the array of search paths.
             *
             *  @zh
             *  获取所有的搜索路径
             *
             *  @return The array of search paths which may contain the prefix of default resource root path.
             *  @note In best practise, getter function should return the value of setter function passes in.
             *        But since we should not break the compatibility, we keep using the old logic.
             *        Therefore, If you want to get the original search paths, please call 'getOriginalSearchPaths()' instead.
             *  @see fullPathForFilename (const char*).
             *  @lua NA
             */
            function getSearchPaths(): Array<string>;
            /**
             *  @en
             *  Get the directory where the file is located by the file path.
             *
             *  @zh
             *  通过文件路径获取文件所在目录
             * @param filepath
             */
            function getFileDir(filepath: string): string;
            /**
             *  @en
             *  write a ValueMap into a plist file.
             *
             *  @zh
             *  将 ValueMap 写入 plist 文件
             *
             *  @param dict the ValueMap want to save (key,value)
             *  @return bool
             */
            function writeToFile(valueMap: any): boolean;
            /**
             *  @en
             *  Gets the original search path array set by 'setSearchPaths' or 'addSearchPath'.
             *
             *  @zh
             *  获取由“setSearchPaths”或“addSearchPath”设置的原始搜索路径数组。
             *
             *  @return The array of the original search paths
             */
            function getOriginalSearchPaths(): Array<string>;
            /**
             *  @en
             *  List all files in a directory
             *
             *  @zh
             *  在文件夹中列出所有文件
             *
             *  @param dirPath The path of the directory, it could be a relative or an absolute path.
             *  @return File paths in a string vector
             */
            function listFiles(filepath: string): Array<string>;
            /**
             *  @en
             *  Converts the contents of a file to a ValueMap.
             *
             *  @zh
             *  转换文件内容为ValueMap
             *
             *  @param filename The filename of the file to gets content.
             *  @return ValueMap of the file contents.
             *  @note This method is used internally.
             */
            function getValueMapFromFile(filepath: string): any;
            /**
             *  @en
             *  Retrieve the file size.
             *
             *  @zh
             *  获取文件大小
             *  @note If a relative path was passed in, it will be inserted a default root path at the beginning.
             *  @param filepath The path of the file, it could be a relative or absolute path.
             *  @return The file size.
             */
            function getFileSize(filepath: string): number;
            /**
             *  @en
             *  Converts the contents of a file to a ValueMap.
             *  This method is used internally.
             *
             *  @zh
             *  转换文件内容为ValueMap
             *  这个方法是内部使用的
             *
             */
            function getValueMapFromData(filedata: string, filesize: number): any;
            /**
             *
             *  @en
             *  Removes a directory..
             *
             *  @zh
             *  删除一个目录
             *
             *  @param dirPath  The full path of the directory, it must be an absolute path.
             *  @return True if the directory have been removed successfully, false if not.
             */
            function removeDirectory(dirPath: string): boolean;
            /**
             *  @en
             *  Sets the array of search paths.
             *
             *  You can use this array to modify the search path of the resources.
             *  If you want to use "themes" or search resources in the "cache", you can do it easily by adding new entries in this array.
             *
             *  @note This method could access relative path and absolute path.
             *        If the relative path was passed to the vector, FileUtils will add the default resource directory before the relative path.
             *        For instance:
             *            On Android, the default resource root path is "@assets/".
             *            If "/mnt/sdcard/" and "resources-large" were set to the search paths vector,
             *            "resources-large" will be converted to "@assets/resources-large" since it was a relative path.
             *  @zh
             *  设置一系列的搜索路径
             *  通过这个数组可以修改资源的搜索路径。例如如果你想使用在cache里的主题资源，你需要尽早的添加到这个数组里
             *
             *  @param searchPaths The array contains search paths.
             *  @see fullPathForFilename (const char*)
             *  @since v2.1
             *  In js:var setSearchPaths(var jsval);
             *  @lua NA
             */
            function setSearchPaths(searchPath: Array<string>): void;
            /**
             *  @en
             *  write a string into a file.
             *
             *  @zh
             *  写字符串到文件里
             *
             * @param dataStr the string want to save
             * @param fullPath The full path to the file you want to save a string
             * @return bool True if write success
             */
            function writeStringToFile(dataStr: string, fullPath: string): boolean;
            /**
             *  @en
             *  Add search path.
             *
             *  @zh
             *  添加文件的搜索路径
             *
             * @since v2.1
             */
            function addSearchPath(path: string, front: boolean): void;
            /**
             *
             *  @en
             *  write ValueVector into a plist file
             *
             *  @zh
             *  将 ValueVector 写入 plist 文件
             *
             *@param vecData the ValueVector want to save
             *@param fullPath The full path to the file you want to save a string
             *@return bool
             */
            function writeValueVectorToFile(vecData: Array<any>, fullPath: string): boolean;
            /**
             *  @en
             *  Checks whether a file exists.
             *
             *  @zh
             *  检测路径是否存在
             *
             *  @note If a relative path was passed in, it will be inserted a default root path at the beginning.
             *  @param filename The path of the file, it could be a relative or absolute path.
             *  @return True if the file exists, false if not.
             */
            function isFileExist(filename: string): boolean;
            /**
             *
             *  @en
             *  Purges full path caches.
             *
             *  @zh
             *  清除路径缓存
             */
            function purgeCachedEntries(): void;
            /**
             *  @en
             *  Gets full path from a file name and the path of the relative file.
             *
             *  @zh
             *  通过文件名或者相对路径转换成绝对路径
             *
             *  @param filename The file name.
             *  @param relativeFile The path of the relative file.
             *  @return The full path.
             *          e.g. filename: hello.png, pszRelativeFile: /User/path1/path2/hello.plist
             *               Return: /User/path1/path2/hello.pvr (If there a a key(hello.png)-value(hello.pvr) in FilenameLookup dictionary. )
             *
             */
            function fullPathFromRelativeFile(filename: string, relativeFile: string): string;
            /**
             *  @en
             *  Windows fopen can't support UTF-8 filename
             *  Need convert all parameters fopen and other 3rd-party libs
             *
             *  @zh
             *  windows的fopen函数不支持utf-8编码的文件
             *  需要转换所有的参数给fopen或者其他的第三方的库使用
             *  @param filenameUtf8 std::string name file for conversion from utf-8
             *  @return std::string ansi filename in current locale
             */
            function getSuitableFOpen(filenameUtf8: string): string;
            /**
             *
             *  @en
             *  write ValueMap into a plist file
             *
             *  @zh
             *  将 ValueMap 写入 plist 文件
             *  @param dict the ValueMap want to save
             *  @param fullPath The full path to the file you want to save a string
             *  @return bool
             */
            function writeValueMapToFile(dict: any, fullPath: string): string;
            /**
             *  @en
             *  Gets filename extension is a suffix (separated from the base filename by a dot) in lower case.
             *  Examples of filename extensions are .png, .jpeg, .exe, .dmg and .txt.
             *
             *  @zh
             *  获取文件的扩展名（使用'.'做分割符），返回的都是小写
             *  例如：返回.png, .jpeg, .exe, .dmg等
             *  @param filePath The path of the file, it could be a relative or absolute path.
             *  @return suffix for filename in lower case or empty if a dot not found.
             */
            function getFileExtension(filePath: string): string;
            /**
             *  @en
             *  Sets writable path.
             *
             *  @zh
             *  设置有可写权限的目录
             *
             *  @param writablePath The path of the directory.
             */
            function setWritablePath(writablePath: string): void;
            /**
             *  @en
             *  Set default resource root path.
             *
             *  @zh
             *  设置默认的资源根目录
             *
             *  @param dirPath The path of the directory.
             */
            function setDefaultResourceRootPath(dirPath: string): void;
            /**
             *  @en
             *  Creates a directory.
             *
             *  @zh
             *  创建一个目录
             *
             *  @param dirPath The path of the directory, it must be an absolute path.
             *  @return True if the directory have been created successfully, false if not.
             */
            function createDirectory(dirPath: string): string;
            /**
             *  @en
             *  List all files recursively in a directory.
             *
             *  @zh
             *  在一个目录里递归搜索所有的文件
             *
             *  @param dirPath The path of the directory, it could be a relative or an absolute path.
             *  @return File paths in a string vector
             */
            function listFilesRecursively(dirPath: string, files: Array<string>): void;
            /**
             *  Gets the writable path.
             *  @return  The path that can be write/read a file in
             */
            function getWritablePath(): string;
            /**
             *  @en
             *  Renames a file under the given directory.
             *
             *  @zh
             *  文件（包含路径）重命名
             *
             *  @param oldFullpath  The current fullpath of the file. Includes path and name.
             *  @param newFullPath  The new fullpath of the file. Includes path and name.
             *  @return True if the file have been renamed successfully, false if not.
             */
            function renameFile(oldFullpath: string, newFullPath: string): boolean;
            /**
             *  @en
             *  Read binary data from a file.
             *
             *  @zh
             *  从文件中读取二进制数据
             *  Creates binary data from a file.
             *  @param fullpath The current fullpath of the file. Includes path and name.
             *  @return A data object.
             */
            function getDataFromFile(fullpath: string): ArrayBuffer;
            /**
             *  @en
             *  write Data into a file
             *
             *  @zh
             *  把数据写入文件内
             *
             *  @param data the data want to save
             *  @param fullpath The full path to the file you want to save a string
             *  @return bool
             */
            function writeDataToFile(buffer: ArrayBuffer, fullpath: string): boolean;
        }
        /**
         * @en DebugTextInfo @zh 调试文本的配置接口
         * @param color @en text color @zh 文本颜色
         * @param bold @en bold text @zh 粗体
         * @param italic @en italic text @zh 斜体
         * @param shadow @en shadow effect @zh 阴影效果
         * @param shadowThickness @en shadow thickness @zh 阴影宽度
         * @param shadowColor @en shadow color @zh 阴影颜色
         * @param scale @en scale @zh 缩放比例
         */
        export interface DebugTextInfo {
            color: math.Color;
            bold: boolean;
            italic: boolean;
            shadow: boolean;
            shadowThickness: number;
            shadowColor: math.Color;
            scale: number;
        }
        /**
         * @en DebugRenderer class used to output debug text on screen
         * @zh 用于输出屏幕调试文字的调试渲染器类
         */
        export class DebugRenderer {
            /**
             * @en get DebugRenderer instance
             * @zh 获取调试渲染器实例
             * @return @en the DebugRenderer instance @zh 返回的调试渲染器实例
             */
            static getInstance(): DebugRenderer;
            /**
             * @en output a text
             * @zh 输出一个文本
             * @param text @en the output text @zh 输出的文本
             * @param screenPos @en the output screen position @zh 输出的屏幕位置
             * @param info @en the output text information @zh 输出的文本属性
             */
            addText(text: string, screenPos: math.Vec2, info?: DebugTextInfo): void;
        }
        export namespace reflection {
            /**
             * https://docs.cocos.com/creator/manual/zh/advanced-topics/java-reflection.html
             * @en call Objective-C/Java static methods
             * @zh 调用 Objective-C/Java 静态方法
             *
             * @param className : @en the class name of the Objective-C/Java class @zh Objective-C/Java 类的类名
             * @param methodName : @en the method name of the Objective-C/Java class @zh Objective-C/Java 类的方法名
             * @param methodSignature : @en the method signature of the Objective-C/Java class @zh Objective-C/Java 方法签名
             * @param parameters : @en the parameters of the Objective-C/Java class to translate @zh 传递至该 Objective-C/Java 方法的参数
             */
            function callStaticMethod(className: string, methodName: string, methodSignature: string, ...parameters: any): any;
        }
        /**
         * @en
         * The API to listen and dispatch events on Objc/JAVA without reflection,
         * Function onNative can only be overriden once by time.
         * https://docs.cocos.com/creator/manual/en/advanced-topics/js-java-bridge.html
         * Sample:
         * ```
         * native.bridge.onNative = (event, data) => {
         *   if (event === 'send_message') {
         *    console.log(data);
         *  }
         * }
         * ```
         * ```
         *  // Java codes
         *  JsbBridge.sendToScript('send_message', 'hello world');
         * ```
         * @zh
         * 不使用反射机制来调用和监听Objc/JAVA事件的接口,
         * 同一时间只能重载一个onNative函数
         * https://docs.cocos.com/creator/manual/zh/advanced-topics/js-java-bridge.html
         * 示例:
         * ```
         * native.bridge.onNative = (event, data) => {
         *   if (event === 'send_message') {
         *    console.log(data);
         *  }
         * }
         * ```
         * ```java
         *  JsbBridge.sendToScript('send_message', 'hello world');
         * ```
         */
        export namespace bridge {
            /**
             * @en send to native with maxmimum of 2 parameters
             * @zh 向原生发送消息，可接受1到2个参数。
             * @param arg0 : @en the first parameter @zh 第一个参数
             * @param arg1 : @en the second parameter @zh 第二个参数
             */
            function sendToNative(arg0: string, arg1?: string): void;
            /**
             * @en
             * Define your own js callback function. When native scripts run sendToScript, this callback will be called.
             * usage: jsb.bridge.onNative = (arg0: String, arg1: String) => {...}
             * @zh
             * 定义自己的js回调函数，当原生调用 sendToScript 时，该回调函数被触发。
             * 使用 jsb.bridge.onNative = (arg0: String, arg1: String) => {...}
             *
             * @param arg0 : @en the first parameter @zh 第一个参数
             * @param arg1 : @en the second parameter @zh 第二个参数
             */
            function onNative(arg0: string, arg1?: string | null): void;
        }
        /**
         * @en
         * Listener for jsbBridgeWrapper's event.
         * It takes one argument as data which is transferred by jsbBridge.
         * @zh
         * jsbBridgeWrapper 的事件监听器，
         * 它接受一个字符串参数，这个参数是通过 jsbBridge 进行传递的数据
         * @param arg: @en the data transferred by jsbBridge @zh jsbBridge 进行传递的数据
         */
        export type OnNativeEventListener = (arg: string) => void;
        /**
         * @en
         * A high level API to call Objc/JAVA methods.
         * Use bridge to implement it. If use jsbBridgeWrapper, bridge should not be used.
         * https://docs.cocos.com/creator/manual/en/advanced-topics/jsb-bridge-wrapper.html
         * @zh
         * 高级 API，用于调用 Objc/JAVA 方法。
         * 该方法封装在bridge之上，如果使用 jsbBridgeWrapper，bridge 不应该被使用。
         * https://docs.cocos.com/creator/manual/zh/advanced-topics/jsb-bridge-wrapper.html
         */
        export namespace jsbBridgeWrapper {
            /**
             * @en
             * Register one listener to the event
             * @zh
             * 给事件注册一个监听
             * @param event : @en the event name @zh 事件名称
             * @param listener : @en the listener @zh 监听器
             */
            function addNativeEventListener(event: string, listener: OnNativeEventListener): any;
            /**
             * @en
             * Dispatch the event registered on Objective-C, Java etc.
             * @zh
             * 调用 Objective-C、Java 等的注册的事件。
             * @param event : @en the event name @zh 事件名称
             * @param data : @en the data @zh 数据
             */
            function dispatchEventToNative(event: string, arg?: string): any;
            /**
             * @en Remove all listeners listennig to event.
             * @zh 移除指定事件的所有监听。
             * @param event : @en the event name @zh 事件名称
             */
            function removeAllListenersForEvent(event: string): any;
            /**
             * @en Remove the listener specified.
             * @zh 移除指定的事件监听器
             * @param event : @en the event name @zh 事件名称
             */
            function removeNativeEventListener(event: string, listener: OnNativeEventListener): any;
            /**
             * @en Remove all events, use it carefully!
             * @zh 移除所有事件，请小心使用！
             * @param event : @en the event name @zh 事件名称
             */
            function removeAllListeners(): any;
        }
    }
    export namespace dragonBones {
        export enum ExtensionType {
            FFD = 0,
            AdjustColor = 10,
            BevelFilter = 11,
            BlurFilter = 12,
            DropShadowFilter = 13,
            GlowFilter = 14,
            GradientBevelFilter = 15,
            GradientGlowFilter = 16
        }
        export enum EventType {
            Frame = 0,
            Sound = 1
        }
        export enum AnimationFadeOutMode {
            None = 0,
            SameLayer = 1,
            SameGroup = 2,
            SameLayerAndGroup = 3,
            All = 4
        }
        /**
         * DragonBones factory
         * @class CCFactory
         * @extends BaseFactory
         * @deprecated since v3.5.1, this is an engine private interface that will be removed in the future.
         */
        export class CCFactory extends BaseFactory implements ISchedulable {
            static _factory: CCFactory | null;
            /**
             * @en
             * Get an CCFactory instance
             * @zh
             * 获取一个 CCFactory 实例
             * @method getInstance
             * @return {CCFactory}
             * @static
             * @example
             * let factory = CCFactory.getInstance();
             */
            static getInstance(): CCFactory;
            id?: string;
            uuid?: string;
            protected _slots?: CCSlot[];
            constructor();
            onRestart(): void;
            initUpdate(dt?: number): void;
            update(dt: number): void;
            getDragonBonesDataByRawData(rawData: any): DragonBonesData | null;
            buildArmatureDisplay(armatureName: string, dragonBonesName?: string, skinName?: string, textureAtlasName?: string): DisplayData | null;
            createArmatureNode(comp: ArmatureDisplay, armatureName: string, node?: Node): ArmatureDisplay;
            _buildTextureAtlasData(textureAtlasData: null | CCTextureAtlasData, textureAtlas?: __private._cocos_core_assets_texture_base__TextureBase): CCTextureAtlasData;
            _sortSlots(): void;
            _buildArmature(dataPackage: any): Armature;
            _buildSlot(dataPackage: any, slotData: any, displays: any): CCSlot;
            getDragonBonesDataByUUID(uuid: any): DragonBonesData | null;
            removeDragonBonesDataByUUID(uuid: string, disposeData?: boolean): void;
        }
        /**
         * @deprecated since v3.5.1, this is an engine private interface that will be removed in the future.
         */
        export class CCSlot extends Slot {
            static toString(): string;
            /**
             * @en Vertices in local coordinate system.
             * @zh 局部坐标顶点数据
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _localVertices: number[];
            /**
             * @en Indices array of vertex data
             * @zh 顶点数组索引
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _indices: number[];
            /**
             * @en Local transformation matrix
             * @zh 局部坐标系变换矩阵
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _matrix: math.Mat4;
            /**
             * @en World transformation matrix
             * @zh 世界坐标系变换矩阵
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _worldMatrix: math.Mat4;
            protected _worldMatrixDirty: boolean;
            /**
             * @en Color setting on a slot
             * @zh 设置在 Slot 上的颜色
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _color: math.Color;
            constructor();
            getTexture(): Texture2D | null;
            calculWorldMatrix(): void;
            _onClear(): void;
            _onUpdateDisplay(): void;
            _initDisplay(value: any): void;
            _addDisplay(): void;
            _replaceDisplay(value: any): void;
            _removeDisplay(): void;
            _disposeDisplay(object: any): void;
            _updateVisible(): void;
            _updateGlueMesh(): void;
            _updateZOrder(): void;
            _updateBlendMode(): void;
            _updateColor(): void;
            _updateFrame(): void;
            _updateMesh(): void;
            _identityTransform(): void;
            _updateTransform(): void;
            updateWorldMatrix(): void;
            _mulMat(out: math.Mat4, a: Readonly<math.Mat4>, b: Readonly<math.Mat4>): void;
        }
        /**
         * @deprecated since v3.5.1, this is an engine private interface that will be removed in the future.
         */
        export class CCTextureAtlasData extends TextureAtlasData {
            get renderTexture(): __private._cocos_core_assets_texture_base__TextureBase | null;
            set renderTexture(value: __private._cocos_core_assets_texture_base__TextureBase | null);
            protected _renderTexture: __private._cocos_core_assets_texture_base__TextureBase | null;
            static toString(): string;
            createTexture(): CCTextureData;
            _onClear(): void;
        }
        /**
         * @deprecated since v3.5.1, this is an engine private interface that will be removed in the future.
         */
        export class CCTextureData extends TextureData {
            spriteFrame: SpriteFrame | null;
            static toString(): string;
            _onClear(): void;
        }
        /**
         * @deprecated since v3.5.1, this is an engine private interface that will be removed in the future.
         */
        export class CCArmatureDisplay extends DisplayData implements IEventDispatcher {
            get node(): this;
            shouldAdvanced: boolean;
            _ccNode: Node | null;
            _ccComponent: ArmatureDisplay | null;
            _eventTarget: EventTarget;
            _armature: Armature | null;
            constructor();
            hasEvent(type: string): boolean;
            addEvent(type: string, listener: any, thisObject: any): void;
            removeEvent(type: string, listener: any, thisObject: any): void;
            setEventTarget(eventTarget: EventTarget): void;
            getRootDisplay(): CCArmatureDisplay;
            convertToRootSpace(pos: math.Vec3): math.Vec3;
            convertToWorldSpace(point: math.Vec3): math.Vec3 | undefined;
            getRootNode(): Node | null;
            dbInit(armature: Armature | null): void;
            dbClear(): void;
            dbUpdate(): void;
            advanceTimeBySelf(on: boolean | number): void;
            hasDBEventListener(type: any): boolean;
            addDBEventListener(type: string, listener: any, target: any): void;
            removeDBEventListener(type: string, listener: any, target: any): void;
            dispatchDBEvent(type: string, eventObject: any): void;
        }
        export interface ArmatureInfo {
            curAnimationCache: AnimationCache | null;
            armature: Armature;
            animationsCache: {
                [key: string]: AnimationCache;
            };
        }
        export interface ArmatureFrame {
            segments: ArmatureFrameSegment[];
            colors: ArmatureFrameColor[];
            boneInfos: ArmatureFrameBoneInfo[];
            vertices: Float32Array;
            uintVert: Uint32Array;
            indices: Uint16Array;
        }
        export interface ArmatureFrameBoneInfo {
            globalTransformMatrix: Matrix;
        }
        export interface ArmatureFrameColor {
            r: number;
            g: number;
            b: number;
            a: number;
            vfOffset?: number;
        }
        export interface ArmatureFrameSegment {
            indexCount: number;
            vfCount: number;
            vertexCount: number;
            tex: Texture2D;
            blendMode: BlendMode;
        }
        export class AnimationCache {
            maxVertexCount: number;
            maxIndexCount: number;
            _privateMode: boolean;
            _inited: boolean;
            _invalid: boolean;
            _enableCacheAttachedInfo: boolean;
            frames: ArmatureFrame[];
            totalTime: number;
            isCompleted: boolean;
            _frameIdx: number;
            _armatureInfo: ArmatureInfo | null;
            _animationName: string | null;
            _tempSegments: ArmatureFrameSegment[] | null;
            _tempColors: ArmatureFrameColor[] | null;
            _tempBoneInfos: ArmatureFrameBoneInfo[] | null;
            constructor();
            init(armatureInfo: ArmatureInfo, animationName: string): void;
            clear(): void;
            begin(): void;
            end(): void;
            _needToUpdate(toFrameIdx?: number): boolean;
            updateToFrame(toFrameIdx?: number): void;
            isInited(): boolean;
            isInvalid(): boolean;
            invalidAllFrame(): void;
            updateAllFrame(): void;
            enableCacheAttachedInfo(): void;
            updateFrame(armature: any, index: any): void;
            _traverseArmature(armature: Armature, parentOpacity: any): void;
        }
        export class ArmatureCache {
            protected _privateMode: boolean;
            protected _animationPool: Record<string, AnimationCache>;
            protected _armatureCache: Record<string, ArmatureInfo>;
            constructor();
            enablePrivateMode(): void;
            dispose(): void;
            _removeArmature(armatureKey: string): void;
            resetArmature(uuid: string): void;
            getArmatureCache(armatureName: string, armatureKey: string, atlasUUID: string): Armature | null;
            getAnimationCache(armatureKey: any, animationName: any): AnimationCache | null;
            initAnimationCache(armatureKey: string, animationName: string): AnimationCache | null;
            invalidAnimationCache(armatureKey: string): void;
            updateAnimationCache(armatureKey: string, animationName: string): void;
            static canCache(armature: Armature): boolean;
            static FrameTime: number;
            static sharedCache: ArmatureCache;
        }
        /**
         * @en The skeleton data of dragonBones.
         * @zh dragonBones 的 骨骼数据。
         * @class DragonBonesAsset
         * @extends Asset
         */
        export class DragonBonesAsset extends Asset {
            /**
             * @en
             * See http://developer.egret.com/cn/github/egret-docs/DB/dbLibs/dataFormat/index.html
             * @zh
             * 可查看 DragonBones 官方文档 http://developer.egret.com/cn/github/egret-docs/DB/dbLibs/dataFormat/index.html
             * @property {string} dragonBonesJson
             */
            protected _dragonBonesJson: string;
            get dragonBonesJson(): string;
            set dragonBonesJson(value: string);
            protected _dragonBonesJsonData?: ArrayBuffer;
            constructctor(): void;
            createNode(callback: (err: Error | null, node: Node) => void): void;
            reset(): void;
            init(factory?: CCFactory, atlasUUID?: string): string;
            getArmatureEnum(): any;
            getAnimsEnum(armatureName: string): {
                "<None>": number;
            } | null;
            destroy(): boolean;
            protected _clear(): void;
        }
        /**
         * @en The skeleton atlas data of dragonBones.
         * @zh dragonBones 的骨骼纹理数据。
         * @class DragonBonesAtlasAsset
         * @extends Asset
         */
        export class DragonBonesAtlasAsset extends Asset {
            constructor();
            _atlasJson: string;
            get atlasJson(): string;
            set atlasJson(value: string);
            _texture: Texture2D | null;
            _atlasJsonData: any;
            _factory: CCFactory | null;
            /**
             * @property {Texture2D} texture
             */
            get texture(): Texture2D | null;
            set texture(value: Texture2D | null);
            _textureAtlasData: TextureAtlasData | null;
            createNode(callback: (error: Error | null, node: Node) => void): void;
            init(factory: CCFactory): void;
            destroy(): boolean;
            protected _clear(): void;
        }
        export let timeScale: number;
        /**
         * @en Enum for cache mode type.
         * @zh Dragonbones渲染类型
         * @enum ArmatureDisplay.AnimationCacheMode
         */
        export enum AnimationCacheMode {
            /**
             * @en The realtime mode.
             * @zh 实时计算模式。
             * @property {Number} REALTIME
             */
            REALTIME = 0,
            /**
             * @en The shared cache mode.
             * @zh 共享缓存模式。
             * @property {Number} SHARED_CACHE
             */
            SHARED_CACHE = 1,
            /**
             * @en The private cache mode.
             * @zh 私有缓存模式。
             * @property {Number} PRIVATE_CACHE
             */
            PRIVATE_CACHE = 2
        }
        export interface ArmatureDisplayDrawData {
            material: Material | null;
            texture: Texture2D | null;
            indexOffset: number;
            indexCount: number;
        }
        export class DragonBoneSocket {
            /**
             * @en Path of the target joint.
             * @zh 此挂点的目标骨骼路径。
             */
            path: string;
            /**
             * @en Transform output node.
             * @zh 此挂点的变换信息输出节点。
             */
            target: Node | null;
            boneIndex: number | null;
            constructor(path?: string, target?: Node | null);
        }
        /**
         * @en
         * The Armature Display of DragonBones <br/>
         * <br/>
         * Armature Display has a reference to a DragonBonesAsset and stores the state for ArmatureDisplay instance,
         * which consists of the current pose's bone SRT, slot colors, and which slot attachments are visible. <br/>
         * Multiple Armature Display can use the same DragonBonesAsset which includes all animations, skins, and attachments. <br/>
         * @zh
         * DragonBones 骨骼动画 <br/>
         * <br/>
         * Armature Display 具有对骨骼数据的引用并且存储了骨骼实例的状态，
         * 它由当前的骨骼动作，slot 颜色，和可见的 slot attachments 组成。<br/>
         * 多个 Armature Display 可以使用相同的骨骼数据，其中包括所有的动画，皮肤和 attachments。<br/>
         *
         * @class ArmatureDisplay
         * @extends RenderComponent
         */
        export class ArmatureDisplay extends UIRenderer {
            static AnimationCacheMode: typeof AnimationCacheMode;
            /**
             * @en
             * The DragonBones data contains the armatures information (bind pose bones, slots, draw order,
             * attachments, skins, etc) and animations but does not hold any state.<br/>
             * Multiple ArmatureDisplay can share the same DragonBones data.
             * @zh
             * 骨骼数据包含了骨骼信息（绑定骨骼动作，slots，渲染顺序，
             * attachments，皮肤等等）和动画但不持有任何状态。<br/>
             * 多个 ArmatureDisplay 可以共用相同的骨骼数据。
             * @property {DragonBonesAsset} dragonAsset
             */
            get dragonAsset(): DragonBonesAsset | null;
            set dragonAsset(value: DragonBonesAsset | null);
            /**
             * @en
             * The atlas asset for the DragonBones.
             * @zh
             * 骨骼数据所需的 Atlas Texture 数据。
             * @property {DragonBonesAtlasAsset} dragonAtlasAsset
             */
            get dragonAtlasAsset(): DragonBonesAtlasAsset | null;
            set dragonAtlasAsset(value: DragonBonesAtlasAsset | null);
            /**
             * @en The name of current armature.
             * @zh 当前的 Armature 名称。
             * @property {String} armatureName
             */
            get armatureName(): string;
            set armatureName(name: string);
            /**
             * @en The name of current playing animation.
             * @zh 当前播放的动画名称。
             * @property {String} animationName
             */
            get animationName(): string;
            set animationName(value: string);
            get _defaultArmatureIndex(): __private._cocos_dragon_bones_ArmatureDisplay__DefaultArmaturesEnum;
            set _defaultArmatureIndex(value: __private._cocos_dragon_bones_ArmatureDisplay__DefaultArmaturesEnum);
            get _animationIndex(): __private._cocos_dragon_bones_ArmatureDisplay__DefaultAnimsEnum;
            set _animationIndex(value: __private._cocos_dragon_bones_ArmatureDisplay__DefaultAnimsEnum);
            get _defaultCacheMode(): AnimationCacheMode;
            set _defaultCacheMode(value: AnimationCacheMode);
            /**
             * @en The time scale of this armature.
             * @zh 当前骨骼中所有动画的时间缩放率。
             * @property {Number} timeScale
             * @default 1
             */
            get timeScale(): number;
            set timeScale(value: number);
            /**
             * @en The play times of the default animation.
             *      -1 means using the value of config file;
             *      0 means repeat for ever
             *      >0 means repeat times
             * @zh 播放默认动画的循环次数
             *      -1 表示使用配置文件中的默认值;
             *      0 表示无限循环
             *      >0 表示循环次数
             * @property {Number} playTimes
             * @default -1
             */
            playTimes: number;
            /**
             * @en Indicates whether to enable premultiplied alpha.
             * You should disable this option when image's transparent area appears to have opaque pixels,
             * or enable this option when image's half transparent area appears to be darken.
             * @zh 是否启用贴图预乘。
             * 当图片的透明区域出现色块时需要关闭该选项，当图片的半透明区域颜色变黑时需要启用该选项。
             * @property {Boolean} premultipliedAlpha
             * @default false
             */
            premultipliedAlpha: boolean;
            /**
             * @en Indicates whether open debug bones.
             * @zh 是否显示 bone 的 debug 信息。
             * @property {Boolean} debugBones
             * @default false
             */
            get debugBones(): boolean;
            set debugBones(value: boolean);
            get enableBatch(): boolean;
            set enableBatch(value: boolean);
            /**
             * @en
             * The bone sockets this animation component maintains.<br>
             * Sockets have to be registered here before attaching custom nodes to animated bones.
             * @zh
             * 当前动画组件维护的挂点数组。要挂载自定义节点到受动画驱动的骨骼上，必须先在此注册挂点。
             */
            get sockets(): DragonBoneSocket[];
            set sockets(val: DragonBoneSocket[]);
            get socketNodes(): Map<string, Node>;
            _armature: Armature | null;
            attachUtil: AttachUtil;
            get drawList(): memop.RecyclePool<ArmatureDisplayDrawData>;
            protected _defaultArmatureIndexValue: __private._cocos_dragon_bones_ArmatureDisplay__DefaultArmaturesEnum;
            _dragonAsset: DragonBonesAsset | null;
            _dragonAtlasAsset: DragonBonesAtlasAsset | null;
            _armatureName: string;
            protected _animationName: string;
            protected _animationIndexValue: __private._cocos_dragon_bones_ArmatureDisplay__DefaultAnimsEnum;
            protected _preCacheMode: number;
            protected _cacheMode: AnimationCacheMode;
            protected _defaultCacheModeValue: AnimationCacheMode;
            protected _timeScale: number;
            protected _playTimes: number;
            protected _debugBones: boolean;
            protected _enableBatch: boolean;
            _debugDraw: Graphics | null;
            /**
             * @internal
             */
            protected _armatureKey: string;
            /**
             * @internal
             */
            protected _accTime: number;
            /**
             * @internal
             */
            protected _playCount: number;
            /**
             * @internal
             */
            protected _frameCache: AnimationCache | null;
            /**
             * @internal
             */
            _curFrame: ArmatureFrame | null;
            protected _playing: boolean;
            protected _armatureCache: ArmatureCache | null;
            protected _eventTarget: EventTarget;
            protected _factory: CCFactory | null;
            protected _displayProxy: CCArmatureDisplay | null;
            protected _drawIdx: number;
            protected _drawList: memop.RecyclePool<ArmatureDisplayDrawData>;
            /**
             * @internal
             */
            maxVertexCount: number;
            /**
             * @internal
             */
            maxIndexCount: number;
            protected _materialCache: {
                [key: string]: renderer.MaterialInstance;
            };
            protected _enumArmatures: any;
            protected _enumAnimations: any;
            protected _socketNodes: Map<string, Node>;
            protected _cachedSockets: Map<string, __private._cocos_dragon_bones_ArmatureDisplay__BoneIndex>;
            protected _sockets: DragonBoneSocket[];
            constructor();
            initFactory(): void;
            onLoad(): void;
            /**
             * @internal
             */
            _requestDrawData(material: Material, texture: Texture2D, indexOffset: number, indexCount: number): ArmatureDisplayDrawData;
            destroyRenderData(): void;
            getMaterialForBlend(src: gfx.BlendFactor, dst: gfx.BlendFactor): renderer.MaterialInstance;
            protected _updateBuiltinMaterial(): Material;
            get customMaterial(): Material | null;
            set customMaterial(val: Material | null);
            protected updateMaterial(): void;
            protected _render(batcher: UI): void;
            __preload(): void;
            _init(): void;
            /**
             * @en
             * The key of dragonbones cache data, which is regard as 'dragonbonesName', when you want to change dragonbones cloth.
             * @zh
             * 缓存龙骨数据的key值，换装的时会使用到该值，作为dragonbonesName使用
             * @method getArmatureKey
             * @return {String}
             * @example
             * let factory = dragonBones.CCFactory.getInstance();
             * let needChangeSlot = needChangeArmature.armature().getSlot("changeSlotName");
             * factory.replaceSlotDisplay(toChangeArmature.getArmatureKey(), "armatureName", "slotName", "displayName", needChangeSlot);
             */
            getArmatureKey(): string;
            /**
             * @en
             * It's best to set cache mode before set property 'dragonAsset', or will waste some cpu time.
             * If set the mode in editor, then no need to worry about order problem.
             * @zh
             * 若想切换渲染模式，最好在设置'dragonAsset'之前，先设置好渲染模式，否则有运行时开销。
             * 若在编辑中设置渲染模式，则无需担心设置次序的问题。
             *
             * @method setAnimationCacheMode
             * @param {AnimationCacheMode} cacheMode
             * @example
             * armatureDisplay.setAnimationCacheMode(dragonBones.ArmatureDisplay.AnimationCacheMode.SHARED_CACHE);
             */
            setAnimationCacheMode(cacheMode: AnimationCacheMode): void;
            /**
             * @en Whether in cached mode.
             * @zh 当前是否处于缓存模式。
             * @method isAnimationCached
             * @return {Boolean}
             */
            isAnimationCached(): boolean;
            onEnable(): void;
            onDisable(): void;
            _emitCacheCompleteEvent(): void;
            updateAnimation(dt: any): void;
            onDestroy(): void;
            _updateDebugDraw(): void;
            protected _updateBatch(): void;
            _buildArmature(): void;
            querySockets(): string[];
            /**
             * @en Query socket path with slot or bone name.
             * @zh 查询 Socket 路径
             * @param name Slot name or Bone name
             */
            querySocketPathByName(name: string): string[];
            _parseDragonAtlasAsset(): void;
            _refresh(): void;
            _cacheModeEnum: any;
            _updateCacheModeEnum(): void;
            _updateAnimEnum(): void;
            _updateArmatureEnum(): void;
            _indexBoneSockets(): void;
            /**
             * @en
             * Play the specified animation.
             * Parameter animName specify the animation name.
             * Parameter playTimes specify the repeat times of the animation.
             * -1 means use the value of the config file.
             * 0 means play the animation for ever.
             * >0 means repeat times.
             * @zh
             * 播放指定的动画.
             * animName 指定播放动画的名称。
             * playTimes 指定播放动画的次数。
             * -1 为使用配置文件中的次数。
             * 0 为无限循环播放。
             * >0 为动画的重复次数。
             */
            playAnimation(animName: string, playTimes?: number): AnimationState | null;
            /**
             * @en
             * Updating an animation cache to calculate all frame data in the animation is a cost in
             * performance due to calculating all data in a single frame.
             * To update the cache, use the invalidAnimationCache method with high performance.
             * @zh
             * 更新某个动画缓存, 预计算动画中所有帧数据，由于在单帧计算所有数据，所以较消耗性能。
             * 若想更新缓存，可使用 invalidAnimationCache 方法，具有较高性能。
             * @method updateAnimationCache
             * @param {String} animName
             */
            updateAnimationCache(animName: string): void;
            /**
             * @en
             * Invalidates the animation cache, which is then recomputed on each frame..
             * @zh
             * 使动画缓存失效，之后会在每帧重新计算。
             * @method invalidAnimationCache
             */
            invalidAnimationCache(): void;
            /**
             * @en
             * Get the all armature names in the DragonBones Data.
             * @zh
             * 获取 DragonBones 数据中所有的 armature 名称
             * @method getArmatureNames
             * @returns {Array}
             */
            getArmatureNames(): string[];
            /**
             * @en
             * Get the all animation names of specified armature.
             * @zh
             * 获取指定的 armature 的所有动画名称。
             * @method getAnimationNames
             * @param {String} armatureName
             * @returns {Array}
             */
            getAnimationNames(armatureName: string): string[];
            /**
             * @en
             * Add event listener for the DragonBones Event, the same to addEventListener.
             * @zh
             * 添加 DragonBones 事件监听器，与 addEventListener 作用相同。
             * @method on
             * @param {String} type - A string representing the event type to listen for.
             * @param {Function} listener - The callback that will be invoked when the event is dispatched.
             * @param {Event} listener.event event
             * @param {Object} [target] - The target (this object) to invoke the callback, can be null
             */
            on(eventType: string, listener: any, target: any): void;
            /**
             * @en
             * Remove the event listener for the DragonBones Event, the same to removeEventListener.
             * @zh
             * 移除 DragonBones 事件监听器，与 removeEventListener 作用相同。
             * @method off
             * @param {String} type - A string representing the event type to listen for.
             * @param {Function} [listener]
             * @param {Object} [target]
             */
            off(eventType: string, listener: any, target: any): void;
            /**
             * @en
             * Add DragonBones one-time event listener, the callback will remove itself after the first time it is triggered.
             * @zh
             * 添加 DragonBones 一次性事件监听器，回调会在第一时间被触发后删除自身。
             * @method once
             * @param {String} type - A string representing the event type to listen for.
             * @param {Function} listener - The callback that will be invoked when the event is dispatched.
             * @param {Event} listener.event event
             * @param {Object} [target] - The target (this object) to invoke the callback, can be null
             */
            once(eventType: string, listener: any, target: any): void;
            /**
             * @en
             * Add event listener for the DragonBones Event.
             * @zh
             * 添加 DragonBones 事件监听器。
             * @method addEventListener
             * @param {String} type - A string representing the event type to listen for.
             * @param {Function} listener - The callback that will be invoked when the event is dispatched.
             * @param {Event} listener.event event
             * @param {Object} [target] - The target (this object) to invoke the callback, can be null
             */
            addEventListener(eventType: any, listener: any, target: any): void;
            /**
             * @en
             * Remove the event listener for the DragonBones Event.
             * @zh
             * 移除 DragonBones 事件监听器。
             * @method removeEventListener
             * @param {String} type - A string representing the event type to listen for.
             * @param {Function} [listener]
             * @param {Object} [target]
             */
            removeEventListener(eventType: any, listener: any, target: any): void;
            /**
             * @en
             * Build the armature for specified name.
             * @zh
             * 构建指定名称的 armature 对象
             * @method buildArmature
             * @param {String} armatureName
             * @param {Node} node
             * @return {dragonBones.ArmatureDisplay}
             */
            buildArmature(armatureName: string, node?: Node): ArmatureDisplay;
            /**
             * @en
             * Get the current armature object of the ArmatureDisplay.
             * @zh
             * 获取 ArmatureDisplay 当前使用的 Armature 对象
             * @method armature
             * @returns {Object}
             */
            armature(): Armature | null;
            protected _flushAssembler(): void;
            protected _updateSocketBindings(): void;
            protected createRenderEntity(): __private._cocos_2d_renderer_render_entity__RenderEntity;
            markForUpdateRenderData(enable?: boolean): void;
        }
        /**
         * @en Attach node tool
         * @zh 挂点工具类
         * @class dragonBones.AttachUtil
         */
        export class AttachUtil {
            _inited: boolean;
            _armature: Armature | null;
            _armatureNode: Node | null;
            _armatureDisplay: ArmatureDisplay | null;
            constructor();
            init(armatureDisplay: ArmatureDisplay): void;
            reset(): void;
            _syncAttachedNode(): void;
        }
        export const simpleDragonBoneAssembler: IAssemblerManager;
        /* eslint-disable @typescript-eslint/ban-types */
        /**
         * The MIT License (MIT)
         *
         * Copyright (c) 2012-2017 DragonBones team and other contributors
         *
         * Permission is hereby granted, free of charge, to any person obtaining a copy of
         * this software and associated documentation files (the "Software"), to deal in
         * the Software without restriction, including without limitation the rights to
         * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
         * the Software, and to permit persons to whom the Software is furnished to do so,
         * subject to the following conditions:
         *
         * The above copyright notice and this permission notice shall be included in all
         * copies or substantial portions of the Software.
         *
         * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
         * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
         * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
         * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
         * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
         * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
         */
        /**
         * @internal
         * @private
         */
        export const webAssemblyModule: {
            HEAP16: Int16Array;
            _malloc(byteSize: number): number;
            _free(pointer: number): void;
            setDataBinary(data: DragonBonesData, binaryPointer: number, intBytesLength: number, floatBytesLength: number, frameIntBytesLength: number, frameFloatBytesLength: number, frameBytesLength: number, timelineBytesLength: number): void;
        };
        /**
         * @internal
         * @private
         */
        export enum BinaryOffset {
            WeigthBoneCount = 0,
            WeigthFloatOffset = 1,
            WeigthBoneIndices = 2,
            MeshVertexCount = 0,
            MeshTriangleCount = 1,
            MeshFloatOffset = 2,
            MeshWeightOffset = 3,
            MeshVertexIndices = 4,
            TimelineScale = 0,
            TimelineOffset = 1,
            TimelineKeyFrameCount = 2,
            TimelineFrameValueCount = 3,
            TimelineFrameValueOffset = 4,
            TimelineFrameOffset = 5,
            FramePosition = 0,
            FrameTweenType = 1,
            FrameTweenEasingOrCurveSampleCount = 2,
            FrameCurveSamples = 3,
            DeformMeshOffset = 0,
            DeformCount = 1,
            DeformValueCount = 2,
            DeformValueOffset = 3,
            DeformFloatOffset = 4
        }
        /**
         * @internal
         * @private
         */
        export enum ArmatureType {
            Armature = 0,
            MovieClip = 1,
            Stage = 2
        }
        /**
         * @internal
         * @private
         */
        export enum BoneType {
            Bone = 0,
            Surface = 1
        }
        /**
         * @private
         */
        export enum DisplayType {
            Image = 0,
            Armature = 1,
            Mesh = 2,
            BoundingBox = 3
        }
        /**
         * - Bounding box type.
         * @version DragonBones 5.0
         * @language en_US
         */
        /**
         * - 边界框类型。
         * @version DragonBones 5.0
         * @language zh_CN
         */
        export enum BoundingBoxType {
            Rectangle = 0,
            Ellipse = 1,
            Polygon = 2
        }
        /**
         * @internal
         * @private
         */
        export enum ActionType {
            Play = 0,
            Stop = 1,
            GotoAndPlay = 2,
            GotoAndStop = 3,
            FadeIn = 4,
            FadeOut = 5,
            Frame = 10,
            Sound = 11
        }
        /**
         * @internal
         * @private
         */
        export enum BlendMode {
            Normal = 0,
            Add = 1,
            Alpha = 2,
            Darken = 3,
            Difference = 4,
            Erase = 5,
            HardLight = 6,
            Invert = 7,
            Layer = 8,
            Lighten = 9,
            Multiply = 10,
            Overlay = 11,
            Screen = 12,
            Subtract = 13
        }
        /**
         * @internal
         * @private
         */
        export enum TweenType {
            None = 0,
            Line = 1,
            Curve = 2,
            QuadIn = 3,
            QuadOut = 4,
            QuadInOut = 5
        }
        /**
         * @internal
         * @private
         */
        export enum TimelineType {
            Action = 0,
            ZOrder = 1,
            BoneAll = 10,
            BoneTranslate = 11,
            BoneRotate = 12,
            BoneScale = 13,
            Surface = 50,
            SlotDisplay = 20,
            SlotColor = 21,
            SlotFFD = 22,
            IKConstraint = 30,
            AnimationTime = 40,
            AnimationWeight = 41
        }
        /**
         * - Offset mode.
         * @version DragonBones 5.5
         * @language en_US
         */
        /**
         * - 偏移模式。
         * @version DragonBones 5.5
         * @language zh_CN
         */
        export enum OffsetMode {
            None = 0,
            Additive = 1,
            Override = 2
        }
        /**
         * @private
         */
        export interface Map<T> {
            [key: string]: T;
        }
        /**
         * @private
         */
        export class DragonBones {
            static readonly VERSION: string;
            static yDown: boolean;
            static debug: boolean;
            static debugDraw: boolean;
            static webAssembly: boolean;
            constructor(eventManager: IEventDispatcher);
            advanceTime(passedTime: number): void;
            bufferEvent(value: EventObject): void;
            bufferObject(object: BaseObject): void;
            readonly clock: WorldClock;
            readonly eventManager: IEventDispatcher;
        }
        /**
         * - The BaseObject is the base export class for all objects in the DragonBones framework.
         * All BaseObject instances are cached to the object pool to reduce the performance consumption of frequent requests for memory or memory recovery.
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 基础对象，通常 DragonBones 的对象都继承自该类。
         * 所有基础对象的实例都会缓存到对象池，以减少频繁申请内存或内存回收的性能消耗。
         * @version DragonBones 4.5
         * @language zh_CN
         */
        export abstract class BaseObject {
            static toString(): string;
            /**
             * - Set the maximum cache count of the specify object pool.
             * @param objectConstructor - The specify class. (Set all object pools max cache count if not set)
             * @param maxCount - Max count.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 设置特定对象池的最大缓存数量。
             * @param objectConstructor - 特定的类。 (不设置则设置所有对象池的最大缓存数量)
             * @param maxCount - 最大缓存数量。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            static setMaxCount(objectConstructor: (typeof BaseObject) | null, maxCount: number): void;
            /**
             * - Clear the cached instances of a specify object pool.
             * @param objectConstructor - Specify class. (Clear all cached instances if not set)
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 清除特定对象池的缓存实例。
             * @param objectConstructor - 特定的类。 (不设置则清除所有缓存的实例)
             * @version DragonBones 4.5
             * @language zh_CN
             */
            static clearPool(objectConstructor?: (typeof BaseObject) | null): void;
            /**
             * - Get an instance of the specify export class from object pool.
             * @param objectConstructor - The specify class.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 从对象池中获取特定类的实例。
             * @param objectConstructor - 特定的类。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            static borrowObject<T extends BaseObject>(objectConstructor: {
                new (): T;
            }): T;
            /**
             * - A unique identification number assigned to the object.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 分配给此实例的唯一标识号。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            readonly hashCode: number;
            /**
             * @private
             */
            protected abstract _onClear(): void;
            /**
             * - Clear the object and return it back to object pool。
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 清除该实例的所有数据并将其返还对象池。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            returnToPool(): void;
        }
        /**
         * - 2D Transform matrix.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 2D 转换矩阵。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        export class Matrix {
            /**
             * - The value that affects the positioning of pixels along the x axis when scaling or rotating an image.
             * @default 1.0
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 缩放或旋转图像时影响像素沿 x 轴定位的值。
             * @default 1.0
             * @version DragonBones 3.0
             * @language zh_CN
             */
            a: number;
            /**
             * - The value that affects the positioning of pixels along the y axis when rotating or skewing an image.
             * @default 0.0
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 旋转或倾斜图像时影响像素沿 y 轴定位的值。
             * @default 0.0
             * @version DragonBones 3.0
             * @language zh_CN
             */
            b: number;
            /**
             * - The value that affects the positioning of pixels along the x axis when rotating or skewing an image.
             * @default 0.0
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 旋转或倾斜图像时影响像素沿 x 轴定位的值。
             * @default 0.0
             * @version DragonBones 3.0
             * @language zh_CN
             */
            c: number;
            /**
             * - The value that affects the positioning of pixels along the y axis when scaling or rotating an image.
             * @default 1.0
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 缩放或旋转图像时影响像素沿 y 轴定位的值。
             * @default 1.0
             * @version DragonBones 3.0
             * @language zh_CN
             */
            d: number;
            /**
             * - The distance by which to translate each point along the x axis.
             * @default 0.0
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 沿 x 轴平移每个点的距离。
             * @default 0.0
             * @version DragonBones 3.0
             * @language zh_CN
             */
            tx: number;
            /**
             * - The distance by which to translate each point along the y axis.
             * @default 0.0
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 沿 y 轴平移每个点的距离。
             * @default 0.0
             * @version DragonBones 3.0
             * @language zh_CN
             */
            ty: number;
            /**
             * @private
             */
            constructor(a?: number, b?: number, c?: number, d?: number, tx?: number, ty?: number);
            toString(): string;
            /**
             * @private
             */
            copyFrom(value: Matrix): Matrix;
            /**
             * @private
             */
            copyFromArray(value: Array<number>, offset?: number): Matrix;
            /**
             * - Convert to unit matrix.
             * The resulting matrix has the following properties: a=1, b=0, c=0, d=1, tx=0, ty=0.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 转换为单位矩阵。
             * 该矩阵具有以下属性：a=1、b=0、c=0、d=1、tx=0、ty=0。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            identity(): Matrix;
            /**
             * - Multiplies the current matrix with another matrix.
             * @param value - The matrix that needs to be multiplied.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 将当前矩阵与另一个矩阵相乘。
             * @param value - 需要相乘的矩阵。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            concat(value: Matrix): Matrix;
            /**
             * - Convert to inverse matrix.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 转换为逆矩阵。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            invert(): Matrix;
            /**
             * - Apply a matrix transformation to a specific point.
             * @param x - X coordinate.
             * @param y - Y coordinate.
             * @param result - The point after the transformation is applied.
             * @param delta - Whether to ignore tx, ty's conversion to point.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 将矩阵转换应用于特定点。
             * @param x - 横坐标。
             * @param y - 纵坐标。
             * @param result - 应用转换之后的点。
             * @param delta - 是否忽略 tx，ty 对点的转换。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            transformPoint(x: number, y: number, result: {
                x: number;
                y: number;
            }, delta?: boolean): void;
            /**
             * @private
             */
            transformRectangle(rectangle: {
                x: number;
                y: number;
                width: number;
                height: number;
            }, delta?: boolean): void;
        }
        /**
         * - 2D Transform.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 2D 变换。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        export class Transform {
            /**
             * @private
             */
            static readonly PI: number;
            /**
             * @private
             */
            static readonly PI_D: number;
            /**
             * @private
             */
            static readonly PI_H: number;
            /**
             * @private
             */
            static readonly PI_Q: number;
            /**
             * @private
             */
            static readonly RAD_DEG: number;
            /**
             * @private
             */
            static readonly DEG_RAD: number;
            /**
             * @private
             */
            static normalizeRadian(value: number): number;
            /**
             * - Horizontal translate.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 水平位移。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            x: number;
            /**
             * - Vertical translate.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 垂直位移。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            y: number;
            /**
             * - Skew. (In radians)
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 倾斜。 （以弧度为单位）
             * @version DragonBones 3.0
             * @language zh_CN
             */
            skew: number;
            /**
             * - rotation. (In radians)
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 旋转。 （以弧度为单位）
             * @version DragonBones 3.0
             * @language zh_CN
             */
            rotation: number;
            /**
             * - Horizontal Scaling.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 水平缩放。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            scaleX: number;
            /**
             * - Vertical scaling.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 垂直缩放。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            scaleY: number;
            /**
             * @private
             */
            constructor(x?: number, y?: number, skew?: number, rotation?: number, scaleX?: number, scaleY?: number);
            toString(): string;
            /**
             * @private
             */
            copyFrom(value: Transform): Transform;
            /**
             * @private
             */
            identity(): Transform;
            /**
             * @private
             */
            add(value: Transform): Transform;
            /**
             * @private
             */
            minus(value: Transform): Transform;
            /**
             * @private
             */
            fromMatrix(matrix: Matrix): Transform;
            /**
             * @private
             */
            toMatrix(matrix: Matrix): Transform;
        }
        /**
         * @internal
         * @private
         */
        export class ColorTransform {
            alphaMultiplier: number;
            redMultiplier: number;
            greenMultiplier: number;
            blueMultiplier: number;
            alphaOffset: number;
            redOffset: number;
            greenOffset: number;
            blueOffset: number;
            constructor(alphaMultiplier?: number, redMultiplier?: number, greenMultiplier?: number, blueMultiplier?: number, alphaOffset?: number, redOffset?: number, greenOffset?: number, blueOffset?: number);
            copyFrom(value: ColorTransform): void;
            identity(): void;
        }
        /**
         * - The Point object represents a location in a two-dimensional coordinate system.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - Point 对象表示二维坐标系统中的某个位置。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        export class Point {
            /**
             * - The horizontal coordinate.
             * @default 0.0
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 该点的水平坐标。
             * @default 0.0
             * @version DragonBones 3.0
             * @language zh_CN
             */
            x: number;
            /**
             * - The vertical coordinate.
             * @default 0.0
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 该点的垂直坐标。
             * @default 0.0
             * @version DragonBones 3.0
             * @language zh_CN
             */
            y: number;
            /**
             * - Creates a new point. If you pass no parameters to this method, a point is created at (0,0).
             * @param x - The horizontal coordinate.
             * @param y - The vertical coordinate.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 创建一个 egret.Point 对象.若不传入任何参数，将会创建一个位于（0，0）位置的点。
             * @param x - 该对象的x属性值，默认为 0.0。
             * @param y - 该对象的y属性值，默认为 0.0。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            constructor(x?: number, y?: number);
            /**
             * @private
             */
            copyFrom(value: Point): void;
            /**
             * @private
             */
            clear(): void;
        }
        /**
         * - A Rectangle object is an area defined by its position, as indicated by its top-left corner point (x, y) and by its
         * width and its height.<br/>
         * The x, y, width, and height properties of the Rectangle export class are independent of each other; changing the value of
         * one property has no effect on the others. However, the right and bottom properties are integrally related to those
         * four properties. For example, if you change the value of the right property, the value of the width property changes;
         * if you change the bottom property, the value of the height property changes.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - Rectangle 对象是按其位置（由它左上角的点 (x, y) 确定）以及宽度和高度定义的区域。<br/>
         * Rectangle 类的 x、y、width 和 height 属性相互独立；更改一个属性的值不会影响其他属性。
         * 但是，right 和 bottom 属性与这四个属性是整体相关的。例如，如果更改 right 属性的值，则 width
         * 属性的值将发生变化；如果更改 bottom 属性，则 height 属性的值将发生变化。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        export class Rectangle {
            /**
             * - The x coordinate of the top-left corner of the rectangle.
             * @default 0.0
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 矩形左上角的 x 坐标。
             * @default 0.0
             * @version DragonBones 3.0
             * @language zh_CN
             */
            x: number;
            /**
             * - The y coordinate of the top-left corner of the rectangle.
             * @default 0.0
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 矩形左上角的 y 坐标。
             * @default 0.0
             * @version DragonBones 3.0
             * @language zh_CN
             */
            y: number;
            /**
             * - The width of the rectangle, in pixels.
             * @default 0.0
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 矩形的宽度（以像素为单位）。
             * @default 0.0
             * @version DragonBones 3.0
             * @language zh_CN
             */
            width: number;
            /**
             * - 矩形的高度（以像素为单位）。
             * @default 0.0
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - The height of the rectangle, in pixels.
             * @default 0.0
             * @version DragonBones 3.0
             * @language zh_CN
             */
            height: number;
            /**
             * @private
             */
            constructor(x?: number, y?: number, width?: number, height?: number);
            /**
             * @private
             */
            copyFrom(value: Rectangle): void;
            /**
             * @private
             */
            clear(): void;
        }
        /**
         * - The user custom data.
         * @version DragonBones 5.0
         * @language en_US
         */
        /**
         * - 用户自定义数据。
         * @version DragonBones 5.0
         * @language zh_CN
         */
        export class UserData extends BaseObject {
            static toString(): string;
            /**
             * - The custom int numbers.
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 自定义整数。
             * @version DragonBones 5.0
             * @language zh_CN
             */
            readonly ints: Array<number>;
            /**
             * - The custom float numbers.
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 自定义浮点数。
             * @version DragonBones 5.0
             * @language zh_CN
             */
            readonly floats: Array<number>;
            /**
             * - The custom strings.
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 自定义字符串。
             * @version DragonBones 5.0
             * @language zh_CN
             */
            readonly strings: Array<string>;
            /**
             * @inheritDoc
             */
            protected _onClear(): void;
            /**
             * @internal
             * @private
             */
            addInt(value: number): void;
            /**
             * @internal
             * @private
             */
            addFloat(value: number): void;
            /**
             * @internal
             * @private
             */
            addString(value: string): void;
            /**
             * - Get the custom int number.
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 获取自定义整数。
             * @version DragonBones 5.0
             * @language zh_CN
             */
            getInt(index?: number): number;
            /**
             * - Get the custom float number.
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 获取自定义浮点数。
             * @version DragonBones 5.0
             * @language zh_CN
             */
            getFloat(index?: number): number;
            /**
             * - Get the custom string.
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 获取自定义字符串。
             * @version DragonBones 5.0
             * @language zh_CN
             */
            getString(index?: number): string;
        }
        /**
         * @internal
         * @private
         */
        export class ActionData extends BaseObject {
            static toString(): string;
            type: ActionType;
            name: string;
            bone: BoneData | null;
            slot: SlotData | null;
            data: UserData | null;
            protected _onClear(): void;
        }
        /**
         * - The DragonBones data.
         * A DragonBones data contains multiple armature data.
         * @see dragonBones.ArmatureData
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 龙骨数据。
         * 一个龙骨数据包含多个骨架数据。
         * @see dragonBones.ArmatureData
         * @version DragonBones 3.0
         * @language zh_CN
         */
        export class DragonBonesData extends BaseObject {
            static toString(): string;
            /**
             * @private
             */
            autoSearch: boolean;
            /**
             * - The animation frame rate.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 动画帧频。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            frameRate: number;
            /**
             * - The data version.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 数据版本。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            version: string;
            /**
             * - The DragonBones data name.
             * The name is consistent with the DragonBones project name.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 龙骨数据名称。
             * 该名称与龙骨项目名保持一致。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            name: string;
            /**
             * @private
             */
            stage: ArmatureData | null;
            /**
             * @internal
             * @private
             */
            readonly frameIndices: Array<number>;
            /**
             * @internal
             * @private
             */
            readonly cachedFrames: Array<number>;
            /**
             * - All armature data names.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 所有的骨架数据名称。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            readonly armatureNames: Array<string>;
            /**
             * @private
             */
            readonly armatures: Map<ArmatureData>;
            /**
             * @internal
             * @private
             */
            binary: ArrayBuffer;
            /**
             * @internal
             * @private
             */
            intArray: Int16Array;
            /**
             * @internal
             * @private
             */
            floatArray: Float32Array;
            /**
             * @internal
             * @private
             */
            frameIntArray: Int16Array;
            /**
             * @internal
             * @private
             */
            frameFloatArray: Float32Array;
            /**
             * @internal
             * @private
             */
            frameArray: Int16Array;
            /**
             * @internal
             * @private
             */
            timelineArray: Uint16Array;
            /**
             * @private
             */
            userData: UserData | null;
            /**
             * @inheritDoc
             */
            protected _onClear(): void;
            /**
             * @internal
             * @private
             */
            addArmature(value: ArmatureData): void;
            /**
             * - Get a specific armature data.
             * @param name - The armature data name.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 获取特定的骨架数据。
             * @param name - 骨架数据名称。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            getArmature(name: string): ArmatureData | null;
            /**
             * - Deprecated, please refer to {@link #dragonBones.BaseFactory#removeDragonBonesData()}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link #dragonBones.BaseFactory#removeDragonBonesData()}。
             * @deprecated
             * @language zh_CN
             */
            dispose(): void;
        }
        /**
         * - The armature data.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 骨架数据。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        export class ArmatureData extends BaseObject {
            static toString(): string;
            /**
             * @private
             */
            type: ArmatureType;
            /**
             * - The animation frame rate.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 动画帧率。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            frameRate: number;
            /**
             * @private
             */
            cacheFrameRate: number;
            /**
             * @private
             */
            scale: number;
            /**
             * - The armature name.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 骨架名称。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            name: string;
            /**
             * @private
             */
            readonly aabb: Rectangle;
            /**
             * - The names of all the animation data.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 所有的动画数据名称。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            readonly animationNames: Array<string>;
            /**
             * @private
             */
            readonly sortedBones: Array<BoneData>;
            /**
             * @private
             */
            readonly sortedSlots: Array<SlotData>;
            /**
             * @private
             */
            readonly defaultActions: Array<ActionData>;
            /**
             * @private
             */
            readonly actions: Array<ActionData>;
            /**
             * @private
             */
            readonly bones: Map<BoneData>;
            /**
             * @private
             */
            readonly slots: Map<SlotData>;
            /**
             * @private
             */
            readonly constraints: Map<ConstraintData>;
            /**
             * @private
             */
            readonly skins: Map<SkinData>;
            /**
             * @private
             */
            readonly animations: Map<AnimationData>;
            /**
             * - The default skin data.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 默认插槽数据。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            defaultSkin: SkinData | null;
            /**
             * - The default animation data.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 默认动画数据。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            defaultAnimation: AnimationData | null;
            /**
             * @private
             */
            canvas: CanvasData | null;
            /**
             * @private
             */
            userData: UserData | null;
            /**
             * @private
             */
            parent: DragonBonesData;
            /**
             * @inheritDoc
             */
            protected _onClear(): void;
            /**
             * @internal
             * @private
             */
            sortBones(): void;
            /**
             * @internal
             * @private
             */
            cacheFrames(frameRate: number): void;
            /**
             * @internal
             * @private
             */
            setCacheFrame(globalTransformMatrix: Matrix, transform: Transform): number;
            /**
             * @internal
             * @private
             */
            getCacheFrame(globalTransformMatrix: Matrix, transform: Transform, arrayOffset: number): void;
            /**
             * @internal
             * @private
             */
            addBone(value: BoneData): void;
            /**
             * @internal
             * @private
             */
            addSlot(value: SlotData): void;
            /**
             * @internal
             * @private
             */
            addConstraint(value: ConstraintData): void;
            /**
             * @internal
             * @private
             */
            addSkin(value: SkinData): void;
            /**
             * @internal
             * @private
             */
            addAnimation(value: AnimationData): void;
            /**
             * @internal
             * @private
             */
            addAction(value: ActionData, isDefault: boolean): void;
            /**
             * - Get a specific done data.
             * @param name - The bone name.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 获取特定的骨骼数据。
             * @param name - 骨骼名称。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            getBone(name: string): BoneData | null;
            /**
             * - Get a specific slot data.
             * @param name - The slot name.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 获取特定的插槽数据。
             * @param name - 插槽名称。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            getSlot(name: string): SlotData | null;
            /**
             * @private
             */
            getConstraint(name: string): ConstraintData | null;
            /**
             * - Get a specific skin data.
             * @param name - The skin name.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 获取特定皮肤数据。
             * @param name - 皮肤名称。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            getSkin(name: string): SkinData | null;
            /**
             * @internal
             * @private
             */
            getMesh(skinName: string, slotName: string, meshName: string): MeshDisplayData | null;
            /**
             * - Get a specific animation data.
             * @param name - The animation name.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 获取特定的动画数据。
             * @param name - 动画名称。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            getAnimation(name: string): AnimationData | null;
        }
        /**
         * - The bone data.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 骨骼数据。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        export class BoneData extends BaseObject {
            static toString(): string;
            /**
             * @private
             */
            inheritTranslation: boolean;
            /**
             * @private
             */
            inheritRotation: boolean;
            /**
             * @private
             */
            inheritScale: boolean;
            /**
             * @private
             */
            inheritReflection: boolean;
            /**
             * @private
             */
            type: BoneType;
            /**
             * - The bone length.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 骨骼长度。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            length: number;
            /**
             * - The bone name.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 骨骼名称。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            name: string;
            /**
             * @private
             */
            readonly transform: Transform;
            /**
             * @private
             */
            userData: UserData | null;
            /**
             * - The parent bone data.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 父骨骼数据。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            parent: BoneData | null;
            /**
             * @inheritDoc
             */
            protected _onClear(): void;
        }
        /**
         * @internal
         * @private
         */
        export class SurfaceData extends BoneData {
            static toString(): string;
            segmentX: number;
            segmentY: number;
            readonly vertices: Array<number>;
            /**
             * @inheritDoc
             */
            protected _onClear(): void;
        }
        /**
         * - The slot data.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 插槽数据。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        export class SlotData extends BaseObject {
            /**
             * @internal
             * @private
             */
            static readonly DEFAULT_COLOR: ColorTransform;
            /**
             * @internal
             * @private
             */
            static createColor(): ColorTransform;
            static toString(): string;
            /**
             * @private
             */
            blendMode: BlendMode;
            /**
             * @private
             */
            displayIndex: number;
            /**
             * @private
             */
            zOrder: number;
            /**
             * - The slot name.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 插槽名称。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            name: string;
            /**
             * @private
             */
            color: ColorTransform;
            /**
             * @private
             */
            userData: UserData | null;
            /**
             * - The parent bone data.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 父骨骼数据。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            parent: BoneData;
            /**
             * @inheritDoc
             */
            protected _onClear(): void;
        }
        /**
         * @internal
         * @private
         */
        export abstract class ConstraintData extends BaseObject {
            order: number;
            name: string;
            target: BoneData;
            root: BoneData;
            bone: BoneData | null;
            protected _onClear(): void;
        }
        /**
         * @internal
         * @private
         */
        export class IKConstraintData extends ConstraintData {
            static toString(): string;
            scaleEnabled: boolean;
            bendPositive: boolean;
            weight: number;
            protected _onClear(): void;
        }
        /**
         * @internal
         * @private
         */
        export class CanvasData extends BaseObject {
            static toString(): string;
            hasBackground: boolean;
            color: number;
            x: number;
            y: number;
            width: number;
            height: number;
            protected _onClear(): void;
        }
        /**
         * - The skin data, typically a armature data instance contains at least one skinData.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 皮肤数据，通常一个骨架数据至少包含一个皮肤数据。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        export class SkinData extends BaseObject {
            static toString(): string;
            /**
             * - The skin name.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 皮肤名称。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            name: string;
            /**
             * @private
             */
            readonly displays: Map<Array<DisplayData | null>>;
            /**
             * @private
             */
            parent: ArmatureData;
            /**
             * @inheritDoc
             */
            protected _onClear(): void;
            /**
             * @internal
             * @private
             */
            addDisplay(slotName: string, value: DisplayData | null): void;
            /**
             * @private
             */
            getDisplay(slotName: string, displayName: string): DisplayData | null;
            /**
             * @private
             */
            getDisplays(slotName: string): Array<DisplayData | null> | null;
        }
        /**
         * @internal
         * @private
         */
        export abstract class DisplayData extends BaseObject {
            type: DisplayType;
            name: string;
            path: string;
            parent: SkinData;
            readonly transform: Transform;
            protected _onClear(): void;
        }
        /**
         * @internal
         * @private
         */
        export class ImageDisplayData extends DisplayData {
            static toString(): string;
            readonly pivot: Point;
            texture: TextureData | null;
            protected _onClear(): void;
        }
        /**
         * @internal
         * @private
         */
        export class ArmatureDisplayData extends DisplayData {
            static toString(): string;
            inheritAnimation: boolean;
            readonly actions: Array<ActionData>;
            armature: ArmatureData | null;
            protected _onClear(): void;
            /**
             * @private
             */
            addAction(value: ActionData): void;
        }
        /**
         * @internal
         * @private
         */
        export class MeshDisplayData extends DisplayData {
            static toString(): string;
            inheritDeform: boolean;
            offset: number;
            weight: WeightData | null;
            glue: GlueData | null;
            texture: TextureData | null;
            protected _onClear(): void;
        }
        /**
         * @internal
         * @private
         */
        export class BoundingBoxDisplayData extends DisplayData {
            static toString(): string;
            boundingBox: BoundingBoxData | null;
            protected _onClear(): void;
        }
        /**
         * @internal
         * @private
         */
        export class WeightData extends BaseObject {
            static toString(): string;
            count: number;
            offset: number;
            readonly bones: Array<BoneData>;
            protected _onClear(): void;
            addBone(value: BoneData): void;
        }
        /**
         * @internal
         * @private
         */
        export class GlueData extends BaseObject {
            static toString(): string;
            readonly weights: Array<number>;
            readonly meshes: Array<MeshDisplayData | null>;
            protected _onClear(): void;
            addMesh(value: MeshDisplayData | null): void;
        }
        /**
         * - The base export class of bounding box data.
         * @see dragonBones.RectangleData
         * @see dragonBones.EllipseData
         * @see dragonBones.PolygonData
         * @version DragonBones 5.0
         * @language en_US
         */
        /**
         * - 边界框数据基类。
         * @see dragonBones.RectangleData
         * @see dragonBones.EllipseData
         * @see dragonBones.PolygonData
         * @version DragonBones 5.0
         * @language zh_CN
         */
        export abstract class BoundingBoxData extends BaseObject {
            /**
             * - The bounding box type.
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 边界框类型。
             * @version DragonBones 5.0
             * @language zh_CN
             */
            type: BoundingBoxType;
            /**
             * @private
             */
            color: number;
            /**
             * @private
             */
            width: number;
            /**
             * @private
             */
            height: number;
            /**
             * @private
             */
            protected _onClear(): void;
            /**
             * - Check whether the bounding box contains a specific point. (Local coordinate system)
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 检查边界框是否包含特定点。（本地坐标系）
             * @version DragonBones 5.0
             * @language zh_CN
             */
            abstract containsPoint(pX: number, pY: number): boolean;
            /**
             * - Check whether the bounding box intersects a specific segment. (Local coordinate system)
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 检查边界框是否与特定线段相交。（本地坐标系）
             * @version DragonBones 5.0
             * @language zh_CN
             */
            abstract intersectsSegment(xA: number, yA: number, xB: number, yB: number, intersectionPointA: {
                x: number;
                y: number;
            } | null, intersectionPointB: {
                x: number;
                y: number;
            } | null, normalRadians: {
                x: number;
                y: number;
            } | null): number;
        }
        /**
         * - The rectangle bounding box data.
         * @version DragonBones 5.1
         * @language en_US
         */
        /**
         * - 矩形边界框数据。
         * @version DragonBones 5.1
         * @language zh_CN
         */
        export class RectangleBoundingBoxData extends BoundingBoxData {
            static toString(): string;
            /**
             * @private
             */
            static rectangleIntersectsSegment(xA: number, yA: number, xB: number, yB: number, xMin: number, yMin: number, xMax: number, yMax: number, intersectionPointA?: {
                x: number;
                y: number;
            } | null, intersectionPointB?: {
                x: number;
                y: number;
            } | null, normalRadians?: {
                x: number;
                y: number;
            } | null): number;
            /**
             * @inheritDoc
             * @private
             */
            protected _onClear(): void;
            /**
             * @inheritDoc
             */
            containsPoint(pX: number, pY: number): boolean;
            /**
             * @inheritDoc
             */
            intersectsSegment(xA: number, yA: number, xB: number, yB: number, intersectionPointA?: {
                x: number;
                y: number;
            } | null, intersectionPointB?: {
                x: number;
                y: number;
            } | null, normalRadians?: {
                x: number;
                y: number;
            } | null): number;
        }
        /**
         * - The ellipse bounding box data.
         * @version DragonBones 5.1
         * @language en_US
         */
        /**
         * - 椭圆边界框数据。
         * @version DragonBones 5.1
         * @language zh_CN
         */
        export class EllipseBoundingBoxData extends BoundingBoxData {
            static toString(): string;
            /**
             * @private
             */
            static ellipseIntersectsSegment(xA: number, yA: number, xB: number, yB: number, xC: number, yC: number, widthH: number, heightH: number, intersectionPointA?: {
                x: number;
                y: number;
            } | null, intersectionPointB?: {
                x: number;
                y: number;
            } | null, normalRadians?: {
                x: number;
                y: number;
            } | null): number;
            /**
             * @inheritDoc
             * @private
             */
            protected _onClear(): void;
            /**
             * @inheritDoc
             */
            containsPoint(pX: number, pY: number): boolean;
            /**
             * @inheritDoc
             */
            intersectsSegment(xA: number, yA: number, xB: number, yB: number, intersectionPointA?: {
                x: number;
                y: number;
            } | null, intersectionPointB?: {
                x: number;
                y: number;
            } | null, normalRadians?: {
                x: number;
                y: number;
            } | null): number;
        }
        /**
         * - The polygon bounding box data.
         * @version DragonBones 5.1
         * @language en_US
         */
        /**
         * - 多边形边界框数据。
         * @version DragonBones 5.1
         * @language zh_CN
         */
        export class PolygonBoundingBoxData extends BoundingBoxData {
            static toString(): string;
            /**
             * @private
             */
            static polygonIntersectsSegment(xA: number, yA: number, xB: number, yB: number, vertices: Array<number>, intersectionPointA?: {
                x: number;
                y: number;
            } | null, intersectionPointB?: {
                x: number;
                y: number;
            } | null, normalRadians?: {
                x: number;
                y: number;
            } | null): number;
            /**
             * @private
             */
            x: number;
            /**
             * @private
             */
            y: number;
            /**
             * - The polygon vertices.
             * @version DragonBones 5.1
             * @language en_US
             */
            /**
             * - 多边形顶点。
             * @version DragonBones 5.1
             * @language zh_CN
             */
            readonly vertices: Array<number>;
            /**
             * @private
             */
            weight: WeightData | null;
            /**
             * @inheritDoc
             * @private
             */
            protected _onClear(): void;
            /**
             * @inheritDoc
             */
            containsPoint(pX: number, pY: number): boolean;
            /**
             * @inheritDoc
             */
            intersectsSegment(xA: number, yA: number, xB: number, yB: number, intersectionPointA?: {
                x: number;
                y: number;
            } | null, intersectionPointB?: {
                x: number;
                y: number;
            } | null, normalRadians?: {
                x: number;
                y: number;
            } | null): number;
        }
        /**
         * - The animation data.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 动画数据。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        export class AnimationData extends BaseObject {
            static toString(): string;
            /**
             * - FrameIntArray.
             * @internal
             * @private
             */
            frameIntOffset: number;
            /**
             * - FrameFloatArray.
             * @internal
             * @private
             */
            frameFloatOffset: number;
            /**
             * - FrameArray.
             * @internal
             * @private
             */
            frameOffset: number;
            /**
             * - The frame count of the animation.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 动画的帧数。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            frameCount: number;
            /**
             * - The play times of the animation. [0: Loop play, [1~N]: Play N times]
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 动画的播放次数。 [0: 无限循环播放, [1~N]: 循环播放 N 次]
             * @version DragonBones 3.0
             * @language zh_CN
             */
            playTimes: number;
            /**
             * - The duration of the animation. (In seconds)
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 动画的持续时间。 （以秒为单位）
             * @version DragonBones 3.0
             * @language zh_CN
             */
            duration: number;
            /**
             * @private
             */
            scale: number;
            /**
             * - The fade in time of the animation. (In seconds)
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 动画的淡入时间。 （以秒为单位）
             * @version DragonBones 3.0
             * @language zh_CN
             */
            fadeInTime: number;
            /**
             * @private
             */
            cacheFrameRate: number;
            /**
             * - The animation name.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 动画名称。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            name: string;
            /**
             * @private
             */
            readonly cachedFrames: Array<boolean>;
            /**
             * @private
             */
            readonly boneTimelines: Map<Array<TimelineData>>;
            /**
             * @private
             */
            readonly surfaceTimelines: Map<Array<TimelineData>>;
            /**
             * @private
             */
            readonly slotTimelines: Map<Array<TimelineData>>;
            /**
             * @private
             */
            readonly constraintTimelines: Map<Array<TimelineData>>;
            /**
             * @private
             */
            readonly animationTimelines: Map<Array<TimelineData>>;
            /**
             * @private
             */
            readonly boneCachedFrameIndices: Map<Array<number>>;
            /**
             * @private
             */
            readonly slotCachedFrameIndices: Map<Array<number>>;
            /**
             * @private
             */
            actionTimeline: TimelineData | null;
            /**
             * @private
             */
            zOrderTimeline: TimelineData | null;
            /**
             * @private
             */
            parent: ArmatureData;
            /**
             * @inheritDoc
             */
            protected _onClear(): void;
            /**
             * @internal
             * @private
             */
            cacheFrames(frameRate: number): void;
            /**
             * @private
             */
            addBoneTimeline(bone: BoneData, timeline: TimelineData): void;
            /**
             * @private
             */
            addSurfaceTimeline(surface: SurfaceData, timeline: TimelineData): void;
            /**
             * @private
             */
            addSlotTimeline(slot: SlotData, timeline: TimelineData): void;
            /**
             * @private
             */
            addConstraintTimeline(constraint: ConstraintData, timeline: TimelineData): void;
            /**
             * @private
             */
            addAnimationTimeline(name: string, timeline: TimelineData): void;
            /**
             * @private
             */
            getBoneTimelines(name: string): Array<TimelineData> | null;
            /**
             * @private
             */
            getSurfaceTimelines(name: string): Array<TimelineData> | null;
            /**
             * @private
             */
            getSlotTimelines(name: string): Array<TimelineData> | null;
            /**
             * @private
             */
            getConstraintTimelines(name: string): Array<TimelineData> | null;
            /**
             * @private
             */
            getAnimationTimelines(name: string): Array<TimelineData> | null;
            /**
             * @private
             */
            getBoneCachedFrameIndices(name: string): Array<number> | null;
            /**
             * @private
             */
            getSlotCachedFrameIndices(name: string): Array<number> | null;
        }
        /**
         * @internal
         * @private
         */
        export class TimelineData extends BaseObject {
            static toString(): string;
            type: TimelineType;
            offset: number;
            frameIndicesOffset: number;
            protected _onClear(): void;
        }
        /**
         * - The animation config is used to describe all the information needed to play an animation state.
         * The API is still in the experimental phase and may encounter bugs or stability or compatibility issues when used.
         * @see dragonBones.AnimationState
         * @beta
         * @version DragonBones 5.0
         * @language en_US
         */
        /**
         * - 动画配置用来描述播放一个动画状态所需要的全部信息。
         * 该 API 仍在实验阶段，使用时可能遭遇 bug 或稳定性或兼容性问题。
         * @see dragonBones.AnimationState
         * @beta
         * @version DragonBones 5.0
         * @language zh_CN
         */
        export class AnimationConfig extends BaseObject {
            static toString(): string;
            /**
             * @private
             */
            pauseFadeOut: boolean;
            /**
             * - Fade out the pattern of other animation states when the animation state is fade in.
             * This property is typically used to specify the substitution of multiple animation states blend.
             * @default dragonBones.AnimationFadeOutMode.All
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 淡入动画状态时淡出其他动画状态的模式。
             * 该属性通常用来指定多个动画状态混合时的相互替换关系。
             * @default dragonBones.AnimationFadeOutMode.All
             * @version DragonBones 5.0
             * @language zh_CN
             */
            fadeOutMode: AnimationFadeOutMode;
            /**
             * @private
             */
            fadeOutTweenType: TweenType;
            /**
             * @private
             */
            fadeOutTime: number;
            /**
             * @private
             */
            pauseFadeIn: boolean;
            /**
             * @private
             */
            actionEnabled: boolean;
            /**
             * @private
             */
            additiveBlending: boolean;
            /**
             * - Whether the animation state has control over the display property of the slots.
             * Sometimes blend a animation state does not want it to control the display properties of the slots,
             * especially if other animation state are controlling the display properties of the slots.
             * @default true
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 动画状态是否对插槽的显示对象属性有控制权。
             * 有时混合一个动画状态并不希望其控制插槽的显示对象属性，
             * 尤其是其他动画状态正在控制这些插槽的显示对象属性时。
             * @default true
             * @version DragonBones 5.0
             * @language zh_CN
             */
            displayControl: boolean;
            /**
             * - Whether to reset the objects without animation to the armature pose when the animation state is start to play.
             * This property should usually be set to false when blend multiple animation states.
             * @default true
             * @version DragonBones 5.1
             * @language en_US
             */
            /**
             * - 开始播放动画状态时是否将没有动画的对象重置为骨架初始值。
             * 通常在混合多个动画状态时应该将该属性设置为 false。
             * @default true
             * @version DragonBones 5.1
             * @language zh_CN
             */
            resetToPose: boolean;
            /**
             * @private
             */
            fadeInTweenType: TweenType;
            /**
             * - The play times. [0: Loop play, [1~N]: Play N times]
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 播放次数。 [0: 无限循环播放, [1~N]: 循环播放 N 次]
             * @version DragonBones 3.0
             * @language zh_CN
             */
            playTimes: number;
            /**
             * - The blend layer.
             * High layer animation state will get the blend weight first.
             * When the blend weight is assigned more than 1, the remaining animation states will no longer get the weight assigned.
             * @readonly
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 混合图层。
             * 图层高的动画状态会优先获取混合权重。
             * 当混合权重分配超过 1 时，剩余的动画状态将不再获得权重分配。
             * @readonly
             * @version DragonBones 5.0
             * @language zh_CN
             */
            layer: number;
            /**
             * - The start time of play. (In seconds)
             * @default 0.0
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 播放的开始时间。 （以秒为单位）
             * @default 0.0
             * @version DragonBones 5.0
             * @language zh_CN
             */
            position: number;
            /**
             * - The duration of play.
             * [-1: Use the default value of the animation data, 0: Stop play, (0~N]: The duration] (In seconds)
             * @default -1.0
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 播放的持续时间。
             * [-1: 使用动画数据默认值, 0: 动画停止, (0~N]: 持续时间] （以秒为单位）
             * @default -1.0
             * @version DragonBones 5.0
             * @language zh_CN
             */
            duration: number;
            /**
             * - The play speed.
             * The value is an overlay relationship with {@link dragonBones.Animation#timeScale}.
             * [(-N~0): Reverse play, 0: Stop play, (0~1): Slow play, 1: Normal play, (1~N): Fast play]
             * @default 1.0
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 播放速度。
             * 该值与 {@link dragonBones.Animation#timeScale} 是叠加关系。
             * [(-N~0): 倒转播放, 0: 停止播放, (0~1): 慢速播放, 1: 正常播放, (1~N): 快速播放]
             * @default 1.0
             * @version DragonBones 3.0
             * @language zh_CN
             */
            timeScale: number;
            /**
             * - The blend weight.
             * @default 1.0
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 混合权重。
             * @default 1.0
             * @version DragonBones 5.0
             * @language zh_CN
             */
            weight: number;
            /**
             * - The fade in time.
             * [-1: Use the default value of the animation data, [0~N]: The fade in time] (In seconds)
             * @default -1.0
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 淡入时间。
             * [-1: 使用动画数据默认值, [0~N]: 淡入时间] （以秒为单位）
             * @default -1.0
             * @version DragonBones 5.0
             * @language zh_CN
             */
            fadeInTime: number;
            /**
             * - The auto fade out time when the animation state play completed.
             * [-1: Do not fade out automatically, [0~N]: The fade out time] (In seconds)
             * @default -1.0
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 动画状态播放完成后的自动淡出时间。
             * [-1: 不自动淡出, [0~N]: 淡出时间] （以秒为单位）
             * @default -1.0
             * @version DragonBones 5.0
             * @language zh_CN
             */
            autoFadeOutTime: number;
            /**
             * - The name of the animation state. (Can be different from the name of the animation data)
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 动画状态名称。 （可以不同于动画数据）
             * @version DragonBones 5.0
             * @language zh_CN
             */
            name: string;
            /**
             * - The animation data name.
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 动画数据名称。
             * @version DragonBones 5.0
             * @language zh_CN
             */
            animation: string;
            /**
             * - The blend group name of the animation state.
             * This property is typically used to specify the substitution of multiple animation states blend.
             * @readonly
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 混合组名称。
             * 该属性通常用来指定多个动画状态混合时的相互替换关系。
             * @readonly
             * @version DragonBones 5.0
             * @language zh_CN
             */
            group: string;
            /**
             * @private
             */
            readonly boneMask: Array<string>;
            /**
             * @private
             */
            protected _onClear(): void;
            /**
             * @private
             */
            clear(): void;
            /**
             * @private
             */
            copyFrom(value: AnimationConfig): void;
            /**
             * @private
             */
            containsBoneMask(name: string): boolean;
            /**
             * @private
             */
            addBoneMask(armature: Armature, name: string, recursive?: boolean): void;
            /**
             * @private
             */
            removeBoneMask(armature: Armature, name: string, recursive?: boolean): void;
        }
        /**
         * - The texture atlas data.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 贴图集数据。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        export abstract class TextureAtlasData extends BaseObject {
            /**
             * @private
             */
            autoSearch: boolean;
            /**
             * @private
             */
            width: number;
            /**
             * @private
             */
            height: number;
            /**
             * @private
             */
            scale: number;
            /**
             * - The texture atlas name.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 贴图集名称。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            name: string;
            /**
             * - The image path of the texture atlas.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 贴图集图片路径。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            imagePath: string;
            /**
             * @private
             */
            readonly textures: Map<TextureData>;
            /**
             * @inheritDoc
             */
            protected _onClear(): void;
            /**
             * @private
             */
            copyFrom(value: TextureAtlasData): void;
            /**
             * @internal
             * @private
             */
            abstract createTexture(): TextureData;
            /**
             * @internal
             * @private
             */
            addTexture(value: TextureData): void;
            /**
             * @private
             */
            getTexture(name: string): TextureData | null;
        }
        /**
         * @internal
         * @private
         */
        export abstract class TextureData extends BaseObject {
            static createRectangle(): Rectangle;
            rotated: boolean;
            name: string;
            readonly region: Rectangle;
            parent: TextureAtlasData;
            frame: Rectangle | null;
            protected _onClear(): void;
            copyFrom(value: TextureData): void;
        }
        /**
         * - The armature proxy interface, the docking engine needs to implement it concretely.
         * @see dragonBones.Armature
         * @version DragonBones 5.0
         * @language en_US
         */
        /**
         * - 骨架代理接口，对接的引擎需要对其进行具体实现。
         * @see dragonBones.Armature
         * @version DragonBones 5.0
         * @language zh_CN
         */
        export interface IArmatureProxy extends IEventDispatcher {
            /**
             * @internal
             * @private
             */
            dbInit(armature: Armature): void;
            /**
             * @internal
             * @private
             */
            dbClear(): void;
            /**
             * @internal
             * @private
             */
            dbUpdate(): void;
            /**
             * - Dispose the instance and the Armature instance. (The Armature instance will return to the object pool)
             * @example
             * <pre>
             *     removeChild(armatureDisplay);
             *     armatureDisplay.dispose();
             * </pre>
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 释放该实例和骨架。 （骨架会回收到对象池）
             * @example
             * <pre>
             *     removeChild(armatureDisplay);
             *     armatureDisplay.dispose();
             * </pre>
             * @version DragonBones 4.5
             * @language zh_CN
             */
            dispose(disposeProxy: boolean): void;
            /**
             * - The armature.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 骨架。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            readonly armature: Armature;
            /**
             * - The animation player.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 动画播放器。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            readonly animation: Animation;
        }
        /**
         * - Armature is the core of the skeleton animation system.
         * @see dragonBones.ArmatureData
         * @see dragonBones.Bone
         * @see dragonBones.Slot
         * @see dragonBones.Animation
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 骨架是骨骼动画系统的核心。
         * @see dragonBones.ArmatureData
         * @see dragonBones.Bone
         * @see dragonBones.Slot
         * @see dragonBones.Animation
         * @version DragonBones 3.0
         * @language zh_CN
         */
        export class Armature extends BaseObject implements IAnimatable {
            static toString(): string;
            /**
             * - Whether to inherit the animation control of the parent armature.
             * True to try to have the child armature play an animation with the same name when the parent armature play the animation.
             * @default true
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 是否继承父骨架的动画控制。
             * 如果该值为 true，当父骨架播放动画时，会尝试让子骨架播放同名动画。
             * @default true
             * @version DragonBones 4.5
             * @language zh_CN
             */
            inheritAnimation: boolean;
            /**
             * @private
             */
            userData: any;
            /**
             * @internal
             * @private
             */
            _cacheFrameIndex: number;
            /* private */
            readonly _bones;
            /* private */
            public readonly _slots: Array<Slot>;
            /**
             * @internal
             * @private
             */
            readonly _glueSlots: Array<Slot>;
            /**
             * @internal
             * @private
             */
            readonly _constraints: Array<Constraint>;
            /**
             * @internal
             * @private
             */
            _armatureData: ArmatureData;
            /* private */
            _animation;
            public _display: DisplayData;
            /* private */
            _skinData: SkinData;
            /* private */
            _isChildArmature: boolean;
            /**
             * @internal
             * @private
             */
            _replaceTextureAtlasData: TextureAtlasData | null;
            /**
             * @internal
             * @private
             */
            _dragonBones: DragonBones;
            /**
             * @internal
             * @private
             */
            _parent: Slot | null;
            /**
             * @private
             */
            protected _onClear(): void;
            /**
             * @internal
             * @private
             */
            _sortZOrder(slotIndices: Array<number> | Int16Array | null, offset: number): void;
            /**
             * @internal
             * @private
             */
            _addBoneToBoneList(value: Bone): void;
            /**
             * @internal
             * @private
             */
            _removeBoneFromBoneList(value: Bone): void;
            /**
             * @internal
             * @private
             */
            _addSlotToSlotList(value: Slot): void;
            /**
             * @internal
             * @private
             */
            _removeSlotFromSlotList(value: Slot): void;
            /**
             * @internal
             * @private
             */
            _bufferAction(action: ActionData, append: boolean): void;
            /**
             * - Dispose the armature. (Return to the object pool)
             * @example
             * <pre>
             *     removeChild(armature.display);
             *     armature.dispose();
             * </pre>
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 释放骨架。 （回收到对象池）
             * @example
             * <pre>
             *     removeChild(armature.display);
             *     armature.dispose();
             * </pre>
             * @version DragonBones 3.0
             * @language zh_CN
             */
            dispose(): void;
            /**
             * @internal
             * @private
             */
            init(armatureData: ArmatureData, proxy: IArmatureProxy, display: any, dragonBones: DragonBones): void;
            /**
             * @inheritDoc
             */
            advanceTime(passedTime: number): void;
            /**
             * - Forces a specific bone or its owning slot to update the transform or display property in the next frame.
             * @param boneName - The bone name. (If not set, all bones will be update)
             * @param updateSlot - Whether to update the bone's slots. (Default: false)
             * @see dragonBones.Bone#invalidUpdate()
             * @see dragonBones.Slot#invalidUpdate()
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 强制特定骨骼或其拥有的插槽在下一帧更新变换或显示属性。
             * @param boneName - 骨骼名称。 （如果未设置，将更新所有骨骼）
             * @param updateSlot - 是否更新骨骼的插槽。 （默认: false）
             * @see dragonBones.Bone#invalidUpdate()
             * @see dragonBones.Slot#invalidUpdate()
             * @version DragonBones 3.0
             * @language zh_CN
             */
            invalidUpdate(boneName?: string | null, updateSlot?: boolean): void;
            /**
             * - Check whether a specific point is inside a custom bounding box in a slot.
             * The coordinate system of the point is the inner coordinate system of the armature.
             * Custom bounding boxes need to be customized in Dragonbones Pro.
             * @param x - The horizontal coordinate of the point.
             * @param y - The vertical coordinate of the point.
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 检查特定点是否在某个插槽的自定义边界框内。
             * 点的坐标系为骨架内坐标系。
             * 自定义边界框需要在 DragonBones Pro 中自定义。
             * @param x - 点的水平坐标。
             * @param y - 点的垂直坐标。
             * @version DragonBones 5.0
             * @language zh_CN
             */
            containsPoint(x: number, y: number): Slot | null;
            /**
             * - Check whether a specific segment intersects a custom bounding box for a slot in the armature.
             * The coordinate system of the segment and intersection is the inner coordinate system of the armature.
             * Custom bounding boxes need to be customized in Dragonbones Pro.
             * @param xA - The horizontal coordinate of the beginning of the segment.
             * @param yA - The vertical coordinate of the beginning of the segment.
             * @param xB - The horizontal coordinate of the end point of the segment.
             * @param yB - The vertical coordinate of the end point of the segment.
             * @param intersectionPointA - The first intersection at which a line segment intersects the bounding box from the beginning to the end. (If not set, the intersection point will not calculated)
             * @param intersectionPointB - The first intersection at which a line segment intersects the bounding box from the end to the beginning. (If not set, the intersection point will not calculated)
             * @param normalRadians - The normal radians of the tangent of the intersection boundary box. [x: Normal radian of the first intersection tangent, y: Normal radian of the second intersection tangent] (If not set, the normal will not calculated)
             * @returns The slot of the first custom bounding box where the segment intersects from the start point to the end point.
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 检查特定线段是否与骨架的某个插槽的自定义边界框相交。
             * 线段和交点的坐标系均为骨架内坐标系。
             * 自定义边界框需要在 DragonBones Pro 中自定义。
             * @param xA - 线段起点的水平坐标。
             * @param yA - 线段起点的垂直坐标。
             * @param xB - 线段终点的水平坐标。
             * @param yB - 线段终点的垂直坐标。
             * @param intersectionPointA - 线段从起点到终点与边界框相交的第一个交点。 （如果未设置，则不计算交点）
             * @param intersectionPointB - 线段从终点到起点与边界框相交的第一个交点。 （如果未设置，则不计算交点）
             * @param normalRadians - 交点边界框切线的法线弧度。 [x: 第一个交点切线的法线弧度, y: 第二个交点切线的法线弧度] （如果未设置，则不计算法线）
             * @returns 线段从起点到终点相交的第一个自定义边界框的插槽。
             * @version DragonBones 5.0
             * @language zh_CN
             */
            intersectsSegment(xA: number, yA: number, xB: number, yB: number, intersectionPointA?: {
                x: number;
                y: number;
            } | null, intersectionPointB?: {
                x: number;
                y: number;
            } | null, normalRadians?: {
                x: number;
                y: number;
            } | null): Slot | null;
            /**
             * - Get a specific bone.
             * @param name - The bone name.
             * @see dragonBones.Bone
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 获取特定的骨骼。
             * @param name - 骨骼名称。
             * @see dragonBones.Bone
             * @version DragonBones 3.0
             * @language zh_CN
             */
            getBone(name: string): Bone | null;
            /**
             * - Get a specific bone by the display.
             * @param display - The display object.
             * @see dragonBones.Bone
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 通过显示对象获取特定的骨骼。
             * @param display - 显示对象。
             * @see dragonBones.Bone
             * @version DragonBones 3.0
             * @language zh_CN
             */
            getBoneByDisplay(display: any): Bone | null;
            /**
             * - Get a specific slot.
             * @param name - The slot name.
             * @see dragonBones.Slot
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 获取特定的插槽。
             * @param name - 插槽名称。
             * @see dragonBones.Slot
             * @version DragonBones 3.0
             * @language zh_CN
             */
            getSlot(name: string): Slot | null;
            /**
             * - Get a specific slot by the display.
             * @param display - The display object.
             * @see dragonBones.Slot
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 通过显示对象获取特定的插槽。
             * @param display - 显示对象。
             * @see dragonBones.Slot
             * @version DragonBones 3.0
             * @language zh_CN
             */
            getSlotByDisplay(display: any): Slot | null;
            /**
             * @deprecated
             */
            addBone(value: Bone, parentName: string): void;
            /**
             * @deprecated
             */
            addSlot(value: Slot, parentName: string): void;
            /**
             * @private
             */
            addConstraint(value: Constraint): void;
            /**
             * @deprecated
             */
            removeBone(value: Bone): void;
            /**
             * @deprecated
             */
            removeSlot(value: Slot): void;
            /**
             * - Get all bones.
             * @see dragonBones.Bone
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 获取所有的骨骼。
             * @see dragonBones.Bone
             * @version DragonBones 3.0
             * @language zh_CN
             */
            getBones(): Array<Bone>;
            /**
             * - Get all slots.
             * @see dragonBones.Slot
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 获取所有的插槽。
             * @see dragonBones.Slot
             * @version DragonBones 3.0
             * @language zh_CN
             */
            getSlots(): Array<Slot>;
            /**
             * - Whether to flip the armature horizontally.
             * @version DragonBones 5.5
             * @language en_US
             */
            /**
             * - 是否将骨架水平翻转。
             * @version DragonBones 5.5
             * @language zh_CN
             */
            flipX: boolean;
            /**
             * - Whether to flip the armature vertically.
             * @version DragonBones 5.5
             * @language en_US
             */
            /**
             * - 是否将骨架垂直翻转。
             * @version DragonBones 5.5
             * @language zh_CN
             */
            flipY: boolean;
            /**
             * - The animation cache frame rate, which turns on the animation cache when the set value is greater than 0.
             * There is a certain amount of memory overhead to improve performance by caching animation data in memory.
             * The frame rate should not be set too high, usually with the frame rate of the animation is similar and lower than the program running frame rate.
             * When the animation cache is turned on, some features will fail, such as the offset property of bone.
             * @example
             * <pre>
             *     armature.cacheFrameRate = 24;
             * </pre>
             * @see dragonBones.DragonBonesData#frameRate
             * @see dragonBones.ArmatureData#frameRate
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 动画缓存帧率，当设置的值大于 0 的时，将会开启动画缓存。
             * 通过将动画数据缓存在内存中来提高运行性能，会有一定的内存开销。
             * 帧率不宜设置的过高，通常跟动画的帧率相当且低于程序运行的帧率。
             * 开启动画缓存后，某些功能将会失效，比如骨骼的 offset 属性等。
             * @example
             * <pre>
             *     armature.cacheFrameRate = 24;
             * </pre>
             * @see dragonBones.DragonBonesData#frameRate
             * @see dragonBones.ArmatureData#frameRate
             * @version DragonBones 4.5
             * @language zh_CN
             */
            cacheFrameRate: number;
            /**
             * - The armature name.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 骨架名称。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            readonly name: string;
            /**
             * - The armature data.
             * @see dragonBones.ArmatureData
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 骨架数据。
             * @see dragonBones.ArmatureData
             * @version DragonBones 4.5
             * @language zh_CN
             */
            readonly armatureData: ArmatureData;
            /**
             * - The animation player.
             * @see dragonBones.Animation
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 动画播放器。
             * @see dragonBones.Animation
             * @version DragonBones 3.0
             * @language zh_CN
             */
            readonly animation: Animation;
            /**
             * @pivate
             */
            readonly proxy: IArmatureProxy;
            /**
             * - The EventDispatcher instance of the armature.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 该骨架的 EventDispatcher 实例。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            readonly eventDispatcher: IEventDispatcher;
            /**
             * - The display container.
             * The display of the slot is displayed as the parent.
             * Depending on the rendering engine, the type will be different, usually the DisplayObjectContainer type.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 显示容器实例。
             * 插槽的显示对象都会以此显示容器为父级。
             * 根据渲染引擎的不同，类型会不同，通常是 DisplayObjectContainer 类型。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            readonly display: any;
            /**
             * @private
             */
            replacedTexture: any;
            /**
             * @inheritDoc
             */
            clock: WorldClock | null;
            /**
             * - Get the parent slot which the armature belongs to.
             * @see dragonBones.Slot
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 该骨架所属的父插槽。
             * @see dragonBones.Slot
             * @version DragonBones 4.5
             * @language zh_CN
             */
            readonly parent: Slot | null;
            /**
             * @deprecated
             * @private
             */
            replaceTexture(texture: any): void;
            /**
             * - Deprecated, please refer to {@link #eventDispatcher}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link #eventDispatcher}。
             * @deprecated
             * @language zh_CN
             */
            hasEventListener(type: EventStringType): boolean;
            /**
             * - Deprecated, please refer to {@link #eventDispatcher}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link #eventDispatcher}。
             * @deprecated
             * @language zh_CN
             */
            addEventListener(type: EventStringType, listener: Function, target: any): void;
            /**
             * - Deprecated, please refer to {@link #eventDispatcher}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link #eventDispatcher}。
             * @deprecated
             * @language zh_CN
             */
            removeEventListener(type: EventStringType, listener: Function, target: any): void;
            /**
             * - Deprecated, please refer to {@link #cacheFrameRate}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link #cacheFrameRate}。
             * @deprecated
             * @language zh_CN
             */
            enableAnimationCache(frameRate: number): void;
            /**
             * - Deprecated, please refer to {@link #display}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link #display}。
             * @deprecated
             * @language zh_CN
             */
            getDisplay(): any;
        }
        /**
         * - The base export class of the transform object.
         * @see dragonBones.Transform
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 变换对象的基类。
         * @see dragonBones.Transform
         * @version DragonBones 4.5
         * @language zh_CN
         */
        export abstract class TransformObject extends BaseObject {
            /**
             * @private
             */
            protected static readonly _helpMatrix: Matrix;
            /**
             * @private
             */
            protected static readonly _helpTransform: Transform;
            /**
             * @private
             */
            protected static readonly _helpPoint: Point;
            /**
             * - A matrix relative to the armature coordinate system.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 相对于骨架坐标系的矩阵。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            readonly globalTransformMatrix: Matrix;
            /**
             * - A transform relative to the armature coordinate system.
             * @see #updateGlobalTransform()
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 相对于骨架坐标系的变换。
             * @see #updateGlobalTransform()
             * @version DragonBones 3.0
             * @language zh_CN
             */
            readonly global: Transform;
            /**
             * - The offset transform relative to the armature or the parent bone coordinate system.
             * @see #dragonBones.Bone#invalidUpdate()
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 相对于骨架或父骨骼坐标系的偏移变换。
             * @see #dragonBones.Bone#invalidUpdate()
             * @version DragonBones 3.0
             * @language zh_CN
             */
            readonly offset: Transform;
            /**
             * @private
             */
            origin: Transform | null;
            /**
             * @private
             */
            userData: any;
            /**
             * @private
             */
            protected _globalDirty: boolean;
            /**
             * @internal
             * @private
             */
            _armature: Armature;
            /**
             * @internal
             * @private
             */
            _parent: Bone;
            /**
             * @private
             */
            protected _onClear(): void;
            /**
             * @internal
             * @private
             */
            _setArmature(value: Armature | null): void;
            /**
             * @internal
             * @private
             */
            _setParent(value: Bone | null): void;
            /**
             * - For performance considerations, rotation or scale in the {@link #global} attribute of the bone or slot is not always properly accessible,
             * some engines do not rely on these attributes to update rendering, such as Egret.
             * The use of this method ensures that the access to the {@link #global} property is correctly rotation or scale.
             * @example
             * <pre>
             *     bone.updateGlobalTransform();
             *     let rotation = bone.global.rotation;
             * </pre>
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 出于性能的考虑，骨骼或插槽的 {@link #global} 属性中的旋转或缩放并不总是正确可访问的，有些引擎并不依赖这些属性更新渲染，比如 Egret。
             * 使用此方法可以保证访问到 {@link #global} 属性中正确的旋转或缩放。
             * @example
             * <pre>
             *     bone.updateGlobalTransform();
             *     let rotation = bone.global.rotation;
             * </pre>
             * @version DragonBones 3.0
             * @language zh_CN
             */
            updateGlobalTransform(): void;
            /**
             * - The armature to which it belongs.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 所属的骨架。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            readonly armature: Armature;
            /**
             * - The parent bone to which it belongs.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 所属的父骨骼。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            readonly parent: Bone;
        }
        /**
         * - Bone is one of the most important logical units in the armature animation system,
         * and is responsible for the realization of translate, rotation, scaling in the animations.
         * A armature can contain multiple bones.
         * @see dragonBones.BoneData
         * @see dragonBones.Armature
         * @see dragonBones.Slot
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 骨骼在骨骼动画体系中是最重要的逻辑单元之一，负责动画中的平移、旋转、缩放的实现。
         * 一个骨架中可以包含多个骨骼。
         * @see dragonBones.BoneData
         * @see dragonBones.Armature
         * @see dragonBones.Slot
         * @version DragonBones 3.0
         * @language zh_CN
         */
        export class Bone extends TransformObject {
            static toString(): string;
            /**
             * - The offset mode.
             * @see #offset
             * @version DragonBones 5.5
             * @language en_US
             */
            /**
             * - 偏移模式。
             * @see #offset
             * @version DragonBones 5.5
             * @language zh_CN
             */
            offsetMode: OffsetMode;
            /**
             * @internal
             * @private
             */
            readonly animationPose: Transform;
            /**
             * @internal
             * @private
             */
            _transformDirty: boolean;
            /**
             * @internal
             * @private
             */
            _childrenTransformDirty: boolean;
            protected _localDirty: boolean;
            /**
             * @internal
             * @private
             */
            _hasConstraint: boolean;
            protected _cachedFrameIndex: number;
            /**
             * @internal
             * @private
             */
            readonly _blendState: BlendState;
            /**
             * @internal
             * @private
             */
            _boneData: BoneData;
            /**
             * @internal
             * @private
             */
            _cachedFrameIndices: Array<number> | null;
            /**
             * @inheritDoc
             */
            protected _onClear(): void;
            /**
             * @private
             */
            protected _updateGlobalTransformMatrix(isCache: boolean): void;
            _getGlobalTransformMatrix(x: number, y: number): Matrix;
            /**
             * @inheritDoc
             */
            _setArmature(value: Armature | null): void;
            /**
             * @internal
             * @private
             */
            init(boneData: BoneData): void;
            /**
             * @internal
             * @private
             */
            update(cacheFrameIndex: number): void;
            /**
             * @internal
             * @private
             */
            updateByConstraint(): void;
            /**
             * - Forces the bone to update the transform in the next frame.
             * When the bone is not animated or its animation state is finished, the bone will not continue to update,
             * and when the skeleton must be updated for some reason, the method needs to be called explicitly.
             * @example
             * <pre>
             *     let bone = armature.getBone("arm");
             *     bone.offset.scaleX = 2.0;
             *     bone.invalidUpdate();
             * </pre>
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 强制骨骼在下一帧更新变换。
             * 当该骨骼没有动画状态或其动画状态播放完成时，骨骼将不在继续更新，而此时由于某些原因必须更新骨骼时，则需要显式调用该方法。
             * @example
             * <pre>
             *     let bone = armature.getBone("arm");
             *     bone.offset.scaleX = 2.0;
             *     bone.invalidUpdate();
             * </pre>
             * @version DragonBones 3.0
             * @language zh_CN
             */
            invalidUpdate(): void;
            /**
             * - Check whether the bone contains a specific bone or slot.
             * @see dragonBones.Bone
             * @see dragonBones.Slot
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 检查该骨骼是否包含特定的骨骼或插槽。
             * @see dragonBones.Bone
             * @see dragonBones.Slot
             * @version DragonBones 3.0
             * @language zh_CN
             */
            contains(value: TransformObject): boolean;
            /**
             * - The bone data.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 骨骼数据。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            readonly boneData: BoneData;
            /**
             * - The visible of all slots in the bone.
             * @default true
             * @see dragonBones.Slot#visible
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 此骨骼所有插槽的可见。
             * @default true
             * @see dragonBones.Slot#visible
             * @version DragonBones 3.0
             * @language zh_CN
             */
            visible: boolean;
            /**
             * - The bone name.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 骨骼名称。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            readonly name: string;
            /**
             * - Deprecated, please refer to {@link dragonBones.Armature#getBones()}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link dragonBones.Armature#getBones()}。
             * @deprecated
             * @language zh_CN
             */
            getBones(): Array<Bone>;
            /**
             * - Deprecated, please refer to {@link dragonBones.Armature#getSlots()}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link dragonBones.Armature#getSlots()}。
             * @deprecated
             * @language zh_CN
             */
            getSlots(): Array<Slot>;
            /**
             * - Deprecated, please refer to {@link dragonBones.Armature#getSlot()}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link dragonBones.Armature#getSlot()}。
             * @deprecated
             * @language zh_CN
             */
            readonly slot: Slot | null;
        }
        /**
         * @internal
         * @private
         */
        export class Surface extends Bone {
            static toString(): string;
            /**
             * For debug draw.
             * @internal
             * @private
             */
            readonly _vertices: Array<number>;
            /**
             * For timeline state.
             * @internal
             * @private
             */
            readonly _deformVertices: Array<number>;
            /**
             * @inheritDoc
             */
            protected _onClear(): void;
            /**
             * @private
             */
            protected _updateGlobalTransformMatrix(isCache: boolean): void;
            _getGlobalTransformMatrix(x: number, y: number): Matrix;
            init(surfaceData: SurfaceData): void;
            /**
             * @internal
             * @private
             */
            update(cacheFrameIndex: number): void;
        }
        /**
         * - The slot attached to the armature, controls the display status and properties of the display object.
         * A bone can contain multiple slots.
         * A slot can contain multiple display objects, displaying only one of the display objects at a time,
         * but you can toggle the display object into frame animation while the animation is playing.
         * The display object can be a normal texture, or it can be a display of a child armature, a grid display object,
         * and a custom other display object.
         * @see dragonBones.Armature
         * @see dragonBones.Bone
         * @see dragonBones.SlotData
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 插槽附着在骨骼上，控制显示对象的显示状态和属性。
         * 一个骨骼上可以包含多个插槽。
         * 一个插槽中可以包含多个显示对象，同一时间只能显示其中的一个显示对象，但可以在动画播放的过程中切换显示对象实现帧动画。
         * 显示对象可以是普通的图片纹理，也可以是子骨架的显示容器，网格显示对象，还可以是自定义的其他显示对象。
         * @see dragonBones.Armature
         * @see dragonBones.Bone
         * @see dragonBones.SlotData
         * @version DragonBones 3.0
         * @language zh_CN
         */
        export abstract class Slot extends TransformObject {
            /**
             * - Displays the animated state or mixed group name controlled by the object, set to null to be controlled by all animation states.
             * @default null
             * @see dragonBones.AnimationState#displayControl
             * @see dragonBones.AnimationState#name
             * @see dragonBones.AnimationState#group
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 显示对象受到控制的动画状态或混合组名称，设置为 null 则表示受所有的动画状态控制。
             * @default null
             * @see dragonBones.AnimationState#displayControl
             * @see dragonBones.AnimationState#name
             * @see dragonBones.AnimationState#group
             * @version DragonBones 4.5
             * @language zh_CN
             */
            displayController: string | null;
            /**
             * @private
             */
            protected _displayDirty: boolean;
            /**
             * @private
             */
            protected _zOrderDirty: boolean;
            /**
             * @private
             */
            protected _visibleDirty: boolean;
            /**
             * @private
             */
            protected _blendModeDirty: boolean;
            /**
             * @internal
             * @private
             */
            _colorDirty: boolean;
            /**
             * @internal
             * @private
             */
            _meshDirty: boolean;
            /**
             * @private
             */
            protected _transformDirty: boolean;
            /**
             * @private
             */
            /* protected */
            _visible: boolean;
            /**
             * @private
             */
            /* protected */
            _blendMode: BlendMode;
            /**
             * @private
             */
            protected _displayIndex: number;
            /**
             * @private
             */
            protected _animationDisplayIndex: number;
            /**
             * @internal
             * @private
             */
            _zOrder: number;
            /**
             * @private
             */
            protected _cachedFrameIndex: number;
            /**
             * @internal
             * @private
             */
            _pivotX: number;
            /**
             * @internal
             * @private
             */
            _pivotY: number;
            /**
             * @private
             */
            protected readonly _localMatrix: Matrix;
            /**
             * @internal
             * @private
             */
            readonly _colorTransform: ColorTransform;
            /**
             * @internal
             * @private
             */
            // readonly _deformVertices: Array<number>;
            readonly _deformVertices: DeformVertices;
            /**
             * @private
             */
            readonly _displayDatas: Array<DisplayData | null>;
            /**
             * @private
             */
            protected readonly _displayList: Array<any | Armature>;
            /**
             * @private
             */
            protected readonly _meshBones: Array<Bone | null>;
            /**
             * @private
             */
            protected readonly _meshSlots: Array<Slot | null>;
            /**
             * @internal
             * @private
             */
            _slotData: SlotData;
            /**
             * @private
             */
            protected _rawDisplayDatas: Array<DisplayData | null> | null;
            /**
             * @private
             */
            /* protected */
            _displayData: DisplayData | null;
            /**
             * @private
             */
            protected _textureData: TextureData | null;
            /**
             * @internal
             * @private
             */
            _meshData: MeshDisplayData | null;
            /**
             * @private
             */
            protected _boundingBoxData: BoundingBoxData | null;
            /**
             * @private
             */
            protected _rawDisplay: any;
            /**
             * @private
             */
            protected _meshDisplay: any;
            /**
             * @private
             */
            protected _display: any;
            /**
             * @private
             */
            protected _childArmature: Armature | null;
            /**
             * @internal
             * @private
             */
            _cachedFrameIndices: Array<number> | null;
            /**
             * @inheritDoc
             */
            protected _onClear(): void;
            /**
             * @private
             */
            protected abstract _initDisplay(value: any, isRetain: boolean): void;
            /**
             * @private
             */
            protected abstract _disposeDisplay(value: any, isRelease: boolean): void;
            /**
             * @private
             */
            protected abstract _onUpdateDisplay(): void;
            /**
             * @private
             */
            protected abstract _addDisplay(): void;
            /**
             * @private
             */
            protected abstract _replaceDisplay(value: any): void;
            /**
             * @private
             */
            protected abstract _removeDisplay(): void;
            /**
             * @private
             */
            protected abstract _updateZOrder(): void;
            /**
             * @private
             */
            abstract _updateVisible(): void;
            /**
             * @private
             */
            protected abstract _updateBlendMode(): void;
            /**
             * @private
             */
            protected abstract _updateColor(): void;
            /**
             * @private
             */
            protected abstract _updateFrame(): void;
            /**
             * @private
             */
            protected abstract _updateMesh(): void;
            /**
             * @internal
             * @private
             */
            abstract _updateGlueMesh(): void;
            /**
             * @private
             */
            protected abstract _updateTransform(): void;
            /**
             * @private
             */
            protected abstract _identityTransform(): void;
            /**
             * @private
             */
            protected _getDefaultRawDisplayData(): DisplayData | null;
            /**
             * @private
             */
            protected _updateDisplayData(): void;
            /**
             * @private
             */
            protected _updateDisplay(): void;
            /**
             * @private
             */
            protected _updateGlobalTransformMatrix(isCache: boolean): void;
            /**
             * @private
             */
            protected _isMeshBonesUpdate(): boolean;
            /**
             * @inheritDoc
             */
            _setArmature(value: Armature | null): void;
            /**
             * @internal
             * @private
             */
            _setDisplayIndex(value: number, isAnimation?: boolean): boolean;
            /**
             * @internal
             * @private
             */
            _setZorder(value: number): boolean;
            /**
             * @internal
             * @private
             */
            _setColor(value: ColorTransform): boolean;
            /**
             * @internal
             * @private
             */
            _setDisplayList(value: Array<any> | null): boolean;
            /**
             * @internal
             * @private
             */
            init(slotData: SlotData, displayDatas: Array<DisplayData | null> | null, rawDisplay: any, meshDisplay: any): void;
            /**
             * @internal
             * @private
             */
            update(cacheFrameIndex: number): void;
            /**
             * @private
             */
            updateTransformAndMatrix(): void;
            /**
             * @private
             */
            replaceDisplayData(value: DisplayData | null, displayIndex?: number): void;
            /**
             * - Check whether a specific point is inside a custom bounding box in the slot.
             * The coordinate system of the point is the inner coordinate system of the armature.
             * Custom bounding boxes need to be customized in Dragonbones Pro.
             * @param x - The horizontal coordinate of the point.
             * @param y - The vertical coordinate of the point.
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 检查特定点是否在插槽的自定义边界框内。
             * 点的坐标系为骨架内坐标系。
             * 自定义边界框需要在 DragonBones Pro 中自定义。
             * @param x - 点的水平坐标。
             * @param y - 点的垂直坐标。
             * @version DragonBones 5.0
             * @language zh_CN
             */
            containsPoint(x: number, y: number): boolean;
            /**
             * - Check whether a specific segment intersects a custom bounding box for the slot.
             * The coordinate system of the segment and intersection is the inner coordinate system of the armature.
             * Custom bounding boxes need to be customized in Dragonbones Pro.
             * @param xA - The horizontal coordinate of the beginning of the segment.
             * @param yA - The vertical coordinate of the beginning of the segment.
             * @param xB - The horizontal coordinate of the end point of the segment.
             * @param yB - The vertical coordinate of the end point of the segment.
             * @param intersectionPointA - The first intersection at which a line segment intersects the bounding box from the beginning to the end. (If not set, the intersection point will not calculated)
             * @param intersectionPointB - The first intersection at which a line segment intersects the bounding box from the end to the beginning. (If not set, the intersection point will not calculated)
             * @param normalRadians - The normal radians of the tangent of the intersection boundary box. [x: Normal radian of the first intersection tangent, y: Normal radian of the second intersection tangent] (If not set, the normal will not calculated)
             * @returns Intersection situation. [1: Disjoint and segments within the bounding box, 0: Disjoint, 1: Intersecting and having a nodal point and ending in the bounding box, 2: Intersecting and having a nodal point and starting at the bounding box, 3: Intersecting and having two intersections, N: Intersecting and having N intersections]
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 检查特定线段是否与插槽的自定义边界框相交。
             * 线段和交点的坐标系均为骨架内坐标系。
             * 自定义边界框需要在 DragonBones Pro 中自定义。
             * @param xA - 线段起点的水平坐标。
             * @param yA - 线段起点的垂直坐标。
             * @param xB - 线段终点的水平坐标。
             * @param yB - 线段终点的垂直坐标。
             * @param intersectionPointA - 线段从起点到终点与边界框相交的第一个交点。 （如果未设置，则不计算交点）
             * @param intersectionPointB - 线段从终点到起点与边界框相交的第一个交点。 （如果未设置，则不计算交点）
             * @param normalRadians - 交点边界框切线的法线弧度。 [x: 第一个交点切线的法线弧度, y: 第二个交点切线的法线弧度] （如果未设置，则不计算法线）
             * @returns 相交的情况。 [-1: 不相交且线段在包围盒内, 0: 不相交, 1: 相交且有一个交点且终点在包围盒内, 2: 相交且有一个交点且起点在包围盒内, 3: 相交且有两个交点, N: 相交且有 N 个交点]
             * @version DragonBones 5.0
             * @language zh_CN
             */
            intersectsSegment(xA: number, yA: number, xB: number, yB: number, intersectionPointA?: {
                x: number;
                y: number;
            } | null, intersectionPointB?: {
                x: number;
                y: number;
            } | null, normalRadians?: {
                x: number;
                y: number;
            } | null): number;
            /**
             * - Forces the slot to update the state of the display object in the next frame.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 强制插槽在下一帧更新显示对象的状态。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            invalidUpdate(): void;
            /**
             * - The visible of slot's display object.
             * @default true
             * @version DragonBones 5.6
             * @language en_US
             */
            /**
             * - 插槽的显示对象的可见。
             * @default true
             * @version DragonBones 5.6
             * @language zh_CN
             */
            visible: boolean;
            /**
             * - The index of the display object displayed in the display list.
             * @example
             * <pre>
             *     let slot = armature.getSlot("weapon");
             *     slot.displayIndex = 3;
             *     slot.displayController = "none";
             * </pre>
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 此时显示的显示对象在显示列表中的索引。
             * @example
             * <pre>
             *     let slot = armature.getSlot("weapon");
             *     slot.displayIndex = 3;
             *     slot.displayController = "none";
             * </pre>
             * @version DragonBones 4.5
             * @language zh_CN
             */
            displayIndex: number;
            /**
             * - The slot name.
             * @see dragonBones.SlotData#name
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 插槽名称。
             * @see dragonBones.SlotData#name
             * @version DragonBones 3.0
             * @language zh_CN
             */
            readonly name: string;
            /**
             * - Contains a display list of display objects or child armatures.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 包含显示对象或子骨架的显示列表。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            displayList: Array<any>;
            /**
             * - The slot data.
             * @see dragonBones.SlotData
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 插槽数据。
             * @see dragonBones.SlotData
             * @version DragonBones 4.5
             * @language zh_CN
             */
            readonly slotData: SlotData;
            /**
             * @private
             */
            rawDisplayDatas: Array<DisplayData | null> | null;
            /**
             * - The custom bounding box data for the slot at current time.
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 插槽此时的自定义包围盒数据。
             * @version DragonBones 5.0
             * @language zh_CN
             */
            readonly boundingBoxData: BoundingBoxData | null;
            /**
             * @private
             */
            readonly rawDisplay: any;
            /**
             * @private
             */
            readonly meshDisplay: any;
            /**
             * - The display object that the slot displays at this time.
             * @example
             * <pre>
             *     let slot = armature.getSlot("text");
             *     slot.display = new yourEngine.TextField();
             * </pre>
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 插槽此时显示的显示对象。
             * @example
             * <pre>
             *     let slot = armature.getSlot("text");
             *     slot.display = new yourEngine.TextField();
             * </pre>
             * @version DragonBones 3.0
             * @language zh_CN
             */
            display: any;
            /**
             * - The child armature that the slot displayed at current time.
             * @example
             * <pre>
             *     let slot = armature.getSlot("weapon");
             *     slot.childArmature = factory.buildArmature("weapon_blabla", "weapon_blabla_project");
             * </pre>
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 插槽此时显示的子骨架。
             * @example
             * <pre>
             *     let slot = armature.getSlot("weapon");
             *     slot.childArmature = factory.buildArmature("weapon_blabla", "weapon_blabla_project");
             * </pre>
             * @version DragonBones 3.0
             * @language zh_CN
             */
            childArmature: Armature | null;
            /**
             * - Deprecated, please refer to {@link #display}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link #display}。
             * @deprecated
             * @language zh_CN
             */
            getDisplay(): any;
            /**
             * - Deprecated, please refer to {@link #display}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link #display}。
             * @deprecated
             * @language zh_CN
             */
            setDisplay(value: any): void;
        }
        /**
         * @internal
         * @private
         */
        export abstract class Constraint extends BaseObject {
            protected static readonly _helpMatrix: Matrix;
            protected static readonly _helpTransform: Transform;
            protected static readonly _helpPoint: Point;
            /**
             * - For timeline state.
             * @internal
             */
            _constraintData: ConstraintData;
            protected _armature: Armature;
            /**
             * - For sort bones.
             * @internal
             */
            _target: Bone;
            /**
             * - For sort bones.
             * @internal
             */
            _root: Bone;
            protected _bone: Bone | null;
            protected _onClear(): void;
            abstract init(constraintData: ConstraintData, armature: Armature): void;
            abstract update(): void;
            abstract invalidUpdate(): void;
            readonly name: string;
        }
        /**
         * @internal
         * @private
         */
        export class IKConstraint extends Constraint {
            static toString(): string;
            /**
             * - For timeline state.
             * @internal
             */
            _bendPositive: boolean;
            /**
             * - For timeline state.
             * @internal
             */
            _weight: number;
            protected _onClear(): void;
            init(constraintData: ConstraintData, armature: Armature): void;
            update(): void;
            invalidUpdate(): void;
        }
        /**
         * - Play animation interface. (Both Armature and Wordclock implement the interface)
         * Any instance that implements the interface can be added to the Worldclock instance and advance time by Worldclock instance uniformly.
         * @see dragonBones.WorldClock
         * @see dragonBones.Armature
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 播放动画接口。 (Armature 和 WordClock 都实现了该接口)
         * 任何实现了此接口的实例都可以添加到 WorldClock 实例中，由 WorldClock 实例统一更新时间。
         * @see dragonBones.WorldClock
         * @see dragonBones.Armature
         * @version DragonBones 3.0
         * @language zh_CN
         */
        export interface IAnimatable {
            /**
             * - Advance time.
             * @param passedTime - Passed time. (In seconds)
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 更新时间。
             * @param passedTime - 前进的时间。 （以秒为单位）
             * @version DragonBones 3.0
             * @language zh_CN
             */
            advanceTime(passedTime: number): void;
            /**
             * - The Wordclock instance to which the current belongs.
             * @example
             * <pre>
             *     armature.clock = factory.clock; // Add armature to clock.
             *     armature.clock = null; // Remove armature from clock.
             * </pre>
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 当前所属的 WordClock 实例。
             * @example
             * <pre>
             *     armature.clock = factory.clock; // 将骨架添加到时钟。
             *     armature.clock = null; // 将骨架从时钟移除。
             * </pre>
             * @version DragonBones 5.0
             * @language zh_CN
             */
            clock: WorldClock | null;
        }
        /**
         * - Worldclock provides clock support for animations, advance time for each IAnimatable object added to the instance.
         * @see dragonBones.IAnimateble
         * @see dragonBones.Armature
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - WorldClock 对动画提供时钟支持，为每个加入到该实例的 IAnimatable 对象更新时间。
         * @see dragonBones.IAnimateble
         * @see dragonBones.Armature
         * @version DragonBones 3.0
         * @language zh_CN
         */
        export class WorldClock implements IAnimatable {
            /**
             * - Current time. (In seconds)
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 当前的时间。 (以秒为单位)
             * @version DragonBones 3.0
             * @language zh_CN
             */
            time: number;
            /**
             * - The play speed, used to control animation speed-shift play.
             * [0: Stop play, (0~1): Slow play, 1: Normal play, (1~N): Fast play]
             * @default 1.0
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 播放速度，用于控制动画变速播放。
             * [0: 停止播放, (0~1): 慢速播放, 1: 正常播放, (1~N): 快速播放]
             * @default 1.0
             * @version DragonBones 3.0
             * @language zh_CN
             */
            timeScale: number;
            /**
             * - Creating a Worldclock instance. Typically, you do not need to create Worldclock instance.
             * When multiple Worldclock instances are running at different speeds, can achieving some specific animation effects, such as bullet time.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 创建一个 WorldClock 实例。通常并不需要创建 WorldClock 实例。
             * 当多个 WorldClock 实例使用不同的速度运行时，可以实现一些特殊的动画效果，比如子弹时间等。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            constructor(time?: number);
            /**
             * - Advance time for all IAnimatable instances.
             * @param passedTime - Passed time. [-1: Automatically calculates the time difference between the current frame and the previous frame, [0~N): Passed time] (In seconds)
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 为所有的 IAnimatable 实例更新时间。
             * @param passedTime - 前进的时间。 [-1: 自动计算当前帧与上一帧的时间差, [0~N): 前进的时间] (以秒为单位)
             * @version DragonBones 3.0
             * @language zh_CN
             */
            advanceTime(passedTime: number): void;
            /**
             * - Check whether contains a specific instance of IAnimatable.
             * @param value - The IAnimatable instance.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 检查是否包含特定的 IAnimatable 实例。
             * @param value - IAnimatable 实例。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            contains(value: IAnimatable): boolean;
            /**
             * - Add IAnimatable instance.
             * @param value - The IAnimatable instance.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 添加 IAnimatable 实例。
             * @param value - IAnimatable 实例。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            add(value: IAnimatable): void;
            /**
             * - Removes a specified IAnimatable instance.
             * @param value - The IAnimatable instance.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 移除特定的 IAnimatable 实例。
             * @param value - IAnimatable 实例。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            remove(value: IAnimatable): void;
            /**
             * - Clear all IAnimatable instances.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 清除所有的 IAnimatable 实例。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            clear(): void;
            /**
             * @inheritDoc
             */
            clock: WorldClock | null;
            /**
             * - Deprecated, please refer to {@link dragonBones.BaseFactory#clock}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link dragonBones.BaseFactory#clock}。
             * @deprecated
             * @language zh_CN
             */
            static readonly clock: WorldClock;
        }
        /**
         * - The animation player is used to play the animation data and manage the animation states.
         * @see dragonBones.AnimationData
         * @see dragonBones.AnimationState
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 动画播放器用来播放动画数据和管理动画状态。
         * @see dragonBones.AnimationData
         * @see dragonBones.AnimationState
         * @version DragonBones 3.0
         * @language zh_CN
         */
        export class Animation extends BaseObject {
            static toString(): string;
            /**
             * - The play speed of all animations. [0: Stop, (0~1): Slow, 1: Normal, (1~N): Fast]
             * @default 1.0
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 所有动画的播放速度。 [0: 停止播放, (0~1): 慢速播放, 1: 正常播放, (1~N): 快速播放]
             * @default 1.0
             * @version DragonBones 3.0
             * @language zh_CN
             */
            timeScale: number;
            /**
             * @private
             */
            protected _onClear(): void;
            /**
             * @internal
             * @private
             */
            init(armature: Armature): void;
            /**
             * @internal
             * @private
             */
            advanceTime(passedTime: number): void;
            /**
             * - Clear all animations states.
             * @see dragonBones.AnimationState
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 清除所有的动画状态。
             * @see dragonBones.AnimationState
             * @version DragonBones 4.5
             * @language zh_CN
             */
            reset(): void;
            /**
             * - Pause a specific animation state.
             * @param animationName - The name of animation state. (If not set, it will pause all animations)
             * @see dragonBones.AnimationState
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 暂停指定动画状态的播放。
             * @param animationName - 动画状态名称。 （如果未设置，则暂停所有动画）
             * @see dragonBones.AnimationState
             * @version DragonBones 3.0
             * @language zh_CN
             */
            stop(animationName?: string | null): void;
            /**
             * - Play animation with a specific animation config.
             * The API is still in the experimental phase and may encounter bugs or stability or compatibility issues when used.
             * @param animationConfig - The animation config.
             * @returns The playing animation state.
             * @see dragonBones.AnimationConfig
             * @beta
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 通过指定的动画配置来播放动画。
             * 该 API 仍在实验阶段，使用时可能遭遇 bug 或稳定性或兼容性问题。
             * @param animationConfig - 动画配置。
             * @returns 播放的动画状态。
             * @see dragonBones.AnimationConfig
             * @beta
             * @version DragonBones 5.0
             * @language zh_CN
             */
            playConfig(animationConfig: AnimationConfig): AnimationState | null;
            /**
             * - Play a specific animation.
             * @param animationName - The name of animation data. (If not set, The default animation will be played, or resume the animation playing from pause status, or replay the last playing animation)
             * @param playTimes - Playing repeat times. [-1: Use default value of the animation data, 0: No end loop playing, [1~N]: Repeat N times] (default: -1)
             * @returns The playing animation state.
             * @example
             * <pre>
             *     armature.animation.play("walk");
             * </pre>
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 播放指定动画。
             * @param animationName - 动画数据名称。 （如果未设置，则播放默认动画，或将暂停状态切换为播放状态，或重新播放之前播放的动画）
             * @param playTimes - 循环播放次数。 [-1: 使用动画数据默认值, 0: 无限循环播放, [1~N]: 循环播放 N 次] （默认: -1）
             * @returns 播放的动画状态。
             * @example
             * <pre>
             *     armature.animation.play("walk");
             * </pre>
             * @version DragonBones 3.0
             * @language zh_CN
             */
            play(animationName?: string | null, playTimes?: number): AnimationState | null;
            /**
             * - Fade in a specific animation.
             * @param animationName - The name of animation data.
             * @param fadeInTime - The fade in time. [-1: Use the default value of animation data, [0~N]: The fade in time (In seconds)] (Default: -1)
             * @param playTimes - playing repeat times. [-1: Use the default value of animation data, 0: No end loop playing, [1~N]: Repeat N times] (Default: -1)
             * @param layer - The blending layer, the animation states in high level layer will get the blending weights with high priority, when the total blending weights are more than 1.0, there will be no more weights can be allocated to the other animation states. (Default: 0)
             * @param group - The blending group name, it is typically used to specify the substitution of multiple animation states blending. (Default: null)
             * @param fadeOutMode - The fade out mode, which is typically used to specify alternate mode of multiple animation states blending. (Default: AnimationFadeOutMode.SameLayerAndGroup)
             * @returns The playing animation state.
             * @example
             * <pre>
             *     armature.animation.fadeIn("walk", 0.3, 0, 0, "normalGroup").resetToPose = false;
             *     armature.animation.fadeIn("attack", 0.3, 1, 0, "attackGroup").resetToPose = false;
             * </pre>
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 淡入播放指定的动画。
             * @param animationName - 动画数据名称。
             * @param fadeInTime - 淡入时间。 [-1: 使用动画数据默认值, [0~N]: 淡入时间 (以秒为单位)] （默认: -1）
             * @param playTimes - 播放次数。 [-1: 使用动画数据默认值, 0: 无限循环播放, [1~N]: 循环播放 N 次] （默认: -1）
             * @param layer - 混合图层，图层高的动画状态会优先获取混合权重，当混合权重分配总和超过 1.0 时，剩余的动画状态将不能再获得权重分配。 （默认: 0）
             * @param group - 混合组名称，该属性通常用来指定多个动画状态混合时的相互替换关系。 （默认: null）
             * @param fadeOutMode - 淡出模式，该属性通常用来指定多个动画状态混合时的相互替换模式。 （默认: AnimationFadeOutMode.SameLayerAndGroup）
             * @returns 播放的动画状态。
             * @example
             * <pre>
             *     armature.animation.fadeIn("walk", 0.3, 0, 0, "normalGroup").resetToPose = false;
             *     armature.animation.fadeIn("attack", 0.3, 1, 0, "attackGroup").resetToPose = false;
             * </pre>
             * @version DragonBones 4.5
             * @language zh_CN
             */
            fadeIn(animationName: string, fadeInTime?: number, playTimes?: number, layer?: number, group?: string | null, fadeOutMode?: AnimationFadeOutMode): AnimationState | null;
            /**
             * - Play a specific animation from the specific time.
             * @param animationName - The name of animation data.
             * @param time - The start time point of playing. (In seconds)
             * @param playTimes - Playing repeat times. [-1: Use the default value of animation data, 0: No end loop playing, [1~N]: Repeat N times] (Default: -1)
             * @returns The played animation state.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 从指定时间开始播放指定的动画。
             * @param animationName - 动画数据名称。
             * @param time - 播放开始的时间。 (以秒为单位)
             * @param playTimes - 循环播放次数。 [-1: 使用动画数据默认值, 0: 无限循环播放, [1~N]: 循环播放 N 次] （默认: -1）
             * @returns 播放的动画状态。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            gotoAndPlayByTime(animationName: string, time?: number, playTimes?: number): AnimationState | null;
            /**
             * - Play a specific animation from the specific frame.
             * @param animationName - The name of animation data.
             * @param frame - The start frame of playing.
             * @param playTimes - Playing repeat times. [-1: Use the default value of animation data, 0: No end loop playing, [1~N]: Repeat N times] (Default: -1)
             * @returns The played animation state.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 从指定帧开始播放指定的动画。
             * @param animationName - 动画数据名称。
             * @param frame - 播放开始的帧数。
             * @param playTimes - 播放次数。 [-1: 使用动画数据默认值, 0: 无限循环播放, [1~N]: 循环播放 N 次] （默认: -1）
             * @returns 播放的动画状态。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            gotoAndPlayByFrame(animationName: string, frame?: number, playTimes?: number): AnimationState | null;
            /**
             * - Play a specific animation from the specific progress.
             * @param animationName - The name of animation data.
             * @param progress - The start progress value of playing.
             * @param playTimes - Playing repeat times. [-1: Use the default value of animation data, 0: No end loop playing, [1~N]: Repeat N times] (Default: -1)
             * @returns The played animation state.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 从指定进度开始播放指定的动画。
             * @param animationName - 动画数据名称。
             * @param progress - 开始播放的进度。
             * @param playTimes - 播放次数。 [-1: 使用动画数据默认值, 0: 无限循环播放, [1~N]: 循环播放 N 次] （默认: -1）
             * @returns 播放的动画状态。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            gotoAndPlayByProgress(animationName: string, progress?: number, playTimes?: number): AnimationState | null;
            /**
             * - Stop a specific animation at the specific time.
             * @param animationName - The name of animation data.
             * @param time - The stop time. (In seconds)
             * @returns The played animation state.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 在指定时间停止指定动画播放
             * @param animationName - 动画数据名称。
             * @param time - 停止的时间。 (以秒为单位)
             * @returns 播放的动画状态。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            gotoAndStopByTime(animationName: string, time?: number): AnimationState | null;
            /**
             * - Stop a specific animation at the specific frame.
             * @param animationName - The name of animation data.
             * @param frame - The stop frame.
             * @returns The played animation state.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 在指定帧停止指定动画的播放
             * @param animationName - 动画数据名称。
             * @param frame - 停止的帧数。
             * @returns 播放的动画状态。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            gotoAndStopByFrame(animationName: string, frame?: number): AnimationState | null;
            /**
             * - Stop a specific animation at the specific progress.
             * @param animationName - The name of animation data.
             * @param progress - The stop progress value.
             * @returns The played animation state.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 在指定的进度停止指定的动画播放。
             * @param animationName - 动画数据名称。
             * @param progress - 停止进度。
             * @returns 播放的动画状态。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            gotoAndStopByProgress(animationName: string, progress?: number): AnimationState | null;
            /**
             * - Get a specific animation state.
             * @param animationName - The name of animation state.
             * @example
             * <pre>
             *     armature.animation.play("walk");
             *     let walkState = armature.animation.getState("walk");
             *     walkState.timeScale = 0.5;
             * </pre>
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 获取指定的动画状态
             * @param animationName - 动画状态名称。
             * @example
             * <pre>
             *     armature.animation.play("walk");
             *     let walkState = armature.animation.getState("walk");
             *     walkState.timeScale = 0.5;
             * </pre>
             * @version DragonBones 3.0
             * @language zh_CN
             */
            getState(animationName: string): AnimationState | null;
            /**
             * - Check whether a specific animation data is included.
             * @param animationName - The name of animation data.
             * @see dragonBones.AnimationData
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 检查是否包含指定的动画数据
             * @param animationName - 动画数据名称。
             * @see dragonBones.AnimationData
             * @version DragonBones 3.0
             * @language zh_CN
             */
            hasAnimation(animationName: string): boolean;
            /**
             * - Get all the animation states.
             * @version DragonBones 5.1
             * @language en_US
             */
            /**
             * - 获取所有的动画状态
             * @version DragonBones 5.1
             * @language zh_CN
             */
            getStates(): Array<AnimationState>;
            /**
             * - Check whether there is an animation state is playing
             * @see dragonBones.AnimationState
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 检查是否有动画状态正在播放
             * @see dragonBones.AnimationState
             * @version DragonBones 3.0
             * @language zh_CN
             */
            readonly isPlaying: boolean;
            /**
             * - Check whether all the animation states' playing were finished.
             * @see dragonBones.AnimationState
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 检查是否所有的动画状态均已播放完毕。
             * @see dragonBones.AnimationState
             * @version DragonBones 3.0
             * @language zh_CN
             */
            readonly isCompleted: boolean;
            /**
             * - The name of the last playing animation state.
             * @see #lastAnimationState
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 上一个播放的动画状态名称
             * @see #lastAnimationState
             * @version DragonBones 3.0
             * @language zh_CN
             */
            readonly lastAnimationName: string;
            /**
             * - The name of all animation data
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 所有动画数据的名称
             * @version DragonBones 4.5
             * @language zh_CN
             */
            readonly animationNames: Array<string>;
            /**
             * - All animation data.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 所有的动画数据。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            animations: Map<AnimationData>;
            /**
             * - An AnimationConfig instance that can be used quickly.
             * @see dragonBones.AnimationConfig
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 一个可以快速使用的动画配置实例。
             * @see dragonBones.AnimationConfig
             * @version DragonBones 5.0
             * @language zh_CN
             */
            readonly animationConfig: AnimationConfig;
            /**
             * - The last playing animation state
             * @see dragonBones.AnimationState
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 上一个播放的动画状态
             * @see dragonBones.AnimationState
             * @version DragonBones 3.0
             * @language zh_CN
             */
            readonly lastAnimationState: AnimationState | null;
            /**
             * - Deprecated, please refer to {@link #play()} {@link #fadeIn()}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link #play()} {@link #fadeIn()}。
             * @deprecated
             * @language zh_CN
             */
            gotoAndPlay(animationName: string, fadeInTime?: number, duration?: number, playTimes?: number, layer?: number, group?: string | null, fadeOutMode?: AnimationFadeOutMode, pauseFadeOut?: boolean, pauseFadeIn?: boolean): AnimationState | null;
            /**
             * - Deprecated, please refer to {@link #gotoAndStopByTime()}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link #gotoAndStopByTime()}。
             * @deprecated
             * @language zh_CN
             */
            gotoAndStop(animationName: string, time?: number): AnimationState | null;
            /**
             * - Deprecated, please refer to {@link #animationNames}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link #animationNames}。
             * @deprecated
             * @language zh_CN
             */
            readonly animationList: Array<string>;
            /**
             * - Deprecated, please refer to {@link #animationNames}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link #animationNames}。
             * @deprecated
             * @language zh_CN
             */
            readonly animationDataList: Array<AnimationData>;
        }
        /**
         * - The animation state is generated when the animation data is played.
         * @see dragonBones.Animation
         * @see dragonBones.AnimationData
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 动画状态由播放动画数据时产生。
         * @see dragonBones.Animation
         * @see dragonBones.AnimationData
         * @version DragonBones 3.0
         * @language zh_CN
         */
        export class AnimationState extends BaseObject {
            static toString(): string;
            /**
             * @private
             */
            actionEnabled: boolean;
            /**
             * @private
             */
            additiveBlending: boolean;
            /**
             * - Whether the animation state has control over the display object properties of the slots.
             * Sometimes blend a animation state does not want it to control the display object properties of the slots,
             * especially if other animation state are controlling the display object properties of the slots.
             * @default true
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 动画状态是否对插槽的显示对象属性有控制权。
             * 有时混合一个动画状态并不希望其控制插槽的显示对象属性，
             * 尤其是其他动画状态正在控制这些插槽的显示对象属性时。
             * @default true
             * @version DragonBones 5.0
             * @language zh_CN
             */
            displayControl: boolean;
            /**
             * - Whether to reset the objects without animation to the armature pose when the animation state is start to play.
             * This property should usually be set to false when blend multiple animation states.
             * @default true
             * @version DragonBones 5.1
             * @language en_US
             */
            /**
             * - 开始播放动画状态时是否将没有动画的对象重置为骨架初始值。
             * 通常在混合多个动画状态时应该将该属性设置为 false。
             * @default true
             * @version DragonBones 5.1
             * @language zh_CN
             */
            resetToPose: boolean;
            /**
             * - The play times. [0: Loop play, [1~N]: Play N times]
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 播放次数。 [0: 无限循环播放, [1~N]: 循环播放 N 次]
             * @version DragonBones 3.0
             * @language zh_CN
             */
            playTimes: number;
            /**
             * - The blend layer.
             * High layer animation state will get the blend weight first.
             * When the blend weight is assigned more than 1, the remaining animation states will no longer get the weight assigned.
             * @readonly
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 混合图层。
             * 图层高的动画状态会优先获取混合权重。
             * 当混合权重分配超过 1 时，剩余的动画状态将不再获得权重分配。
             * @readonly
             * @version DragonBones 5.0
             * @language zh_CN
             */
            layer: number;
            /**
             * - The play speed.
             * The value is an overlay relationship with {@link dragonBones.Animation#timeScale}.
             * [(-N~0): Reverse play, 0: Stop play, (0~1): Slow play, 1: Normal play, (1~N): Fast play]
             * @default 1.0
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 播放速度。
             * 该值与 {@link dragonBones.Animation#timeScale} 是叠加关系。
             * [(-N~0): 倒转播放, 0: 停止播放, (0~1): 慢速播放, 1: 正常播放, (1~N): 快速播放]
             * @default 1.0
             * @version DragonBones 3.0
             * @language zh_CN
             */
            timeScale: number;
            /**
             * - The blend weight.
             * @default 1.0
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 混合权重。
             * @default 1.0
             * @version DragonBones 5.0
             * @language zh_CN
             */
            weight: number;
            /**
             * - The auto fade out time when the animation state play completed.
             * [-1: Do not fade out automatically, [0~N]: The fade out time] (In seconds)
             * @default -1.0
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 动画状态播放完成后的自动淡出时间。
             * [-1: 不自动淡出, [0~N]: 淡出时间] （以秒为单位）
             * @default -1.0
             * @version DragonBones 5.0
             * @language zh_CN
             */
            autoFadeOutTime: number;
            /**
             * @private
             */
            fadeTotalTime: number;
            /**
             * - The name of the animation state. (Can be different from the name of the animation data)
             * @readonly
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 动画状态名称。 （可以不同于动画数据）
             * @readonly
             * @version DragonBones 5.0
             * @language zh_CN
             */
            name: string;
            /**
             * - The blend group name of the animation state.
             * This property is typically used to specify the substitution of multiple animation states blend.
             * @readonly
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 混合组名称。
             * 该属性通常用来指定多个动画状态混合时的相互替换关系。
             * @readonly
             * @version DragonBones 5.0
             * @language zh_CN
             */
            group: string;
            /**
             * - xx: Play Enabled, Fade Play Enabled
             * @internal
             * @private
             */
            _playheadState: number;
            /**
             * -1: Fade in, 0: Fade complete, 1: Fade out;
             * @internal
             * @private
             */
            _fadeState: number;
            /**
             * -1: Fade start, 0: Fading, 1: Fade complete;
             * @internal
             * @private
             */
            _subFadeState: number;
            /**
             * @internal
             * @private
             */
            _position: number;
            /**
             * @internal
             * @private
             */
            _duration: number;
            /**
             * @internal
             * @private
             */
            _fadeProgress: number;
            /**
             * @internal
             * @private
             */
            _weightResult: number;
            /**
             * @internal
             * @private
             */
            readonly _blendState: BlendState;
            /**
             * @internal
             * @private
             */
            _animationData: AnimationData;
            /**
             * @internal
             * @private
             */
            _actionTimeline: ActionTimelineState;
            /**
             * @internal
             * @private
             */
            _parent: AnimationState;
            /**
             * @private
             */
            protected _onClear(): void;
            /**
             * @internal
             * @private
             */
            init(armature: Armature, animationData: AnimationData, animationConfig: AnimationConfig): void;
            /**
             * @internal
             * @private
             */
            advanceTime(passedTime: number, cacheFrameRate: number): void;
            /**
             * - Continue play.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 继续播放。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            play(): void;
            /**
             * - Stop play.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 暂停播放。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            stop(): void;
            /**
             * - Fade out the animation state.
             * @param fadeOutTime - The fade out time. (In seconds)
             * @param pausePlayhead - Whether to pause the animation playing when fade out.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 淡出动画状态。
             * @param fadeOutTime - 淡出时间。 （以秒为单位）
             * @param pausePlayhead - 淡出时是否暂停播放。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            fadeOut(fadeOutTime: number, pausePlayhead?: boolean): void;
            /**
             * - Check if a specific bone mask is included.
             * @param name - The bone name.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 检查是否包含特定骨骼遮罩。
             * @param name - 骨骼名称。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            containsBoneMask(name: string): boolean;
            /**
             * - Add a specific bone mask.
             * @param name - The bone name.
             * @param recursive - Whether or not to add a mask to the bone's sub-bone.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 添加特定的骨骼遮罩。
             * @param name - 骨骼名称。
             * @param recursive - 是否为该骨骼的子骨骼添加遮罩。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            addBoneMask(name: string, recursive?: boolean): void;
            /**
             * - Remove the mask of a specific bone.
             * @param name - The bone name.
             * @param recursive - Whether to remove the bone's sub-bone mask.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 删除特定骨骼的遮罩。
             * @param name - 骨骼名称。
             * @param recursive - 是否删除该骨骼的子骨骼遮罩。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            removeBoneMask(name: string, recursive?: boolean): void;
            /**
             * - Remove all bone masks.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 删除所有骨骼遮罩。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            removeAllBoneMask(): void;
            /**
             * - Whether the animation state is fading in.
             * @version DragonBones 5.1
             * @language en_US
             */
            /**
             * - 是否正在淡入。
             * @version DragonBones 5.1
             * @language zh_CN
             */
            readonly isFadeIn: boolean;
            /**
             * - Whether the animation state is fading out.
             * @version DragonBones 5.1
             * @language en_US
             */
            /**
             * - 是否正在淡出。
             * @version DragonBones 5.1
             * @language zh_CN
             */
            readonly isFadeOut: boolean;
            /**
             * - Whether the animation state is fade completed.
             * @version DragonBones 5.1
             * @language en_US
             */
            /**
             * - 是否淡入或淡出完毕。
             * @version DragonBones 5.1
             * @language zh_CN
             */
            readonly isFadeComplete: boolean;
            /**
             * - Whether the animation state is playing.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 是否正在播放。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            readonly isPlaying: boolean;
            /**
             * - Whether the animation state is play completed.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 是否播放完毕。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            readonly isCompleted: boolean;
            /**
             * - The times has been played.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 已经循环播放的次数。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            readonly currentPlayTimes: number;
            /**
             * - The total time. (In seconds)
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 总播放时间。 （以秒为单位）
             * @version DragonBones 3.0
             * @language zh_CN
             */
            readonly totalTime: number;
            /**
             * - The time is currently playing. (In seconds)
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 当前播放的时间。 （以秒为单位）
             * @version DragonBones 3.0
             * @language zh_CN
             */
            currentTime: number;
            /**
             * - The animation data.
             * @see dragonBones.AnimationData
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 动画数据。
             * @see dragonBones.AnimationData
             * @version DragonBones 3.0
             * @language zh_CN
             */
            readonly animationData: AnimationData;
        }
        /**
         * @internal
         * @private
         */
        export class BonePose extends BaseObject {
            static toString(): string;
            readonly current: Transform;
            readonly delta: Transform;
            readonly result: Transform;
            protected _onClear(): void;
        }
        /**
         * @internal
         * @private
         */
        export class BlendState {
            dirty: boolean;
            layer: number;
            leftWeight: number;
            layerWeight: number;
            blendWeight: number;
            update(weight: number, layer: number): number;
            clear(): void;
        }
        /**
         * @internal
         * @private
         */
        export enum TweenState {
            None = 0,
            Once = 1,
            Always = 2
        }
        /**
         * @internal
         * @private
         */
        export abstract class TimelineState extends BaseObject {
            playState: number;
            currentPlayTimes: number;
            currentTime: number;
            protected _tweenState: TweenState;
            protected _frameRate: number;
            protected _frameValueOffset: number;
            protected _frameCount: number;
            protected _frameOffset: number;
            protected _frameIndex: number;
            protected _frameRateR: number;
            protected _position: number;
            protected _duration: number;
            protected _timeScale: number;
            protected _timeOffset: number;
            protected _dragonBonesData: DragonBonesData;
            protected _animationData: AnimationData;
            protected _timelineData: TimelineData | null;
            protected _armature: Armature;
            protected _animationState: AnimationState;
            protected _actionTimeline: TimelineState;
            protected _frameArray: Array<number> | Int16Array;
            protected _frameIntArray: Array<number> | Int16Array;
            protected _frameFloatArray: Array<number> | Int16Array;
            protected _timelineArray: Array<number> | Uint16Array;
            protected _frameIndices: Array<number>;
            protected _onClear(): void;
            protected abstract _onArriveAtFrame(): void;
            protected abstract _onUpdateFrame(): void;
            protected _setCurrentTime(passedTime: number): boolean;
            init(armature: Armature, animationState: AnimationState, timelineData: TimelineData | null): void;
            fadeOut(): void;
            update(passedTime: number): void;
        }
        /**
         * @internal
         * @private
         */
        export abstract class TweenTimelineState extends TimelineState {
            protected _tweenType: TweenType;
            protected _curveCount: number;
            protected _framePosition: number;
            protected _frameDurationR: number;
            protected _tweenProgress: number;
            protected _tweenEasing: number;
            protected _onClear(): void;
            protected _onArriveAtFrame(): void;
            protected _onUpdateFrame(): void;
        }
        /**
         * @internal
         * @private
         */
        export abstract class BoneTimelineState extends TweenTimelineState {
            bone: Bone;
            bonePose: BonePose;
            protected _onClear(): void;
            blend(state: number): void;
        }
        /**
         * @internal
         * @private
         */
        export abstract class SlotTimelineState extends TweenTimelineState {
            slot: Slot;
            protected _onClear(): void;
        }
        /**
         * @internal
         * @private
         */
        export abstract class ConstraintTimelineState extends TweenTimelineState {
            constraint: Constraint;
            protected _onClear(): void;
        }
        /**
         * @internal
         * @private
         */
        export class ActionTimelineState extends TimelineState {
            static toString(): string;
            protected _onArriveAtFrame(): void;
            protected _onUpdateFrame(): void;
            update(passedTime: number): void;
            setCurrentTime(value: number): void;
        }
        /**
         * @internal
         * @private
         */
        export class ZOrderTimelineState extends TimelineState {
            static toString(): string;
            protected _onArriveAtFrame(): void;
            protected _onUpdateFrame(): void;
        }
        /**
         * @internal
         * @private
         */
        export class BoneAllTimelineState extends BoneTimelineState {
            static toString(): string;
            protected _onArriveAtFrame(): void;
            protected _onUpdateFrame(): void;
            fadeOut(): void;
        }
        /**
         * @internal
         * @private
         */
        export class BoneTranslateTimelineState extends BoneTimelineState {
            static toString(): string;
            protected _onArriveAtFrame(): void;
            protected _onUpdateFrame(): void;
        }
        /**
         * @internal
         * @private
         */
        export class BoneRotateTimelineState extends BoneTimelineState {
            static toString(): string;
            protected _onArriveAtFrame(): void;
            protected _onUpdateFrame(): void;
            fadeOut(): void;
        }
        /**
         * @internal
         * @private
         */
        export class BoneScaleTimelineState extends BoneTimelineState {
            static toString(): string;
            protected _onArriveAtFrame(): void;
            protected _onUpdateFrame(): void;
        }
        /**
         * @internal
         * @private
         */
        export class SurfaceTimelineState extends TweenTimelineState {
            static toString(): string;
            surface: Surface;
            protected _onClear(): void;
            protected _onArriveAtFrame(): void;
            protected _onUpdateFrame(): void;
            init(armature: Armature, animationState: AnimationState, timelineData: TimelineData | null): void;
            blend(state: number): void;
        }
        /**
         * @internal
         * @private
         */
        export class SlotDislayTimelineState extends SlotTimelineState {
            static toString(): string;
            protected _onArriveAtFrame(): void;
        }
        /**
         * @internal
         * @private
         */
        export class SlotColorTimelineState extends SlotTimelineState {
            static toString(): string;
            protected _onClear(): void;
            protected _onArriveAtFrame(): void;
            protected _onUpdateFrame(): void;
            fadeOut(): void;
            update(passedTime: number): void;
        }
        /**
         * @internal
         * @private
         */
        export class SlotFFDTimelineState extends SlotTimelineState {
            static toString(): string;
            meshOffset: number;
            protected _onClear(): void;
            protected _onArriveAtFrame(): void;
            protected _onUpdateFrame(): void;
            init(armature: Armature, animationState: AnimationState, timelineData: TimelineData | null): void;
            fadeOut(): void;
            update(passedTime: number): void;
        }
        /**
         * @internal
         * @private
         */
        export class IKConstraintTimelineState extends ConstraintTimelineState {
            static toString(): string;
            protected _onClear(): void;
            protected _onArriveAtFrame(): void;
            protected _onUpdateFrame(): void;
        }
        /**
         * @internal
         * @private
         */
        export class AnimationTimelineState extends TweenTimelineState {
            static toString(): string;
            animationState: AnimationState;
            protected _onClear(): void;
            protected _onArriveAtFrame(): void;
            protected _onUpdateFrame(): void;
            blend(state: number): void;
        }
        /**
         * - The properties of the object carry basic information about an event,
         * which are passed as parameter or parameter's parameter to event listeners when an event occurs.
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 事件对象，包含有关事件的基本信息，当发生事件时，该实例将作为参数或参数的参数传递给事件侦听器。
         * @version DragonBones 4.5
         * @language zh_CN
         */
        export class EventObject extends BaseObject {
            /**
             * - Animation start play.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 动画开始播放。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            static readonly START: string;
            /**
             * - Animation loop play complete once.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 动画循环播放完成一次。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            static readonly LOOP_COMPLETE: string;
            /**
             * - Animation play complete.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 动画播放完成。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            static readonly COMPLETE: string;
            /**
             * - Animation fade in start.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 动画淡入开始。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            static readonly FADE_IN: string;
            /**
             * - Animation fade in complete.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 动画淡入完成。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            static readonly FADE_IN_COMPLETE: string;
            /**
             * - Animation fade out start.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 动画淡出开始。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            static readonly FADE_OUT: string;
            /**
             * - Animation fade out complete.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 动画淡出完成。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            static readonly FADE_OUT_COMPLETE: string;
            /**
             * - Animation frame event.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 动画帧事件。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            static readonly FRAME_EVENT: string;
            /**
             * - Animation frame sound event.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 动画帧声音事件。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            static readonly SOUND_EVENT: string;
            static toString(): string;
            /**
             * - If is a frame event, the value is used to describe the time that the event was in the animation timeline. (In seconds)
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 如果是帧事件，此值用来描述该事件在动画时间轴中所处的时间。（以秒为单位）
             * @version DragonBones 4.5
             * @language zh_CN
             */
            time: number;
            /**
             * - The event type。
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 事件类型。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            type: EventStringType;
            /**
             * - The event name. (The frame event name or the frame sound name)
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 事件名称。 (帧事件的名称或帧声音的名称)
             * @version DragonBones 4.5
             * @language zh_CN
             */
            name: string;
            /**
             * - The armature that dispatch the event.
             * @see dragonBones.Armature
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 发出该事件的骨架。
             * @see dragonBones.Armature
             * @version DragonBones 4.5
             * @language zh_CN
             */
            armature: Armature;
            /**
             * - The bone that dispatch the event.
             * @see dragonBones.Bone
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 发出该事件的骨骼。
             * @see dragonBones.Bone
             * @version DragonBones 4.5
             * @language zh_CN
             */
            bone: Bone | null;
            /**
             * - The slot that dispatch the event.
             * @see dragonBones.Slot
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 发出该事件的插槽。
             * @see dragonBones.Slot
             * @version DragonBones 4.5
             * @language zh_CN
             */
            slot: Slot | null;
            /**
             * - The animation state that dispatch the event.
             * @see dragonBones.AnimationState
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 发出该事件的动画状态。
             * @see dragonBones.AnimationState
             * @version DragonBones 4.5
             * @language zh_CN
             */
            animationState: AnimationState;
            /**
             * - The custom data.
             * @see dragonBones.CustomData
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 自定义数据。
             * @see dragonBones.CustomData
             * @version DragonBones 5.0
             * @language zh_CN
             */
            data: UserData | null;
            /**
             * @private
             */
            protected _onClear(): void;
        }
        /**
         * @private
         */
        export type EventStringType = string | "start" | "loopComplete" | "complete" | "fadeIn" | "fadeInComplete" | "fadeOut" | "fadeOutComplete" | "frameEvent" | "soundEvent";
        /**
         * - The event dispatcher interface.
         * Dragonbones event dispatch usually relies on docking engine to implement, which defines the event method to be implemented when docking the engine.
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 事件派发接口。
         * DragonBones 的事件派发通常依赖于对接的引擎来实现，该接口定义了对接引擎时需要实现的事件方法。
         * @version DragonBones 4.5
         * @language zh_CN
         */
        export interface IEventDispatcher {
            /**
             * - Checks whether the object has any listeners registered for a specific type of event。
             * @param type - Event type.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 检查是否为特定的事件类型注册了任何侦听器。
             * @param type - 事件类型。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            hasDBEventListener(type: EventStringType): boolean;
            /**
             * - Dispatches an event into the event flow.
             * @param type - Event type.
             * @param eventObject - Event object.
             * @see dragonBones.EventObject
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 分派特定的事件到事件流中。
             * @param type - 事件类型。
             * @param eventObject - 事件数据。
             * @see dragonBones.EventObject
             * @version DragonBones 4.5
             * @language zh_CN
             */
            dispatchDBEvent(type: EventStringType, eventObject: EventObject): void;
            /**
             * - Add an event listener object so that the listener receives notification of an event.
             * @param type - Event type.
             * @param listener - Event listener.
             * @param thisObject - The listener function's "this".
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 添加特定事件类型的事件侦听器，以使侦听器能够接收事件通知。
             * @param type - 事件类型。
             * @param listener - 事件侦听器。
             * @param thisObject - 侦听函数绑定的 this 对象。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            addDBEventListener(type: EventStringType, listener: Function, thisObject: any): void;
            /**
             * - Removes a listener from the object.
             * @param type - Event type.
             * @param listener - Event listener.
             * @param thisObject - The listener function's "this".
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 删除特定事件类型的侦听器。
             * @param type - 事件类型。
             * @param listener - 事件侦听器。
             * @param thisObject - 侦听函数绑定的 this 对象。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            removeDBEventListener(type: EventStringType, listener: Function, thisObject: any): void;
            /**
             * - Deprecated, please refer to {@link #hasDBEventListener()}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link #hasDBEventListener()}。
             * @deprecated
             * @language zh_CN
             */
            hasEvent(type: EventStringType): boolean;
            /**
             * - Deprecated, please refer to {@link #addDBEventListener()}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link #addDBEventListener()}。
             * @deprecated
             * @language zh_CN
             */
            addEvent(type: EventStringType, listener: Function, thisObject: any): void;
            /**
             * - Deprecated, please refer to {@link #removeDBEventListener()}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link #removeDBEventListener()}。
             * @deprecated
             * @language zh_CN
             */
            removeEvent(type: EventStringType, listener: Function, thisObject: any): void;
        }
        /**
         * @internal
         * @private
         */
        export abstract class DataParser {
            protected static readonly DATA_VERSION_2_3: string;
            protected static readonly DATA_VERSION_3_0: string;
            protected static readonly DATA_VERSION_4_0: string;
            protected static readonly DATA_VERSION_4_5: string;
            protected static readonly DATA_VERSION_5_0: string;
            protected static readonly DATA_VERSION_5_5: string;
            protected static readonly DATA_VERSION: string;
            protected static readonly DATA_VERSIONS: Array<string>;
            protected static readonly TEXTURE_ATLAS: string;
            protected static readonly SUB_TEXTURE: string;
            protected static readonly FORMAT: string;
            protected static readonly IMAGE_PATH: string;
            protected static readonly WIDTH: string;
            protected static readonly HEIGHT: string;
            protected static readonly ROTATED: string;
            protected static readonly FRAME_X: string;
            protected static readonly FRAME_Y: string;
            protected static readonly FRAME_WIDTH: string;
            protected static readonly FRAME_HEIGHT: string;
            protected static readonly DRADON_BONES: string;
            protected static readonly USER_DATA: string;
            protected static readonly ARMATURE: string;
            protected static readonly BONE: string;
            protected static readonly SURFACE: string;
            protected static readonly SLOT: string;
            protected static readonly CONSTRAINT: string;
            protected static readonly IK: string;
            protected static readonly SKIN: string;
            protected static readonly DISPLAY: string;
            protected static readonly ANIMATION: string;
            protected static readonly Z_ORDER: string;
            protected static readonly FFD: string;
            protected static readonly FRAME: string;
            protected static readonly TRANSLATE_FRAME: string;
            protected static readonly ROTATE_FRAME: string;
            protected static readonly SCALE_FRAME: string;
            protected static readonly DISPLAY_FRAME: string;
            protected static readonly COLOR_FRAME: string;
            protected static readonly DEFAULT_ACTIONS: string;
            protected static readonly ACTIONS: string;
            protected static readonly EVENTS: string;
            protected static readonly INTS: string;
            protected static readonly FLOATS: string;
            protected static readonly STRINGS: string;
            protected static readonly CANVAS: string;
            protected static readonly TRANSFORM: string;
            protected static readonly PIVOT: string;
            protected static readonly AABB: string;
            protected static readonly COLOR: string;
            protected static readonly VERSION: string;
            protected static readonly COMPATIBLE_VERSION: string;
            protected static readonly FRAME_RATE: string;
            protected static readonly TYPE: string;
            protected static readonly SUB_TYPE: string;
            protected static readonly NAME: string;
            protected static readonly PARENT: string;
            protected static readonly TARGET: string;
            protected static readonly STAGE: string;
            protected static readonly SHARE: string;
            protected static readonly PATH: string;
            protected static readonly LENGTH: string;
            protected static readonly DISPLAY_INDEX: string;
            protected static readonly BLEND_MODE: string;
            protected static readonly INHERIT_TRANSLATION: string;
            protected static readonly INHERIT_ROTATION: string;
            protected static readonly INHERIT_SCALE: string;
            protected static readonly INHERIT_REFLECTION: string;
            protected static readonly INHERIT_ANIMATION: string;
            protected static readonly INHERIT_DEFORM: string;
            protected static readonly SEGMENT_X: string;
            protected static readonly SEGMENT_Y: string;
            protected static readonly BEND_POSITIVE: string;
            protected static readonly CHAIN: string;
            protected static readonly WEIGHT: string;
            protected static readonly FADE_IN_TIME: string;
            protected static readonly PLAY_TIMES: string;
            protected static readonly SCALE: string;
            protected static readonly OFFSET: string;
            protected static readonly POSITION: string;
            protected static readonly DURATION: string;
            protected static readonly TWEEN_EASING: string;
            protected static readonly TWEEN_ROTATE: string;
            protected static readonly TWEEN_SCALE: string;
            protected static readonly CLOCK_WISE: string;
            protected static readonly CURVE: string;
            protected static readonly SOUND: string;
            protected static readonly EVENT: string;
            protected static readonly ACTION: string;
            protected static readonly X: string;
            protected static readonly Y: string;
            protected static readonly SKEW_X: string;
            protected static readonly SKEW_Y: string;
            protected static readonly SCALE_X: string;
            protected static readonly SCALE_Y: string;
            protected static readonly VALUE: string;
            protected static readonly ROTATE: string;
            protected static readonly SKEW: string;
            protected static readonly ALPHA_OFFSET: string;
            protected static readonly RED_OFFSET: string;
            protected static readonly GREEN_OFFSET: string;
            protected static readonly BLUE_OFFSET: string;
            protected static readonly ALPHA_MULTIPLIER: string;
            protected static readonly RED_MULTIPLIER: string;
            protected static readonly GREEN_MULTIPLIER: string;
            protected static readonly BLUE_MULTIPLIER: string;
            protected static readonly UVS: string;
            protected static readonly VERTICES: string;
            protected static readonly TRIANGLES: string;
            protected static readonly WEIGHTS: string;
            protected static readonly SLOT_POSE: string;
            protected static readonly BONE_POSE: string;
            protected static readonly GLUE_WEIGHTS: string;
            protected static readonly GLUE_MESHES: string;
            protected static readonly GOTO_AND_PLAY: string;
            protected static readonly DEFAULT_NAME: string;
            protected static _getArmatureType(value: string): ArmatureType;
            protected static _getBoneType(value: string): BoneType;
            protected static _getDisplayType(value: string): DisplayType;
            protected static _getBoundingBoxType(value: string): BoundingBoxType;
            protected static _getActionType(value: string): ActionType;
            protected static _getBlendMode(value: string): BlendMode;
            abstract parseDragonBonesData(rawData: any, scale: number): DragonBonesData | null;
            abstract parseTextureAtlasData(rawData: any, textureAtlasData: TextureAtlasData, scale: number): boolean;
            /**
             * - Deprecated, please refer to {@link dragonBones.BaseFactory#parsetTextureAtlasData()}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link dragonBones.BaseFactory#parsetTextureAtlasData()}。
             * @deprecated
             * @language zh_CN
             */
            static parseDragonBonesData(rawData: any): DragonBonesData | null;
            /**
             * - Deprecated, please refer to {@link dragonBones.BaseFactory#parsetTextureAtlasData()}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link dragonBones.BaseFactory#parsetTextureAtlasData()}。
             * @deprecated
             * @language zh_CN
             */
            static parseTextureAtlasData(rawData: any, scale?: number): any;
        }
        /**
         * @internal
         * @private
         */
        export class ObjectDataParser extends DataParser {
            protected static _getBoolean(rawData: any, key: string, defaultValue: boolean): boolean;
            protected static _getNumber(rawData: any, key: string, defaultValue: number): number;
            protected static _getString(rawData: any, key: string, defaultValue: string): string;
            protected _rawTextureAtlasIndex: number;
            protected readonly _rawBones: Array<BoneData>;
            protected _data: DragonBonesData;
            protected _armature: ArmatureData;
            protected _bone: BoneData;
            protected _surface: SurfaceData;
            protected _slot: SlotData;
            protected _skin: SkinData;
            protected _mesh: MeshDisplayData;
            protected _animation: AnimationData;
            protected _timeline: TimelineData;
            protected _rawTextureAtlases: Array<any> | null;
            protected _parseArmature(rawData: any, scale: number): ArmatureData;
            protected _parseBone(rawData: any): BoneData;
            protected _parseIKConstraint(rawData: any): ConstraintData | null;
            protected _parseSlot(rawData: any, zOrder: number): SlotData;
            protected _parseSkin(rawData: any): SkinData;
            protected _parseDisplay(rawData: any): DisplayData | null;
            protected _parsePivot(rawData: any, display: ImageDisplayData): void;
            protected _parseMesh(rawData: any, mesh: MeshDisplayData): void;
            protected _parseMeshGlue(rawData: any, mesh: MeshDisplayData): void;
            protected _parseBoundingBox(rawData: any): BoundingBoxData | null;
            protected _parsePolygonBoundingBox(rawData: any): PolygonBoundingBoxData;
            protected _parseAnimation(rawData: any): AnimationData;
            protected _parseTimeline(rawData: any, rawFrames: Array<any> | null, framesKey: string, type: TimelineType, addIntOffset: boolean, addFloatOffset: boolean, frameValueCount: number, frameParser: (rawData: any, frameStart: number, frameCount: number) => number): TimelineData | null;
            protected _parseBoneTimeline(rawData: any): void;
            protected _parseSlotTimeline(rawData: any): void;
            protected _parseFrame(rawData: any, frameStart: number, frameCount: number): number;
            protected _parseTweenFrame(rawData: any, frameStart: number, frameCount: number): number;
            protected _parseActionFrame(frame: ActionFrame, frameStart: number, frameCount: number): number;
            protected _parseZOrderFrame(rawData: any, frameStart: number, frameCount: number): number;
            protected _parseBoneAllFrame(rawData: any, frameStart: number, frameCount: number): number;
            protected _parseBoneTranslateFrame(rawData: any, frameStart: number, frameCount: number): number;
            protected _parseBoneRotateFrame(rawData: any, frameStart: number, frameCount: number): number;
            protected _parseBoneScaleFrame(rawData: any, frameStart: number, frameCount: number): number;
            protected _parseSurfaceFrame(rawData: any, frameStart: number, frameCount: number): number;
            protected _parseSlotDisplayFrame(rawData: any, frameStart: number, frameCount: number): number;
            protected _parseSlotColorFrame(rawData: any, frameStart: number, frameCount: number): number;
            protected _parseSlotFFDFrame(rawData: any, frameStart: number, frameCount: number): number;
            protected _parseIKConstraintFrame(rawData: any, frameStart: number, frameCount: number): number;
            protected _parseAnimationFrame(rawData: any, frameStart: number, frameCount: number): number;
            protected _parseActionData(rawData: any, type: ActionType, bone: BoneData | null, slot: SlotData | null): Array<ActionData>;
            protected _parseTransform(rawData: any, transform: Transform, scale: number): void;
            protected _parseColorTransform(rawData: any, color: ColorTransform): void;
            protected _parseArray(rawData: any): void;
            protected _modifyArray(): void;
            parseDragonBonesData(rawData: any, scale?: number): DragonBonesData | null;
            parseTextureAtlasData(rawData: any, textureAtlasData: TextureAtlasData, scale?: number): boolean;
            /**
             * - Deprecated, please refer to {@link dragonBones.BaseFactory#parseDragonBonesData()}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link dragonBones.BaseFactory#parseDragonBonesData()}。
             * @deprecated
             * @language zh_CN
             */
            static getInstance(): ObjectDataParser;
        }
        /**
         * @internal
         * @private
         */
        export class ActionFrame {
            frameStart: number;
            readonly actions: Array<number>;
        }
        /**
         * @internal
         * @private
         */
        export class BinaryDataParser extends ObjectDataParser {
            protected _parseMesh(rawData: any, mesh: MeshDisplayData): void;
            protected _parseAnimation(rawData: any): AnimationData;
            protected _parseArray(rawData: any): void;
            parseDragonBonesData(rawData: any, scale?: number): DragonBonesData | null;
            /**
             * - Deprecated, please refer to {@link dragonBones.BaseFactory#parseDragonBonesData()}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link dragonBones.BaseFactory#parseDragonBonesData()}。
             * @deprecated
             * @language zh_CN
             */
            static getInstance(): BinaryDataParser;
        }
        /**
         * - Base export class for the factory that create the armatures. (Typically only one global factory instance is required)
         * The factory instance create armatures by parsed and added DragonBonesData instances and TextureAtlasData instances.
         * Once the data has been parsed, it has been cached in the factory instance and does not need to be parsed again until it is cleared by the factory instance.
         * @see dragonBones.DragonBonesData
         * @see dragonBones.TextureAtlasData
         * @see dragonBones.ArmatureData
         * @see dragonBones.Armature
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 创建骨架的工厂基类。 （通常只需要一个全局工厂实例）
         * 工厂通过解析并添加的 DragonBonesData 实例和 TextureAtlasData 实例来创建骨架。
         * 当数据被解析过之后，已经添加到工厂中，在没有被工厂清理之前，不需要再次解析。
         * @see dragonBones.DragonBonesData
         * @see dragonBones.TextureAtlasData
         * @see dragonBones.ArmatureData
         * @see dragonBones.Armature
         * @version DragonBones 3.0
         * @language zh_CN
         */
        export abstract class BaseFactory {
            /**
             * @private
             */
            public static _objectParser: ObjectDataParser;
            /**
             * @private
             */
            public static _binaryParser: BinaryDataParser;
            /**
             * @private
             */
            autoSearch: boolean;
            /**
             * @private
             */
            protected readonly _dragonBonesDataMap: Map<DragonBonesData>;
            /**
             * @private
             */
            protected readonly _textureAtlasDataMap: Map<Array<TextureAtlasData>>;
            /**
             * @private
             */
            /* protected */
            _dragonBones: DragonBones;
            /**
             * @private
             */
            protected _dataParser: DataParser;
            /**
             * - Create a factory instance. (typically only one global factory instance is required)
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 创建一个工厂实例。 （通常只需要一个全局工厂实例）
             * @version DragonBones 3.0
             * @language zh_CN
             */
            constructor(dataParser?: DataParser | null);
            /**
             * @private
             */
            protected _isSupportMesh(): boolean;
            /**
             * @private
             */
            protected _getTextureData(textureAtlasName: string, textureName: string): TextureData | null;
            /**
             * @private
             */
            protected _fillBuildArmaturePackage(dataPackage: BuildArmaturePackage, dragonBonesName: string, armatureName: string, skinName: string, textureAtlasName: string): boolean;
            /**
             * @private
             */
            protected _buildBones(dataPackage: BuildArmaturePackage, armature: Armature): void;
            /**
             * @private
             */
            protected _buildSlots(dataPackage: BuildArmaturePackage, armature: Armature): void;
            /**
             * @private
             */
            protected _buildChildArmature(dataPackage: BuildArmaturePackage | null, slot: Slot, displayData: DisplayData): Armature | null;
            /**
             * @private
             */
            protected _getSlotDisplay(dataPackage: BuildArmaturePackage | null, displayData: DisplayData, rawDisplayData: DisplayData | null, slot: Slot): any;
            /**
             * @private
             */
            protected abstract _buildTextureAtlasData(textureAtlasData: TextureAtlasData | null, textureAtlas: any): TextureAtlasData;
            /**
             * @private
             */
            protected abstract _buildArmature(dataPackage: BuildArmaturePackage): Armature;
            /**
             * @private
             */
            protected abstract _buildSlot(dataPackage: BuildArmaturePackage, slotData: SlotData, displays: Array<DisplayData | null> | null, armature: Armature): Slot;
            /**
             * - Parse the raw data to a DragonBonesData instance and cache it to the factory.
             * @param rawData - The raw data.
             * @param name - Specify a cache name for the instance so that the instance can be obtained through this name. (If not set, use the instance name instead)
             * @param scale - Specify a scaling value for all armatures. (Default: 1.0)
             * @returns DragonBonesData instance
             * @see #getDragonBonesData()
             * @see #addDragonBonesData()
             * @see #removeDragonBonesData()
             * @see dragonBones.DragonBonesData
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 将原始数据解析为 DragonBonesData 实例，并缓存到工厂中。
             * @param rawData - 原始数据。
             * @param name - 为该实例指定一个缓存名称，以便可以通过此名称获取该实例。 （如果未设置，则使用该实例中的名称）
             * @param scale - 为所有的骨架指定一个缩放值。 （默认: 1.0）
             * @returns DragonBonesData 实例
             * @see #getDragonBonesData()
             * @see #addDragonBonesData()
             * @see #removeDragonBonesData()
             * @see dragonBones.DragonBonesData
             * @version DragonBones 4.5
             * @language zh_CN
             */
            parseDragonBonesData(rawData: any, name?: string | null, scale?: number): DragonBonesData | null;
            /**
             * - Parse the raw texture atlas data and the texture atlas object to a TextureAtlasData instance and cache it to the factory.
             * @param rawData - The raw texture atlas data.
             * @param textureAtlas - The texture atlas object.
             * @param name - Specify a cache name for the instance so that the instance can be obtained through this name. (If not set, use the instance name instead)
             * @param scale - Specify a scaling value for the map set. (Default: 1.0)
             * @returns TextureAtlasData instance
             * @see #getTextureAtlasData()
             * @see #addTextureAtlasData()
             * @see #removeTextureAtlasData()
             * @see dragonBones.TextureAtlasData
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 将原始贴图集数据和贴图集对象解析为 TextureAtlasData 实例，并缓存到工厂中。
             * @param rawData - 原始贴图集数据。
             * @param textureAtlas - 贴图集对象。
             * @param name - 为该实例指定一个缓存名称，以便可以通过此名称获取该实例。 （如果未设置，则使用该实例中的名称）
             * @param scale - 为贴图集指定一个缩放值。 （默认: 1.0）
             * @returns TextureAtlasData 实例
             * @see #getTextureAtlasData()
             * @see #addTextureAtlasData()
             * @see #removeTextureAtlasData()
             * @see dragonBones.TextureAtlasData
             * @version DragonBones 4.5
             * @language zh_CN
             */
            parseTextureAtlasData(rawData: any, textureAtlas: any, name?: string | null, scale?: number): TextureAtlasData;
            /**
             * @private
             */
            updateTextureAtlasData(name: string, textureAtlases: Array<any>): void;
            /**
             * - Get a specific DragonBonesData instance.
             * @param name - The DragonBonesData instance cache name.
             * @returns DragonBonesData instance
             * @see #parseDragonBonesData()
             * @see #addDragonBonesData()
             * @see #removeDragonBonesData()
             * @see dragonBones.DragonBonesData
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 获取特定的 DragonBonesData 实例。
             * @param name - DragonBonesData 实例的缓存名称。
             * @returns DragonBonesData 实例
             * @see #parseDragonBonesData()
             * @see #addDragonBonesData()
             * @see #removeDragonBonesData()
             * @see dragonBones.DragonBonesData
             * @version DragonBones 3.0
             * @language zh_CN
             */
            getDragonBonesData(name: string): DragonBonesData | null;
            /**
             * - Cache a DragonBonesData instance to the factory.
             * @param data - The DragonBonesData instance.
             * @param name - Specify a cache name for the instance so that the instance can be obtained through this name. (if not set, use the instance name instead)
             * @see #parseDragonBonesData()
             * @see #getDragonBonesData()
             * @see #removeDragonBonesData()
             * @see dragonBones.DragonBonesData
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 将 DragonBonesData 实例缓存到工厂中。
             * @param data - DragonBonesData 实例。
             * @param name - 为该实例指定一个缓存名称，以便可以通过此名称获取该实例。 （如果未设置，则使用该实例中的名称）
             * @see #parseDragonBonesData()
             * @see #getDragonBonesData()
             * @see #removeDragonBonesData()
             * @see dragonBones.DragonBonesData
             * @version DragonBones 3.0
             * @language zh_CN
             */
            addDragonBonesData(data: DragonBonesData, name?: string | null): void;
            /**
             * - Remove a DragonBonesData instance.
             * @param name - The DragonBonesData instance cache name.
             * @param disposeData - Whether to dispose data. (Default: true)
             * @see #parseDragonBonesData()
             * @see #getDragonBonesData()
             * @see #addDragonBonesData()
             * @see dragonBones.DragonBonesData
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 移除 DragonBonesData 实例。
             * @param name - DragonBonesData 实例缓存名称。
             * @param disposeData - 是否释放数据。 （默认: true）
             * @see #parseDragonBonesData()
             * @see #getDragonBonesData()
             * @see #addDragonBonesData()
             * @see dragonBones.DragonBonesData
             * @version DragonBones 3.0
             * @language zh_CN
             */
            removeDragonBonesData(name: string, disposeData?: boolean): void;
            /**
             * - Get a list of specific TextureAtlasData instances.
             * @param name - The TextureAtlasData cahce name.
             * @see #parseTextureAtlasData()
             * @see #addTextureAtlasData()
             * @see #removeTextureAtlasData()
             * @see dragonBones.TextureAtlasData
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 获取特定的 TextureAtlasData 实例列表。
             * @param name - TextureAtlasData 实例缓存名称。
             * @see #parseTextureAtlasData()
             * @see #addTextureAtlasData()
             * @see #removeTextureAtlasData()
             * @see dragonBones.TextureAtlasData
             * @version DragonBones 3.0
             * @language zh_CN
             */
            getTextureAtlasData(name: string): Array<TextureAtlasData> | null;
            /**
             * - Cache a TextureAtlasData instance to the factory.
             * @param data - The TextureAtlasData instance.
             * @param name - Specify a cache name for the instance so that the instance can be obtained through this name. (if not set, use the instance name instead)
             * @see #parseTextureAtlasData()
             * @see #getTextureAtlasData()
             * @see #removeTextureAtlasData()
             * @see dragonBones.TextureAtlasData
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 将 TextureAtlasData 实例缓存到工厂中。
             * @param data - TextureAtlasData 实例。
             * @param name - 为该实例指定一个缓存名称，以便可以通过此名称获取该实例。 （如果未设置，则使用该实例中的名称）
             * @see #parseTextureAtlasData()
             * @see #getTextureAtlasData()
             * @see #removeTextureAtlasData()
             * @see dragonBones.TextureAtlasData
             * @version DragonBones 3.0
             * @language zh_CN
             */
            addTextureAtlasData(data: TextureAtlasData, name?: string | null): void;
            /**
             * - Remove a TextureAtlasData instance.
             * @param name - The TextureAtlasData instance cache name.
             * @param disposeData - Whether to dispose data.
             * @see #parseTextureAtlasData()
             * @see #getTextureAtlasData()
             * @see #addTextureAtlasData()
             * @see dragonBones.TextureAtlasData
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 移除 TextureAtlasData 实例。
             * @param name - TextureAtlasData 实例的缓存名称。
             * @param disposeData - 是否释放数据。
             * @see #parseTextureAtlasData()
             * @see #getTextureAtlasData()
             * @see #addTextureAtlasData()
             * @see dragonBones.TextureAtlasData
             * @version DragonBones 3.0
             * @language zh_CN
             */
            removeTextureAtlasData(name: string, disposeData?: boolean): void;
            /**
             * - Get a specific armature data.
             * @param name - The armature data name.
             * @param dragonBonesName - The cached name for DragonbonesData instance.
             * @see dragonBones.ArmatureData
             * @version DragonBones 5.1
             * @language en_US
             */
            /**
             * - 获取特定的骨架数据。
             * @param name - 骨架数据名称。
             * @param dragonBonesName - DragonBonesData 实例的缓存名称。
             * @see dragonBones.ArmatureData
             * @version DragonBones 5.1
             * @language zh_CN
             */
            getArmatureData(name: string, dragonBonesName?: string): ArmatureData | null;
            /**
             * - Clear all cached DragonBonesData instances and TextureAtlasData instances.
             * @param disposeData - Whether to dispose data.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 清除缓存的所有 DragonBonesData 实例和 TextureAtlasData 实例。
             * @param disposeData - 是否释放数据。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            clear(disposeData?: boolean): void;
            /**
             * - Create a armature from cached DragonBonesData instances and TextureAtlasData instances.
             * @param armatureName - The armature data name.
             * @param dragonBonesName - The cached name of the DragonBonesData instance. (If not set, all DragonBonesData instances are retrieved, and when multiple DragonBonesData instances contain a the same name armature data, it may not be possible to accurately create a specific armature)
             * @param skinName - The skin name, you can set a different ArmatureData name to share it's skin data. (If not set, use the default skin data)
             * @returns The armature.
             * @example
             * <pre>
             *     let armature = factory.buildArmature("armatureName", "dragonBonesName");
             *     armature.clock = factory.clock;
             * </pre>
             * @see dragonBones.DragonBonesData
             * @see dragonBones.ArmatureData
             * @see dragonBones.Armature
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 通过缓存的 DragonBonesData 实例和 TextureAtlasData 实例创建一个骨架。
             * @param armatureName - 骨架数据名称。
             * @param dragonBonesName - DragonBonesData 实例的缓存名称。 （如果未设置，将检索所有的 DragonBonesData 实例，当多个 DragonBonesData 实例中包含同名的骨架数据时，可能无法准确的创建出特定的骨架）
             * @param skinName - 皮肤名称，可以设置一个其他骨架数据名称来共享其皮肤数据（如果未设置，则使用默认的皮肤数据）。
             * @returns 骨架。
             * @example
             * <pre>
             *     let armature = factory.buildArmature("armatureName", "dragonBonesName");
             *     armature.clock = factory.clock;
             * </pre>
             * @see dragonBones.DragonBonesData
             * @see dragonBones.ArmatureData
             * @see dragonBones.Armature
             * @version DragonBones 3.0
             * @language zh_CN
             */
            buildArmature(armatureName: string, dragonBonesName?: string, skinName?: string, textureAtlasName?: string): Armature | null;
            /**
             * @private
             */
            replaceDisplay(slot: Slot, displayData: DisplayData, displayIndex?: number): void;
            /**
             * - Replaces the current display data for a particular slot with a specific display data.
             * Specify display data with "dragonBonesName/armatureName/slotName/displayName".
             * @param dragonBonesName - The DragonBonesData instance cache name.
             * @param armatureName - The armature data name.
             * @param slotName - The slot data name.
             * @param displayName - The display data name.
             * @param slot - The slot.
             * @param displayIndex - The index of the display data that is replaced. (If it is not set, replaces the current display data)
             * @example
             * <pre>
             *     let slot = armature.getSlot("weapon");
             *     factory.replaceSlotDisplay("dragonBonesName", "armatureName", "slotName", "displayName", slot);
             * </pre>
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 用特定的显示对象数据替换特定插槽当前的显示对象数据。
             * 用 "dragonBonesName/armatureName/slotName/displayName" 指定显示对象数据。
             * @param dragonBonesName - DragonBonesData 实例的缓存名称。
             * @param armatureName - 骨架数据名称。
             * @param slotName - 插槽数据名称。
             * @param displayName - 显示对象数据名称。
             * @param slot - 插槽。
             * @param displayIndex - 被替换的显示对象数据的索引。 （如果未设置，则替换当前的显示对象数据）
             * @example
             * <pre>
             *     let slot = armature.getSlot("weapon");
             *     factory.replaceSlotDisplay("dragonBonesName", "armatureName", "slotName", "displayName", slot);
             * </pre>
             * @version DragonBones 4.5
             * @language zh_CN
             */
            replaceSlotDisplay(dragonBonesName: string, armatureName: string, slotName: string, displayName: string, slot: Slot, displayIndex?: number): boolean;
            /**
             * @private
             */
            replaceSlotDisplayList(dragonBonesName: string | null, armatureName: string, slotName: string, slot: Slot): boolean;
            /**
             * - Share specific skin data with specific armature.
             * @param armature - The armature.
             * @param skin - The skin data.
             * @param isOverride - Whether it completely override the original skin. (Default: false)
             * @param exclude - A list of slot names that do not need to be replace.
             * @example
             * <pre>
             *     let armatureA = factory.buildArmature("armatureA", "dragonBonesA");
             *     let armatureDataB = factory.getArmatureData("armatureB", "dragonBonesB");
             *     if (armatureDataB && armatureDataB.defaultSkin) {
             *     factory.replaceSkin(armatureA, armatureDataB.defaultSkin, false, ["arm_l", "weapon_l"]);
             *     }
             * </pre>
             * @see dragonBones.Armature
             * @see dragonBones.SkinData
             * @version DragonBones 5.6
             * @language en_US
             */
            /**
             * - 将特定的皮肤数据共享给特定的骨架使用。
             * @param armature - 骨架。
             * @param skin - 皮肤数据。
             * @param isOverride - 是否完全覆盖原来的皮肤。 （默认: false）
             * @param exclude - 不需要被替换的插槽名称列表。
             * @example
             * <pre>
             *     let armatureA = factory.buildArmature("armatureA", "dragonBonesA");
             *     let armatureDataB = factory.getArmatureData("armatureB", "dragonBonesB");
             *     if (armatureDataB && armatureDataB.defaultSkin) {
             *     factory.replaceSkin(armatureA, armatureDataB.defaultSkin, false, ["arm_l", "weapon_l"]);
             *     }
             * </pre>
             * @see dragonBones.Armature
             * @see dragonBones.SkinData
             * @version DragonBones 5.6
             * @language zh_CN
             */
            replaceSkin(armature: Armature, skin: SkinData, isOverride?: boolean, exclude?: Array<string> | null): boolean;
            /**
             * - Replaces the existing animation data for a specific armature with the animation data for the specific armature data.
             * This enables you to make a armature template so that other armature without animations can share it's animations.
             * @param armature - The armtaure.
             * @param armatureData - The armature data.
             * @param isOverride - Whether to completely overwrite the original animation. (Default: false)
             * @example
             * <pre>
             *     let armatureA = factory.buildArmature("armatureA", "dragonBonesA");
             *     let armatureDataB = factory.getArmatureData("armatureB", "dragonBonesB");
             *     if (armatureDataB) {
             *     factory.replaceAnimation(armatureA, armatureDataB);
             *     }
             * </pre>
             * @see dragonBones.Armature
             * @see dragonBones.ArmatureData
             * @version DragonBones 5.6
             * @language en_US
             */
            /**
             * - 用特定骨架数据的动画数据替换特定骨架现有的动画数据。
             * 这样就能实现制作一个骨架动画模板，让其他没有制作动画的骨架共享该动画。
             * @param armature - 骨架。
             * @param armatureData - 骨架数据。
             * @param isOverride - 是否完全覆盖原来的动画。（默认: false）。
             * @example
             * <pre>
             *     let armatureA = factory.buildArmature("armatureA", "dragonBonesA");
             *     let armatureDataB = factory.getArmatureData("armatureB", "dragonBonesB");
             *     if (armatureDataB) {
             *     factory.replaceAnimation(armatureA, armatureDataB);
             *     }
             * </pre>
             * @see dragonBones.Armature
             * @see dragonBones.ArmatureData
             * @version DragonBones 5.6
             * @language zh_CN
             */
            replaceAnimation(armature: Armature, armatureData: ArmatureData, isOverride?: boolean): boolean;
            /**
             * @private
             */
            getAllDragonBonesData(): Map<DragonBonesData>;
            /**
             * @private
             */
            getAllTextureAtlasData(): Map<Array<TextureAtlasData>>;
            /**
             * - An Worldclock instance updated by engine.
             * @version DragonBones 5.7
             * @language en_US
             */
            /**
             * - 由引擎驱动的 WorldClock 实例。
             * @version DragonBones 5.7
             * @language zh_CN
             */
            readonly clock: WorldClock;
            /**
             * @private
             */
            readonly dragonBones: DragonBones;
            /**
             * - Deprecated, please refer to {@link #replaceSkin}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link #replaceSkin}。
             * @deprecated
             * @language zh_CN
             */
            changeSkin(armature: Armature, skin: SkinData, exclude?: Array<string> | null): boolean;
            /**
             * - Deprecated, please refer to {@link #replaceAnimation}.
             * @deprecated
             * @language en_US
             */
            /**
             * - 已废弃，请参考 {@link #replaceAnimation}。
             * @deprecated
             * @language zh_CN
             */
            copyAnimationsToArmature(toArmature: Armature, fromArmatreName: string, fromSkinName?: string, fromDragonBonesDataName?: string, replaceOriginalAnimation?: boolean): boolean;
        }
        /**
         * @internal
         * @private
         */
        export class BuildArmaturePackage {
            dataName: string;
            textureAtlasName: string;
            data: DragonBonesData;
            armature: ArmatureData;
            skin: SkinData | null;
        }
        export class DeformVertices extends BaseObject {
            static toString(): string;
            vertices: number[];
            bones: Bone[];
            verticesData: {
                offset: number;
                data: {
                    intArray: Int32Array;
                    floatArray: Float32Array;
                };
                weight: {
                    offset: number;
                };
                inheritDeform: boolean;
                rotated: boolean;
            };
            verticesDirty: boolean;
            isBonesUpdate(): boolean;
            _onClear(): void;
        }
    }
    export interface IGeometryInfo {
        maxLines: number;
        maxDashedLines: number;
        maxTriangles: number;
    }
    export class GeometryRenderer {
        constructor();
        activate(device: gfx.Device, info?: IGeometryInfo): void;
        render(renderPass: gfx.RenderPass, cmdBuff: gfx.CommandBuffer, sceneData: PipelineSceneData): void;
        destroy(): void;
        empty(): boolean;
        update(): void;
        reset(): void;
        addDashedLine(v0: math.Vec3, v1: math.Vec3, color: math.Color, depthTest?: boolean): void;
        addLine(v0: math.Vec3, v1: math.Vec3, color: math.Color, depthTest?: boolean): void;
        addTriangle(v0: math.Vec3, v1: math.Vec3, v2: math.Vec3, color: math.Color, wireframe?: boolean, depthTest?: boolean, unlit?: boolean): void;
        addQuad(v0: math.Vec3, v1: math.Vec3, v2: math.Vec3, v3: math.Vec3, color: math.Color, wireframe?: boolean, depthTest?: boolean, unlit?: boolean): void;
        addBoundingBox(aabb: geometry.AABB, color: math.Color, wireframe?: boolean, depthTest?: boolean, unlit?: boolean, useTransform?: boolean, transform?: math.Mat4): void;
        addCross(position: math.Vec3, size: number, color: math.Color, depthTest?: boolean): void;
        addFrustum(frustum: geometry.Frustum, color: math.Color, depthTest?: boolean): void;
        addCapsule(center: math.Vec3, radius: number, height: number, color: math.Color, segmentsU?: number, hemiSegmentsV?: number, wireframe?: boolean, depthTest?: boolean, unlit?: boolean, useTransform?: boolean, transform?: math.Mat4): void;
        addCylinder(center: math.Vec3, radius: number, height: number, color: math.Color, segments?: number, wireframe?: boolean, depthTest?: boolean, unlit?: boolean, useTransform?: boolean, transform?: math.Mat4): void;
        addCone(center: math.Vec3, radius: number, height: number, color: math.Color, segments?: number, wireframe?: boolean, depthTest?: boolean, unlit?: boolean, useTransform?: boolean, transform?: math.Mat4): void;
        addCircle(center: math.Vec3, radius: number, color: math.Color, segments?: number, depthTest?: boolean, useTransform?: boolean, transform?: math.Mat4): void;
        addArc(center: math.Vec3, radius: number, color: math.Color, startAngle: number, endAngle: number, segments?: number, depthTest?: boolean, useTransform?: boolean, transform?: math.Mat4): void;
        addPolygon(center: math.Vec3, radius: number, color: math.Color, segments?: number, wireframe?: boolean, depthTest?: boolean, unlit?: boolean, useTransform?: boolean, transform?: math.Mat4): void;
        addDisc(center: math.Vec3, radius: number, color: math.Color, segments?: number, wireframe?: boolean, depthTest?: boolean, unlit?: boolean, useTransform?: boolean, transform?: math.Mat4): void;
        addSector(center: math.Vec3, radius: number, color: math.Color, startAngle: number, endAngle: number, segments?: number, wireframe?: boolean, depthTest?: boolean, unlit?: boolean, useTransform?: boolean, transform?: math.Mat4): void;
        addSphere(center: math.Vec3, radius: number, color: math.Color, segmentsU?: number, segmentsV?: number, wireframe?: boolean, depthTest?: boolean, unlit?: boolean, useTransform?: boolean, transform?: math.Mat4): void;
        addTorus(center: math.Vec3, bigRadius: number, radius: number, color: math.Color, segmentsU?: number, segmentsV?: number, wireframe?: boolean, depthTest?: boolean, unlit?: boolean, useTransform?: boolean, transform?: math.Mat4): void;
        addOctahedron(center: math.Vec3, radius: number, color: math.Color, wireframe?: boolean, depthTest?: boolean, unlit?: boolean, useTransform?: boolean, transform?: math.Mat4): void;
        addBezier(v0: math.Vec3, v1: math.Vec3, v2: math.Vec3, v3: math.Vec3, color: math.Color, segments?: number, depthTest?: boolean, useTransform?: boolean, transform?: math.Mat4): void;
        addSpline(spline: geometry.Spline, color: math.Color, index?: number, knotSize?: number, segments?: number, depthTest?: boolean): void;
        addMesh(center: math.Vec3, vertices: Array<math.Vec3>, color: math.Color, depthTest?: boolean, useTransform?: boolean, transform?: math.Mat4): void;
        addIndexedMesh(center: math.Vec3, vertices: Array<math.Vec3>, indices: Array<number>, color: math.Color, depthTest?: boolean, useTransform?: boolean, transform?: math.Mat4): void;
    }
    export class EmptyDevice extends gfx.Device {
        initialize(info: gfx.DeviceInfo): boolean;
        destroy(): void;
        flushCommands(cmdBuffs: Readonly<gfx.CommandBuffer[]>): void;
        acquire(swapchains: Readonly<gfx.Swapchain[]>): void;
        present(): void;
        createCommandBuffer(info: Readonly<gfx.CommandBufferInfo>): gfx.CommandBuffer;
        createSwapchain(info: Readonly<gfx.SwapchainInfo>): gfx.Swapchain;
        createBuffer(info: Readonly<gfx.BufferInfo> | Readonly<gfx.BufferViewInfo>): gfx.Buffer;
        createTexture(info: Readonly<gfx.TextureInfo> | Readonly<gfx.TextureViewInfo>): gfx.Texture;
        createDescriptorSet(info: Readonly<gfx.DescriptorSetInfo>): gfx.DescriptorSet;
        createShader(info: Readonly<gfx.ShaderInfo>): gfx.Shader;
        createInputAssembler(info: Readonly<gfx.InputAssemblerInfo>): gfx.InputAssembler;
        createRenderPass(info: Readonly<gfx.RenderPassInfo>): gfx.RenderPass;
        createFramebuffer(info: Readonly<gfx.FramebufferInfo>): gfx.Framebuffer;
        createDescriptorSetLayout(info: Readonly<gfx.DescriptorSetLayoutInfo>): gfx.DescriptorSetLayout;
        createPipelineLayout(info: Readonly<gfx.PipelineLayoutInfo>): gfx.PipelineLayout;
        createPipelineState(info: Readonly<gfx.PipelineStateInfo>): gfx.PipelineState;
        createQueue(info: Readonly<gfx.QueueInfo>): gfx.Queue;
        getSampler(info: Readonly<gfx.SamplerInfo>): gfx.Sampler;
        getSwapchains(): Readonly<gfx.Swapchain[]>;
        getGeneralBarrier(info: Readonly<gfx.GeneralBarrierInfo>): gfx.GeneralBarrier;
        getTextureBarrier(info: Readonly<gfx.TextureBarrierInfo>): gfx.TextureBarrier;
        getBufferBarrier(info: Readonly<gfx.BufferBarrierInfo>): __private._cocos_core_gfx_base_states_buffer_barrier__BufferBarrier;
        copyBuffersToTexture(buffers: Readonly<ArrayBufferView[]>, texture: gfx.Texture, regions: Readonly<gfx.BufferTextureCopy[]>): void;
        copyTextureToBuffers(texture: Readonly<gfx.Texture>, buffers: ArrayBufferView[], regions: Readonly<gfx.BufferTextureCopy[]>): void;
        copyTexImagesToTexture(texImages: Readonly<TexImageSource[]>, texture: gfx.Texture, regions: Readonly<gfx.BufferTextureCopy[]>): void;
    }
    export class WebGLDevice extends gfx.Device {
        get gl(): WebGLRenderingContext;
        get extensions(): __private._cocos_core_gfx_webgl_webgl_define__IWebGLExtensions;
        get stateCache(): __private._cocos_core_gfx_webgl_webgl_state_cache__WebGLStateCache;
        get nullTex2D(): __private._cocos_core_gfx_webgl_webgl_texture__WebGLTexture;
        get nullTexCube(): __private._cocos_core_gfx_webgl_webgl_texture__WebGLTexture;
        get textureExclusive(): boolean[];
        get bindingMappings(): __private._cocos_core_gfx_webgl_webgl_gpu_objects__IWebGLBindingMapping;
        protected _textureExclusive: boolean[];
        initialize(info: Readonly<gfx.DeviceInfo>): boolean;
        destroy(): void;
        flushCommands(cmdBuffs: gfx.CommandBuffer[]): void;
        acquire(swapchains: gfx.Swapchain[]): void;
        present(): void;
        protected initFormatFeatures(exts: __private._cocos_core_gfx_webgl_webgl_define__IWebGLExtensions): void;
        createCommandBuffer(info: Readonly<gfx.CommandBufferInfo>): gfx.CommandBuffer;
        createSwapchain(info: Readonly<gfx.SwapchainInfo>): gfx.Swapchain;
        createBuffer(info: Readonly<gfx.BufferInfo> | Readonly<gfx.BufferViewInfo>): gfx.Buffer;
        createTexture(info: Readonly<gfx.TextureInfo> | Readonly<gfx.TextureViewInfo>): gfx.Texture;
        createDescriptorSet(info: Readonly<gfx.DescriptorSetInfo>): gfx.DescriptorSet;
        createShader(info: Readonly<gfx.ShaderInfo>): gfx.Shader;
        createInputAssembler(info: Readonly<gfx.InputAssemblerInfo>): gfx.InputAssembler;
        createRenderPass(info: Readonly<gfx.RenderPassInfo>): gfx.RenderPass;
        createFramebuffer(info: Readonly<gfx.FramebufferInfo>): gfx.Framebuffer;
        createDescriptorSetLayout(info: Readonly<gfx.DescriptorSetLayoutInfo>): gfx.DescriptorSetLayout;
        createPipelineLayout(info: Readonly<gfx.PipelineLayoutInfo>): gfx.PipelineLayout;
        createPipelineState(info: Readonly<gfx.PipelineStateInfo>): gfx.PipelineState;
        createQueue(info: Readonly<gfx.QueueInfo>): gfx.Queue;
        getSampler(info: Readonly<gfx.SamplerInfo>): gfx.Sampler;
        getSwapchains(): Readonly<gfx.Swapchain[]>;
        getGeneralBarrier(info: Readonly<gfx.GeneralBarrierInfo>): gfx.GeneralBarrier;
        getTextureBarrier(info: Readonly<gfx.TextureBarrierInfo>): gfx.TextureBarrier;
        getBufferBarrier(info: Readonly<gfx.BufferBarrierInfo>): __private._cocos_core_gfx_base_states_buffer_barrier__BufferBarrier;
        copyBuffersToTexture(buffers: Readonly<ArrayBufferView[]>, texture: gfx.Texture, regions: Readonly<gfx.BufferTextureCopy[]>): void;
        copyTextureToBuffers(texture: Readonly<gfx.Texture>, buffers: ArrayBufferView[], regions: Readonly<gfx.BufferTextureCopy[]>): void;
        copyTexImagesToTexture(texImages: Readonly<TexImageSource[]>, texture: gfx.Texture, regions: Readonly<gfx.BufferTextureCopy[]>): void;
    }
    export class WebGL2Device extends gfx.Device {
        get gl(): WebGL2RenderingContext;
        get extensions(): __private._cocos_core_gfx_webgl2_webgl2_define__IWebGL2Extensions;
        get stateCache(): __private._cocos_core_gfx_webgl2_webgl2_state_cache__WebGL2StateCache;
        get nullTex2D(): __private._cocos_core_gfx_webgl2_webgl2_texture__WebGL2Texture;
        get nullTexCube(): __private._cocos_core_gfx_webgl2_webgl2_texture__WebGL2Texture;
        get textureExclusive(): boolean[];
        get bindingMappings(): __private._cocos_core_gfx_webgl2_webgl2_gpu_objects__IWebGL2BindingMapping;
        protected _textureExclusive: boolean[];
        initialize(info: Readonly<gfx.DeviceInfo>): boolean;
        destroy(): void;
        flushCommands(cmdBuffs: Readonly<gfx.CommandBuffer[]>): void;
        acquire(swapchains: Readonly<gfx.Swapchain[]>): void;
        present(): void;
        protected initFormatFeatures(exts: __private._cocos_core_gfx_webgl2_webgl2_define__IWebGL2Extensions): void;
        createCommandBuffer(info: Readonly<gfx.CommandBufferInfo>): gfx.CommandBuffer;
        createSwapchain(info: Readonly<gfx.SwapchainInfo>): gfx.Swapchain;
        createBuffer(info: Readonly<gfx.BufferInfo> | Readonly<gfx.BufferViewInfo>): gfx.Buffer;
        createTexture(info: Readonly<gfx.TextureInfo> | Readonly<gfx.TextureViewInfo>): gfx.Texture;
        createDescriptorSet(info: Readonly<gfx.DescriptorSetInfo>): gfx.DescriptorSet;
        createShader(info: Readonly<gfx.ShaderInfo>): gfx.Shader;
        createInputAssembler(info: Readonly<gfx.InputAssemblerInfo>): gfx.InputAssembler;
        createRenderPass(info: Readonly<gfx.RenderPassInfo>): gfx.RenderPass;
        createFramebuffer(info: Readonly<gfx.FramebufferInfo>): gfx.Framebuffer;
        createDescriptorSetLayout(info: Readonly<gfx.DescriptorSetLayoutInfo>): gfx.DescriptorSetLayout;
        createPipelineLayout(info: Readonly<gfx.PipelineLayoutInfo>): gfx.PipelineLayout;
        createPipelineState(info: Readonly<gfx.PipelineStateInfo>): gfx.PipelineState;
        createQueue(info: Readonly<gfx.QueueInfo>): gfx.Queue;
        getSampler(info: Readonly<gfx.SamplerInfo>): gfx.Sampler;
        getSwapchains(): Readonly<gfx.Swapchain[]>;
        getGeneralBarrier(info: Readonly<gfx.GeneralBarrierInfo>): gfx.GeneralBarrier;
        getTextureBarrier(info: Readonly<gfx.TextureBarrierInfo>): gfx.TextureBarrier;
        getBufferBarrier(info: Readonly<gfx.BufferBarrierInfo>): __private._cocos_core_gfx_base_states_buffer_barrier__BufferBarrier;
        copyBuffersToTexture(buffers: Readonly<ArrayBufferView[]>, texture: gfx.Texture, regions: Readonly<gfx.BufferTextureCopy[]>): void;
        copyTextureToBuffers(texture: Readonly<gfx.Texture>, buffers: ArrayBufferView[], regions: Readonly<gfx.BufferTextureCopy[]>): void;
        copyTexImagesToTexture(texImages: Readonly<TexImageSource[]>, texture: gfx.Texture, regions: Readonly<gfx.BufferTextureCopy[]>): void;
    }
    /**
     * @en Intersection2D helper class
     * @zh 辅助类，用于测试形状与形状是否相交
     * @class Intersection2D
     */
    export class Intersection2D {
        static lineLine: typeof __private._cocos_physics_2d_builtin_intersection_2d__lineLine;
        static lineRect: typeof __private._cocos_physics_2d_builtin_intersection_2d__lineRect;
        static linePolygon: typeof __private._cocos_physics_2d_builtin_intersection_2d__linePolygon;
        static rectRect: typeof __private._cocos_physics_2d_builtin_intersection_2d__rectRect;
        static rectPolygon: typeof __private._cocos_physics_2d_builtin_intersection_2d__rectPolygon;
        static rectCircle: typeof __private._cocos_physics_2d_builtin_intersection_2d__rectCircle;
        static polygonPolygon: typeof __private._cocos_physics_2d_builtin_intersection_2d__polygonPolygon;
        static circleCircle: typeof __private._cocos_physics_2d_builtin_intersection_2d__circleCircle;
        static polygonCircle: typeof __private._cocos_physics_2d_builtin_intersection_2d__polygonCircle;
        static pointInPolygon: typeof __private._cocos_physics_2d_builtin_intersection_2d__pointInPolygon;
        static pointLineDistance: typeof __private._cocos_physics_2d_builtin_intersection_2d__pointLineDistance;
    }
    /**
     * @en Particle System base class.
     * cocos2d also supports particles generated by Particle Designer (http://particledesigner.71squared.com/).
     * 'Radius Mode' in Particle Designer uses a fixed emit rate of 30 hz. Since that can't be guarateed in cocos2d,
     * cocos2d uses a another approach, but the results are almost identical.
     * cocos2d supports all the variables used by Particle Designer plus a bit more:
     *  - spinning particles (supported when using ParticleSystem)
     *  - tangential acceleration (Gravity mode)
     *  - radial acceleration (Gravity mode)
     *  - radius direction (Radius mode) (Particle Designer supports outwards to inwards direction only)
     * It is possible to customize any of the above mentioned properties in runtime. Example:
     * emitter.radialAccel = 15;
     * emitter.startSpin = 0;
     *
     * @zh 2D 粒子基础类型
     * cocos2d 同样支 Particle Designer (http://particledesigner.71squared.com/) 生成的粒子
     * 粒子设计器中的 半径模式 使用 30 hz 的固定发射率。由于 cocos2d 无法保证，
     * cocos2d 使用了另一种方法，但结果几乎相同。
     * cocos2d 支持 Particle Designer 使用的所有变量，还有：
     * -旋转粒子（使用粒子系统时支持）
     * -切向加速度（重力模式）
     * -径向加速度（重力模式）
     * -半径方向（半径模式）（Particle Designer 仅支持向外到向内的方向）
     * 可以在运行时自定义上述任何属性。例如：
     * emitter.radialAccel = 15;
     * emitter.startSpin = 0;
     *
     */
    export class ParticleSystem2D extends UIRenderer {
        static EmitterMode: {
            GRAVITY: number;
            RADIUS: number;
        };
        static PositionType: {
            FREE: number;
            RELATIVE: number;
            GROUPED: number;
        };
        static readonly DURATION_INFINITY = "Bad expression <-1>";
        static readonly START_SIZE_EQUAL_TO_END_SIZE = "Bad expression <-1>";
        static readonly START_RADIUS_EQUAL_TO_END_RADIUS = "Bad expression <-1>";
        /**
         * @en If set custom to true, then use custom properties instead of read particle file.
         * @zh 是否自定义粒子属性。
         */
        get custom(): boolean;
        set custom(value: boolean);
        /**
         * @en The plist file.
         * @zh plist 格式的粒子配置文件。
         */
        get file(): ParticleAsset | null;
        set file(value: ParticleAsset | null);
        /**
         * @en SpriteFrame used for particles display
         * @zh 用于粒子呈现的 SpriteFrame
         */
        get spriteFrame(): SpriteFrame | null;
        set spriteFrame(value: SpriteFrame | null);
        /**
         * @en Current quantity of particles that are being simulated.
         * @zh 当前播放的粒子数量。
         * @readonly
         */
        get particleCount(): number;
        /**
         * @en Maximum particles of the system.
         * @zh 粒子最大数量。
         */
        get totalParticles(): number;
        set totalParticles(value: number);
        /**
         * @en How many seconds the emitter wil run. -1 means 'forever'.
         * @zh 发射器生存时间，单位秒，-1表示持续发射。
         */
        duration: number;
        /**
         * @en Emission rate of the particles.
         * @zh 每秒发射的粒子数目。
         */
        emissionRate: number;
        /**
         * @en Life of each particle setter.
         * @zh 粒子的运行时间。
         */
        life: number;
        /**
         * @en Variation of life.
         * @zh 粒子的运行时间变化范围。
         */
        lifeVar: number;
        /**
         * @en Start color of each particle.
         * @zh 粒子初始颜色。
         */
        get startColor(): math.Color;
        set startColor(val: math.Color);
        /**
         * @en Variation of the start color.
         * @zh 粒子初始颜色变化范围。
         */
        get startColorVar(): math.Color;
        set startColorVar(val: math.Color);
        set color(value: Readonly<math.Color>);
        get color(): Readonly<math.Color>;
        /**
         * @en Ending color of each particle.
         * @zh 粒子结束颜色。
         */
        get endColor(): math.Color;
        set endColor(val: math.Color);
        /**
         * @en Variation of the end color.
         * @zh 粒子结束颜色变化范围。
         */
        get endColorVar(): math.Color;
        set endColorVar(val: math.Color);
        /**
         * @en Angle of each particle setter.
         * @zh 粒子角度。
         */
        angle: number;
        /**
         * @en Variation of angle of each particle setter.
         * @zh 粒子角度变化范围。
         */
        angleVar: number;
        /**
         * @en Start size in pixels of each particle.
         * @zh 粒子的初始大小。
         */
        startSize: number;
        /**
         * @en Variation of start size in pixels.
         * @zh 粒子初始大小的变化范围。
         */
        startSizeVar: number;
        /**
         * @en End size in pixels of each particle.
         * @zh 粒子结束时的大小。
         */
        endSize: number;
        /**
         * @en Variation of end size in pixels.
         * @zh 粒子结束大小的变化范围。
         */
        endSizeVar: number;
        /**
         * @en Start angle of each particle.
         * @zh 粒子开始自旋角度。
         */
        startSpin: number;
        /**
         * @en Variation of start angle.
         * @zh 粒子开始自旋角度变化范围。
         */
        startSpinVar: number;
        /**
         * @en End angle of each particle.
         * @zh 粒子结束自旋角度。
         */
        endSpin: number;
        /**
         * @en Variation of end angle.
         * @zh 粒子结束自旋角度变化范围。
         */
        endSpinVar: number;
        /**
         * @en Source position of the emitter.
         * @zh 发射器位置。
         */
        sourcePos: math.Vec2;
        /**
         * @en Variation of source position.
         * @zh 发射器位置的变化范围。（横向和纵向）
         */
        posVar: math.Vec2;
        /**
         * @en Particles movement type.
         * @zh 粒子位置类型。
         */
        get positionType(): number;
        set positionType(val: number);
        /**
         * @en Preview particle system effect.
         * @ch 查看粒子效果
         */
        get preview(): boolean;
        set preview(val: boolean);
        /**
         * @en Particles emitter modes.
         * @zh 发射器类型。
         */
        emitterMode: number;
        /**
         * @en Gravity of the emitter.
         * @zh 重力。
         */
        gravity: math.Vec2;
        /**
         * @en Speed of the emitter.
         * @zh 速度。
         */
        speed: number;
        /**
         * @en Variation of the speed.
         * @zh 速度变化范围。
         */
        speedVar: number;
        /**
         * @en Tangential acceleration of each particle. Only available in 'Gravity' mode.
         * @zh 每个粒子的切向加速度，即垂直于重力方向的加速度，只有在重力模式下可用。
         */
        tangentialAccel: number;
        /**
         * @en Variation of the tangential acceleration.
         * @zh 每个粒子的切向加速度变化范围。
         */
        tangentialAccelVar: number;
        /**
         * @en Acceleration of each particle. Only available in 'Gravity' mode.
         * @zh 粒子径向加速度，即平行于重力方向的加速度，只有在重力模式下可用。
         */
        radialAccel: number;
        /**
         * @en Variation of the radial acceleration.
         * @zh 粒子径向加速度变化范围。
         */
        radialAccelVar: number;
        /**
         * @en Indicate whether the rotation of each particle equals to its direction. Only available in 'Gravity' mode.
         * @zh 每个粒子的旋转是否等于其方向，只有在重力模式下可用。
         */
        rotationIsDir: boolean;
        /**
         * @en Starting radius of the particles. Only available in 'Radius' mode.
         * @zh 初始半径，表示粒子出生时相对发射器的距离，只有在半径模式下可用。
         */
        startRadius: number;
        /**
         * @en Variation of the starting radius.
         * @zh 初始半径变化范围。
         */
        startRadiusVar: number;
        /**
         * @en Ending radius of the particles. Only available in 'Radius' mode.
         * @zh 结束半径，只有在半径模式下可用。
         */
        endRadius: number;
        /**
         * @en Variation of the ending radius.
         * @zh 结束半径变化范围。
         */
        endRadiusVar: number;
        /**
         * @en Number of degrees to rotate a particle around the source pos per second. Only available in 'Radius' mode.
         * @zh 粒子每秒围绕起始点的旋转角度，只有在半径模式下可用。
         */
        rotatePerS: number;
        /**
         * @en Variation of the degrees to rotate a particle around the source pos per second.
         * @zh 粒子每秒围绕起始点的旋转角度变化范围。
         */
        rotatePerSVar: number;
        /**
         * @en Indicate whether the system simulation have stopped.
         * @zh 指示粒子播放是否完毕。
         */
        get stopped(): boolean;
        /**
         * @en Indicate whether the particle system is activated.
         * @zh 是否激活粒子。
         * @readonly
         */
        get active(): boolean;
        get assembler(): IAssembler | null;
        aspectRatio: number;
        /**
         * The temporary SpriteFrame object used for the renderer. Because there is no corresponding asset, it can't be serialized.
         * @internal since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _renderSpriteFrame: SpriteFrame | null;
        /**
         * @internal since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _simulator: __private._cocos_particle_2d_particle_simulator_2d__Simulator;
        /**
         * @en If set to true, the particle system will automatically start playing on onLoad.
         * @zh 如果设置为 true 运行时会自动发射粒子。
         */
        playOnLoad: boolean;
        /**
         * @en Indicate whether the owner node will be auto-removed when it has no particles left.
         * @zh 粒子播放完毕后自动销毁所在的节点。
         */
        autoRemoveOnFinish: boolean;
        constructor();
        onEnable(): void;
        onDestroy(): void;
        onFocusInEditor(): void;
        onLostFocusInEditor(): void;
        __preload(): void;
        protected _flushAssembler(): void;
        protected lateUpdate(dt: any): void;
        /**
         * @en Add a particle to the emitter.
         * @zh 添加一个粒子到发射器中。
         * @return {Boolean}
         */
        addParticle(): void;
        /**
         * @en Stop emitting particles. Running particles will continue to run until they die.
         * @zh 停止发射器发射粒子，发射出去的粒子将继续运行，直至粒子生命结束。
         * @example
         * // stop particle system.
         * myParticleSystem.stopSystem();
         */
        stopSystem(): void;
        /**
         * @en Kill all living particles.
         * @zh 杀死所有存在的粒子，然后重新启动粒子发射器。
         * @example
         * // play particle system.
         * myParticleSystem.resetSystem();
         */
        resetSystem(): void;
        /**
         * @en Whether or not the system is full.
         * @zh 发射器中粒子是否大于等于设置的总粒子数量。
         * @return {Boolean}
         */
        isFull(): boolean;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _applyFile(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _initTextureWithDictionary(dict: any): boolean;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _initWithDictionary(dict: any): boolean;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _syncAspect(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _applySpriteFrame(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _getTexture(): __private._cocos_core_assets_texture_base__TextureBase | null;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _updateMaterial(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _finishedSimulation(): void;
        protected _canRender(): boolean;
        protected _render(render: __private._cocos_2d_renderer_i_batcher__IBatcher): void;
        protected _updatePositionType(): void;
    }
    /**
     * @en
     * cc.MotionStreak manages a Ribbon based on it's motion in absolute space.                 <br/>
     * You construct it with a fadeTime, minimum segment size, texture path, texture            <br/>
     * length and color. The fadeTime controls how long it takes each vertex in                 <br/>
     * the streak to fade out, the minimum segment size it how many pixels the                  <br/>
     * streak will move before adding a new ribbon segment, and the texture                     <br/>
     * length is the how many pixels the texture is stretched across. The texture               <br/>
     * is vertically aligned along the streak segment.
     * @zh 运动轨迹，用于游戏对象的运动轨迹上实现拖尾渐隐效果。
     */
    export class MotionStreak extends UIRenderer {
        static Point: typeof __private._cocos_particle_2d_motion_streak_2d__Point;
        /**
         * @en Preview the trailing effect in editor mode.
         * @zh 在编辑器模式下预览拖尾效果。
         */
        get preview(): boolean;
        set preview(val: boolean);
        /**
         * @en The fade time to fade.
         * @zh 拖尾的渐隐时间，以秒为单位。
         * @example
         * motionStreak.fadeTime = 3;
         */
        get fadeTime(): number;
        set fadeTime(val: number);
        /**
         * @en The minimum segment size.
         * @zh 拖尾之间最小距离。
         * @example
         * motionStreak.minSeg = 3;
         */
        get minSeg(): number;
        set minSeg(val: number);
        /**
         * @en The stroke's width.
         * @zh 拖尾的宽度。
         * @example
         * motionStreak.stroke = 64;
         */
        get stroke(): number;
        set stroke(val: number);
        /**
         * @en The texture of the MotionStreak.
         * @zh 拖尾的贴图。
         * @example
         * motionStreak.texture = newTexture;
         */
        get texture(): Texture2D | null;
        set texture(val: Texture2D | null);
        /**
         * @en The fast Mode.
         * @zh 是否启用了快速模式。当启用快速模式，新的点会被更快地添加，但精度较低。
         * @example
         * motionStreak.fastMode = true;
         */
        get fastMode(): boolean;
        set fastMode(val: boolean);
        get points(): __private._cocos_particle_2d_motion_streak_2d__Point[];
        onEnable(): void;
        protected _flushAssembler(): void;
        onFocusInEditor(): void;
        onLostFocusInEditor(): void;
        /**
         * @en Remove all living segments of the ribbon.
         * @zh 删除当前所有的拖尾片段。
         * @example
         * // Remove all living segments of the ribbon.
         * myMotionStreak.reset();
         */
        reset(): void;
        lateUpdate(dt: any): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _render(render: __private._cocos_2d_renderer_i_batcher__IBatcher): void;
    }
    export const MotionStreakAssemblerManager: IAssemblerManager;
    export const ParticleSystem2DAssembler: IAssemblerManager;
    /**
     * @en Class for 2D particle asset handling.
     * @zh 2D 粒子资产
     * @class ParticleAsset
     * @extends Asset
     */
    export class ParticleAsset extends Asset {
        spriteFrame: SpriteFrame | null;
    }
    export class Billboard extends Component {
        /**
         * @zh Billboard纹理。
         */
        get texture(): null;
        set texture(val: null);
        /**
         * @zh 高度。
         */
        get height(): number;
        set height(val: number);
        /**
         * @zh 宽度。
         */
        get width(): number;
        set width(val: number);
        /**
         * @zh billboard绕中心点旋转的角度
         */
        get rotation(): number;
        set rotation(val: number);
        constructor();
        onLoad(): void;
        onEnable(): void;
        onDisable(): void;
    }
    export class Line extends Component {
        /**
         * @zh 显示的纹理。
         */
        get texture(): null;
        set texture(val: null);
        get material(): Material | null;
        set material(val: Material | null);
        /**
         * @zh positions是否为世界空间坐标。
         */
        get worldSpace(): boolean;
        set worldSpace(val: boolean);
        /**
         * @en Inflection point positions of each polyline
         * @zh 每段折线的拐点坐标。
         */
        get positions(): never[];
        set positions(val: never[]);
        /**
         * @zh 线段的宽度。
         */
        get width(): CurveRange;
        set width(val: CurveRange);
        /**
         * @zh 图块数。
         */
        get tile(): math.Vec2;
        set tile(val: math.Vec2);
        get offset(): math.Vec2;
        set offset(val: math.Vec2);
        /**
         * @zh 线段颜色。
         */
        get color(): GradientRange;
        set color(val: GradientRange);
        constructor();
        onLoad(): void;
        onEnable(): void;
        onDisable(): void;
        protected _attachToScene(): void;
        protected _detachFromScene(): void;
    }
    export class ParticleSystem extends ModelRenderer {
        /**
         * @zh 粒子系统能生成的最大粒子数量。
         */
        get capacity(): number;
        set capacity(val: number);
        /**
         * @zh 粒子初始颜色。
         */
        startColor: GradientRange;
        scaleSpace: number;
        startSize3D: boolean;
        /**
         * @zh 粒子初始大小。
         */
        startSizeX: CurveRange;
        /**
         * @zh 粒子初始大小。
         */
        startSizeY: CurveRange;
        /**
         * @zh 粒子初始大小。
         */
        startSizeZ: CurveRange;
        /**
         * @zh 粒子初始速度。
         */
        startSpeed: CurveRange;
        startRotation3D: boolean;
        /**
         * @zh 粒子初始旋转角度。
         */
        startRotationX: CurveRange;
        /**
         * @zh 粒子初始旋转角度。
         */
        startRotationY: CurveRange;
        /**
         * @zh 粒子初始旋转角度。
         */
        startRotationZ: CurveRange;
        /**
         * @zh 粒子系统开始运行后，延迟粒子发射的时间。
         */
        startDelay: CurveRange;
        /**
         * @zh 粒子生命周期。
         */
        startLifetime: CurveRange;
        /**
         * @zh 粒子系统运行时间。
         */
        duration: number;
        /**
         * @zh 粒子系统是否循环播放。
         */
        loop: boolean;
        /**
         * @zh 选中之后，粒子系统会以已播放完一轮之后的状态开始播放（仅当循环播放启用时有效）。
         */
        get prewarm(): boolean;
        set prewarm(val: boolean);
        /**
         * @zh 选择粒子系统所在的坐标系[[Space]]。<br>
         */
        get simulationSpace(): number;
        set simulationSpace(val: number);
        /**
         * @zh 控制整个粒子系统的更新速度。
         */
        simulationSpeed: number;
        /**
         * @zh 粒子系统加载后是否自动开始播放。
         */
        playOnAwake: boolean;
        /**
         * @zh 粒子受重力影响的重力系数。
         */
        gravityModifier: CurveRange;
        /**
         * @zh 每秒发射的粒子数。
         */
        rateOverTime: CurveRange;
        /**
         * @zh 每移动单位距离发射的粒子数。
         */
        rateOverDistance: CurveRange;
        /**
         * @zh 设定在指定时间发射指定数量的粒子的 burst 的数量。
         */
        bursts: Burst[];
        /**
         * @en Enable particle culling switch. Open it to enable particle culling. If enabled will generate emitter bounding box and emitters outside the frustum will be culled.
         * @zh 粒子剔除开关，如果打开将会生成一个发射器包围盒，包围盒在相机外发射器将被剔除。
         */
        set renderCulling(value: boolean);
        get renderCulling(): boolean;
        /**
         * @en Particle culling mode option. Includes pause, pause and catchup, always simulate.
         * @zh 粒子剔除模式选择。包括暂停模拟，暂停以后快进继续以及不间断模拟。
         */
        get cullingMode(): number;
        set cullingMode(value: number);
        _cullingMode: number;
        static CullingMode: {
            Pause: number;
            PauseAndCatchup: number;
            AlwaysSimulate: number;
        };
        /**
         * @en Particle bounding box half width.
         * @zh 粒子包围盒半宽。
         */
        get aabbHalfX(): number;
        set aabbHalfX(value: number);
        /**
         * @en Particle bounding box half height.
         * @zh 粒子包围盒半高。
         */
        get aabbHalfY(): number;
        set aabbHalfY(value: number);
        /**
         * @en Particle bounding box half depth.
         * @zh 粒子包围盒半深。
         */
        get aabbHalfZ(): number;
        set aabbHalfZ(value: number);
        /**
         * @en Culling module data before serialize.
         * @zh 序列化之前剔除不需要的模块数据。
         */
        get dataCulling(): boolean;
        set dataCulling(value: boolean);
        get sharedMaterials(): any;
        set sharedMaterials(val: any);
        _colorOverLifetimeModule: __private._cocos_particle_animator_color_overtime__default | null;
        /**
         * @zh 颜色控制模块。
         */
        get colorOverLifetimeModule(): __private._cocos_particle_animator_color_overtime__default | null;
        set colorOverLifetimeModule(val: __private._cocos_particle_animator_color_overtime__default | null);
        _shapeModule: __private._cocos_particle_emitter_shape_module__default | null;
        /**
         * @zh 粒子发射器模块。
         */
        get shapeModule(): __private._cocos_particle_emitter_shape_module__default | null;
        set shapeModule(val: __private._cocos_particle_emitter_shape_module__default | null);
        _sizeOvertimeModule: __private._cocos_particle_animator_size_overtime__default | null;
        /**
         * @zh 粒子大小模块。
         */
        get sizeOvertimeModule(): __private._cocos_particle_animator_size_overtime__default | null;
        set sizeOvertimeModule(val: __private._cocos_particle_animator_size_overtime__default | null);
        _velocityOvertimeModule: __private._cocos_particle_animator_velocity_overtime__default | null;
        /**
         * @zh 粒子速度模块。
         */
        get velocityOvertimeModule(): __private._cocos_particle_animator_velocity_overtime__default | null;
        set velocityOvertimeModule(val: __private._cocos_particle_animator_velocity_overtime__default | null);
        _forceOvertimeModule: __private._cocos_particle_animator_force_overtime__default | null;
        /**
         * @zh 粒子加速度模块。
         */
        get forceOvertimeModule(): __private._cocos_particle_animator_force_overtime__default | null;
        set forceOvertimeModule(val: __private._cocos_particle_animator_force_overtime__default | null);
        _limitVelocityOvertimeModule: __private._cocos_particle_animator_limit_velocity_overtime__default | null;
        /**
         * @zh 粒子限制速度模块（只支持 CPU 粒子）。
         */
        get limitVelocityOvertimeModule(): __private._cocos_particle_animator_limit_velocity_overtime__default | null;
        set limitVelocityOvertimeModule(val: __private._cocos_particle_animator_limit_velocity_overtime__default | null);
        _rotationOvertimeModule: __private._cocos_particle_animator_rotation_overtime__default | null;
        /**
         * @zh 粒子旋转模块。
         */
        get rotationOvertimeModule(): __private._cocos_particle_animator_rotation_overtime__default | null;
        set rotationOvertimeModule(val: __private._cocos_particle_animator_rotation_overtime__default | null);
        _textureAnimationModule: __private._cocos_particle_animator_texture_animation__default | null;
        /**
         * @zh 贴图动画模块。
         */
        get textureAnimationModule(): __private._cocos_particle_animator_texture_animation__default | null;
        set textureAnimationModule(val: __private._cocos_particle_animator_texture_animation__default | null);
        get noiseModule(): __private._cocos_particle_animator_noise_module__NoiseModule | null;
        set noiseModule(val: __private._cocos_particle_animator_noise_module__NoiseModule | null);
        _trailModule: __private._cocos_particle_renderer_trail__default | null;
        /**
         * @zh 粒子轨迹模块。
         */
        get trailModule(): __private._cocos_particle_renderer_trail__default | null;
        set trailModule(val: __private._cocos_particle_renderer_trail__default | null);
        renderer: __private._cocos_particle_renderer_particle_system_renderer_data__default;
        processor: __private._cocos_particle_renderer_particle_system_renderer_base__IParticleSystemRenderer;
        constructor();
        onFocusInEditor(): void;
        onLoad(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _onMaterialModified(index: number, material: Material): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _onRebuildPSO(index: number, material: Material): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _collectModels(): renderer.scene.Model[];
        protected _attachToScene(): void;
        protected _detachFromScene(): void;
        bindModule(): void;
        /**
         * @en play particle system
         * @zh 播放粒子效果。
         */
        play(): void;
        /**
         * @en pause particle system
         * @zh 暂停播放粒子效果。
         */
        pause(): void;
        /**
         * @zh 停止发射粒子。
         * @en Stop emitting particles.
         */
        stopEmitting(): void;
        /**
         * @en stop particle system
         * @zh 停止播放粒子。
         */
        stop(): void;
        /**
         * @en remove all particles from current particle system.
         * @zh 将所有粒子从粒子系统中清除。
         */
        clear(): void;
        /**
         * @zh 获取当前粒子数量
         */
        getParticleCount(): number;
        /**
         * @ignore
         */
        setCustomData1(x: any, y: any): void;
        setCustomData2(x: any, y: any): void;
        protected onDestroy(): void;
        protected onEnable(): void;
        protected onDisable(): void;
        protected update(dt: number): void;
        protected beforeRender(): void;
        protected _onVisibilityChange(val: any): void;
        /**
         * @ignore
         */
        get isPlaying(): boolean;
        get isPaused(): boolean;
        get isStopped(): boolean;
        get isEmitting(): boolean;
        get time(): number;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _onBeforeSerialize(props: any): any;
        getNoisePreview(width: number, height: number): number[];
    }
    export class ParticleUtils {
        /**
         * @en instantiate particle system from prefab
         * @zh 从 prefab 实例化粒子系统
         */
        static instantiate(prefab: any): CCObject;
        static destroy(prefab: any): void;
        static play(rootNode: Node): void;
        static stop(rootNode: Node): void;
    }
    export class CurveRange {
        static Mode: {
            Constant: number;
            Curve: number;
            TwoCurves: number;
            TwoConstants: number;
        };
        /**
         * @zh 曲线类型[[Mode]]。
         */
        mode: number;
        /**
         * @zh 当mode为Curve时，使用的曲线。
         */
        spline: RealCurve;
        /**
         * @zh 当mode为TwoCurves时，使用的曲线下限。
         */
        splineMin: RealCurve;
        /**
         * @zh 当mode为TwoCurves时，使用的曲线上限。
         */
        splineMax: RealCurve;
        /**
         * @zh 当mode为Curve时，使用的曲线。
         * @deprecated Since V3.3. Use `spline` instead.
         */
        get curve(): geometry.AnimationCurve;
        set curve(value: geometry.AnimationCurve);
        /**
         * @zh 当mode为TwoCurves时，使用的曲线下限。
         * @deprecated Since V3.3. Use `splineMin` instead.
         */
        get curveMin(): geometry.AnimationCurve;
        set curveMin(value: geometry.AnimationCurve);
        /**
         * @zh 当mode为TwoCurves时，使用的曲线上限。
         * @deprecated Since V3.3. Use `splineMax` instead.
         */
        get curveMax(): geometry.AnimationCurve;
        set curveMax(value: geometry.AnimationCurve);
        /**
         * @zh 当mode为Constant时，曲线的值。
         */
        constant: number;
        /**
         * @zh 当mode为TwoConstants时，曲线的上限。
         */
        constantMin: number;
        /**
         * @zh 当mode为TwoConstants时，曲线的下限。
         */
        constantMax: number;
        /**
         * @zh 应用于曲线插值的系数。
         */
        multiplier: number;
        constructor();
        evaluate(time: number, rndRatio: number): number;
        getMax(): number;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _onBeforeSerialize(props: any): readonly [
            "mode",
            "constant",
            "multiplier"
        ] | readonly [
            "mode",
            "spline",
            "multiplier"
        ] | readonly [
            "mode",
            "splineMin",
            "splineMax",
            "multiplier"
        ] | readonly [
            "mode",
            "constantMin",
            "constantMax",
            "multiplier"
        ];
    }
    export class GradientRange {
        /**
         * @zh 渐变色类型 [[Mode]]。
         */
        get mode(): number;
        set mode(m: number);
        static Mode: {
            Color: number;
            Gradient: number;
            TwoColors: number;
            TwoGradients: number;
            RandomColor: number;
        };
        /**
         * @zh 当mode为Color时的颜色。
         */
        color: math.Color;
        /**
         * @zh 当mode为TwoColors时的颜色下限。
         */
        colorMin: math.Color;
        /**
         * @zh 当mode为TwoColors时的颜色上限。
         */
        colorMax: math.Color;
        /**
         * @zh 当mode为Gradient时的颜色渐变。
         */
        gradient: Gradient;
        /**
         * @zh 当mode为TwoGradients时的颜色渐变下限。
         */
        gradientMin: Gradient;
        /**
         * @zh 当mode为TwoGradients时的颜色渐变上限。
         */
        gradientMax: Gradient;
        evaluate(time: number, rndRatio: number): math.Color;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _onBeforeSerialize(props: any): any;
    }
    export class Gradient {
        static Mode: {
            Blend: number;
            Fixed: number;
        };
        /**
         * @en Array of color key.
         * @zh 颜色关键帧列表。
         */
        colorKeys: ColorKey[];
        /**
         * @en Array of alpha key.
         * @zh 透明度关键帧列表。
         */
        alphaKeys: AlphaKey[];
        /**
         * @en Blend mode.
         * @zh 混合模式。
         */
        mode: number;
        constructor();
        setKeys(colorKeys: ColorKey[], alphaKeys: AlphaKey[]): void;
        sortKeys(): void;
        evaluate(time: number): math.Color;
        randomColor(): math.Color;
    }
    export class AlphaKey {
        /**
         * @en Alpha value.
         * @zh 透明度。
         */
        alpha: number;
        /**
         * @en Time.
         * @zh 时间帧。
         */
        time: number;
    }
    export class ColorKey {
        /**
         * @en Color value.
         * @zh 颜色值。
         */
        color: math.Color;
        /**
         * @en Time value.
         * @zh 时间值。
         */
        time: number;
    }
    export class Burst {
        /**
         * @zh 粒子系统开始运行到触发此次 Brust 的时间。
         */
        get time(): number;
        set time(val: number);
        /**
         * @zh Burst 的触发次数。
         */
        get repeatCount(): number;
        set repeatCount(val: number);
        /**
         * @zh 每次触发的间隔时间。
         */
        repeatInterval: number;
        /**
         * @zh 发射的粒子的数量。
         */
        count: CurveRange;
        constructor();
        update(psys: any, dt: number): void;
        reset(): void;
        getMaxCount(psys: any): number;
    }
    export const Physics2DUtils: {
        PolygonSeparator: typeof __private._cocos_physics_2d_framework_utils_polygon_separator;
        PolygonPartition: typeof __private._cocos_physics_2d_framework_utils_polygon_partition;
    };
    export enum ERigidBody2DType {
        /**
         * @en
         * zero mass, zero velocity, may be manually moved.
         * @zh
         * 零质量，零速度，可以手动移动。
         */
        Static = 0,
        /**
         * @en
         * zero mass, non-zero velocity set by user.
         * @zh
         * 零质量，可以被设置速度。
         */
        Kinematic = 1,
        /**
         * @en
         * positive mass, non-zero velocity determined by forces.
         * @zh
         * 有质量，可以设置速度，力等。
         */
        Dynamic = 2,
        /**
         * @en
         * An extension of Kinematic type, can be animated by Animation.
         * @zh
         * Kinematic 类型的扩展，可以被动画控制动画效果。
         */
        Animated = 3
    }
    export enum ECollider2DType {
        None = 0,
        BOX = 1,
        CIRCLE = 2,
        POLYGON = 3
    }
    export enum EJoint2DType {
        None = 0,
        DISTANCE = 1,
        SPRING = 2,
        WHEEL = 3,
        MOUSE = 4,
        FIXED = 5,
        SLIDER = 6,
        RELATIVE = 7,
        HINGE = 8
    }
    export enum PhysicsGroup {
        DEFAULT = 1
    }
    /**
     * @en Enum for ERaycast2DType.
     * @zh 射线检测类型
     * @enum ERaycast2DType
     */
    export enum ERaycast2DType {
        /**
         * @en
         * Detects closest collider on the raycast path.
         * @zh
         * 检测射线路径上最近的碰撞体
         */
        Closest = 0,
        /**
         * @en
         * Detects any collider on the raycast path.
         * Once detects a collider, will stop the searching process.
         * @zh
         * 检测射线路径上任意的碰撞体。
         * 一旦检测到任何碰撞体，将立刻结束检测其他的碰撞体。
         */
        Any = 1,
        /**
         * @en
         * Detects all colliders on the raycast path.
         * One collider may return several collision points(because one collider may have several fixtures,
         * one fixture will return one point, the point may inside collider), AllClosest will return the closest one.
         * @zh
         * 检测射线路径上所有的碰撞体。
         * 同一个碰撞体上有可能会返回多个碰撞点(因为一个碰撞体可能由多个夹具组成，每一个夹具会返回一个碰撞点，碰撞点有可能在碰撞体内部)，AllClosest 删选同一个碰撞体上最近的哪一个碰撞点。
         */
        AllClosest = 2,
        /**
         * @en
         * Detects all colliders on the raycast path.
         * One collider may return several collision points, All will return all these points.
         * @zh
         * 检测射线路径上所有的碰撞体。
         * 同一个碰撞体上有可能会返回多个碰撞点，All 将返回所有这些碰撞点。
         */
        All = 3
    }
    export const Contact2DType: {
        None: string;
        BEGIN_CONTACT: string;
        END_CONTACT: string;
        PRE_SOLVE: string;
        POST_SOLVE: string;
    };
    export interface RaycastResult2D {
        collider: Collider2D;
        fixtureIndex: number;
        point: math.Vec2;
        normal: math.Vec2;
        fraction: number;
    }
    export enum EPhysics2DDrawFlags {
        None = 0,
        Shape = 1,
        Joint = 2,
        Aabb = 4,
        Pair = 8,
        CenterOfMass = 16,
        Particle = 32,
        Controller = 64,
        All = 63
    }
    export const PHYSICS_2D_PTM_RATIO = 32;
    export class PhysicsSystem2D extends __private._cocos_physics_2d_framework_physics_system__PhysicsSystem2D_base {
        /**
         * @en
         * Gets or sets whether the physical system is enabled, which can be used to pause or continue running the physical system.
         * @zh
         * 获取或设置是否启用物理系统，可以用于暂停或继续运行物理系统。
         */
        get enable(): boolean;
        set enable(value: boolean);
        /**
         * @zh
         * Gets or sets whether the physical system allows automatic sleep, which defaults to true.
         * @zh
         * 获取或设置物理系统是否允许自动休眠，默认为 true。
         */
        get allowSleep(): boolean;
        set allowSleep(v: boolean);
        /**
         * @en
         * Gets or sets the value of gravity in the physical world, which defaults to (0, -10).
         * @zh
         * 获取或设置物理世界的重力数值，默认为 (0, -10)。
         */
        get gravity(): math.Vec2;
        set gravity(gravity: math.Vec2);
        /**
         * @en
         * Gets or sets the maximum number of simulated substeps per frame.
         * @zh
         * 获取或设置每帧模拟的最大子步数。
         */
        get maxSubSteps(): number;
        set maxSubSteps(value: number);
        /**
         * @en
         * Gets or sets the fixed delta time consumed by each simulation step.
         * @zh
         * 获取或设置每步模拟消耗的固定时间。
         */
        get fixedTimeStep(): number;
        set fixedTimeStep(value: number);
        /**
         * @en
         * Turn on or off the automatic simulation.
         * @zh
         * 获取或设置是否自动模拟。
         */
        get autoSimulation(): boolean;
        set autoSimulation(value: boolean);
        get debugDrawFlags(): number;
        set debugDrawFlags(v: number);
        /**
         * @en
         * The velocity iterations for the velocity constraint solver.
         * @zh
         * 速度更新迭代数
         */
        velocityIterations: number;
        /**
         * @en
         * The position Iterations for the position constraint solver.
         * @zh
         * 位置迭代更新数
         */
        positionIterations: number;
        /**
         * @en
         * Gets the wrappered object of the physical world through which you can access the actual underlying object.
         * @zh
         * 获取物理世界的封装对象，通过它你可以访问到实际的底层对象。
         */
        readonly physicsWorld: __private._cocos_physics_2d_spec_i_physics_world__IPhysicsWorld;
        /**
         * @en
         * Gets the ID of the system.
         * @zh
         * 获取此系统的ID。
         */
        static readonly ID = "PHYSICS_2D";
        static get PHYSICS_NONE(): boolean;
        static get PHYSICS_BUILTIN(): boolean;
        static get PHYSICS_BOX2D(): boolean;
        /**
         * @en
         * Gets the predefined physics groups.
         * @zh
         * 获取预定义的物理分组。
         */
        static get PhysicsGroup(): typeof PhysicsGroup;
        /**
         * @en
         * Gets the physical system instance.
         * @zh
         * 获取物理系统实例。
         */
        static get instance(): PhysicsSystem2D;
        /**
         * @en
         * Gets the collision matrix。
         * @zh
         * 获取碰撞矩阵。
         */
        readonly collisionMatrix: physics.ICollisionMatrix;
        get stepping(): boolean;
        /**
         * @en
         * Perform a simulation of the physics system, which will now be performed automatically on each frame.
         * @zh
         * 执行一次物理系统的模拟，目前将在每帧自动执行一次。
         * @param deltaTime 与上一次执行相差的时间，目前为每帧消耗时间
         */
        postUpdate(deltaTime: number): void;
        _callAfterStep(target: object, func: Function): void;
        /**
         * @en
         * Reset the accumulator of time to given value.
         * @zh
         * 重置时间累积总量为给定值。
         */
        resetAccumulator(time?: number): void;
        /**
         * @en
         * Perform simulation steps for the physics world.
         * @zh
         * 执行物理世界的模拟步进。
         * @param fixedTimeStep
         */
        step(fixedTimeStep: number): void;
        /**
         * @en
         * Raycast the world for all colliders in the path of the ray.
         * The raycast ignores colliders that contain the starting point.
         * @zh
         * 检测哪些碰撞体在给定射线的路径上，射线检测将忽略包含起始点的碰撞体。
         * @method rayCast
         * @param {Vec2} p1 - start point of the raycast
         * @param {Vec2} p2 - end point of the raycast
         * @param {RayCastType} type - optional, default is RayCastType.Closest
         * @param {number} mask - optional, default is 0xffffffff
         * @return {[PhysicsRayCastResult]}
         */
        raycast(p1: math.IVec2Like, p2: math.IVec2Like, type?: ERaycast2DType, mask?: number): readonly Readonly<RaycastResult2D>[];
        /**
         * @en Test which colliders contain the point.
         * @zh 检测给定点在哪些碰撞体内。
         */
        testPoint(p: math.Vec2): readonly Collider2D[];
        /**
         * @en Test which colliders contain the point.
         * @zh 检测给定点在哪些碰撞体内。
         */
        testAABB(rect: math.Rect): readonly Collider2D[];
    }
    /**
     * @en
     * Contact impulses for reporting.
     * @zh
     * 用于返回给回调的接触冲量。
     */
    export interface IPhysics2DImpulse {
        /**
         * @en
         * Normal impulses.
         * @zh
         * 法线方向的冲量
         * @property normalImpulses
         */
        normalImpulses: number[];
        /**
         * @en
         * Tangent impulses
         * @zh
         * 切线方向的冲量
         * @property tangentImpulses
         */
        tangentImpulses: number[];
    }
    /**
     * @en
     * A world manifold.
     * @zh
     * 世界坐标系下的流形。
     */
    export interface IPhysics2DWorldManifold {
        /**
         * @en
         * world contact point (point of intersection)
         * @zh
         * 碰撞点集合
         */
        points: math.Vec2[];
        /**
         * @en
         * a negative value indicates overlap
         * @zh
         * 一个负数，用于指明重叠的部分
         */
        separations: number[];
        /**
         * @en
         * world vector pointing from A to B
         * @zh
         * 世界坐标系下由 A 指向 B 的向量
         */
        normal: math.Vec2;
    }
    /**
     * @en Manifold Type
     * @zh 流形类型
     */
    export enum Physics2DManifoldType {
        Circles = 0,
        FaceA = 1,
        FaceB = 2
    }
    /**
     * @en
     * A manifold point is a contact point belonging to a contact manifold.
     * It holds details related to the geometry and dynamics of the contact points.
     * Note: the impulses are used for internal caching and may not
     * provide reliable contact forces, especially for high speed collisions.
     * @zh
     * ManifoldPoint 是接触信息中的接触点信息。它拥有关于几何和接触点的详细信息。
     * 注意：信息中的冲量用于系统内部缓存，提供的接触力可能不是很准确，特别是高速移动中的碰撞信息。
     */
    export interface IPhysics2DManifoldPoint {
        /**
         * @en
         * The local point usage depends on the manifold type:
         * - Physics2DManifoldType.Circles: the local center of circleB
         * - Physics2DManifoldType.FaceA: the local center of circleB or the clip point of polygonB
         * - Physics2DManifoldType.FaceB: the clip point of polygonA
         * @zh
         * 本地坐标点的用途取决于 manifold 的类型
         * - Physics2DManifoldType.Circles: circleB 的本地中心点
         * - Physics2DManifoldType.FaceA: circleB 的本地中心点 或者是 polygonB 的截取点
         * - Physics2DManifoldType.FaceB: polygonB 的截取点
         */
        localPoint: math.Vec2;
        /**
         * @en
         * Normal impulse.
         * @zh
         * 法线冲量。
         */
        normalImpulse: number;
        /**
         * @en
         * Tangent impulse.
         * @zh
         * 切线冲量。
         */
        tangentImpulse: number;
    }
    /**
     * @en Manifold
     * @zh 流形
     */
    export interface IPhysics2DManifold {
        /**
         * @en
         * Manifold type
         * @zh
         * Manifold 类型
         */
        type: Physics2DManifoldType;
        /**
         * @en
         * The local point usage depends on the manifold type:
         * -Physics2DManifoldType.Circles: the local center of circleA
         * -Physics2DManifoldType.FaceA: the center of faceA
         * -Physics2DManifoldType.FaceB: the center of faceB
         * @zh
         * 用途取决于 manifold 类型
         * -Physics2DManifoldType.Circles: circleA 的本地中心点
         * -Physics2DManifoldType.FaceA: faceA 的本地中心点
         * -Physics2DManifoldType.FaceB: faceB 的本地中心点
         */
        localPoint: math.Vec2;
        /**
         * @en
         * -Physics2DManifoldType.Circles: not used
         * -Physics2DManifoldType.FaceA: the normal on polygonA
         * -Physics2DManifoldType.FaceB: the normal on polygonB
         * @zh
         * -Physics2DManifoldType.Circles: 没被使用到
         * -Physics2DManifoldType.FaceA: polygonA 的法向量
         * -Physics2DManifoldType.FaceB: polygonB 的法向量
         */
        localNormal: math.Vec2;
        /**
         * @en
         * the points of contact.
         * @zh
         * 接触点信息。
         */
        points: IPhysics2DManifoldPoint[];
    }
    /**
     * @en
     * PhysicsContact will be generated during begin and end collision as a parameter of the collision callback.
     * Note that contacts will be reused for speed up cpu time, so do not cache anything in the contact.
     * @zh
     * 物理接触会在开始和结束碰撞之间生成，并作为参数传入到碰撞回调函数中。
     * 注意：传入的物理接触会被系统进行重用，所以不要在使用中缓存里面的任何信息。
     */
    export interface IPhysics2DContact {
        /**
         * @en
         * One of the collider that collided
         * @zh
         * 发生碰撞的碰撞体之一
         */
        colliderA: Collider2D | null;
        /**
         * @en
         * One of the collider that collided
         * @zh
         * 发生碰撞的碰撞体之一
         */
        colliderB: Collider2D | null;
        /**
         * @en
         * If set disabled to true, the contact will be ignored until contact end.
         * If you just want to disabled contact for current time step or sub-step, please use disabledOnce.
         * @zh
         * 如果 disabled 被设置为 true，那么直到接触结束此接触都将被忽略。
         * 如果只是希望在当前时间步或子步中忽略此接触，请使用 disabledOnce 。
         */
        disabled: boolean;
        /**
         * @en
         * Disabled contact for current time step or sub-step.
         * @zh
         * 在当前时间步或子步中忽略此接触。
         */
        disabledOnce: boolean;
        /**
         * @en
         * Get the world manifold.
         * @zh
         * 获取世界坐标系下的碰撞信息。
         */
        getWorldManifold(): IPhysics2DWorldManifold;
        /**
         * @en
         * Get the manifold.
         * @zh
         * 获取本地（局部）坐标系下的碰撞信息。
         */
        getManifold(): IPhysics2DManifold;
        /**
         * @en
         * Get the impulses.
         * Note: PhysicsImpulse can only used in onPostSolve callback.
         * @zh
         * 获取冲量信息
         * 注意：这个信息只有在 onPostSolve 回调中才能获取到
         */
        getImpulse(): IPhysics2DImpulse | null;
        /**
         * @en
         * Is this contact touching?
         * @zh
         * 返回碰撞体是否已经接触到。
         */
        isTouching(): boolean;
        /**
         * @en
         * Set the desired tangent speed for a conveyor belt behavior.
         * @zh
         * 为传送带设置期望的切线速度
         */
        setTangentSpeed(value: number): any;
        /**
         * @en
         * Get the desired tangent speed.
         * @zh
         * 获取切线速度
         */
        getTangentSpeed(): number;
        /**
         * @en
         * Override the default friction mixture. You can call this in onPreSolve callback.
         * @zh
         * 覆盖默认的摩擦力系数。你可以在 onPreSolve 回调中调用此函数。
         */
        setFriction(value: number): any;
        /**
         * @en
         * Get the friction.
         * @zh
         * 获取当前摩擦力系数
         */
        getFriction(): number;
        /**
         * @en
         * Override the default restitution mixture. You can call this in onPreSolve callback.
         * @zh
         * 覆盖默认的恢复系数。你可以在 onPreSolve 回调中调用此函数。
         */
        setRestitution(restitution: number): any;
        /**
         * @en
         * Get the restitution.
         * @zh
         * 获取当前恢复系数
         */
        getRestitution(): number;
    }
    export class RigidBody2D extends Component {
        /**
         * @en
         * Gets or sets the group of the rigid body.
         * @zh
         * 获取或设置分组。
         */
        get group(): number;
        set group(v: number);
        enabledContactListener: boolean;
        /**
         * @en
         * Is this a fast moving body that should be prevented from tunneling through
         * other moving bodies?
         * Note :
         * - All bodies are prevented from tunneling through kinematic and static bodies. This setting is only considered on dynamic bodies.
         * - You should use this flag sparingly since it increases processing time.
         * @zh
         * 这个刚体是否是一个快速移动的刚体，并且需要禁止穿过其他快速移动的刚体？
         * 需要注意的是 :
         *  - 所有刚体都被禁止从 运动刚体 和 静态刚体 中穿过。此选项只关注于 动态刚体。
         *  - 应该尽量少的使用此选项，因为它会增加程序处理时间。
         */
        bullet: boolean;
        /**
         * @en
         * Rigidbody type : Static, Kinematic, Dynamic or Animated.
         * @zh
         * 刚体类型： Static, Kinematic, Dynamic or Animated.
         */
        get type(): ERigidBody2DType;
        set type(v: ERigidBody2DType);
        /**
         * @en
         * Set this flag to false if this body should never fall asleep.
         * Note that this increases CPU usage.
         * @zh
         * 如果此刚体永远都不应该进入睡眠，那么设置这个属性为 false。
         * 需要注意这将使 CPU 占用率提高。
         */
        get allowSleep(): boolean;
        set allowSleep(v: boolean);
        /**
         * @en
         * Scale the gravity applied to this body.
         * @zh
         * 缩放应用在此刚体上的重力值
         */
        get gravityScale(): number;
        set gravityScale(v: number);
        /**
         * @en
         * Linear damping is use to reduce the linear velocity.
         * The damping parameter can be larger than 1, but the damping effect becomes sensitive to the
         * time step when the damping parameter is large.
         * @zh
         * Linear damping 用于衰减刚体的线性速度。衰减系数可以大于 1，但是当衰减系数比较大的时候，衰减的效果会变得比较敏感。
         */
        get linearDamping(): number;
        set linearDamping(v: number);
        /**
         * @en
         * Angular damping is use to reduce the angular velocity. The damping parameter
         * can be larger than 1 but the damping effect becomes sensitive to the
         * time step when the damping parameter is large.
         * @zh
         * Angular damping 用于衰减刚体的角速度。衰减系数可以大于 1，但是当衰减系数比较大的时候，衰减的效果会变得比较敏感。
         */
        get angularDamping(): number;
        set angularDamping(v: number);
        /**
         * @en
         * The linear velocity of the body's origin in world co-ordinates.
         * @zh
         * 刚体在世界坐标下的线性速度
         */
        get linearVelocity(): math.Vec2;
        set linearVelocity(v: math.Vec2);
        /**
         * @en
         * The angular velocity of the body.
         * @zh
         * 刚体的角速度
         */
        get angularVelocity(): number;
        set angularVelocity(v: number);
        /**
         * @en
         * Should this body be prevented from rotating?
         * @zh
         * 是否禁止此刚体进行旋转
         */
        get fixedRotation(): boolean;
        set fixedRotation(v: boolean);
        /**
         * @en
         * Whether to wake up this rigid body during initialization
         * @zh
         * 是否在初始化时唤醒此刚体
         */
        awakeOnLoad: boolean;
        /**
         * @en
         * Whether the rigid body is awake.
         * @zh
         * 获取刚体是否正在休眠
         */
        isAwake(): boolean;
        /**
         * @en
         * Wake up the rigid body.
         * @zh
         * 唤醒刚体。
         */
        wakeUp(): void;
        /**
         * @en
         * Dormancy of rigid body.
         * @zh
         * 休眠刚体。
         */
        sleep(): void;
        /**
         * @en
         * Get total mass of the body.
         * @zh
         * 获取刚体的质量。
         */
        getMass(): number;
        /**
         * @en
         * Apply a force at a world point. If the force is not
         * applied at the center of mass, it will generate a torque and
         * affect the angular velocity.
         * @zh
         * 施加一个力到刚体上的一个点。如果力没有施加到刚体的质心上，还会产生一个扭矩并且影响到角速度。
         * @param force - the world force vector.
         * @param point - the world position.
         * @param wake - also wake up the body.
         */
        applyForce(force: math.Vec2, point: math.Vec2, wake: boolean): void;
        /**
         * @en
         * Apply a force to the center of mass.
         * @zh
         * 施加一个力到刚体上的质心上。
         * @param force - the world force vector.
         * @param wake - also wake up the body.
         */
        applyForceToCenter(force: math.Vec2, wake: boolean): void;
        /**
         * @en
         * Apply a torque. This affects the angular velocity.
         * @zh
         * 施加一个扭矩力，将影响刚体的角速度
         * @param torque - about the z-axis (out of the screen), usually in N-m.
         * @param wake - also wake up the body
         */
        applyTorque(torque: number, wake: boolean): void;
        /**
         * @en
         * Apply a impulse at a world point, this immediately modifies the velocity.
         * If the impulse is not applied at the center of mass, it will generate a torque and
         * affect the angular velocity.
         * @zh
         * 施加冲量到刚体上的一个点，将立即改变刚体的线性速度。
         * 如果冲量施加到的点不是刚体的质心，那么将产生一个扭矩并影响刚体的角速度。
         * @param impulse - the world impulse vector, usually in N-seconds or kg-m/s.
         * @param point - the world position
         * @param wake - alse wake up the body
         */
        applyLinearImpulse(impulse: math.Vec2, point: math.Vec2, wake: boolean): void;
        /**
         * @en
         * Apply a impulse at the center of mass, this immediately modifies the velocity.
         * @zh
         * 施加冲量到刚体上的质心点，将立即改变刚体的线性速度。
         * @param impulse - the world impulse vector, usually in N-seconds or kg-m/s.
         * @param point - the world position
         * @param wake - alse wake up the body
         */
        applyLinearImpulseToCenter(impulse: math.Vec2, wake: boolean): void;
        /**
         * @en
         * Apply an angular impulse.
         * @zh
         * 施加一个角速度冲量。
         * @param impulse - the angular impulse in units of kg*m*m/s
         * @param wake - also wake up the body
         */
        applyAngularImpulse(impulse: number, wake: boolean): void;
        /**
         * @en
         * Get the world linear velocity of a world point attached to this body.
         * @zh
         * 获取刚体上指定点的线性速度
         * @param worldPoint - a point in world coordinates.
         * @param out - optional, the receiving point
         */
        getLinearVelocityFromWorldPoint<Out extends math.IVec2Like>(worldPoint: math.IVec2Like, out: Out): Out;
        /**
         * @en
         * Converts a world coordinate point to the given rigid body coordinate.
         * @zh
         * 将一个给定的世界坐标系下的向量转换为刚体本地坐标系下的向量
         * @param worldVector - a vector in world coordinates.
         * @param out - optional, the receiving vector
         */
        getLocalVector<Out extends math.IVec2Like>(worldVector: math.IVec2Like, out: Out): Out;
        /**
         * @en
         * Converts a given vector in this rigid body's local coordinate system to the world coordinate system
         * @zh
         * 将一个给定的刚体本地坐标系下的向量转换为世界坐标系下的向量
         * @param localVector - a vector in world coordinates.
         * @param out - optional, the receiving vector
         */
        getWorldVector<Out extends math.IVec2Like>(localVector: math.IVec2Like, out: Out): Out;
        /**
         * @en
         * Converts a given point in the world coordinate system to this rigid body's local coordinate system
         * @zh
         * 将一个给定的世界坐标系下的点转换为刚体本地坐标系下的点
         * @param worldPoint - a point in world coordinates.
         * @param out - optional, the receiving point
         */
        getLocalPoint<Out extends math.IVec2Like>(worldPoint: math.IVec2Like, out: Out): Out;
        /**
         * @en
         * Converts a given point in this rigid body's local coordinate system to the world coordinate system
         * @zh
         * 将一个给定的刚体本地坐标系下的点转换为世界坐标系下的点
         * @param localPoint - a point in local coordinates.
         * @param out - optional, the receiving point
         */
        getWorldPoint<Out extends math.IVec2Like>(localPoint: math.IVec2Like, out: Out): Out;
        /**
         * @en
         * Get the local position of the center of mass.
         * @zh
         * 获取刚体本地坐标系下的质心
         */
        getLocalCenter<Out extends math.IVec2Like>(out: Out): Out;
        /**
         * @en
         * Get the world position of the center of mass.
         * @zh
         * 获取刚体世界坐标系下的质心
         */
        getWorldCenter<Out extends math.IVec2Like>(out: Out): Out;
        /**
         * @en
         * Get the rotational inertia of the body about the local origin.
         * @zh
         * 获取刚体本地坐标系下原点的旋转惯性
         */
        getInertia(): number;
        protected onLoad(): void;
        protected onEnable(): void;
        protected onDisable(): void;
        protected onDestroy(): void;
        get impl(): __private._cocos_physics_2d_spec_i_rigid_body__IRigidBody2D | null;
    }
    export class Collider2D extends __private._cocos_physics_2d_framework_components_colliders_collider_2d__Collider2D_base {
        editing: boolean;
        /**
         * @en Tag. If a node has several collider components, you can judge which type of collider is collided according to the tag.
         * @zh 标签。当一个节点上有多个碰撞组件时，在发生碰撞后，可以使用此标签来判断是节点上的哪个碰撞组件被碰撞了。
         */
        tag: number;
        /**
         * @en
         * Gets or sets the group of the rigid body.
         * @zh
         * 获取或设置分组。
         */
        get group(): number;
        set group(v: number);
        /**
         * @en The density.
         * @zh 密度
         */
        get density(): number;
        set density(v: number);
        /**
         * @en
         * A sensor collider collects contact information but never generates a collision response
         * @zh
         * 一个传感器类型的碰撞体会产生碰撞回调，但是不会发生物理碰撞效果。
         */
        get sensor(): boolean;
        set sensor(v: boolean);
        /**
         * @en
         * The friction coefficient, usually in the range [0,1].
         * @zh
         * 摩擦系数，取值一般在 [0, 1] 之间
         */
        get friction(): number;
        set friction(v: number);
        /**
         * @en
         * The restitution (elasticity) usually in the range [0,1].
         * @zh
         * 弹性系数，取值一般在 [0, 1]之间
         */
        get restitution(): number;
        set restitution(v: number);
        /**
         * @en Position offset
         * @zh 位置偏移量
         */
        get offset(): math.Vec2;
        set offset(v: math.Vec2);
        /**
         * @en
         * Physics collider will find the rigidbody component on the node and set to this property.
         * @zh
         * 碰撞体会在初始化时查找节点上是否存在刚体，如果查找成功则赋值到这个属性上。
         */
        get body(): RigidBody2D | null;
        get impl(): __private._cocos_physics_2d_spec_i_physics_shape__IBaseShape | null;
        readonly TYPE: ECollider2DType;
        protected onLoad(): void;
        protected onEnable(): void;
        protected onDisable(): void;
        protected onDestroy(): void;
        /**
         * @en
         * If the physics engine is box2d, need to call this function to apply current changes to collider, this will regenerate inner box2d fixtures.
         * @zh
         * 如果物理引擎是 box2d, 需要调用此函数来应用当前 collider 中的修改，调用此函数会重新生成 box2d 的夹具。
         */
        apply(): void;
        /**
         * @en
         * Get the world aabb of the collider
         * @zh
         * 获取碰撞体的世界坐标系下的包围盒
         */
        get worldAABB(): Readonly<math.Rect>;
        protected _shape: __private._cocos_physics_2d_spec_i_physics_shape__IBaseShape | null;
        protected _body: RigidBody2D | null;
        protected _group: physics.PhysicsGroup;
        protected _density: number;
        protected _sensor: boolean;
        protected _friction: number;
        protected _restitution: number;
        protected _offset: math.Vec2;
    }
    export class BoxCollider2D extends Collider2D {
        /**
         * @en Box size
         * @zh 包围盒大小
         */
        get size(): math.Size;
        set size(v: math.Size);
        /**
         * @en Get world points
         * @zh 世界坐标下 BoX 的四个点
         */
        get worldPoints(): readonly Readonly<math.Vec2>[];
        readonly TYPE = ECollider2DType.BOX;
    }
    export class CircleCollider2D extends Collider2D {
        /**
         * @en Circle radius
         * @zh 圆形半径
         */
        get radius(): number;
        set radius(v: number);
        /**
         * @en Get world center of the circle collider.
         * @zh 世界坐标下圆形碰撞体的中心。
         */
        get worldPosition(): Readonly<math.Vec2>;
        /**
         * @en Get world radius of the circle collider.
         * @zh 世界坐标下圆形碰撞体的半径。
         */
        get worldRadius(): number;
        readonly TYPE = ECollider2DType.CIRCLE;
    }
    export class PolygonCollider2D extends Collider2D {
        threshold: number;
        /**
         * @en Polygon points
         * @zh 多边形顶点数组
         */
        get points(): math.Vec2[];
        set points(v: math.Vec2[]);
        /**
         * @en Get world points
         * @zh 世界坐标下多边形碰撞体的点
         */
        get worldPoints(): readonly Readonly<math.Vec2>[];
        readonly TYPE = ECollider2DType.POLYGON;
    }
    export class Joint2D extends Component {
        anchor: math.Vec2;
        connectedAnchor: math.Vec2;
        collideConnected: boolean;
        connectedBody: RigidBody2D | null;
        _body: RigidBody2D | null;
        get body(): RigidBody2D | null;
        get impl(): __private._cocos_physics_2d_spec_i_physics_joint__IJoint2D | null;
        protected _joint: __private._cocos_physics_2d_spec_i_physics_joint__IJoint2D | null;
        TYPE: EJoint2DType;
        protected onLoad(): void;
        protected onEnable(): void;
        protected onDisable(): void;
        protected start(): void;
        protected onDestroy(): void;
    }
    export class DistanceJoint2D extends Joint2D {
        TYPE: EJoint2DType;
        /**
         * @en
         * The max length.
         * @zh
         * 最大长度。
         */
        get maxLength(): number;
        set maxLength(v: number);
        /**
         * @en
         * Auto calculate the distance between the connected two rigid bodies.
         * @zh
         * 自动计算关节连接的两个刚体间的距离
         */
        get autoCalcDistance(): boolean;
        set autoCalcDistance(v: boolean);
    }
    export class SpringJoint2D extends Joint2D {
        TYPE: EJoint2DType;
        /**
         * @en
         * The spring frequency.
         * @zh
         * 弹性系数。
         */
        get frequency(): number;
        set frequency(v: number);
        /**
         * @en
         * The damping ratio.
         * @zh
         * 阻尼，表示关节变形后，恢复到初始状态受到的阻力。
         */
        get dampingRatio(): number;
        set dampingRatio(v: number);
        /**
         * @en
         * The distance separating the two ends of the joint.
         * @zh
         * 关节两端的距离
         */
        get distance(): number;
        set distance(v: number);
        /**
         * @en
         * Auto calculate the distance between the connected two rigid bodies.
         * @zh
         * 自动计算关节连接的两个刚体间的距离
         */
        get autoCalcDistance(): boolean;
        set autoCalcDistance(v: boolean);
    }
    export class MouseJoint2D extends Joint2D {
        TYPE: EJoint2DType;
        get target(): math.Vec2;
        set target(v: math.Vec2);
        /**
         * @en
         * The spring frequency.
         * @zh
         * 弹簧系数。
         */
        get frequency(): number;
        set frequency(v: number);
        /**
         * @en
         * The damping ratio.
         * @zh
         * 阻尼，表示关节变形后，恢复到初始状态受到的阻力。
         */
        get dampingRatio(): number;
        set dampingRatio(v: number);
        /**
         * @en
         * The maximum force
         * @zh
         * 最大阻力值
         */
        get maxForce(): number;
        set maxForce(v: number);
        update(dt: any): void;
    }
    export class RelativeJoint2D extends Joint2D {
        TYPE: EJoint2DType;
        /**
         * @en
         * The maximum force can be applied to rigidbody.
         * @zh
         * 可以应用于刚体的最大的力值
         */
        get maxForce(): number;
        set maxForce(v: number);
        /**
         * @en
         * The maximum torque can be applied to rigidbody.
         * @zh
         * 可以应用于刚体的最大扭矩值
         */
        get maxTorque(): number;
        set maxTorque(v: number);
        /**
         * @en
         * The position correction factor in the range [0,1].
         * @zh
         * 位置矫正系数，范围为 [0, 1]
         */
        get correctionFactor(): number;
        set correctionFactor(v: number);
        /**
         * @en
         * The linear offset from connected rigidbody to rigidbody.
         * @zh
         * 关节另一端的刚体相对于起始端刚体的位置偏移量
         */
        get linearOffset(): math.Vec2;
        set linearOffset(v: math.Vec2);
        /**
         * @en
         * The angular offset from connected rigidbody to rigidbody.
         * @zh
         * 关节另一端的刚体相对于起始端刚体的角度偏移量
         */
        get angularOffset(): number;
        set angularOffset(v: number);
        /**
         * @en
         * Auto calculate the angularOffset and linearOffset between the connected two rigid bodies.
         * @zh
         * 自动计算关节连接的两个刚体间的 angularOffset 和 linearOffset
         */
        get autoCalcOffset(): boolean;
        set autoCalcOffset(v: boolean);
    }
    export class SliderJoint2D extends Joint2D {
        TYPE: EJoint2DType;
        /**
         * @en Slide direction
         * @zh 滑动的方向
         */
        get angle(): number;
        set angle(v: number);
        /**
         * @en Auto calculate slide direction according to the slide direction
         * @zh 根据连接的两个刚体自动计算滑动方向
         */
        get autoCalcAngle(): boolean;
        set autoCalcAngle(v: boolean);
        /**
         * @en
         * Enable joint motor?
         * @zh
         * 是否开启关节马达？
         */
        get enableMotor(): boolean;
        set enableMotor(v: boolean);
        /**
         * @en
         * The maxium force can be applied to rigidbody to rearch the target motor speed.
         * @zh
         * 可以施加到刚体的最大力。
         */
        get maxMotorForce(): number;
        set maxMotorForce(v: number);
        /**
         * @en
         * The expected motor speed.
         * @zh
         * 期望的马达速度。
         */
        get motorSpeed(): number;
        set motorSpeed(v: number);
        /**
         * @en
         * Enable joint distance limit?
         * @zh
         * 是否开启关节的距离限制？
         */
        get enableLimit(): boolean;
        set enableLimit(v: boolean);
        /**
         * @en
         * The lower joint limit.
         * @zh
         * 刚体能够移动的最小值
         */
        get lowerLimit(): number;
        set lowerLimit(v: number);
        /**
         * @en
         * The lower joint limit.
         * @zh
         * 刚体能够移动的最大值
         */
        get upperLimit(): number;
        set upperLimit(v: number);
    }
    export class FixedJoint2D extends Joint2D {
        TYPE: EJoint2DType;
        /**
         * @en
         * The frequency.
         * @zh
         * 弹性系数。
         */
        get frequency(): number;
        set frequency(v: number);
        /**
         * @en
         * The damping ratio.
         * @zh
         * 阻尼，表示关节变形后，恢复到初始状态受到的阻力。
         */
        get dampingRatio(): number;
        set dampingRatio(v: number);
    }
    export class WheelJoint2D extends Joint2D {
        TYPE: EJoint2DType;
        /**
         * @en Wheel susspension direction
         * @zh 轮子震动方向
         */
        get angle(): number;
        set angle(v: number);
        /**
         * @en
         * Enable joint motor?
         * @zh
         * 是否开启关节马达？
         */
        get enableMotor(): boolean;
        set enableMotor(v: boolean);
        /**
         * @en
         * The maxium torque can be applied to rigidbody to rearch the target motor speed.
         * @zh
         * 可以施加到刚体的最大扭矩。
         */
        get maxMotorTorque(): number;
        set maxMotorTorque(v: number);
        /**
         * @en
         * The expected motor speed.
         * @zh
         * 期望的马达速度。
         */
        get motorSpeed(): number;
        set motorSpeed(v: number);
        /**
         * @en
         * The spring frequency.
         * @zh
         * 弹性系数。
         */
        get frequency(): number;
        set frequency(v: number);
        /**
         * @en
         * The damping ratio.
         * @zh
         * 阻尼，表示关节变形后，恢复到初始状态受到的阻力。
         */
        get dampingRatio(): number;
        set dampingRatio(v: number);
    }
    export class HingeJoint2D extends Joint2D {
        TYPE: EJoint2DType;
        /**
         * @en
         * Enable joint limit?
         * @zh
         * 是否开启关节的限制？
         */
        get enableLimit(): boolean;
        set enableLimit(v: boolean);
        /**
         * @en
         * The lower angle.
         * @zh
         * 角度的最低限制。
         */
        get lowerAngle(): number;
        set lowerAngle(v: number);
        /**
         * @en
         * The upper angle.
         * @zh
         * 角度的最高限制。
         */
        get upperAngle(): number;
        set upperAngle(v: number);
        /**
         * @en
         * Enable joint motor?
         * @zh
         * 是否开启关节马达？
         */
        get enableMotor(): boolean;
        set enableMotor(v: boolean);
        /**
         * @en
         * The maxium torque can be applied to rigidbody to rearch the target motor speed.
         * @zh
         * 可以施加到刚体的最大扭矩。
         */
        get maxMotorTorque(): number;
        set maxMotorTorque(v: number);
        /**
         * @en
         * The expected motor speed.
         * @zh
         * 期望的马达速度。
         */
        get motorSpeed(): number;
        set motorSpeed(v: number);
    }
    /**
     * @en
     * The definition of the triggering event.
     * @zh
     * 触发事件。
     */
    export interface ITriggerEvent {
        /**
         * @en
         * The type of trigger event.
         * @zh
         * 触发的事件类型。
         */
        readonly type: TriggerEventType;
        /**
         * @en
         * The collider component instance of the event owner.
         * @zh
         * 触发事件中的自己的碰撞器
         */
        readonly selfCollider: physics.Collider;
        /**
         * @en
         * Trigger another collider in event.
         * @zh
         * 触发事件中的另一个碰撞器
         */
        readonly otherCollider: physics.Collider;
        /**
         * @en
         * Gets the lowLevel object, through which all the exposed properties can be accessed.
         * @zh
         * 获取实现对象，通过它可以访问到底层暴露的所有属性。
         */
        readonly impl: any;
    }
    /**
     * @en
     * The value type definition of the trigger event.
     * @zh
     * 触发事件的值类型定义。
     */
    export type TriggerEventType = "onTriggerEnter" | "onTriggerStay" | "onTriggerExit";
    /**
     * @en
     * Signature definition of the callback function that triggers the event.
     * @zh
     * 触发事件的回调函数签名定义。
     */
    export type TriggerCallback = (event?: ITriggerEvent) => void;
    /**
     * @en
     * Collision information for collision events.
     * @zh
     * 碰撞事件的碰撞信息。
     */
    export interface IContactEquation {
        /**
         * @en
         * Gets the lowLevel object, through which all the exposed properties can be accessed.
         * @zh
         * 获取实现对象，通过它可以访问到底层暴露的所有属性。
         */
        readonly impl: any;
        /**
         * @en
         * Gets whether the rigid body bound to the selfCollider is A.
         * @zh
         * 获取`selfCollider`所绑定的刚体是否为 A 。
         */
        readonly isBodyA: boolean;
        /**
         * @en
         * Gets the contact point relative to the rigid body A in the local coordinate system.
         * @zh
         * 获取本地坐标系中相对于刚体 A 的碰撞点。
         * @param out used to storage the output.
         */
        getLocalPointOnA(out: math.IVec3Like): void;
        /**
         * @en
         * Gets the contact point relative to the rigid body B in the local coordinate system.
         * @zh
         * 获取本地坐标系中相对于刚体 B 的碰撞点。
         * @param out used to storage the output.
         */
        getLocalPointOnB(out: math.IVec3Like): void;
        /**
         * @en
         * Gets the contact point relative to the rigid body A in the world coordinate system.
         * @zh
         * 获取世界坐标系中相对于刚体 A 的碰撞点。
         * @param out used to storage the output.
         */
        getWorldPointOnA(out: math.IVec3Like): void;
        /**
         * @en
         * Gets the contact point relative to the rigid body B in the world coordinate system.
         * @zh
         * 获取世界坐标系中相对于刚体 B 的碰撞点。
         * @param out used to storage the output.
         */
        getWorldPointOnB(out: math.IVec3Like): void;
        /**
         * @en
         * Gets the contact normal relative to the rigid body A in the local coordinate system.
         * @zh
         * 获取本地坐标系中相对于刚体 A 的碰撞法线。
         * @param out used to storage the output.
         */
        getLocalNormalOnA(out: math.IVec3Like): void;
        /**
         * @en
         * Gets the contact normal relative to the rigid body B in the local coordinate system.
         * @zh
         * 获取本地坐标系中相对于刚体 B 的碰撞法线。
         * @param out used to storage the output.
         */
        getLocalNormalOnB(out: math.IVec3Like): void;
        /**
         * @en
         * Gets the contact normal relative to the rigid body A in the world coordinate system.
         * @zh
         * 获取世界坐标系中相对于刚体 A 的碰撞法线。
         * @param out used to storage the output.
         */
        getWorldNormalOnA(out: math.IVec3Like): void;
        /**
         * @en
         * Gets the contact normal relative to the rigid body B in the world coordinate system.
         * @zh
         * 获取世界坐标系中相对于刚体 B 的碰撞法线。
         * @param out used to storage the output.
         */
        getWorldNormalOnB(out: math.IVec3Like): void;
    }
    /**
     * @en
     * The definition of the collision event.
     * @zh
     * 碰撞事件。
     */
    export interface ICollisionEvent {
        /**
         * @en
         * The type of collision event.
         * @zh
         * 碰撞的事件类型。
         */
        readonly type: CollisionEventType;
        /**
         * @en
         * The collider component instance of the event owner.
         * @zh
         * 碰撞中的自己的碰撞器。
         */
        readonly selfCollider: physics.Collider;
        /**
         * @en
         * Another collider in collision.
         * @zh
         * 碰撞中的另一个碰撞器。
         */
        readonly otherCollider: physics.Collider;
        /**
         * @en
         * Information about all points of impact in a collision event.
         * @zh
         * 碰撞中的所有碰撞点的信息。
         */
        readonly contacts: IContactEquation[];
        /**
         * @en
         * Gets the lowLevel object, through which all the exposed properties can be accessed.
         * @zh
         * 获取实现对象，通过它可以访问到底层暴露的所有属性。
         */
        readonly impl: any;
    }
    /**
     * @en
     * Value type definitions for collision events.
     * @zh
     * 碰撞事件的值类型定义。
     */
    export type CollisionEventType = "onCollisionEnter" | "onCollisionStay" | "onCollisionExit";
    /**
     * @en
     * Callback function signature definition for collision events.
     * @zh
     * 碰撞事件的回调函数签名定义。
     */
    export type CollisionCallback = (event?: ICollisionEvent) => void;
    export namespace physics {
        /**
         * @en
         * Physics system.
         * @zh
         * 物理系统。
         */
        export class PhysicsSystem extends System implements __private._cocos_physics_framework_physics_selector__IWorldInitData {
            static get PHYSICS_NONE(): boolean;
            static get PHYSICS_BUILTIN(): boolean;
            static get PHYSICS_CANNON(): boolean;
            static get PHYSICS_BULLET(): boolean;
            static get PHYSICS_PHYSX(): boolean;
            /**
             * @en
             * Gets the ID of the system.
             * @zh
             * 获取此系统的ID。
             */
            static readonly ID = "PHYSICS";
            /**
             * @en
             * Gets the predefined physics groups.
             * @zh
             * 获取预定义的物理分组。
             */
            static get PhysicsGroup(): typeof PhysicsGroup;
            /**
             * @en
             * Gets the physical system instance.
             * @zh
             * 获取物理系统实例。
             */
            static get instance(): PhysicsSystem;
            /**
             * @en
             * Gets or sets whether the physical system is enabled, which can be used to pause or continue running the physical system.
             * @zh
             * 获取或设置是否启用物理系统，可以用于暂停或继续运行物理系统。
             */
            get enable(): boolean;
            set enable(value: boolean);
            /**
             * @zh
             * Gets or sets whether the physical system allows automatic sleep, which defaults to true.
             * @zh
             * 获取或设置物理系统是否允许自动休眠，默认为 true。
             */
            get allowSleep(): boolean;
            set allowSleep(v: boolean);
            /**
             * @en
             * Gets or sets the maximum number of simulated substeps per frame.
             * @zh
             * 获取或设置每帧模拟的最大子步数。
             */
            get maxSubSteps(): number;
            set maxSubSteps(value: number);
            /**
             * @en
             * Gets or sets the fixed delta time consumed by each simulation step in seconds.
             * @zh
             * 获取或设置每步模拟消耗的固定时间（以 s 为单位）。
             */
            get fixedTimeStep(): number;
            set fixedTimeStep(value: number);
            /**
             * @en
             * Gets or sets the value of gravity in the physical world, which defaults to (0, -10, 0).
             * @zh
             * 获取或设置物理世界的重力数值，默认为 (0, -10, 0)。
             */
            get gravity(): math.Vec3;
            set gravity(gravity: math.Vec3);
            /**
             * @en
             * Gets or sets the default speed threshold for going to sleep.
             * @zh
             * 获取或设置进入休眠的默认速度临界值。
             */
            get sleepThreshold(): number;
            set sleepThreshold(v: number);
            /**
             * @en
             * Turn on or off the automatic simulation.
             * @zh
             * 获取或设置是否自动模拟。
             */
            get autoSimulation(): boolean;
            set autoSimulation(value: boolean);
            /**
             * @en
             * Gets the global default physical material.
             * @zh
             * 获取全局的默认物理材质。
             */
            get defaultMaterial(): PhysicsMaterial;
            initDefaultMaterial(): void;
            /**
             * @en
             * Gets the wrappered object of the physical world through which you can access the actual underlying object.
             * @zh
             * 获取物理世界的封装对象，通过它你可以访问到实际的底层对象。
             */
            get physicsWorld(): __private._cocos_physics_spec_i_physics_world__IPhysicsWorld;
            /**
             * @en
             * Gets the raycastClosest test result.
             * @zh
             * 获取 raycastClosest 的检测结果。
             */
            readonly raycastClosestResult: PhysicsRayResult;
            /**
             * @en
             * Gets the raycast test results.
             * @zh
             * 获取 raycast 的检测结果。
             */
            readonly raycastResults: PhysicsRayResult[];
            /**
             * @en
             * Gets the collision matrix that used for initialization only.
             * @zh
             * 获取碰撞矩阵，它仅用于初始化。
             */
            readonly collisionMatrix: ICollisionMatrix;
            /**
             * @en
             * The minimum size of the collision body.
             * @zh
             * 碰撞体的最小尺寸。
             */
            minVolumeSize: number;
            readonly useNodeChains: boolean;
            postUpdate(deltaTime: number): void;
            /**
             * @en
             * Reset the physics configuration.
             * @zh
             * 重置物理配置。
             */
            resetConfiguration(config?: IPhysicsConfig): void;
            /**
             * @en
             * Set the default physics material to given value.
             * @zh
             * 设置默认物理材质到指定的值。
             */
            setDefaultMaterial(materialConfig: IPhysicsMaterial): void;
            /**
             * @en
             * Reset the accumulator of time to given value.
             * @zh
             * 重置时间累积总量为给定值。
             */
            resetAccumulator(time?: number): void;
            /**
             * @en
             * Perform simulation steps for the physics world.
             * @zh
             * 执行物理世界的模拟步进。
             * @param fixedTimeStep
             */
            step(fixedTimeStep: number, deltaTime?: number, maxSubSteps?: number): void;
            /**
             * @en
             * Sync the scene world transform changes to the physics world.
             * @zh
             * 同步场景世界的变化信息到物理世界中。
             */
            syncSceneToPhysics(): void;
            /**
             * @en
             * Emit trigger and collision events.
             * @zh
             * 触发`trigger`和`collision`事件。
             */
            emitEvents(): void;
            /**
             * @en
             * Collision detect all collider, and record all the detected results, through PhysicsSystem.Instance.RaycastResults access to the results.
             * @zh
             * 检测所有的碰撞盒，并记录所有被检测到的结果，通过 PhysicsSystem.instance.raycastResults 访问结果。
             * @param worldRay @zh 世界空间下的一条射线 @en A ray in world space
             * @param mask @zh 掩码，默认为 0xffffffff @en Mask, default value is 0xffffffff
             * @param maxDistance @zh 最大检测距离，默认为 10000000，目前请勿传入 Infinity 或 Number.MAX_VALUE
             *                    @en Maximum detection distance, default value is 10000000, do not pass Infinity or Number.MAX_VALUE for now
             * @param queryTrigger @zh 是否检测触发器 @en Whether to detect triggers
             * @return {boolean} @zh 表示是否有检测到碰撞 @en Indicates whether a collision has been detected
             */
            raycast(worldRay: geometry.Ray, mask?: number, maxDistance?: number, queryTrigger?: boolean): boolean;
            /**
             * @en
             * Collision detect all collider, and record and ray test results with the shortest distance
             * by PhysicsSystem.Instance.RaycastClosestResult access to the results.
             * @zh
             * 检测所有的碰撞盒，并记录与射线距离最短的检测结果，通过 PhysicsSystem.instance.raycastClosestResult 访问结果。
             * @param worldRay @zh 世界空间下的一条射线 @en A ray in world space
             * @param mask @zh 掩码，默认为 0xffffffff @en Mask, default value is 0xffffffff
             * @param maxDistance @zh 最大检测距离，默认为 10000000，目前请勿传入 Infinity 或 Number.MAX_VALUE
             *                    @en Maximum detection distance, default value is 10000000, do not pass Infinity or Number.MAX_VALUE for now
             * @param queryTrigger @zh 是否检测触发器 @en Whether to detect triggers
             * @return {boolean} @zh 表示是否有检测到碰撞 @en Indicates whether a collision has been detected
             */
            raycastClosest(worldRay: geometry.Ray, mask?: number, maxDistance?: number, queryTrigger?: boolean): boolean;
            /**
             * @en
             * Construct and register the system singleton.
             * If the module is pre-loaded, it will be executed automatically.
             * @zh
             * 构造并注册系统单例。
             * 预先加载模块的情况下，会自动执行。
             */
            static constructAndRegister(): void;
        }
        /**
         * @en
         * Used to store physics ray test results.
         * @zh
         * 用于保存物理射线检测结果。
         */
        export class PhysicsRayResult {
            /**
             * @en
             * The hit point，in world space.
             * @zh
             * 在世界坐标系下的击中点。
             */
            get hitPoint(): math.Vec3;
            /**
             * @en
             * The distance between the ray origin with the hit.
             * @zh
             * 距离。
             */
            get distance(): number;
            /**
             * @en
             * The collider hit by the ray.
             * @zh
             * 击中的碰撞盒
             */
            get collider(): Collider;
            /**
             * @en
             * The normal of the hit plane，in world space.
             * @zh
             * 在世界坐标系下击中面的法线。
             */
            get hitNormal(): math.Vec3;
            /**
             * @en
             * internal methods.
             * @zh
             * 设置射线，此方法由引擎内部使用，请勿在外部脚本调用。
             *
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _assign(hitPoint: math.IVec3Like, distance: number, collider: Collider, hitNormal: math.IVec3Like): void;
            /**
             * @en
             * clone.
             * @zh
             * 克隆。
             */
            clone(): PhysicsRayResult;
        }
        /**
         * @en
         * Base class for colliders.
         * @zh
         * 碰撞器的基类。
         */
        export class Collider extends __private._cocos_physics_framework_components_colliders_collider__Collider_base {
            /**
             * @en
             * Enumeration of collider types.
             * @zh
             * 碰撞体类型的枚举。
             */
            static readonly Type: typeof EColliderType;
            /**
             * @en
             * Enumeration of axes.
             * @zh
             * 坐标轴方向的枚举。
             */
            static readonly Axis: typeof EAxisDirection;
            /**
             * @en
             * Get the rigid body component to which the collider is bound, possibly null.
             * @zh
             * 获取碰撞器所绑定的刚体组件，可能为空。
             */
            get attachedRigidBody(): RigidBody | null;
            /**
             * @en
             * Gets or sets the physical material for this collider.
             * @zh
             * 获取或设置此碰撞器的物理材质。
             */
            get sharedMaterial(): PhysicsMaterial | null;
            set sharedMaterial(value: PhysicsMaterial | null);
            /**
             * @en
             * Gets or sets the physics material for this collider, which in Shared state will generate a new instance.
             * @zh
             * 获取或设置此碰撞器的物理材质，共享状态下获取将会生成新的实例。
             */
            get material(): PhysicsMaterial | null;
            set material(value: PhysicsMaterial | null);
            /**
             * @en
             * Gets or sets the collider is trigger, this will be always trigger if using builtin.
             * @zh
             * 获取或设置碰撞器是否为触发器。(builtin 中无论真假都为触发器)
             */
            get isTrigger(): boolean;
            set isTrigger(value: boolean);
            /**
             * @en
             * Gets or sets the center of the collider, in local space.
             * @zh
             * 在本地空间中，获取或设置碰撞器的中心点。
             */
            get center(): math.Vec3;
            set center(value: math.Vec3);
            /**
             * @en
             * Gets the wrapper object, through which the lowLevel instance can be accessed.
             * @zh
             * 获取封装对象，通过此对象可以访问到底层实例。
             */
            get shape(): __private._cocos_physics_spec_i_physics_shape__IBaseShape | null;
            get worldBounds(): Readonly<geometry.AABB>;
            get boundingSphere(): Readonly<geometry.Sphere>;
            get needTriggerEvent(): boolean;
            get needCollisionEvent(): boolean;
            readonly type: EColliderType;
            protected _shape: __private._cocos_physics_spec_i_physics_shape__IBaseShape | null;
            protected _aabb: geometry.AABB | null;
            protected _boundingSphere: geometry.Sphere | null;
            protected _isSharedMaterial: boolean;
            protected _needTriggerEvent: boolean;
            protected _needCollisionEvent: boolean;
            protected _material: PhysicsMaterial | null;
            protected _isTrigger: boolean;
            protected readonly _center: math.Vec3;
            protected get _isInitialized(): boolean;
            constructor(type: EColliderType);
            /**
             * @en
             * Registers callbacks associated with triggered or collision events.
             * @zh
             * 注册触发或碰撞事件相关的回调。
             * @param type - The event type, onTriggerEnter|onTriggerStay|onTriggerExit|onCollisionEnter|onCollisionStay|onCollisionExit;
             * @param callback - The event callback, signature:`(event?:ICollisionEvent|ITriggerEvent)=>void`.
             * @param target - The event callback target.
             */
            on<TFunction extends (...any: any[]) => void>(type: TriggerEventType | CollisionEventType, callback: TFunction, target?: any, once?: boolean): any;
            /**
             * @en
             * Unregisters callbacks associated with trigger or collision events that have been registered.
             * @zh
             * 取消已经注册的触发或碰撞事件相关的回调。
             * @param type - The event type, onTriggerEnter|onTriggerStay|onTriggerExit|onCollisionEnter|onCollisionStay|onCollisionExit;
             * @param callback - The event callback, signature:`(event?:ICollisionEvent|ITriggerEvent)=>void`.
             * @param target - The event callback target.
             */
            off(type: TriggerEventType | CollisionEventType, callback?: (...any: any[]) => void, target?: any): void;
            /**
             * @en
             * Registers a callback associated with a trigger or collision event, which is automatically unregistered once executed.
             * @zh
             * 注册触发或碰撞事件相关的回调，执行一次后会自动取消注册。
             * @param type - The event type, onTriggerEnter|onTriggerStay|onTriggerExit|onCollisionEnter|onCollisionStay|onCollisionExit;
             * @param callback - The event callback, signature:`(event?:ICollisionEvent|ITriggerEvent)=>void`.
             * @param target - The event callback target.
             */
            once<TFunction extends (...any: any[]) => void>(type: TriggerEventType | CollisionEventType, callback: TFunction, target?: any): any;
            /**
             * @en
             * Removes all registered events of the specified target or type.
             * @zh
             * 移除所有指定目标或类型的注册事件。
             * @param typeOrTarget - The event type or target.
             */
            removeAll(typeOrTarget: TriggerEventType | CollisionEventType | Record<string, unknown>): void;
            /**
             * @en
             * Gets the group value.
             * @zh
             * 获取分组值。
             * @returns @zh 分组值，为 32 位整数，范围为 [2^0, 2^31] @en Group value which is a 32-bits integer, the range is [2^0, 2^31]
             */
            getGroup(): number;
            /**
             * @en
             * Sets the group value.
             * @zh
             * 设置分组值。
             * @param v @zh 分组值，为 32 位整数，范围为 [2^0, 2^31] @en Group value which is a 32-bits integer, the range is [2^0, 2^31]
             */
            setGroup(v: number): void;
            /**
             * @en
             * Add a grouping value to fill in the group you want to join.
             * @zh
             * 添加分组值，可填要加入的 group。
             * @param v @zh 分组值，为 32 位整数，范围为 [2^0, 2^31] @en Group value which is a 32-bits integer, the range is [2^0, 2^31]
             */
            addGroup(v: number): void;
            /**
             * @en
             * Subtract the grouping value to fill in the group to be removed.
             * @zh
             * 减去分组值，可填要移除的 group。
             * @param v @zh 分组值，为 32 位整数，范围为 [2^0, 2^31] @en Group value which is a 32-bits integer, the range is [2^0, 2^31]
             */
            removeGroup(v: number): void;
            /**
             * @en
             * Gets the mask value.
             * @zh
             * 获取掩码值。
             * @returns @zh 掩码值，为 32 位整数，范围为 [2^0, 2^31] @en Mask value which is a 32-bits integer, the range is [2^0, 2^31]
             */
            getMask(): number;
            /**
             * @en
             * Sets the mask value.
             * @zh
             * 设置掩码值。
             * @param v @zh 掩码值，为 32 位整数，范围为 [2^0, 2^31] @en Mask value which is a 32-bits integer, the range is [2^0, 2^31]
             */
            setMask(v: number): void;
            /**
             * @en
             * Add mask values to fill in groups that need to be checked.
             * @zh
             * 添加掩码值，可填入需要检查的 group。
             * @param v @zh 掩码值，为 32 位整数，范围为 [2^0, 2^31] @en Mask value which is a 32-bits integer, the range is [2^0, 2^31]
             */
            addMask(v: number): void;
            /**
             * @en
             * Subtract the mask value to fill in the group that does not need to be checked.
             * @zh
             * 减去掩码值，可填入不需要检查的 group。
             * @param v @zh 掩码值，为 32 位整数，范围为 [2^0, 2^31] @en Mask value which is a 32-bits integer, the range is [2^0, 2^31]
             */
            removeMask(v: number): void;
            protected onLoad(): void;
            protected onEnable(): void;
            protected onDisable(): void;
            protected onDestroy(): void;
        }
        export namespace Collider {
            export type Type = __private._types_globals__EnumAlias<typeof EColliderType>;
            export type Axis = __private._types_globals__EnumAlias<typeof EAxisDirection>;
        }
        /**
         * @en
         * Box collider component.
         * @zh
         * 盒子碰撞器。
         */
        export class BoxCollider extends Collider {
            /**
             * @en
             * Gets or sets the size of the box, in local space.
             * @zh
             * 获取或设置盒的大小。
             */
            get size(): math.Vec3;
            set size(value: math.Vec3);
            /**
             * @en
             * Gets the wrapper object, through which the lowLevel instance can be accessed.
             * @zh
             * 获取封装对象，通过此对象可以访问到底层实例。
             */
            get shape(): __private._cocos_physics_spec_i_physics_shape__IBoxShape;
            constructor();
        }
        /**
         * @en
         * Sphere collider component.
         * @zh
         * 球碰撞器。
         */
        export class SphereCollider extends Collider {
            /**
             * @en
             * Gets or sets the radius of the sphere.
             * @zh
             * 获取或设置球的半径。
             */
            get radius(): number;
            set radius(value: number);
            /**
             * @en
             * Gets the wrapper object, through which the lowLevel instance can be accessed.
             * @zh
             * 获取封装对象，通过此对象可以访问到底层实例。
             */
            get shape(): __private._cocos_physics_spec_i_physics_shape__ISphereShape;
            constructor();
        }
        /**
         * @en
         * Capsule collider component.
         * @zh
         * 胶囊体碰撞器。
         */
        export class CapsuleCollider extends Collider {
            /**
             * @en
             * Gets or sets the radius of the sphere on the capsule body, in local space.
             * @zh
             * 获取或设置胶囊体在本地坐标系下的球半径。
             */
            get radius(): number;
            set radius(value: number);
            /**
             * @en
             * Gets or sets the cylinder on the capsule body is at the corresponding axial height, in local space.
             * @zh
             * 获取或设置在本地坐标系下的胶囊体上圆柱体的高度。
             */
            get cylinderHeight(): number;
            set cylinderHeight(value: number);
            /**
             * @en
             * Gets or sets the capsule direction, in local space.
             * @zh
             * 获取或设置在本地坐标系下胶囊体的方向。
             */
            get direction(): EAxisDirection;
            set direction(value: EAxisDirection);
            /**
             * @en
             * Gets or sets the capsule height, in local space, with the minimum value being the diameter of the sphere.
             * @zh
             * 获取或设置在本地坐标系下胶囊体的高度，最小值为球的直径。
             */
            get height(): number;
            set height(value: number);
            /**
             * @en
             * Gets the capsule body is at the corresponding axial height, in world space.
             * @zh
             * 获取胶囊体在世界坐标系下相应胶囊体朝向上的高度，只读属性。
             */
            get worldHeight(): number;
            /**
             * @en
             * Gets the wrapper object, through which the lowLevel instance can be accessed.
             * @zh
             * 获取封装对象，通过此对象可以访问到底层实例。
             */
            get shape(): __private._cocos_physics_spec_i_physics_shape__ICapsuleShape;
            constructor();
        }
        /**
         * @en
         * Triangle mesh collider component.
         * @zh
         * 三角网格碰撞器。
         */
        export class MeshCollider extends Collider {
            /**
             * @en
             * Gets or sets the mesh assets referenced by this collider.
             * @zh
             * 获取或设置此碰撞体引用的网格资源.
             */
            get mesh(): Mesh | null;
            set mesh(value: Mesh | null);
            /**
             * @en
             * Gets or sets whether the collider replaces the mesh with a convex shape.
             * @zh
             * 获取或设置此碰撞体是否用凸形状代替网格.
             */
            get convex(): boolean;
            set convex(value: boolean);
            /**
             * @en
             * Gets the wrapper object, through which the lowLevel instance can be accessed.
             * @zh
             * 获取封装对象，通过此对象可以访问到底层实例。
             */
            get shape(): __private._cocos_physics_spec_i_physics_shape__ITrimeshShape;
            constructor();
        }
        /**
         * @en
         * Cylinder collider component.
         * @zh
         * 圆柱体碰撞器。
         */
        export class CylinderCollider extends Collider {
            /**
             * @en
             * Gets or sets the radius of the circle on the cylinder body, in local space.
             * @zh
             * 获取或设置圆柱体上圆面半径。
             */
            get radius(): number;
            set radius(value: number);
            /**
             * @en
             * Gets or sets the cylinder body is at the corresponding axial height, in local space.
             * @zh
             * 获取或设置圆柱体在相应轴向的高度。
             */
            get height(): number;
            set height(value: number);
            /**
             * @en
             * Gets or sets the cylinder direction, in local space.
             * @zh
             * 获取或设置在圆柱体本地空间上的方向。
             */
            get direction(): EAxisDirection;
            set direction(value: EAxisDirection);
            get shape(): __private._cocos_physics_spec_i_physics_shape__ICylinderShape;
            constructor();
        }
        /**
         * @en
         * Cone collider component.
         * @zh
         * 圆锥体碰撞器。
         */
        export class ConeCollider extends Collider {
            /**
             * @en
             * Gets or sets the radius of the circle on the cone body, in local space.
             * @zh
             * 获取或设置圆锥体上圆面半径。
             */
            get radius(): number;
            set radius(value: number);
            /**
             * @en
             * Gets or sets the cone body is at the corresponding axial height, in local space.
             * @zh
             * 获取或设置圆锥体在相应轴向的高度。
             */
            get height(): number;
            set height(value: number);
            /**
             * @en
             * Gets or sets the cone direction, in local space.
             * @zh
             * 获取或设置在圆锥体本地空间上的方向。
             */
            get direction(): EAxisDirection;
            set direction(value: EAxisDirection);
            get shape(): __private._cocos_physics_spec_i_physics_shape__IConeShape;
            constructor();
        }
        /**
         * @en
         * Terrain collider component.
         * @zh
         * 地形碰撞器。
         */
        export class TerrainCollider extends Collider {
            /**
             * @en
             * Gets or sets the terrain assets referenced by this collider.
             * @zh
             * 获取或设置此碰撞体引用的网格资源.
             */
            get terrain(): __private._cocos_physics_spec_i_external__ITerrainAsset | null;
            set terrain(value: __private._cocos_physics_spec_i_external__ITerrainAsset | null);
            /**
             * @en
             * Gets the wrapper object, through which the lowLevel instance can be accessed.
             * @zh
             * 获取封装对象，通过此对象可以访问到底层实例。
             */
            get shape(): __private._cocos_physics_spec_i_physics_shape__ITerrainShape;
            constructor();
        }
        /**
         * @en
         * Simplex collider, support point, line, triangle, tetrahedron.
         * @zh
         * 单纯形碰撞器，支持点、线、三角形、四面体。
         */
        export class SimplexCollider extends Collider {
            static readonly ESimplexType: typeof ESimplexType;
            get shapeType(): ESimplexType;
            set shapeType(v: ESimplexType);
            get vertex0(): math.IVec3Like;
            set vertex0(v: math.IVec3Like);
            get vertex1(): math.IVec3Like;
            set vertex1(v: math.IVec3Like);
            get vertex2(): math.IVec3Like;
            set vertex2(v: math.IVec3Like);
            get vertex3(): math.IVec3Like;
            set vertex3(v: math.IVec3Like);
            /**
             * @en
             * Gets the wrapper object, through which the lowLevel instance can be accessed.
             * @zh
             * 获取封装对象，通过此对象可以访问到底层实例。
             */
            get shape(): __private._cocos_physics_spec_i_physics_shape__ISimplexShape;
            get vertices(): math.IVec3Like[];
            constructor();
            updateVertices(): void;
        }
        export namespace SimplexCollider {
            export type ESimplexType = __private._types_globals__EnumAlias<typeof physics.ESimplexType>;
        }
        /**
         * @en
         * Plane collider component.
         * @zh
         * 静态平面碰撞器。
         */
        export class PlaneCollider extends Collider {
            /**
             * @en
             * Gets or sets the normal of the plane, in local space.
             * @zh
             * 获取或设置平面在本地坐标系下的法线。
             */
            get normal(): math.Vec3;
            set normal(value: math.Vec3);
            /**
             * @en
             * Gets or sets the value of the plane moving along the normal, in local space.
             * @zh
             * 获取或设置平面在本地坐标系下沿着法线移动的数值。
             */
            get constant(): number;
            set constant(v: number);
            /**
             * @en
             * Gets the wrapper object, through which the lowLevel instance can be accessed.
             * @zh
             * 获取封装对象，通过此对象可以访问到底层实例。
             */
            get shape(): __private._cocos_physics_spec_i_physics_shape__IPlaneShape;
            constructor();
        }
        /**
         * @en
         * Base class for joint constraints, which depends on rigid body components.
         * @zh
         * 关节约束的基类，它依赖于刚体组件。
         */
        export class Constraint extends __private._cocos_physics_framework_components_constraints_constraint__Constraint_base {
            /**
             * @en
             * Enumeration of joint types.
             * @zh
             * 关节类型的枚举。
             */
            static readonly Type: typeof EConstraintType;
            /**
             * @en
             * Gets the collider attached rigid-body.
             * @zh
             * 获取碰撞器所绑定的刚体组件。
             */
            get attachedBody(): RigidBody | null;
            /**
             * @en
             * Get or set the jointed rigid body, null means link to a static rigid body at the world origin.
             * @zh
             * 获取或设置关节连接的刚体，为空时表示链接到位于世界原点的静态刚体。
             */
            get connectedBody(): RigidBody | null;
            set connectedBody(v: RigidBody | null);
            /**
             * @en
             * Get or set whether collision is turned on between two rigid bodies connected by a joint.
             * @zh
             * 获取或设置关节连接的两刚体之间是否开启碰撞。
             */
            get enableCollision(): boolean;
            set enableCollision(v: boolean);
            /**
             * @en
             * Gets the type of this joint.
             * @zh
             * 获取此关节的类型。
             */
            readonly TYPE: EConstraintType;
            protected _enableCollision: boolean;
            protected _connectedBody: RigidBody | null;
            protected _constraint: __private._cocos_physics_spec_i_physics_constraint__IBaseConstraint | null;
            constructor(type: EConstraintType);
            protected onLoad(): void;
            protected onEnable(): void;
            protected onDisable(): void;
            protected onDestroy(): void;
        }
        export namespace Constraint {
            export type Type = __private._types_globals__EnumAlias<typeof EConstraintType>;
        }
        export class HingeConstraint extends Constraint {
            /**
             * @en
             * The position of the own rigid body in local space with respect to the constraint axis.
             * @zh
             * 在本地空间中，自身刚体相对于约束关节的位置。
             */
            get pivotA(): math.Vec3;
            set pivotA(v: math.Vec3);
            /**
             * @en
             * The position of the connected rigid body in the local space with respect to the constraint axis.
             * @zh
             * 在本地空间中，连接刚体相对于约束关节的位置。
             */
            get pivotB(): math.Vec3;
            set pivotB(v: math.Vec3);
            /**
             * @en
             * The direction of the constraint axis rotation in local space.
             * @zh
             * 在本地空间中，约束关节旋转的方向。
             */
            get axis(): math.Vec3;
            set axis(v: math.Vec3);
            get constraint(): __private._cocos_physics_spec_i_physics_constraint__IHingeConstraint;
            constructor();
        }
        export class PointToPointConstraint extends Constraint {
            /**
             * @en
             * The position of the own rigid body in local space with respect to the constraint axis.
             * @zh
             * 在本地空间中，自身刚体相对于约束关节的位置。
             */
            get pivotA(): math.IVec3Like;
            set pivotA(v: math.IVec3Like);
            /**
             * @en
             * The position of the connected rigid body in the local space with respect to the constraint axis.
             * @zh
             * 在本地空间中，连接刚体相对于约束关节的位置。
             */
            get pivotB(): math.IVec3Like;
            set pivotB(v: math.IVec3Like);
            get constraint(): __private._cocos_physics_spec_i_physics_constraint__IPointToPointConstraint;
            constructor();
        }
        /**
         * @en
         * Rigid body component.
         * @zh
         * 刚体组件。
         */
        export class RigidBody extends Component {
            /**
             * @en
             * Enumeration of rigid body types.
             * @zh
             * 刚体类型的枚举。
             */
            static readonly Type: typeof ERigidBodyType;
            /**
             * @en
             * Gets or sets the group of the rigid body.
             * @zh
             * 获取或设置分组。
             */
            get group(): number;
            set group(v: number);
            /**
             * @en
             * Gets or sets the type of rigid body.
             * @zh
             * 获取或设置刚体类型。
             */
            get type(): ERigidBodyType;
            set type(v: ERigidBodyType);
            /**
             * @en
             * Gets or sets the mass of the rigid body.
             * @zh
             * 获取或设置刚体的质量。
             */
            get mass(): number;
            set mass(value: number);
            /**
             * @en
             * Gets or sets whether hibernation is allowed.
             * @zh
             * 获取或设置是否允许休眠。
             */
            get allowSleep(): boolean;
            set allowSleep(v: boolean);
            /**
             * @en
             * Gets or sets linear damping.
             * @zh
             * 获取或设置线性阻尼。
             */
            get linearDamping(): number;
            set linearDamping(value: number);
            /**
             * @en
             * Gets or sets the rotation damping.
             * @zh
             * 获取或设置旋转阻尼。
             */
            get angularDamping(): number;
            set angularDamping(value: number);
            /**
             * @en
             * Gets or sets whether a rigid body uses gravity.
             * @zh
             * 获取或设置刚体是否使用重力。
             */
            get useGravity(): boolean;
            set useGravity(value: boolean);
            /**
             * @en
             * Gets or sets the linear velocity factor that can be used to control the scaling of the velocity in each axis direction.
             * @zh
             * 获取或设置线性速度的因子，可以用来控制每个轴方向上的速度的缩放。
             */
            get linearFactor(): math.Vec3;
            set linearFactor(value: math.Vec3);
            /**
             * @en
             * Gets or sets the rotation speed factor that can be used to control the scaling of the rotation speed in each axis direction.
             * @zh
             * 获取或设置旋转速度的因子，可以用来控制每个轴方向上的旋转速度的缩放。
             */
            get angularFactor(): math.Vec3;
            set angularFactor(value: math.Vec3);
            /**
             * @en
             * Gets or sets the speed threshold for going to sleep.
             * @zh
             * 获取或设置进入休眠的速度临界值。
             */
            get sleepThreshold(): number;
            set sleepThreshold(v: number);
            /**
             * @en
             * Turning on or off continuous collision detection.
             * @zh
             * 开启或关闭连续碰撞检测。
             */
            get useCCD(): boolean;
            set useCCD(v: boolean);
            /**
             * @en
             * Gets whether it is the state of awake.
             * @zh
             * 获取是否是唤醒的状态。
             */
            get isAwake(): boolean;
            /**
             * @en
             * Gets whether you can enter a dormant state.
             * @zh
             * 获取是否是可进入休眠的状态。
             */
            get isSleepy(): boolean;
            /**
             * @en
             * Gets whether the state is dormant.
             * @zh
             * 获取是否是正在休眠的状态。
             */
            get isSleeping(): boolean;
            /**
             * @en
             * Gets or sets whether the rigid body is static.
             * @zh
             * 获取或设置刚体是否是静态类型的（静止不动的）。
             */
            get isStatic(): boolean;
            set isStatic(v: boolean);
            /**
             * @en
             * Gets or sets whether the rigid body moves through physical dynamics.
             * @zh
             * 获取或设置刚体是否是动力学态类型的（将根据物理动力学控制运动）。
             */
            get isDynamic(): boolean;
            set isDynamic(v: boolean);
            /**
             * @en
             * Gets or sets whether a rigid body is controlled by users.
             * @zh
             * 获取或设置刚体是否是运动态类型的（将由用户来控制运动）。
             */
            get isKinematic(): boolean;
            set isKinematic(v: boolean);
            /**
             * @en
             * Gets the wrapper object, through which the lowLevel instance can be accessed.
             * @zh
             * 获取封装对象，通过此对象可以访问到底层实例。
             */
            get body(): __private._cocos_physics_spec_i_rigid_body__IRigidBody | null;
            protected get _isInitialized(): boolean;
            protected onLoad(): void;
            protected onEnable(): void;
            protected onDisable(): void;
            protected onDestroy(): void;
            /**
             * @en
             * Apply force to a world point. This could, for example, be a point on the Body surface.
             * @zh
             * 在世界空间中，相对于刚体的质心的某点上对刚体施加作用力。
             * @param force @zh 作用力 @en The force applied
             * @param relativePoint @zh 作用点，相对于刚体的质心 @en The point to apply the force on, relative to the center of mass of the rigid body
             */
            applyForce(force: math.Vec3, relativePoint?: math.Vec3): void;
            /**
             * @en
             * Apply force to a local point. This could, for example, be a point on the Body surface.
             * @zh
             * 在本地空间中，相对于刚体的质心的某点上对刚体施加作用力。
             * @param force @zh 作用力 @en The force applied
             * @param localPoint @zh 作用点 @en The point to apply the force on
             */
            applyLocalForce(force: math.Vec3, localPoint?: math.Vec3): void;
            /**
             * @en
             * In world space, impulse is applied to the rigid body at some point relative to the center of mass of the rigid body.
             * @zh
             * 在世界空间中，相对于刚体的质心的某点上对刚体施加冲量。
             * @param impulse @zh 冲量 @en The impulse applied
             * @param relativePoint @zh 作用点，相对于刚体的中心点 @en The point to apply the impulse, relative to the center of mass of the rigid body
             */
            applyImpulse(impulse: math.Vec3, relativePoint?: math.Vec3): void;
            /**
             * @en
             * In local space, impulse is applied to the rigid body at some point relative to the center of mass of the rigid body.
             * @zh
             * 在本地空间中，相对于刚体的质心的某点上对刚体施加冲量。
             * @param impulse @zh 冲量 @en The impulse applied
             * @param localPoint @zh 作用点 @en The point to apply the impulse
             */
            applyLocalImpulse(impulse: math.Vec3, localPoint?: math.Vec3): void;
            /**
             * @en
             * In world space, torque is applied to the rigid body.
             * @zh
             * 在世界空间中，对刚体施加扭矩。
             * @param torque @zh 扭矩 @en The torque applied
             */
            applyTorque(torque: math.Vec3): void;
            /**
             * @zh
             * 在本地空间中，对刚体施加扭矩。
             * @zh
             * In local space, torque is applied to the rigid body.
             * @param torque @zh 扭矩 @en The torque applied
             */
            applyLocalTorque(torque: math.Vec3): void;
            /**
             * @en
             * Wake up the rigid body.
             * @zh
             * 唤醒刚体。
             */
            wakeUp(): void;
            /**
             * @en
             * Dormancy of rigid body.
             * @zh
             * 休眠刚体。
             */
            sleep(): void;
            /**
             * @en
             * Clear the forces and velocity of the rigid body.
             * @zh
             * 清除刚体受到的力和速度。
             */
            clearState(): void;
            /**
             * @en
             * Clear the forces of the rigid body.
             * @zh
             * 清除刚体受到的力。
             */
            clearForces(): void;
            /**
             * @en
             * Clear velocity of the rigid body.
             * @zh
             * 清除刚体的速度。
             */
            clearVelocity(): void;
            /**
             * @en
             * Gets the linear velocity.
             * @zh
             * 获取线性速度。
             * @param out @zh 速度向量 @en The velocity vector
             */
            getLinearVelocity(out: math.Vec3): void;
            /**
             * @en
             * Sets the linear velocity.
             * @zh
             * 设置线性速度。
             * @param value @zh 速度向量 @en The velocity vector
             */
            setLinearVelocity(value: math.Vec3): void;
            /**
             * @en
             * Gets the angular velocity.
             * @zh
             * 获取旋转速度。
             * @param out @zh 角速度向量 @en The angular velocity vector
             */
            getAngularVelocity(out: math.Vec3): void;
            /**
             * @en
             * Sets the angular velocity.
             * @zh
             * 设置旋转速度。
             * @param value @zh 角速度向量 @en The angular velocity vector
             */
            setAngularVelocity(value: math.Vec3): void;
            /**
             * @en
             * Gets the group value.
             * @zh
             * 获取分组值。
             * @returns @zh 分组值，为 32 位整数，范围为 [2^0, 2^31] @en Group value which is a 32-bits integer, the range is [2^0, 2^31]
             */
            getGroup(): number;
            /**
             * @en
             * Sets the group value.
             * @zh
             * 设置分组值。
             * @param v @zh 分组值，为 32 位整数，范围为 [2^0, 2^31] @en Group value which is a 32-bits integer, the range is [2^0, 2^31]
             */
            setGroup(v: number): void;
            /**
             * @en
             * Add a grouping value to fill in the group you want to join.
             * @zh
             * 添加分组值，可填要加入的 group。
             * @param v @zh 分组值，为 32 位整数，范围为 [2^0, 2^31] @en Group value which is a 32-bits integer, the range is [2^0, 2^31]
             */
            addGroup(v: number): void;
            /**
             * @en
             * Subtract the grouping value to fill in the group to be removed.
             * @zh
             * 减去分组值，可填要移除的 group。
             * @param v @zh 分组值，为 32 位整数，范围为 [2^0, 2^31] @en Group value which is a 32-bits integer, the range is [2^0, 2^31]
             */
            removeGroup(v: number): void;
            /**
             * @en
             * Gets the mask value.
             * @zh
             * 获取掩码值。
             * @returns {number} @zh 掩码值，为 32 位整数，范围为 [2^0, 2^31] @en Mask value which is a 32-bits integer, the range is [2^0, 2^31]
             */
            getMask(): number;
            /**
             * @en
             * Sets the mask value.
             * @zh
             * 设置掩码值。
             * @param v @zh 掩码值，为 32 位整数，范围为 [2^0, 2^31] @en Mask value which is a 32-bits integer, the range is [2^0, 2^31]
             */
            setMask(v: number): void;
            /**
             * @en
             * Add mask values to fill in groups that need to be checked.
             * @zh
             * 添加掩码值，可填入需要检查的 group。
             * @param v @zh 掩码值，为 32 位整数，范围为 [2^0, 2^31] @en Mask value which is a 32-bits integer, the range is [2^0, 2^31]
             */
            addMask(v: number): void;
            /**
             * @en
             * Subtract the mask value to fill in the group that does not need to be checked.
             * @zh
             * 减去掩码值，可填入不需要检查的 group。
             * @param v @zh 掩码值，为 32 位整数，范围为 [2^0, 2^31] @en Mask value which is a 32-bits integer, the range is [2^0, 2^31]
             */
            removeMask(v: number): void;
        }
        export namespace RigidBody {
            export type Type = __private._types_globals__EnumAlias<typeof ERigidBodyType>;
        }
        /**
         * @en
         * Physics materials.
         * @zh
         * 物理材质。
         */
        export class PhysicsMaterial extends Asset {
            /**
             * @en
             * Gets all physics material instances.
             * @zh
             * 获取所有的物理材质实例。
             */
            static allMaterials: PhysicsMaterial[];
            /**
             * @en
             * The event which will be triggered when the entity of physics material update.
             * @zh
             * 物理材质实例更新时触发的事件。
             * @event PhysicsMaterial.EVENT_UPDATE
             */
            static readonly EVENT_UPDATE = "event_update";
            /**
             * @en
             * Friction for this material.
             * @zh
             * 此材质的摩擦系数。
             */
            get friction(): number;
            set friction(value: number);
            /**
             * @en
             * Rolling friction for this material.
             * @zh
             * 此材质的滚动摩擦系数。
             */
            get rollingFriction(): number;
            set rollingFriction(value: number);
            /**
             * @en
             * Spinning friction for this material.
             * @zh
             * 此材质的自旋摩擦系数。
             */
            get spinningFriction(): number;
            set spinningFriction(value: number);
            /**
             * @en
             * Restitution for this material.
             * @zh
             * 此材质的回弹系数。
             */
            get restitution(): number;
            set restitution(value: number);
            readonly id: number;
            constructor();
            /**
             * @en
             * clone.
             * @zh
             * 克隆。
             */
            clone(): PhysicsMaterial;
            /**
             * @en
             * destroy.
             * @zh
             * 销毁。
             * @return 是否成功
             */
            destroy(): boolean;
            /**
             * @en
             * Sets the coefficients values.
             * @zh
             * 设置材质相关的系数。
             * @param friction
             * @param rollingFriction
             * @param spinningFriction
             * @param restitution
             */
            setValues(friction: number, rollingFriction: number, spinningFriction: number, restitution: number): void;
        }
        /**
         * @en
         * A tool component to help apply force to the rigid body at each frame.
         * @zh
         * 在每帧对一个刚体施加持续的力，依赖 RigidBody 组件。
         */
        export class ConstantForce extends Component {
            /**
             * @en
             * Gets or sets forces in world coordinates.
             * @zh
             * 获取或设置世界坐标系下的力。
             */
            get force(): math.Vec3;
            set force(value: math.Vec3);
            /**
             * @en
             * Gets or sets the forces in the local coordinate system.
             * @zh
             * 获取或设置本地坐标系下的力。
             */
            get localForce(): math.Vec3;
            set localForce(value: math.Vec3);
            /**
             * @en
             * Gets or sets the torsional force in world coordinates.
             * @zh
             * 获取或设置世界坐标系下的扭转力。
             */
            get torque(): math.Vec3;
            set torque(value: math.Vec3);
            /**
             * @en
             * Gets or sets the torsional force in the local coordinate system.
             * @zh
             * 获取或设置本地坐标系下的扭转力。
             */
            get localTorque(): math.Vec3;
            set localTorque(value: math.Vec3);
            onLoad(): void;
            lateUpdate(dt: number): void;
        }
        /**
         * @en
         * The physics selector is used to register and switch the physics engine backend.
         * @zh
         * 物理选择器用于注册和切换物理引擎后端。
         */
        export const selector: __private._cocos_physics_framework_physics_selector__IPhysicsSelector;
        export namespace utils {
            export function setWrap<Wrapper>(object: any, wrapper: Wrapper): void;
            export function getWrap<Wrapper>(object: any): Wrapper;
            export function maxComponent(v: math.IVec3Like): number;
            export function shrinkPositions(buffer: Float32Array | number[]): number[];
            export function absolute(v: math.Vec3): math.Vec3;
            /**
             * @en
             * Generate a cylinder with radiusTop radiusBottom 0.5, height 2 and centered at origin,
             * but may be repositioned through the `center` option.
             * @zh
             * 生成一个圆柱。
             * @param radiusTop @en Radius of top plane. @zh 顶部半径。
             * @param radiusBottom @en Radius of bottom plane.  @zh 底部半径。
             * @param height @en The cylinder height.  @zh 圆柱的高
             * @param opts @en The optional creation parameters of the cylinder.  @zh 圆柱参数选项。
             */
            export function cylinder(radiusTop?: number, radiusBottom?: number, height?: number, opts?: __private._types_globals__RecursivePartial<__private._cocos_primitive_cylinder__ICylinderOptions>): primitives.IGeometry;
            export const VEC3_0: math.Vec3;
            export const TriggerEventObject: {
                type: TriggerEventType;
                selfCollider: Collider | null;
                otherCollider: Collider | null;
                impl: any;
            };
            export const CollisionEventObject: {
                type: CollisionEventType;
                selfCollider: Collider;
                otherCollider: Collider;
                contacts: IContactEquation[];
                impl: any;
            };
        }
        export interface ICollisionMatrix {
            [x: string]: number;
        }
        export interface IPhysicsMaterial {
            friction: number;
            rollingFriction: number;
            spinningFriction: number;
            restitution: number;
        }
        export interface ICollisionGroup {
            index: number;
            name: string;
        }
        export interface IPhysicsConfig {
            gravity?: math.IVec3Like;
            allowSleep?: boolean;
            fixedTimeStep?: number;
            maxSubSteps?: number;
            sleepThreshold?: number;
            collisionMatrix?: ICollisionMatrix;
            collisionGroups?: ICollisionGroup[];
            defaultMaterial?: IPhysicsMaterial;
            autoSimulation?: boolean;
            useNodeChains?: boolean;
            physicsEngine?: "builtin" | "cannon.js" | "ammo.js" | string;
        }
        export enum ERigidBodyType {
            DYNAMIC = 1,
            STATIC = 2,
            KINEMATIC = 4
        }
        export enum EAxisDirection {
            X_AXIS = 0,
            Y_AXIS = 1,
            Z_AXIS = 2
        }
        export enum ESimplexType {
            VERTEX = 1,
            LINE = 2,
            TRIANGLE = 3,
            TETRAHEDRON = 4
        }
        export enum EColliderType {
            BOX = 0,
            SPHERE = 1,
            CAPSULE = 2,
            CYLINDER = 3,
            CONE = 4,
            MESH = 5,
            PLANE = 6,
            SIMPLEX = 7,
            TERRAIN = 8
        }
        export enum EConstraintType {
            POINT_TO_POINT = 0,
            HINGE = 1,
            CONE_TWIST = 2
        }
        export enum PhysicsGroup {
            DEFAULT = 1
        }
        export { ITriggerEvent, TriggerEventType, TriggerCallback, IContactEquation, ICollisionEvent, CollisionEventType, CollisionCallback };
    }
    export namespace primitives {
        /**
         * @en
         * This function generates a box with specified extents and centered at origin,
         * but may be repositioned through the `center` option.
         * @zh
         * 生成一个立方体，其大小是定义的范围且中心在原点。
         * @param options @zh 参数选项。@en The optional creation parameters of the box
         */
        export function box(options?: __private._cocos_primitive_box__IBoxOptions): IGeometry;
        /**
         * @en
         * Generate a cone with radius 0.5, height 1, centered at origin,
         * but may be repositioned through the `center` option.
         * @zh
         * 生成一个圆锥。
         * @param radius @zh 圆锥半径。 @en The radius of cone
         * @param height @zh 圆锥高度。 @en The height of cone
         * @param opts @zh 圆锥参数选项。@en The optional creation parameters of the cone
         */
        export function cone(radius?: number, height?: number, opts?: __private._types_globals__RecursivePartial<__private._cocos_primitive_cone__IConeOptions>): IGeometry;
        /**
         * @en
         * This function generates a plane on XOZ plane with positive Y direction.
         * @zh
         * 生成一个平面，其位于XOZ平面，方向为Y轴正方向。
         * @param options @zh 平面参数选项。@en The optional creation parameters of the plane
         */
        export function plane(options?: __private._cocos_primitive_plane__IPlaneOptions): IGeometry;
        /**
         * @en
         * Generate a quad with width and height both to 1, centered at origin.
         * @zh
         * 生成一个四边形，宽高都为1，中心在原点。
         * @param options @zh 参数选项。 @en The optional creation parameters of the quad
         */
        export function quad(options?: IGeometryOptions): IGeometry;
        /**
         * @en
         * Generate a shpere with radius 0.5.
         * @zh
         * 生成一个球。
         * @param radius @en The radius. @zh 球半径。
         * @param options @en The sphere creation options. @zh 参数选项。
         */
        export function sphere(radius?: number, opts?: __private._types_globals__RecursivePartial<__private._cocos_primitive_sphere__ISphereOptions>): IGeometry;
        /**
         * @en
         * Generate a torus with radius 0.4, tube 0.1 and centered at origin.
         * @zh
         * 生成一个环面。
         * @param radius @zh 环面半径。@en The radius fo torus
         * @param tube @zh 管形大小。@en The radius of tube
         * @param opts @zh 参数选项。@en The optional creation parameters of the torus
         */
        export function torus(radius?: number, tube?: number, opts?: __private._types_globals__RecursivePartial<__private._cocos_primitive_torus__ITorusOptions>): {
            positions: number[];
            normals: number[];
            uvs: number[];
            indices: number[];
            minPos: math.Vec3;
            maxPos: math.Vec3;
            boundingRadius: number;
        };
        /**
         * Generate a capsule with radiusTop radiusBottom 0.5, height 2, centered at origin,
         * but may be repositioned through the `center` option.
         * @zh
         * 生成一个胶囊体。
         * @param radiusTop @zh 顶部半径。 @en The radius of top sphere
         * @param radiusBottom @zh 底部半径。@en The radius of bottom sphere
         * @param opts @zh 胶囊体参数选项。@en The optional creation parameters of the capsule
         */
        export function capsule(radiusTop?: number, radiusBottom?: number, height?: number, opts?: __private._types_globals__RecursivePartial<__private._cocos_primitive_capsule__ICapsuteOptions>): {
            positions: number[];
            normals: number[];
            uvs: number[];
            indices: number[];
            minPos: math.Vec3;
            maxPos: math.Vec3;
            boundingRadius: number;
        };
        /**
         * @en
         * Generate a circle with radius 1, centered at origin,
         * but may be repositioned through the `center` option.
         * @zh
         * 生成一个圆，其半径是单位1，中心点在原点。
         * @param options @zh 参数选项。 @en The optional creation parameters of the circle
         */
        export function circle(options?: __private._types_globals__RecursivePartial<__private._cocos_primitive_circle__ICircleOptions> | __private._cocos_primitive_circle__ICircleOptions): IGeometry;
        /**
         * @en
         * Translate the geometry.
         * @zh
         * 平移几何体。
         * @param geometry @zh 几何体信息。@en The geometry to be translated
         * @param offset @zh 偏移量。@en The translation
         */
        export function translate(geometry: IGeometry, offset: {
            x?: number;
            y?: number;
            z?: number;
        }): IGeometry;
        /**
         * @en
         * Scale the geometry.
         * @zh
         * 缩放几何体。
         * @param geometry @zh 几何体信息。 @en The geometry to be scaled
         * @param value @zh 缩放量。@en The scaling size
         */
        export function scale(geometry: IGeometry, value: {
            x?: number;
            y?: number;
            z?: number;
        }): IGeometry;
        /**
         * @en
         * Converts geometry to wireframe mode. Only geometry with triangle topology is supported.
         * @zh
         * 将几何体转换为线框模式，仅支持三角形拓扑的几何体。
         * @param geometry @zh 几何体信息。@en The geometry to be converted to wireframe
         */
        export function wireframed(geometry: IGeometry): IGeometry;
        /**
         * @deprecated
         */
        export function wireframe(indices: number[]): number[];
        /**
         * @deprecated
         */
        export function invWinding(indices: number[]): number[];
        /**
         * @deprecated
         */
        export function toWavefrontOBJ(primitive: IGeometry, scale?: number): string;
        /**
         * @deprecated
         */
        export function normals(positions: number[], nms: number[], length?: number): number[];
        /**
         * @en
         * Apply the options to default.
         * @zh
         * 应用默认的几何参数选项。
         */
        export function applyDefaultGeometryOptions<GeometryOptions = IGeometryOptions>(options?: __private._types_globals__RecursivePartial<IGeometryOptions>): GeometryOptions;
        /**
         * @en
         * The definition of the parameter for building a primitive geometry.
         * @zh
         * 几何体参数选项。
         */
        export interface IGeometryOptions {
            /**
             * @en
             * Whether to include normal. Default to true.
             * @zh
             * 是否包含法线。默认为true。
             */
            includeNormal: boolean;
            /**
             * @en
             * Whether to include uv. Default to true.
             * @zh
             * 是否包含UV。默认为true。
             */
            includeUV: boolean;
        }
        /**
         * @en
         * The definition of the geometry, this struct can build a mesh.
         * @zh
         * 几何体信息。
         */
        export interface IGeometry {
            /**
             * @en
             * Vertex positions.
             * @zh
             * 顶点位置。
             */
            positions: number[];
            /**
             * @en
             * Vertex normals.
             * @zh
             * 顶点法线。
             */
            normals?: number[];
            /**
             * @en
             * Texture coordinates.
             * @zh
             * 纹理坐标。
             */
            uvs?: number[];
            /**
             * @en
             * Vertex Tangents.
             * @zh
             * 顶点切线。
             */
            tangents?: number[];
            /**
             * @en
             * Vertex colors.
             * @zh
             * 顶点颜色。
             */
            colors?: number[];
            /**
             * @en
             * specify vertex attributes, use (positions|normals|uvs|colors) as keys
             * @zh
             * 顶点属性。
             */
            attributes?: gfx.Attribute[];
            customAttributes?: {
                attr: gfx.Attribute;
                values: number[];
            }[];
            /**
             * @en
             * Bounding sphere radius.
             * @zh
             * 包围球半径。
             */
            boundingRadius?: number;
            /**
             * @en
             * Min position.
             * @zh
             * 最小位置。
             */
            minPos?: {
                x: number;
                y: number;
                z: number;
            };
            /**
             * @en
             * Max position.
             * @zh
             * 最大位置。
             */
            maxPos?: {
                x: number;
                y: number;
                z: number;
            };
            /**
             * @en
             * Geometry indices, if one needs indexed-draw.
             * @zh
             * 几何索引，当使用索引绘制时。
             */
            indices?: number[];
            /**
             * @en
             * Topology of the geometry vertices. Default is TRIANGLE_LIST.
             * @zh
             * 几何顶点的拓扑图元。默认值是TRIANGLE_LIST。
             */
            primitiveMode?: gfx.PrimitiveMode;
            /**
             * @en
             * whether rays casting from the back face of this geometry could collide with it
             * @zh
             * 是否是双面，用于判断来自于几何体背面的射线检测。
             */
            doubleSided?: boolean;
        }
        /**
         * @en
         * The definition of the dynamic geometry, this struct can build a dynamic mesh.
         * @zh
         * 几何体信息。
         */
        export interface IDynamicGeometry {
            /**
             * @en
             * Vertex positions: 3 float components.
             * @zh
             * 顶点位置：3个float分量。
             */
            positions: Float32Array;
            /**
             * @en
             * Vertex normals: 3 float components.
             * @zh
             * 顶点法线：3个float分量。
             */
            normals?: Float32Array;
            /**
             * @en
             * Texture coordinates: 2 float components.
             * @zh
             * 纹理坐标：2个float分量。
             */
            uvs?: Float32Array;
            /**
             * @en
             * Vertex Tangents: 4 float components.
             * @zh
             * 顶点切线：4个float分量。
             */
            tangents?: Float32Array;
            /**
             * @en
             * Vertex colors: 4 float components.
             * @zh
             * 顶点颜色：4个float分量。
             */
            colors?: Float32Array;
            /**
             * @en
             * Custom attributes
             * @zh
             * 定制属性列表。
             */
            customAttributes?: {
                attr: gfx.Attribute;
                values: Float32Array;
            }[];
            /**
             * @en
             * Min position.
             * @zh
             * 最小位置。
             */
            minPos?: {
                x: number;
                y: number;
                z: number;
            };
            /**
             * @en
             * Max position.
             * @zh
             * 最大位置。
             */
            maxPos?: {
                x: number;
                y: number;
                z: number;
            };
            /**
             * @en
             * 16 bits Geometry indices, if one needs indexed-draw.
             * @zh
             * 16位几何索引，当使用索引绘制时。
             */
            indices16?: Uint16Array;
            /**
             * @en
             * 32 bits Geometry indices, if one needs indexed-draw.
             * @zh
             * 32位几何索引，当使用索引绘制时。
             */
            indices32?: Uint32Array;
            /**
             * @en
             * Topology of the geometry vertices. Default is TRIANGLE_LIST.
             * @zh
             * 几何顶点的拓扑图元。默认值是TRIANGLE_LIST。
             */
            primitiveMode?: gfx.PrimitiveMode;
            /**
             * @en
             * whether rays casting from the back face of this geometry could collide with it
             * @zh
             * 是否是双面，用于判断来自于几何体背面的射线检测。
             */
            doubleSided?: boolean;
        }
        export interface ICreateMeshOptions {
            /**
             * @en calculate mesh's aabb or not
             * @zh 是否计算模型的包围盒。
             */
            calculateBounds?: boolean;
        }
        export interface ICreateDynamicMeshOptions {
            /**
             * @en max sub mesh count
             * @zh 最大子模型个数。
             */
            maxSubMeshes: number;
            /**
             * @en max sub mesh vertex count
             * @zh 子模型最大顶点个数。
             */
            maxSubMeshVertices: number;
            /**
             * @en max sub mesh index count
             * @zh 子模型最大索引个数。
             */
            maxSubMeshIndices: number;
        }
        export import cylinder = physics.utils.cylinder;
    }
    /**
     * @en
     * Basic primitive mesh, this can be generate some primitive mesh at runtime.
     * @zh
     * 基础图形网格，可以在运行时构建一些基础的网格。
     */
    export class Primitive extends Mesh {
        static PrimitiveType: typeof __private._cocos_primitive_primitive__PrimitiveType;
        /**
         * @en
         * The type of the primitive mesh, set it before you call onLoaded.
         * @zh
         * 此基础图形网格的类型，请在 onLoaded 调用之前设置。
         */
        type: number;
        /**
         * @en
         * The option for build the primitive mesh, set it before you call onLoaded.
         * @zh
         * 创建此基础图形网格的可选参数，请在 onLoaded 调用之前设置。
         */
        info: Record<string, number>;
        constructor(type?: __private._cocos_primitive_primitive__PrimitiveType);
        /**
         * @en
         * Construct the primitive mesh with `type` and `info`.
         * @zh
         * 根据`type`和`info`构建相应的网格。
         */
        onLoaded(): void;
    }
    export namespace Primitive {
        export type PrimitiveType = __private._types_globals__EnumAlias<typeof __private._cocos_primitive_primitive__PrimitiveType>;
    }
    export class Profiler extends System {
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _stats: __private._cocos_profiler_profiler__IProfilerState | null;
        constructor();
        init(): void;
        isShowingStats(): boolean;
        hideStats(): void;
        showStats(): void;
        generateCanvas(): void;
        generateStats(): void;
        generateNode(): void;
        beforeUpdate(): void;
        afterUpdate(): void;
        beforePhysics(): void;
        afterPhysics(): void;
        beforeDraw(): void;
        afterDraw(): void;
    }
    export const profiler: Profiler;
    /**
     * @en
     * The data conversion tool for skeleton animation
     * @zh
     * 骨骼动画数据转换中心。
     * @internal
     */
    export class SkelAnimDataHub {
        static getOrExtract(clip: AnimationClip): __private._cocos_3d_skeletal_animation_skeletal_animation_data_hub__BakeData;
        static destroy(clip: AnimationClip): void;
    }
    /**
     * @en The animation state for skeletal animations.
     * @zh 骨骼动画的动画状态控制对象。
     */
    export class SkeletalAnimationState extends AnimationState {
        protected _frames: number;
        protected _bakedDuration: number;
        protected _animInfo: __private._cocos_3d_skeletal_animation_skeletal_animation_utils__IAnimInfo | null;
        protected _sockets: __private._cocos_3d_skeletal_animation_skeletal_animation_state__ISocketData[];
        protected _animInfoMgr: __private._cocos_3d_skeletal_animation_skeletal_animation_utils__JointAnimationInfo;
        protected _parent: SkeletalAnimation | null;
        protected _curvesInited: boolean;
        constructor(clip: AnimationClip, name?: string);
        initialize(root: Node): void;
        protected onPlay(): void;
        /**
         * @internal This method only friends to `SkeletalAnimation`.
         */
        setUseBaked(useBaked: boolean): void;
        /**
         * @en Rebuild animation curves and register the socket transforms per frame to the sockets. It will replace the internal sockets list.
         * @zh 为所有指定挂点更新动画曲线运算结果，并存储所有挂点的逐帧变换矩阵。这个方法会用传入的挂点更新取代内部挂点列表。
         * @param sockets @en The sockets need update @zh 需要重建的挂点列表
         * @returns void
         */
        rebuildSocketCurves(sockets: Socket[]): void;
    }
    /**
     * @en The socket to synchronize transform from skeletal joint to target node.
     * @zh 骨骼动画的挂点，用于将骨骼树的挂点节点变化矩阵同步到目标节点上
     */
    export class Socket {
        /**
         * @en Path of the target joint.
         * @zh 此挂点的目标骨骼路径。
         */
        path: string;
        /**
         * @en Transform output node.
         * @zh 此挂点的变换信息输出节点。
         */
        target: Node | null;
        constructor(path?: string, target?: Node | null);
    }
    /**
     * @en
     * Skeletal animation component, offers the following features on top of [[Animation]]:
     * * Choice between baked animation and real-time calculation, to leverage efficiency and expressiveness.
     * * Joint socket system: Create any socket node directly under the animation component root node,
     *   find your target joint and register both to the socket list, so that the socket node would be in-sync with the joint.
     * @zh
     * 骨骼动画组件，在普通动画组件基础上额外提供以下功能：
     * * 可选预烘焙动画模式或实时计算模式，用以权衡运行时效率与效果；
     * * 提供骨骼挂点功能：通过在动画根节点下创建挂点节点，并在骨骼动画组件上配置 socket 列表，挂点节点的 Transform 就能与骨骼保持同步。
     */
    export class SkeletalAnimation extends Animation {
        static Socket: typeof Socket;
        /**
         * @en
         * The joint sockets this animation component maintains.<br>
         * Sockets have to be registered here before attaching custom nodes to animated joints.
         * @zh
         * 当前动画组件维护的挂点数组。要挂载自定义节点到受动画驱动的骨骼上，必须先在此注册挂点。
         */
        get sockets(): Socket[];
        set sockets(val: Socket[]);
        /**
         * @en
         * Whether to bake animations. Default to true,<br>
         * which substantially increases performance while making all animations completely fixed.<br>
         * Dynamically changing this property will take effect when playing the next animation clip.
         * @zh
         * 是否使用预烘焙动画，默认启用，可以大幅提高运行效时率，但所有动画效果会被彻底固定，不支持任何形式的编辑和混合。<br>
         * 运行时动态修改此选项会在播放下一条动画片段时生效。
         */
        get useBakedAnimation(): boolean;
        set useBakedAnimation(val: boolean);
        protected _useBakedAnimation: boolean;
        protected _sockets: Socket[];
        onLoad(): void;
        onDestroy(): void;
        onEnable(): void;
        onDisable(): void;
        start(): void;
        pause(): void;
        resume(): void;
        stop(): void;
        /**
         * @en Query all socket paths
         * @zh 获取所有挂点的骨骼路径
         * @returns @en All socket paths @zh 所有挂点的骨骼路径
         */
        querySockets(): string[];
        /**
         * @en Rebuild animations to synchronize immediately all sockets to their target node.
         * @zh 重建动画并立即同步所有挂点的转换矩阵到它们的目标节点上。
         */
        rebuildSocketAnimations(): void;
        /**
         * @en Create or get the target node from a socket.
         * If a socket haven't been created for the corresponding path, this function will register a new socket.
         * @zh 创建或获取一个挂点的同步目标节点。
         * 如果对应路径还没有创建挂点，这个函数会创建一个新的挂点。
         * @param path @en Path of the target joint. @zh 此挂点的骨骼路径。
         * @returns @en The target node of the socket. @zh 挂点的目标节点
         */
        createSocket(path: string): Node | null;
        /**
         * @internal This method only friends to skinned mesh renderer.
         */
        notifySkinnedMeshAdded(skinnedMeshRenderer: SkinnedMeshRenderer): void;
        /**
         * @internal This method only friends to skinned mesh renderer.
         */
        notifySkinnedMeshRemoved(skinnedMeshRenderer: SkinnedMeshRenderer): void;
        /**
         * Get all users.
         * @internal This method only friends to the skeleton animation state.
         */
        getUsers(): Set<SkinnedMeshRenderer>;
        protected _createState(clip: AnimationClip, name?: string): SkeletalAnimationState;
        protected _doCreateState(clip: AnimationClip, name: string): SkeletalAnimationState;
        protected doPlayOrCrossFade(state: AnimationState, duration: number): void;
    }
    export namespace sp {
        export namespace spine {
            export class Animation {
                name: string;
                timelines: Array<Timeline>;
                timelineIds: Array<boolean>;
                duration: number;
                constructor(name: string, timelines: Array<Timeline>, duration: number);
                hasTimeline(id: number): boolean;
                apply(skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;
                static binarySearch(values: ArrayLike<number>, target: number, step?: number): number;
                static linearSearch(values: ArrayLike<number>, target: number, step: number): number;
            }
            export interface Timeline {
                apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;
                getPropertyId(): number;
            }
            export enum MixBlend {
                setup = 0,
                first = 1,
                replace = 2,
                add = 3
            }
            export enum MixDirection {
                mixIn = 0,
                mixOut = 1
            }
            export enum TimelineType {
                rotate = 0,
                translate = 1,
                scale = 2,
                shear = 3,
                attachment = 4,
                color = 5,
                deform = 6,
                event = 7,
                drawOrder = 8,
                ikConstraint = 9,
                transformConstraint = 10,
                pathConstraintPosition = 11,
                pathConstraintSpacing = 12,
                pathConstraintMix = 13,
                twoColor = 14
            }
            export abstract class CurveTimeline implements Timeline {
                static LINEAR: number;
                static STEPPED: number;
                static BEZIER: number;
                static BEZIER_SIZE: number;
                abstract getPropertyId(): number;
                constructor(frameCount: number);
                getFrameCount(): number;
                setLinear(frameIndex: number): void;
                setStepped(frameIndex: number): void;
                getCurveType(frameIndex: number): number;
                setCurve(frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number): void;
                getCurvePercent(frameIndex: number, percent: number): number;
                abstract apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;
            }
            export class RotateTimeline extends CurveTimeline {
                static ENTRIES: number;
                static PREV_TIME: number;
                static PREV_ROTATION: number;
                static ROTATION: number;
                boneIndex: number;
                frames: ArrayLike<number>;
                constructor(frameCount: number);
                getPropertyId(): number;
                setFrame(frameIndex: number, time: number, degrees: number): void;
                apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;
            }
            export class TranslateTimeline extends CurveTimeline {
                static ENTRIES: number;
                static PREV_TIME: number;
                static PREV_X: number;
                static PREV_Y: number;
                static X: number;
                static Y: number;
                boneIndex: number;
                frames: ArrayLike<number>;
                constructor(frameCount: number);
                getPropertyId(): number;
                setFrame(frameIndex: number, time: number, x: number, y: number): void;
                apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;
            }
            export class ScaleTimeline extends TranslateTimeline {
                constructor(frameCount: number);
                getPropertyId(): number;
                apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;
            }
            export class ShearTimeline extends TranslateTimeline {
                constructor(frameCount: number);
                getPropertyId(): number;
                apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;
            }
            export class ColorTimeline extends CurveTimeline {
                static ENTRIES: number;
                static PREV_TIME: number;
                static PREV_R: number;
                static PREV_G: number;
                static PREV_B: number;
                static PREV_A: number;
                static R: number;
                static G: number;
                static B: number;
                static A: number;
                slotIndex: number;
                frames: ArrayLike<number>;
                constructor(frameCount: number);
                getPropertyId(): number;
                setFrame(frameIndex: number, time: number, r: number, g: number, b: number, a: number): void;
                apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;
            }
            export class TwoColorTimeline extends CurveTimeline {
                static ENTRIES: number;
                static PREV_TIME: number;
                static PREV_R: number;
                static PREV_G: number;
                static PREV_B: number;
                static PREV_A: number;
                static PREV_R2: number;
                static PREV_G2: number;
                static PREV_B2: number;
                static R: number;
                static G: number;
                static B: number;
                static A: number;
                static R2: number;
                static G2: number;
                static B2: number;
                slotIndex: number;
                frames: ArrayLike<number>;
                constructor(frameCount: number);
                getPropertyId(): number;
                setFrame(frameIndex: number, time: number, r: number, g: number, b: number, a: number, r2: number, g2: number, b2: number): void;
                apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;
            }
            export class AttachmentTimeline implements Timeline {
                slotIndex: number;
                frames: ArrayLike<number>;
                attachmentNames: Array<string>;
                constructor(frameCount: number);
                getPropertyId(): number;
                getFrameCount(): number;
                setFrame(frameIndex: number, time: number, attachmentName: string): void;
                apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;
                setAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string): void;
            }
            export class DeformTimeline extends CurveTimeline {
                slotIndex: number;
                attachment: VertexAttachment;
                frames: ArrayLike<number>;
                frameVertices: Array<ArrayLike<number>>;
                constructor(frameCount: number);
                getPropertyId(): number;
                setFrame(frameIndex: number, time: number, vertices: ArrayLike<number>): void;
                apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;
            }
            export class EventTimeline implements Timeline {
                frames: ArrayLike<number>;
                events: Array<Event>;
                constructor(frameCount: number);
                getPropertyId(): number;
                getFrameCount(): number;
                setFrame(frameIndex: number, event: Event): void;
                apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;
            }
            export class DrawOrderTimeline implements Timeline {
                frames: ArrayLike<number>;
                drawOrders: Array<Array<number>>;
                constructor(frameCount: number);
                getPropertyId(): number;
                getFrameCount(): number;
                setFrame(frameIndex: number, time: number, drawOrder: Array<number>): void;
                apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;
            }
            export class IkConstraintTimeline extends CurveTimeline {
                static ENTRIES: number;
                static PREV_TIME: number;
                static PREV_MIX: number;
                static PREV_SOFTNESS: number;
                static PREV_BEND_DIRECTION: number;
                static PREV_COMPRESS: number;
                static PREV_STRETCH: number;
                static MIX: number;
                static SOFTNESS: number;
                static BEND_DIRECTION: number;
                static COMPRESS: number;
                static STRETCH: number;
                ikConstraintIndex: number;
                frames: ArrayLike<number>;
                constructor(frameCount: number);
                getPropertyId(): number;
                setFrame(frameIndex: number, time: number, mix: number, softness: number, bendDirection: number, compress: boolean, stretch: boolean): void;
                apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;
            }
            export class TransformConstraintTimeline extends CurveTimeline {
                static ENTRIES: number;
                static PREV_TIME: number;
                static PREV_ROTATE: number;
                static PREV_TRANSLATE: number;
                static PREV_SCALE: number;
                static PREV_SHEAR: number;
                static ROTATE: number;
                static TRANSLATE: number;
                static SCALE: number;
                static SHEAR: number;
                transformConstraintIndex: number;
                frames: ArrayLike<number>;
                constructor(frameCount: number);
                getPropertyId(): number;
                setFrame(frameIndex: number, time: number, rotateMix: number, translateMix: number, scaleMix: number, shearMix: number): void;
                apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;
            }
            export class PathConstraintPositionTimeline extends CurveTimeline {
                static ENTRIES: number;
                static PREV_TIME: number;
                static PREV_VALUE: number;
                static VALUE: number;
                pathConstraintIndex: number;
                frames: ArrayLike<number>;
                constructor(frameCount: number);
                getPropertyId(): number;
                setFrame(frameIndex: number, time: number, value: number): void;
                apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;
            }
            export class PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {
                constructor(frameCount: number);
                getPropertyId(): number;
                apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;
            }
            export class PathConstraintMixTimeline extends CurveTimeline {
                static ENTRIES: number;
                static PREV_TIME: number;
                static PREV_ROTATE: number;
                static PREV_TRANSLATE: number;
                static ROTATE: number;
                static TRANSLATE: number;
                pathConstraintIndex: number;
                frames: ArrayLike<number>;
                constructor(frameCount: number);
                getPropertyId(): number;
                setFrame(frameIndex: number, time: number, rotateMix: number, translateMix: number): void;
                apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;
            }
            export class AnimationState {
                static emptyAnimation: Animation;
                static SUBSEQUENT: number;
                static FIRST: number;
                static HOLD_SUBSEQUENT: number;
                static HOLD_FIRST: number;
                static HOLD_MIX: number;
                static SETUP: number;
                static CURRENT: number;
                data: AnimationStateData;
                tracks: TrackEntry[];
                timeScale: number;
                unkeyedState: number;
                events: Event[];
                listeners: AnimationStateListener[];
                queue: EventQueue;
                propertyIDs: IntSet;
                animationsChanged: boolean;
                trackEntryPool: Pool<TrackEntry>;
                constructor(data: AnimationStateData);
                update(delta: number): void;
                updateMixingFrom(to: TrackEntry, delta: number): boolean;
                apply(skeleton: Skeleton): boolean;
                applyMixingFrom(to: TrackEntry, skeleton: Skeleton, blend: MixBlend): number;
                applyAttachmentTimeline(timeline: AttachmentTimeline, skeleton: Skeleton, time: number, blend: MixBlend, attachments: boolean): void;
                setAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string, attachments: boolean): void;
                applyRotateTimeline(timeline: Timeline, skeleton: Skeleton, time: number, alpha: number, blend: MixBlend, timelinesRotation: Array<number>, i: number, firstFrame: boolean): void;
                queueEvents(entry: TrackEntry, animationTime: number): void;
                clearTracks(): void;
                clearTrack(trackIndex: number): void;
                setCurrent(index: number, current: TrackEntry, interrupt: boolean): void;
                setAnimation(trackIndex: number, animationName: string, loop: boolean): TrackEntry;
                setAnimationWith(trackIndex: number, animation: Animation, loop: boolean): TrackEntry;
                addAnimation(trackIndex: number, animationName: string, loop: boolean, delay: number): TrackEntry;
                addAnimationWith(trackIndex: number, animation: Animation, loop: boolean, delay: number): TrackEntry;
                setEmptyAnimation(trackIndex: number, mixDuration: number): TrackEntry;
                addEmptyAnimation(trackIndex: number, mixDuration: number, delay: number): TrackEntry;
                setEmptyAnimations(mixDuration: number): void;
                expandToIndex(index: number): TrackEntry;
                trackEntry(trackIndex: number, animation: Animation, loop: boolean, last: TrackEntry): TrackEntry;
                disposeNext(entry: TrackEntry): void;
                _animationsChanged(): void;
                computeHold(entry: TrackEntry): void;
                getCurrent(trackIndex: number): TrackEntry;
                addListener(listener: AnimationStateListener): void;
                removeListener(listener: AnimationStateListener): void;
                clearListeners(): void;
                clearListenerNotifications(): void;
            }
            export class TrackEntry {
                animation: Animation;
                next: TrackEntry;
                mixingFrom: TrackEntry;
                mixingTo: TrackEntry;
                listener: AnimationStateListener;
                trackIndex: number;
                loop: boolean;
                holdPrevious: boolean;
                eventThreshold: number;
                attachmentThreshold: number;
                drawOrderThreshold: number;
                animationStart: number;
                animationEnd: number;
                animationLast: number;
                nextAnimationLast: number;
                delay: number;
                trackTime: number;
                trackLast: number;
                nextTrackLast: number;
                trackEnd: number;
                timeScale: number;
                alpha: number;
                mixTime: number;
                mixDuration: number;
                interruptAlpha: number;
                totalAlpha: number;
                mixBlend: MixBlend;
                timelineMode: number[];
                timelineHoldMix: TrackEntry[];
                timelinesRotation: number[];
                reset(): void;
                getAnimationTime(): number;
                setAnimationLast(animationLast: number): void;
                isComplete(): boolean;
                resetRotationDirections(): void;
            }
            export class EventQueue {
                objects: Array<any>;
                drainDisabled: boolean;
                animState: AnimationState;
                constructor(animState: AnimationState);
                start(entry: TrackEntry): void;
                interrupt(entry: TrackEntry): void;
                end(entry: TrackEntry): void;
                dispose(entry: TrackEntry): void;
                complete(entry: TrackEntry): void;
                event(entry: TrackEntry, event: Event): void;
                drain(): void;
                clear(): void;
            }
            export enum EventType {
                start = 0,
                interrupt = 1,
                end = 2,
                dispose = 3,
                complete = 4,
                event = 5
            }
            export interface AnimationStateListener {
                start(entry: TrackEntry): void;
                interrupt(entry: TrackEntry): void;
                end(entry: TrackEntry): void;
                dispose(entry: TrackEntry): void;
                complete(entry: TrackEntry): void;
                event(entry: TrackEntry, event: Event): void;
            }
            export abstract class AnimationStateAdapter implements AnimationStateListener {
                start(entry: TrackEntry): void;
                interrupt(entry: TrackEntry): void;
                end(entry: TrackEntry): void;
                dispose(entry: TrackEntry): void;
                complete(entry: TrackEntry): void;
                event(entry: TrackEntry, event: Event): void;
            }
            export class AnimationStateData {
                skeletonData: SkeletonData;
                animationToMixTime: Map<number>;
                defaultMix: number;
                constructor(skeletonData: SkeletonData);
                setMix(fromName: string, toName: string, duration: number): void;
                setMixWith(from: Animation, to: Animation, duration: number): void;
                getMix(from: Animation, to: Animation): number;
            }
            export class AssetManager implements Disposable {
                constructor(textureLoader: (image: HTMLImageElement) => any, pathPrefix?: string);
                setRawDataURI(path: string, data: string): void;
                loadBinary(path: string, success?: (path: string, binary: Uint8Array) => void, error?: (path: string, error: string) => void): void;
                loadText(path: string, success?: (path: string, text: string) => void, error?: (path: string, error: string) => void): void;
                loadTexture(path: string, success?: (path: string, image: HTMLImageElement) => void, error?: (path: string, error: string) => void): void;
                loadTextureAtlas(path: string, success?: (path: string, atlas: TextureAtlas) => void, error?: (path: string, error: string) => void): void;
                get(path: string): any;
                remove(path: string): void;
                removeAll(): void;
                isLoadingComplete(): boolean;
                getToLoad(): number;
                getLoaded(): number;
                dispose(): void;
                hasErrors(): boolean;
                getErrors(): Map<string>;
            }
            export class AtlasAttachmentLoader implements AttachmentLoader {
                atlas: TextureAtlas;
                constructor(atlas: TextureAtlas);
                newRegionAttachment(skin: Skin, name: string, path: string): RegionAttachment;
                newMeshAttachment(skin: Skin, name: string, path: string): MeshAttachment;
                newBoundingBoxAttachment(skin: Skin, name: string): BoundingBoxAttachment;
                newPathAttachment(skin: Skin, name: string): PathAttachment;
                newPointAttachment(skin: Skin, name: string): PointAttachment;
                newClippingAttachment(skin: Skin, name: string): ClippingAttachment;
            }
            export enum BlendMode {
                Normal = 0,
                Additive = 1,
                Multiply = 2,
                Screen = 3
            }
            export class Bone implements Updatable {
                data: BoneData;
                skeleton: Skeleton;
                parent: Bone;
                children: Bone[];
                x: number;
                y: number;
                rotation: number;
                scaleX: number;
                scaleY: number;
                shearX: number;
                shearY: number;
                ax: number;
                ay: number;
                arotation: number;
                ascaleX: number;
                ascaleY: number;
                ashearX: number;
                ashearY: number;
                appliedValid: boolean;
                a: number;
                b: number;
                c: number;
                d: number;
                worldY: number;
                worldX: number;
                sorted: boolean;
                active: boolean;
                constructor(data: BoneData, skeleton: Skeleton, parent: Bone);
                isActive(): boolean;
                update(): void;
                updateWorldTransform(): void;
                updateWorldTransformWith(x: number, y: number, rotation: number, scaleX: number, scaleY: number, shearX: number, shearY: number): void;
                setToSetupPose(): void;
                getWorldRotationX(): number;
                getWorldRotationY(): number;
                getWorldScaleX(): number;
                getWorldScaleY(): number;
                updateAppliedTransform(): void;
                worldToLocal(world: Vector2): Vector2;
                localToWorld(local: Vector2): Vector2;
                worldToLocalRotation(worldRotation: number): number;
                localToWorldRotation(localRotation: number): number;
                rotateWorld(degrees: number): void;
            }
            export class BoneData {
                index: number;
                name: string;
                parent: BoneData;
                length: number;
                x: number;
                y: number;
                rotation: number;
                scaleX: number;
                scaleY: number;
                shearX: number;
                shearY: number;
                transformMode: TransformMode;
                skinRequired: boolean;
                color: Color;
                constructor(index: number, name: string, parent: BoneData);
            }
            export enum TransformMode {
                Normal = 0,
                OnlyTranslation = 1,
                NoRotationOrReflection = 2,
                NoScale = 3,
                NoScaleOrReflection = 4
            }
            export abstract class ConstraintData {
                name: string;
                order: number;
                skinRequired: boolean;
                constructor(name: string, order: number, skinRequired: boolean);
            }
            export class Event {
                data: EventData;
                intValue: number;
                floatValue: number;
                stringValue: string;
                time: number;
                volume: number;
                balance: number;
                constructor(time: number, data: EventData);
            }
            export class EventData {
                name: string;
                intValue: number;
                floatValue: number;
                stringValue: string;
                audioPath: string;
                volume: number;
                balance: number;
                constructor(name: string);
            }
            export class IkConstraint implements Updatable {
                data: IkConstraintData;
                bones: Array<Bone>;
                target: Bone;
                bendDirection: number;
                compress: boolean;
                stretch: boolean;
                mix: number;
                softness: number;
                active: boolean;
                constructor(data: IkConstraintData, skeleton: Skeleton);
                isActive(): boolean;
                apply(): void;
                update(): void;
                apply1(bone: Bone, targetX: number, targetY: number, compress: boolean, stretch: boolean, uniform: boolean, alpha: number): void;
                apply2(parent: Bone, child: Bone, targetX: number, targetY: number, bendDir: number, stretch: boolean, softness: number, alpha: number): void;
            }
            export class IkConstraintData extends ConstraintData {
                bones: BoneData[];
                target: BoneData;
                bendDirection: number;
                compress: boolean;
                stretch: boolean;
                uniform: boolean;
                mix: number;
                softness: number;
                constructor(name: string);
            }
            export class PathConstraint implements Updatable {
                static NONE: number;
                static BEFORE: number;
                static AFTER: number;
                static epsilon: number;
                data: PathConstraintData;
                bones: Array<Bone>;
                target: Slot;
                position: number;
                spacing: number;
                rotateMix: number;
                translateMix: number;
                spaces: number[];
                positions: number[];
                world: number[];
                curves: number[];
                lengths: number[];
                segments: number[];
                active: boolean;
                constructor(data: PathConstraintData, skeleton: Skeleton);
                isActive(): boolean;
                apply(): void;
                update(): void;
                computeWorldPositions(path: PathAttachment, spacesCount: number, tangents: boolean, percentPosition: boolean, percentSpacing: boolean): number[];
                addBeforePosition(p: number, temp: Array<number>, i: number, out: Array<number>, o: number): void;
                addAfterPosition(p: number, temp: Array<number>, i: number, out: Array<number>, o: number): void;
                addCurvePosition(p: number, x1: number, y1: number, cx1: number, cy1: number, cx2: number, cy2: number, x2: number, y2: number, out: Array<number>, o: number, tangents: boolean): void;
            }
            export class PathConstraintData extends ConstraintData {
                bones: BoneData[];
                target: SlotData;
                positionMode: PositionMode;
                spacingMode: SpacingMode;
                rotateMode: RotateMode;
                offsetRotation: number;
                position: number;
                spacing: number;
                rotateMix: number;
                translateMix: number;
                constructor(name: string);
            }
            export enum PositionMode {
                Fixed = 0,
                Percent = 1
            }
            export enum SpacingMode {
                Length = 0,
                Fixed = 1,
                Percent = 2
            }
            export enum RotateMode {
                Tangent = 0,
                Chain = 1,
                ChainScale = 2
            }
            export class SharedAssetManager implements Disposable {
                constructor(pathPrefix?: string);
                loadText(clientId: string, path: string): void;
                loadJson(clientId: string, path: string): void;
                loadTexture(clientId: string, textureLoader: (image: HTMLImageElement | ImageBitmap) => any, path: string): void;
                get(clientId: string, path: string): any;
                isLoadingComplete(clientId: string): boolean;
                dispose(): void;
                hasErrors(): boolean;
                getErrors(): Map<string>;
            }
            export class Skeleton {
                data: SkeletonData;
                bones: Array<Bone>;
                slots: Array<Slot>;
                drawOrder: Array<Slot>;
                ikConstraints: Array<IkConstraint>;
                transformConstraints: Array<TransformConstraint>;
                pathConstraints: Array<PathConstraint>;
                _updateCache: Updatable[];
                updateCacheReset: Updatable[];
                skin: Skin;
                color: Color;
                time: number;
                scaleX: number;
                scaleY: number;
                x: number;
                y: number;
                constructor(data: SkeletonData);
                updateCache(): void;
                sortIkConstraint(constraint: IkConstraint): void;
                sortPathConstraint(constraint: PathConstraint): void;
                sortTransformConstraint(constraint: TransformConstraint): void;
                sortPathConstraintAttachment(skin: Skin, slotIndex: number, slotBone: Bone): void;
                sortPathConstraintAttachmentWith(attachment: Attachment, slotBone: Bone): void;
                sortBone(bone: Bone): void;
                sortReset(bones: Array<Bone>): void;
                updateWorldTransform(): void;
                setToSetupPose(): void;
                setBonesToSetupPose(): void;
                setSlotsToSetupPose(): void;
                getRootBone(): Bone;
                findBone(boneName: string): Bone;
                findBoneIndex(boneName: string): number;
                findSlot(slotName: string): Slot;
                findSlotIndex(slotName: string): number;
                setSkinByName(skinName: string): void;
                setSkin(newSkin: Skin): void;
                getAttachmentByName(slotName: string, attachmentName: string): Attachment;
                getAttachment(slotIndex: number, attachmentName: string): Attachment;
                setAttachment(slotName: string, attachmentName: string): void;
                findIkConstraint(constraintName: string): IkConstraint;
                findTransformConstraint(constraintName: string): TransformConstraint;
                findPathConstraint(constraintName: string): PathConstraint;
                getBounds(offset: Vector2, size: Vector2, temp?: Array<number>): void;
                update(delta: number): void;
            }
            export class SkeletonBinary {
                static AttachmentTypeValues: number[];
                static TransformModeValues: TransformMode[];
                static PositionModeValues: PositionMode[];
                static SpacingModeValues: SpacingMode[];
                static RotateModeValues: RotateMode[];
                static BlendModeValues: BlendMode[];
                static BONE_ROTATE: number;
                static BONE_TRANSLATE: number;
                static BONE_SCALE: number;
                static BONE_SHEAR: number;
                static SLOT_ATTACHMENT: number;
                static SLOT_COLOR: number;
                static SLOT_TWO_COLOR: number;
                static PATH_POSITION: number;
                static PATH_SPACING: number;
                static PATH_MIX: number;
                static CURVE_LINEAR: number;
                static CURVE_STEPPED: number;
                static CURVE_BEZIER: number;
                scale: number;
                attachmentLoader: AttachmentLoader;
                constructor(attachmentLoader: AttachmentLoader);
                readSkeletonData(binary: Uint8Array): SkeletonData;
                setCurve(timeline: CurveTimeline, frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number): void;
            }
            export class SkeletonBounds {
                minX: number;
                minY: number;
                maxX: number;
                maxY: number;
                boundingBoxes: BoundingBoxAttachment[];
                polygons: ArrayLike<number>[];
                update(skeleton: Skeleton, updateAabb: boolean): void;
                aabbCompute(): void;
                aabbContainsPoint(x: number, y: number): boolean;
                aabbIntersectsSegment(x1: number, y1: number, x2: number, y2: number): boolean;
                aabbIntersectsSkeleton(bounds: SkeletonBounds): boolean;
                containsPoint(x: number, y: number): BoundingBoxAttachment;
                containsPointPolygon(polygon: ArrayLike<number>, x: number, y: number): boolean;
                intersectsSegment(x1: number, y1: number, x2: number, y2: number): BoundingBoxAttachment;
                intersectsSegmentPolygon(polygon: ArrayLike<number>, x1: number, y1: number, x2: number, y2: number): boolean;
                getPolygon(boundingBox: BoundingBoxAttachment): ArrayLike<number>;
                getWidth(): number;
                getHeight(): number;
            }
            export class SkeletonClipping {
                clippedVertices: number[];
                clippedTriangles: number[];
                clipStart(slot: Slot, clip: ClippingAttachment): number;
                clipEndWithSlot(slot: Slot): void;
                clipEnd(): void;
                isClipping(): boolean;
                clipTriangles(vertices: ArrayLike<number>, verticesLength: number, triangles: ArrayLike<number>, trianglesLength: number, uvs: ArrayLike<number>, light: Color, dark: Color, twoColor: boolean, strideFloat?: number, offsetV?: number, offsetI?: number): void;
                clip(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, clippingArea: Array<number>, output: Array<number>): boolean;
                static makeClockwise(polygon: ArrayLike<number>): void;
            }
            export class SkeletonData {
                name: string;
                bones: BoneData[];
                slots: SlotData[];
                skins: Skin[];
                defaultSkin: Skin;
                events: EventData[];
                animations: Animation[];
                ikConstraints: IkConstraintData[];
                transformConstraints: TransformConstraintData[];
                pathConstraints: PathConstraintData[];
                x: number;
                y: number;
                width: number;
                height: number;
                version: string;
                hash: string;
                fps: number;
                imagesPath: string;
                audioPath: string;
                findBone(boneName: string): BoneData;
                findBoneIndex(boneName: string): number;
                findSlot(slotName: string): SlotData;
                findSlotIndex(slotName: string): number;
                findSkin(skinName: string): Skin;
                findEvent(eventDataName: string): EventData;
                findAnimation(animationName: string): Animation;
                findIkConstraint(constraintName: string): IkConstraintData;
                findTransformConstraint(constraintName: string): TransformConstraintData;
                findPathConstraint(constraintName: string): PathConstraintData;
                findPathConstraintIndex(pathConstraintName: string): number;
            }
            export class SkeletonJson {
                attachmentLoader: AttachmentLoader;
                scale: number;
                constructor(attachmentLoader: AttachmentLoader);
                readSkeletonData(json: string | any): SkeletonData;
                readAttachment(map: any, skin: Skin, slotIndex: number, name: string, skeletonData: SkeletonData): Attachment;
                readVertices(map: any, attachment: VertexAttachment, verticesLength: number): void;
                readAnimation(map: any, name: string, skeletonData: SkeletonData): void;
                readCurve(map: any, timeline: CurveTimeline, frameIndex: number): void;
                getValue(map: any, prop: string, defaultValue: any): any;
                static blendModeFromString(str: string): BlendMode;
                static positionModeFromString(str: string): PositionMode;
                static spacingModeFromString(str: string): SpacingMode;
                static rotateModeFromString(str: string): RotateMode;
                static transformModeFromString(str: string): TransformMode;
            }
            export class SkinEntry {
                slotIndex: number;
                name: string;
                attachment: Attachment;
                constructor(slotIndex: number, name: string, attachment: Attachment);
            }
            export class Skin {
                name: string;
                attachments: Map<Attachment>[];
                bones: BoneData[];
                constraints: ConstraintData[];
                constructor(name: string);
                setAttachment(slotIndex: number, name: string, attachment: Attachment): void;
                addSkin(skin: Skin): void;
                copySkin(skin: Skin): void;
                getAttachment(slotIndex: number, name: string): Attachment;
                removeAttachment(slotIndex: number, name: string): void;
                getAttachments(): Array<SkinEntry>;
                getAttachmentsForSlot(slotIndex: number, attachments: Array<SkinEntry>): void;
                clear(): void;
                attachAll(skeleton: Skeleton, oldSkin: Skin): void;
            }
            export class Slot {
                data: SlotData;
                bone: Bone;
                color: Color;
                darkColor: Color;
                attachment: Attachment;
                attachmentState: number;
                deform: number[];
                constructor(data: SlotData, bone: Bone);
                getSkeleton(): Skeleton;
                getAttachment(): Attachment;
                setAttachment(attachment: Attachment): void;
                setAttachmentTime(time: number): void;
                getAttachmentTime(): number;
                setToSetupPose(): void;
            }
            export class SlotData {
                index: number;
                name: string;
                boneData: BoneData;
                color: Color;
                darkColor: Color;
                attachmentName: string;
                blendMode: BlendMode;
                constructor(index: number, name: string, boneData: BoneData);
            }
            export abstract class Texture {
                protected _image: HTMLImageElement | ImageBitmap;
                constructor(image: HTMLImageElement | ImageBitmap);
                getImage(): HTMLImageElement | ImageBitmap;
                abstract setFilters(minFilter: TextureFilter, magFilter: TextureFilter): void;
                abstract setWraps(uWrap: TextureWrap, vWrap: TextureWrap): void;
                abstract dispose(): void;
                static filterFromString(text: string): TextureFilter;
                static wrapFromString(text: string): TextureWrap;
            }
            export enum TextureFilter {
                Nearest = 9728,
                Linear = 9729,
                MipMap = 9987,
                MipMapNearestNearest = 9984,
                MipMapLinearNearest = 9985,
                MipMapNearestLinear = 9986,
                MipMapLinearLinear = 9987
            }
            export enum TextureWrap {
                MirroredRepeat = 33648,
                ClampToEdge = 33071,
                Repeat = 10497
            }
            export class TextureRegion {
                renderObject: any;
                u: number;
                v: number;
                u2: number;
                v2: number;
                width: number;
                height: number;
                rotate: boolean;
                offsetX: number;
                offsetY: number;
                originalWidth: number;
                originalHeight: number;
            }
            export class FakeTexture extends Texture {
                setFilters(minFilter: TextureFilter, magFilter: TextureFilter): void;
                setWraps(uWrap: TextureWrap, vWrap: TextureWrap): void;
                dispose(): void;
            }
            export class TextureAtlas implements Disposable {
                pages: TextureAtlasPage[];
                regions: TextureAtlasRegion[];
                constructor(atlasText: string, textureLoader: (path: string) => any);
                findRegion(name: string): TextureAtlasRegion;
                dispose(): void;
            }
            export class TextureAtlasPage {
                name: string;
                minFilter: TextureFilter;
                magFilter: TextureFilter;
                uWrap: TextureWrap;
                vWrap: TextureWrap;
                texture: Texture;
                width: number;
                height: number;
            }
            export class TextureAtlasRegion extends TextureRegion {
                page: TextureAtlasPage;
                name: string;
                x: number;
                y: number;
                index: number;
                rotate: boolean;
                degrees: number;
                texture: Texture;
            }
            export class TransformConstraint implements Updatable {
                data: TransformConstraintData;
                bones: Array<Bone>;
                target: Bone;
                rotateMix: number;
                translateMix: number;
                scaleMix: number;
                shearMix: number;
                temp: Vector2;
                active: boolean;
                constructor(data: TransformConstraintData, skeleton: Skeleton);
                isActive(): boolean;
                apply(): void;
                update(): void;
                applyAbsoluteWorld(): void;
                applyRelativeWorld(): void;
                applyAbsoluteLocal(): void;
                applyRelativeLocal(): void;
            }
            export class TransformConstraintData extends ConstraintData {
                bones: BoneData[];
                target: BoneData;
                rotateMix: number;
                translateMix: number;
                scaleMix: number;
                shearMix: number;
                offsetRotation: number;
                offsetX: number;
                offsetY: number;
                offsetScaleX: number;
                offsetScaleY: number;
                offsetShearY: number;
                relative: boolean;
                local: boolean;
                constructor(name: string);
            }
            export class Triangulator {
                triangulate(verticesArray: ArrayLike<number>): Array<number>;
                decompose(verticesArray: Array<number>, triangles: Array<number>): Array<Array<number>>;
            }
            export interface Updatable {
                update(): void;
                isActive(): boolean;
            }
            export interface Map<T> {
                [key: string]: T;
            }
            export class IntSet {
                array: number[];
                add(value: number): boolean;
                contains(value: number): boolean;
                remove(value: number): void;
                clear(): void;
            }
            export interface Disposable {
                dispose(): void;
            }
            export interface Restorable {
                restore(): void;
            }
            export class Color {
                r: number;
                g: number;
                b: number;
                a: number;
                static WHITE: Color;
                static RED: Color;
                static GREEN: Color;
                static BLUE: Color;
                static MAGENTA: Color;
                constructor(r?: number, g?: number, b?: number, a?: number);
                set(r: number, g: number, b: number, a: number): this;
                setFromColor(c: Color): this;
                setFromString(hex: string): this;
                add(r: number, g: number, b: number, a: number): this;
                clamp(): this;
                static rgba8888ToColor(color: Color, value: number): void;
                static rgb888ToColor(color: Color, value: number): void;
            }
            export class MathUtils {
                static PI: number;
                static PI2: number;
                static radiansToDegrees: number;
                static radDeg: number;
                static degreesToRadians: number;
                static degRad: number;
                static clamp(value: number, min: number, max: number): number;
                static cosDeg(degrees: number): number;
                static sinDeg(degrees: number): number;
                static signum(value: number): number;
                static toInt(x: number): number;
                static cbrt(x: number): number;
                static randomTriangular(min: number, max: number): number;
                static randomTriangularWith(min: number, max: number, mode: number): number;
            }
            export abstract class Interpolation {
                protected abstract applyInternal(a: number): number;
                apply(start: number, end: number, a: number): number;
            }
            export class Pow extends Interpolation {
                protected power: number;
                constructor(power: number);
                applyInternal(a: number): number;
            }
            export class PowOut extends Pow {
                constructor(power: number);
                applyInternal(a: number): number;
            }
            export class Utils {
                static SUPPORTS_TYPED_ARRAYS: boolean;
                static arrayCopy<T>(source: ArrayLike<T>, sourceStart: number, dest: ArrayLike<T>, destStart: number, numElements: number): void;
                static setArraySize<T>(array: Array<T>, size: number, value?: any): Array<T>;
                static ensureArrayCapacity<T>(array: Array<T>, size: number, value?: any): Array<T>;
                static newArray<T>(size: number, defaultValue: T): Array<T>;
                static newFloatArray(size: number): ArrayLike<number>;
                static newShortArray(size: number): ArrayLike<number>;
                static toFloatArray(array: Array<number>): number[] | Float32Array;
                static toSinglePrecision(value: number): number;
                static webkit602BugfixHelper(alpha: number, blend: MixBlend): void;
                static contains<T>(array: Array<T>, element: T, identity?: boolean): boolean;
            }
            export class DebugUtils {
                static logBones(skeleton: Skeleton): void;
            }
            export class Pool<T> {
                constructor(instantiator: () => T);
                obtain(): T;
                free(item: T): void;
                freeAll(items: ArrayLike<T>): void;
                clear(): void;
            }
            export class Vector2 {
                x: number;
                y: number;
                constructor(x?: number, y?: number);
                set(x: number, y: number): Vector2;
                length(): number;
                normalize(): this;
            }
            export class TimeKeeper {
                maxDelta: number;
                framesPerSecond: number;
                delta: number;
                totalTime: number;
                update(): void;
            }
            export interface ArrayLike<T> {
                length: number;
                [n: number]: T;
            }
            export class WindowedMean {
                values: Array<number>;
                addedValues: number;
                lastValue: number;
                mean: number;
                dirty: boolean;
                constructor(windowSize?: number);
                hasEnoughData(): boolean;
                addValue(value: number): void;
                getMean(): number;
            }
            export interface VertexEffect {
                begin(skeleton: Skeleton): void;
                transform(position: Vector2, uv: Vector2, light: Color, dark: Color): void;
                end(): void;
            }
            export abstract class Attachment {
                name: string;
                constructor(name: string);
                abstract copy(): Attachment;
            }
            export abstract class VertexAttachment extends Attachment {
                id: number;
                bones: Array<number>;
                vertices: ArrayLike<number>;
                worldVerticesLength: number;
                deformAttachment: VertexAttachment;
                constructor(name: string);
                computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: ArrayLike<number>, offset: number, stride: number): void;
                copyTo(attachment: VertexAttachment): void;
            }
            export interface AttachmentLoader {
                newRegionAttachment(skin: Skin, name: string, path: string): RegionAttachment;
                newMeshAttachment(skin: Skin, name: string, path: string): MeshAttachment;
                newBoundingBoxAttachment(skin: Skin, name: string): BoundingBoxAttachment;
                newPathAttachment(skin: Skin, name: string): PathAttachment;
                newPointAttachment(skin: Skin, name: string): PointAttachment;
                newClippingAttachment(skin: Skin, name: string): ClippingAttachment;
            }
            export enum AttachmentType {
                Region = 0,
                BoundingBox = 1,
                Mesh = 2,
                LinkedMesh = 3,
                Path = 4,
                Point = 5,
                Clipping = 6
            }
            export class BoundingBoxAttachment extends VertexAttachment {
                color: Color;
                constructor(name: string);
                copy(): Attachment;
            }
            export class ClippingAttachment extends VertexAttachment {
                endSlot: SlotData;
                color: Color;
                constructor(name: string);
                copy(): Attachment;
            }
            export class MeshAttachment extends VertexAttachment {
                region: TextureRegion;
                path: string;
                regionUVs: ArrayLike<number>;
                uvs: ArrayLike<number>;
                triangles: Array<number>;
                color: Color;
                width: number;
                height: number;
                hullLength: number;
                edges: Array<number>;
                tempColor: Color;
                constructor(name: string);
                updateUVs(): void;
                getParentMesh(): MeshAttachment;
                setParentMesh(parentMesh: MeshAttachment): void;
                copy(): Attachment;
                newLinkedMesh(): MeshAttachment;
            }
            export class PathAttachment extends VertexAttachment {
                lengths: Array<number>;
                closed: boolean;
                constantSpeed: boolean;
                color: Color;
                constructor(name: string);
                copy(): Attachment;
            }
            export class PointAttachment extends VertexAttachment {
                x: number;
                y: number;
                rotation: number;
                color: Color;
                constructor(name: string);
                computeWorldPosition(bone: Bone, point: Vector2): Vector2;
                computeWorldRotation(bone: Bone): number;
                copy(): Attachment;
            }
            export class RegionAttachment extends Attachment {
                static OX1: number;
                static OY1: number;
                static OX2: number;
                static OY2: number;
                static OX3: number;
                static OY3: number;
                static OX4: number;
                static OY4: number;
                static X1: number;
                static Y1: number;
                static C1R: number;
                static C1G: number;
                static C1B: number;
                static C1A: number;
                static U1: number;
                static V1: number;
                static X2: number;
                static Y2: number;
                static C2R: number;
                static C2G: number;
                static C2B: number;
                static C2A: number;
                static U2: number;
                static V2: number;
                static X3: number;
                static Y3: number;
                static C3R: number;
                static C3G: number;
                static C3B: number;
                static C3A: number;
                static U3: number;
                static V3: number;
                static X4: number;
                static Y4: number;
                static C4R: number;
                static C4G: number;
                static C4B: number;
                static C4A: number;
                static U4: number;
                static V4: number;
                x: number;
                y: number;
                scaleX: number;
                scaleY: number;
                rotation: number;
                width: number;
                height: number;
                color: Color;
                path: string;
                rendererObject: any;
                region: TextureRegion;
                offset: ArrayLike<number>;
                uvs: ArrayLike<number>;
                tempColor: Color;
                constructor(name: string);
                updateOffset(): void;
                setRegion(region: TextureRegion): void;
                computeWorldVertices(bone: Bone, worldVertices: ArrayLike<number>, offset: number, stride: number): void;
                copy(): Attachment;
            }
            export class JitterEffect implements VertexEffect {
                jitterX: number;
                jitterY: number;
                constructor(jitterX: number, jitterY: number);
                begin(skeleton: Skeleton): void;
                transform(position: Vector2, uv: Vector2, light: Color, dark: Color): void;
                end(): void;
            }
            export class SwirlEffect implements VertexEffect {
                static interpolation: PowOut;
                centerX: number;
                centerY: number;
                radius: number;
                angle: number;
                constructor(radius: number, interpolation?: Interpolation);
                begin(skeleton: Skeleton): void;
                transform(position: Vector2, uv: Vector2, light: Color, dark: Color): void;
                end(): void;
            }
        }
        /**
         * @en
         * The attachment type of spine. It contains three type: REGION(0), BOUNDING_BOX(1), MESH(2) and SKINNED_MESH
         * @zh
         * Attachment 类型枚举。类型包括 REGION，BOUNDING_BOX，MESH，SKINNED_MESH
         */
        export enum ATTACHMENT_TYPE {
            REGION = 0,
            BOUNDING_BOX = 1,
            MESH = 2,
            SKINNED_MESH = 3
        }
        /**
         * @en The event type of spine skeleton animation.
         * @zh 骨骼动画事件类型。
         * @enum AnimationEventType
         */
        export enum AnimationEventType {
            /**
             * @en The play spine skeleton animation start type.
             * @zh 开始播放骨骼动画。
             * @property {Number} START
             */
            START = 0,
            /**
             * @en Another entry has replaced this entry as the current entry. This entry may continue being applied for mixing.
             * @zh 当前的 entry 被其他的 entry 替换。当使用 mixing 时，当前的 entry 会继续运行。
             */
            INTERRUPT = 1,
            /**
             * @en The play spine skeleton animation finish type.
             * @zh 播放骨骼动画结束。
             * @property {Number} END
             */
            END = 2,
            /**
             * @en The entry will be disposed.
             * @zh entry 将被销毁。
             */
            DISPOSE = 3,
            /**
             * @en The play spine skeleton animation complete type.
             * @zh 播放骨骼动画完成。
             * @property {Number} COMPLETE
             */
            COMPLETE = 4,
            /**
             * @en The spine skeleton animation event type.
             * @zh 骨骼动画事件。
             * @property {Number} EVENT
             */
            EVENT = 5
        }
        export const timeScale = 1;
        export enum DefaultSkinsEnum {
            default = 0
        }
        export enum DefaultAnimsEnum {
            '<None>' = 0
        }
        /**
         * @en Enum for animation cache mode type.
         * @zh Spine动画缓存类型
         */
        export enum AnimationCacheMode {
            /**
             * @en The realtime mode.
             * @zh 实时计算模式。
             */
            REALTIME = 0,
            /**
             * @en The shared cache mode.
             * @zh 共享缓存模式。
             */
            SHARED_CACHE = 1,
            /**
             * @en The private cache mode.
             * @zh 私有缓存模式。
             */
            PRIVATE_CACHE = 2
        }
        export enum SpineMaterialType {
            COLORED_TEXTURED = 0,
            TWO_COLORED = 1
        }
        export interface SkeletonDrawData {
            material: Material | null;
            texture: Texture2D | null;
            indexOffset: number;
            indexCount: number;
        }
        export class SpineSocket {
            /**
             * @en Path of the target joint.
             * @zh 此挂点的目标骨骼路径。
             */
            path: string;
            /**
             * @en Transform output node.
             * @zh 此挂点的变换信息输出节点。
             */
            target: Node | null;
            constructor(path?: string, target?: Node | null);
        }
        /**
         * @en
         * The skeleton of Spine <br/>
         * <br/>
         * (Skeleton has a reference to a SkeletonData and stores the state for skeleton instance,
         * which consists of the current pose's bone SRT, slot colors, and which slot attachments are visible. <br/>
         * Multiple skeletons can use the same SkeletonData which includes all animations, skins, and attachments.) <br/>
         * @zh
         * Spine 骨骼动画 <br/>
         * <br/>
         * (Skeleton 具有对骨骼数据的引用并且存储了骨骼实例的状态，
         * 它由当前的骨骼动作，slot 颜色，和可见的 slot attachments 组成。<br/>
         * 多个 Skeleton 可以使用相同的骨骼数据，其中包括所有的动画，皮肤和 attachments。
         *
         * @class Skeleton
         * @extends UIRenderer
         */
        export class Skeleton extends UIRenderer {
            static SpineSocket: typeof SpineSocket;
            static AnimationCacheMode: typeof AnimationCacheMode;
            get drawList(): memop.RecyclePool<SkeletonDrawData>;
            protected _updateBuiltinMaterial(): Material;
            get customMaterial(): Material | null;
            set customMaterial(val: Material | null);
            protected updateMaterial(): void;
            /**
             * @en The skeletal animation is paused?
             * @zh 该骨骼动画是否暂停。
             * @property paused
             * @type {Boolean}
             * @default false
             */
            get paused(): boolean;
            set paused(value: boolean);
            /** dstBlendFactor
             * @en
             * The skeleton data contains the skeleton information (bind pose bones, slots, draw order,
             * attachments, skins, etc) and animations but does not hold any state.<br/>
             * Multiple skeletons can share the same skeleton data.
             * @zh
             * 骨骼数据包含了骨骼信息（绑定骨骼动作，slots，渲染顺序，
             * attachments，皮肤等等）和动画但不持有任何状态。<br/>
             * 多个 Skeleton 可以共用相同的骨骼数据。
             * @property {sp.SkeletonData} skeletonData
             */
            get skeletonData(): SkeletonData;
            set skeletonData(value: SkeletonData);
            /**
             * @en The name of current playing animation.
             * @zh 当前播放的动画名称。
             * @property {String} animation
             */
            get animation(): string;
            set animation(value: string);
            /**
             * @internal
             */
            get _defaultSkinIndex(): number;
            set _defaultSkinIndex(value: number);
            /**
             * @internal
             */
            get _animationIndex(): number;
            set _animationIndex(value: number);
            get defaultCacheMode(): AnimationCacheMode;
            set defaultCacheMode(mode: AnimationCacheMode);
            /**
             * @en Whether play animations in loop mode
             * @zh 是否循环播放当前骨骼动画。
             */
            loop: boolean;
            get premultipliedAlpha(): boolean;
            set premultipliedAlpha(v: boolean);
            /**
             * @en The time scale of this skeleton.
             * @zh 当前骨骼中所有动画的时间缩放率。
             */
            get timeScale(): number;
            set timeScale(value: number);
            /**
             * @en Indicates whether open debug slots.
             * @zh 是否显示 slot 的 debug 信息。
             */
            get debugSlots(): boolean;
            set debugSlots(v: boolean);
            /**
             * @en Indicates whether open debug bones.
             * @zh 是否显示 bone 的 debug 信息。
             */
            get debugBones(): boolean;
            set debugBones(v: boolean);
            /**
             * @en Indicates whether open debug mesh.
             * @zh 是否显示 mesh 的 debug 信息。
             */
            get debugMesh(): boolean;
            set debugMesh(value: boolean);
            /**
             * @en Enabled two color tint.
             * @zh 是否启用染色效果。
             */
            get useTint(): boolean;
            set useTint(value: boolean);
            get enableBatch(): boolean;
            set enableBatch(value: boolean);
            /**
             * @en
             * The bone sockets this animation component maintains.<br>
             * Sockets have to be registered here before attaching custom nodes to animated bones.
             * @zh
             * 当前动画组件维护的挂点数组。要挂载自定义节点到受动画驱动的骨骼上，必须先在此注册挂点。
             */
            get sockets(): SpineSocket[];
            set sockets(val: SpineSocket[]);
            get socketNodes(): Map<number, Node>;
            /**
             * @internal
             */
            _frameCache: __private._cocos_spine_skeleton_cache__AnimationCache | null;
            /**
             * @internal
             */
            _curFrame: __private._cocos_spine_skeleton_cache__AnimationFrame | null;
            /**
             * @internal
             */
            _effectDelegate: VertexEffectDelegate | null | undefined;
            /**
             * @internal
             */
            _skeleton: spine.Skeleton | null;
            /**
             * @internal
             */
            _clipper?: spine.SkeletonClipping;
            /**
             * @internal
             */
            _debugRenderer: Graphics | null;
            /**
             * @internal
             */
            _startSlotIndex: any;
            /**
             * @internal
             */
            _endSlotIndex: any;
            /**
             * @internal
             */
            _startEntry: any;
            /**
             * @internal
             */
            _endEntry: any;
            /**
             * @internal
             */
            attachUtil: __private._cocos_spine_attach_util__AttachUtil;
            /**
             * @internal
             */
            maxVertexCount: number;
            /**
             * @internal
             */
            maxIndexCount: number;
            protected _materialCache: {
                [key: string]: renderer.MaterialInstance;
            };
            protected _enumSkins: any;
            protected _enumAnimations: any;
            protected _playTimes: number;
            protected _timeScale: number;
            protected _paused: boolean;
            protected _accTime: number;
            protected _playCount: number;
            protected _skeletonCache: __private._cocos_spine_skeleton_cache__SkeletonCache | null;
            protected _animationName: string;
            protected _animationQueue: __private._cocos_spine_skeleton__AnimationItem[];
            protected _headAniInfo: __private._cocos_spine_skeleton__AnimationItem | null;
            protected _isAniComplete: boolean;
            protected _needUpdateSkeltonData: boolean;
            protected _useTint: boolean;
            protected _preCacheMode: number;
            protected _cacheMode: AnimationCacheMode;
            protected _defaultCacheMode: AnimationCacheMode;
            protected _debugBones: boolean;
            protected _debugSlots: boolean;
            protected _skeletonData: SkeletonData | null;
            /**
             * @en Indicates whether to enable premultiplied alpha.
             * You should disable this option when image's transparent area appears to have opaque pixels,
             * or enable this option when image's half transparent area appears to be darken.
             * @zh 是否启用贴图预乘。
             * 当图片的透明区域出现色块时需要关闭该选项，当图片的半透明区域颜色变黑时需要启用该选项。
             */
            protected _premultipliedAlpha: boolean;
            /**
             * @en
             * The name of default skin.
             * @zh
             * 默认的皮肤名称。
             * @property {String} defaultSkin
             */
            protected defaultSkin: string;
            /**
             * @en
             * The name of default animation.
             * @zh
             * 默认的动画名称。
             * @property {String} defaultAnimation
             */
            protected defaultAnimation: string;
            protected _enableBatch: boolean;
            protected _sockets: SpineSocket[];
            protected _drawIdx: number;
            protected _drawList: memop.RecyclePool<SkeletonDrawData>;
            protected _debugMesh: boolean;
            protected _rootBone: spine.Bone | null;
            protected _state?: spine.AnimationState;
            protected _listener: spine.AnimationStateListener | null;
            protected _socketNodes: Map<number, Node>;
            protected _cachedSockets: Map<string, number>;
            constructor();
            /**
             * @en
             * Sets runtime skeleton data to sp.Skeleton.<br>
             * This method is different from the `skeletonData` property. This method is passed in the raw data provided by the
             *  Spine runtime, and the skeletonData type is the asset type provided by Creator.
             * @zh
             * 设置底层运行时用到的 SkeletonData。<br>
             * 这个接口有别于 `skeletonData` 属性，这个接口传入的是 Spine runtime 提供的原始数据，而 skeletonData 的类型是 Creator 提供的资源类型。
             * @method setSkeletonData
             * @param {sp.spine.SkeletonData} skeletonData
             */
            setSkeletonData(skeletonData: spine.SkeletonData): void;
            /**
             * @en Sets slots visible range.
             * @zh 设置骨骼插槽可视范围。
             */
            setSlotsRange(startSlotIndex: any, endSlotIndex: any): void;
            /**
             * @en Sets animation state data.<br>
             * The parameter type is {{#crossLinkModule "sp.spine"}}sp.spine{{/crossLinkModule}}.AnimationStateData.
             * @zh 设置动画状态数据。<br>
             * 参数是 {{#crossLinkModule "sp.spine"}}sp.spine{{/crossLinkModule}}.AnimationStateData。
             */
            setAnimationStateData(stateData: any): void;
            __preload(): void;
            /**
             * @en
             * It's best to set cache mode before set property 'dragonAsset', or will waste some cpu time.
             * If set the mode in editor, then no need to worry about order problem.
             * @zh
             * 若想切换渲染模式，最好在设置'dragonAsset'之前，先设置好渲染模式，否则有运行时开销。
             * 若在编辑中设置渲染模式，则无需担心设置次序的问题。
             *
             * @example
             * skeleton.setAnimationCacheMode(sp.Skeleton.AnimationCacheMode.SHARED_CACHE);
             */
            setAnimationCacheMode(cacheMode: AnimationCacheMode): void;
            /**
             * @en Whether in cached mode.
             * @zh 当前是否处于缓存模式。
             */
            isAnimationCached(): boolean;
            updateAnimation(dt: number): void;
            /**
             * @en Sets vertex effect delegate.
             * @zh 设置顶点动画代理
             */
            setVertexEffectDelegate(effectDelegate: VertexEffectDelegate | null | undefined): void;
            /**
             * @en Sets the bones and slots to the setup pose.
             * @zh 还原到起始动作
             * @method setToSetupPose
             */
            setToSetupPose(): void;
            /**
             * @en
             * Sets the bones to the setup pose,
             * using the values from the `BoneData` list in the `SkeletonData`.
             * @zh
             * 设置 bone 到起始动作
             * 使用 SkeletonData 中的 BoneData 列表中的值。
             * @method setBonesToSetupPose
             */
            setBonesToSetupPose(): void;
            /**
             * @en
             * Sets the slots to the setup pose,
             * using the values from the `SlotData` list in the `SkeletonData`.
             * @zh
             * 设置 slot 到起始动作。
             * 使用 SkeletonData 中的 SlotData 列表中的值。
             * @method setSlotsToSetupPose
             */
            setSlotsToSetupPose(): void;
            /**
             * @en
             * Updating an animation cache to calculate all frame data in the animation is a cost in
             * performance due to calculating all data in a single frame.
             * To update the cache, use the invalidAnimationCache method with high performance.
             * @zh
             * 更新某个动画缓存, 预计算动画中所有帧数据，由于在单帧计算所有数据，所以较消耗性能。
             * 若想更新缓存，可使用 invalidAnimationCache 方法，具有较高性能。
             * @method updateAnimationCache
             * @param {String} animName
             */
            updateAnimationCache(animName: any): void;
            /**
             * @en
             * Invalidates the animation cache, which is then recomputed on each frame..
             * @zh
             * 使动画缓存失效，之后会在每帧重新计算。
             * @method invalidAnimationCache
             */
            invalidAnimationCache(): void;
            /**
             * @en
             * Finds a bone by name.
             * This does a string comparison for every bone.<br>
             * Returns a {{#crossLinkModule "sp.spine"}}sp.spine{{/crossLinkModule}}.Bone object.
             * @zh
             * 通过名称查找 bone。
             * 这里对每个 bone 的名称进行了对比。<br>
             * 返回一个 {{#crossLinkModule "sp.spine"}}sp.spine{{/crossLinkModule}}.Bone 对象。
             *
             * @method findBone
             * @param {String} boneName
             * @return {sp.spine.Bone}
             */
            findBone(boneName: string): spine.Bone | null;
            /**
             * @en
             * Finds a slot by name. This does a string comparison for every slot.<br>
             * Returns a {{#crossLinkModule "sp.spine"}}sp.spine{{/crossLinkModule}}.Slot object.
             * @zh
             * 通过名称查找 slot。这里对每个 slot 的名称进行了比较。<br>
             * 返回一个 {{#crossLinkModule "sp.spine"}}sp.spine{{/crossLinkModule}}.Slot 对象。
             *
             * @method findSlot
             * @param {String} slotName
             * @return {sp.spine.Slot}
             */
            findSlot(slotName: string): spine.Slot | null;
            /**
             * @en
             * Finds a skin by name and makes it the active skin.
             * This does a string comparison for every skin.<br>
             * Note that setting the skin does not change which attachments are visible.<br>
             * Returns a {{#crossLinkModule "sp.spine"}}sp.spine{{/crossLinkModule}}.Skin object.
             * @zh
             * 按名称查找皮肤，激活该皮肤。这里对每个皮肤的名称进行了比较。<br>
             * 注意：设置皮肤不会改变 attachment 的可见性。<br>
             * 返回一个 {{#crossLinkModule "sp.spine"}}sp.spine{{/crossLinkModule}}.Skin 对象。
             *
             * @method setSkin
             * @param {String} skinName
             */
            setSkin(skinName: string): void;
            /**
             * @en
             * Returns the attachment for the slot and attachment name.
             * The skeleton looks first in its skin, then in the skeleton data’s default skin.<br>
             * Returns a {{#crossLinkModule "sp.spine"}}sp.spine{{/crossLinkModule}}.Attachment object.
             * @zh
             * 通过 slot 和 attachment 的名称获取 attachment。Skeleton 优先查找它的皮肤，然后才是 Skeleton Data 中默认的皮肤。<br>
             * 返回一个 {{#crossLinkModule "sp.spine"}}sp.spine{{/crossLinkModule}}.Attachment 对象。
             *
             * @method getAttachment
             * @param {String} slotName
             * @param {String} attachmentName
             * @return {sp.spine.Attachment}
             */
            getAttachment(slotName: string, attachmentName: string): spine.Attachment | null;
            /**
             * @en
             * Sets the attachment for the slot and attachment name.
             * The skeleton looks first in its skin, then in the skeleton data’s default skin.
             * @zh
             * 通过 slot 和 attachment 的名字来设置 attachment。
             * Skeleton 优先查找它的皮肤，然后才是 Skeleton Data 中默认的皮肤。
             * @method setAttachment
             * @param {String} slotName
             * @param {String} attachmentName
             */
            setAttachment(slotName: string, attachmentName: string): void;
            /**
             * Return the renderer of attachment.
             * @method getTextureAtlas
             * @param {sp.spine.RegionAttachment|spine.BoundingBoxAttachment} regionAttachment
             * @return {sp.spine.TextureAtlasRegion}
             */
            getTextureAtlas(regionAttachment: spine.RegionAttachment | spine.BoundingBoxAttachment): spine.TextureRegion;
            /**
             * @en
             * Mix applies all keyframe values,
             * interpolated for the specified time and mixed with the current values.
             * @zh 为所有关键帧设定混合及混合时间（从当前值开始差值）。
             * @method setMix
             * @param {String} fromAnimation
             * @param {String} toAnimation
             * @param {Number} duration
             */
            setMix(fromAnimation: string, toAnimation: string, duration: number): void;
            /**
             * @en Set the current animation. Any queued animations are cleared.<br>
             * Returns a {{#crossLinkModule "sp.spine"}}sp.spine{{/crossLinkModule}}.TrackEntry object.
             * @zh 设置当前动画。队列中的任何的动画将被清除。<br>
             * 返回一个 {{#crossLinkModule "sp.spine"}}sp.spine{{/crossLinkModule}}.TrackEntry 对象。
             * @method setAnimation
             * @param {Number} trackIndex
             * @param {String} name
             * @param {Boolean} loop
             * @return {sp.spine.TrackEntry}
             */
            setAnimation(trackIndex: number, name: string, loop: boolean): spine.TrackEntry | null;
            /**
             * @en Adds an animation to be played delay seconds after the current or last queued animation.<br>
             * Returns a {{#crossLinkModule "sp.spine"}}sp.spine{{/crossLinkModule}}.TrackEntry object.
             * @zh 添加一个动画到动画队列尾部，还可以延迟指定的秒数。<br>
             * 返回一个 {{#crossLinkModule "sp.spine"}}sp.spine{{/crossLinkModule}}.TrackEntry 对象。
             * @method addAnimation
             * @param {Number} trackIndex
             * @param {String} name
             * @param {Boolean} loop
             * @param {Number} [delay=0]
             * @return {sp.spine.TrackEntry}
             */
            addAnimation(trackIndex: number, name: string, loop: boolean, delay?: number): spine.TrackEntry | null | undefined;
            /**
             * @en Find animation with specified name.
             * @zh 查找指定名称的动画
             * @method findAnimation
             * @param {String} name
             * @returns {sp.spine.Animation}
             */
            findAnimation(name: string): spine.Animation | null;
            /**
             * @en Returns track entry by trackIndex.<br>
             * Returns a {{#crossLinkModule "sp.spine"}}sp.spine{{/crossLinkModule}}.TrackEntry object.
             * @zh 通过 track 索引获取 TrackEntry。<br>
             * 返回一个 {{#crossLinkModule "sp.spine"}}sp.spine{{/crossLinkModule}}.TrackEntry 对象。
             * @method getCurrent
             * @param trackIndex
             * @return {sp.spine.TrackEntry}
             */
            getCurrent(trackIndex: number): spine.TrackEntry | null;
            /**
             * @en Clears all tracks of animation state.
             * @zh 清除所有 track 的动画状态。
             * @method clearTracks
             */
            clearTracks(): void;
            /**
             * @en Clears track of animation state by trackIndex.
             * @zh 清除出指定 track 的动画状态。
             * @method clearTrack
             * @param {number} trackIndex
             */
            clearTrack(trackIndex: number): void;
            /**
             * @en Set the start event listener.
             * @zh 用来设置开始播放动画的事件监听。
             * @method setStartListener
             * @param {function} listener
             */
            setStartListener(listener: __private._cocos_spine_skeleton__TrackListener): void;
            /**
             * @en Set the interrupt event listener.
             * @zh 用来设置动画被打断的事件监听。
             * @method setInterruptListener
             * @param {function} listener
             */
            setInterruptListener(listener: __private._cocos_spine_skeleton__TrackListener): void;
            /**
             * @en Set the end event listener.
             * @zh 用来设置动画播放完后的事件监听。
             * @method setEndListener
             * @param {function} listener
             */
            setEndListener(listener: __private._cocos_spine_skeleton__TrackListener): void;
            /**
             * @en Set the dispose event listener.
             * @zh 用来设置动画将被销毁的事件监听。
             * @method setDisposeListener
             * @param {function} listener
             */
            setDisposeListener(listener: __private._cocos_spine_skeleton__TrackListener): void;
            /**
             * @en Set the complete event listener.
             * @zh 用来设置动画播放一次循环结束后的事件监听。
             * @method setCompleteListener
             * @param {function} listener
             */
            setCompleteListener(listener: __private._cocos_spine_skeleton__TrackListener): void;
            /**
             * @en Set the animation event listener.
             * @zh 用来设置动画播放过程中帧事件的监听。
             * @method setEventListener
             * @param {function} listener
             */
            setEventListener(listener: __private._cocos_spine_skeleton__TrackListener2): void;
            /**
             * @en Set the start event listener for specified TrackEntry.
             * @zh 用来为指定的 TrackEntry 设置动画开始播放的事件监听。
             * @method setTrackStartListener
             * @param {sp.spine.TrackEntry} entry
             * @param {function} listener
             */
            setTrackStartListener(entry: spine.TrackEntry, listener: __private._cocos_spine_skeleton__TrackListener): void;
            /**
             * @en Set the interrupt event listener for specified TrackEntry.
             * @zh 用来为指定的 TrackEntry 设置动画被打断的事件监听。
             * @method setTrackInterruptListener
             * @param {sp.spine.TrackEntry} entry
             * @param {function} listener
             */
            setTrackInterruptListener(entry: spine.TrackEntry, listener: __private._cocos_spine_skeleton__TrackListener): void;
            /**
             * @en Set the end event listener for specified TrackEntry.
             * @zh 用来为指定的 TrackEntry 设置动画播放结束的事件监听。
             * @method setTrackEndListener
             * @param {sp.spine.TrackEntry} entry
             * @param {function} listener
             */
            setTrackEndListener(entry: spine.TrackEntry, listener: __private._cocos_spine_skeleton__TrackListener): void;
            /**
             * @en Set the dispose event listener for specified TrackEntry.
             * @zh 用来为指定的 TrackEntry 设置动画即将被销毁的事件监听。
             * @method setTrackDisposeListener
             * @param {sp.spine.TrackEntry} entry
             * @param {function} listener
             */
            setTrackDisposeListener(entry: spine.TrackEntry, listener: __private._cocos_spine_skeleton__TrackListener): void;
            /**
             * @en Set the complete event listener for specified TrackEntry.
             * @zh 用来为指定的 TrackEntry 设置动画一次循环播放结束的事件监听。
             * @method setTrackCompleteListener
             * @param {sp.spine.TrackEntry} entry
             * @param {function} listener
             * @param {sp.spine.TrackEntry} listener.entry
             * @param {Number} listener.loopCount
             */
            setTrackCompleteListener(entry: spine.TrackEntry, listener: __private._cocos_spine_skeleton__TrackListener2): void;
            /**
             * @en Set the event listener for specified TrackEntry.
             * @zh 用来为指定的 TrackEntry 设置动画帧事件的监听。
             * @method setTrackEventListener
             * @param {sp.spine.TrackEntry} entry
             * @param {function} listener
             */
            setTrackEventListener(entry: spine.TrackEntry, listener: __private._cocos_spine_skeleton__TrackListener | __private._cocos_spine_skeleton__TrackListener2): void;
            /**
             * @en Get the animation state object
             * @zh 获取动画状态
             * @method getState
             * @return {sp.spine.AnimationState} state
             */
            getState(): spine.AnimationState | undefined;
            onEnable(): void;
            onDisable(): void;
            onDestroy(): void;
            destroyRenderData(): void;
            getMaterialForBlendAndTint(src: gfx.BlendFactor, dst: gfx.BlendFactor, type: SpineMaterialType): renderer.MaterialInstance;
            onRestore(): void;
            querySockets(): string[];
            /**
             * @internal
             */
            _requestDrawData(material: Material, texture: Texture2D, indexOffset: number, indexCount: number): SkeletonDrawData;
            protected _render(batcher: UI): void;
            /**
             * @en Computes the world SRT from the local SRT for each bone.
             * @zh 重新更新所有骨骼的世界 Transform，
             * 当获取 bone 的数值未更新时，即可使用该函数进行更新数值。
             * @method updateWorldTransform
             * @example
             * var bone = spine.findBone('head');
             * cc.log(bone.worldX); // return 0;
             * spine.updateWorldTransform();
             * bone = spine.findBone('head');
             * cc.log(bone.worldX); // return -23.12;
             */
            protected updateWorldTransform(): void;
            protected _emitCacheCompleteEvent(): void;
            protected _updateCache(dt: number): void;
            protected _updateRealtime(dt: number): void;
            protected _indexBoneSockets(): void;
            protected _updateUseTint(): void;
            protected _updateBatch(): void;
            protected _updateAnimEnum(): void;
            protected _updateSkinEnum(): void;
            protected _ensureListener(): void;
            protected _updateSkeletonData(): void;
            protected _refreshInspector(): void;
            protected _updateDebugDraw(): void;
            protected _flushAssembler(): void;
            protected _updateSocketBindings(): void;
            protected createRenderEntity(): __private._cocos_2d_renderer_render_entity__RenderEntity;
            markForUpdateRenderData(enable?: boolean): void;
        }
        /**
         * @en The skeleton data of spine.
         * @zh Spine 的 骨骼数据。
         * @class SkeletonData
         * @extends Asset
         */
        export class SkeletonData extends Asset {
            /**
             * @en See http://en.esotericsoftware.com/spine-json-format
             * @zh 可查看 Spine 官方文档 http://zh.esotericsoftware.com/spine-json-format
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _skeletonJson: spine.SkeletonJson | null;
            get skeletonJsonStr(): string;
            /**
             * @en See http://en.esotericsoftware.com/spine-json-format
             * @zh 可查看 Spine 官方文档 http://zh.esotericsoftware.com/spine-json-format
             * @property {Object} skeletonJson
             */
            get skeletonJson(): spine.SkeletonJson;
            set skeletonJson(value: spine.SkeletonJson);
            /**
             * @property {String} atlasText
             */
            get atlasText(): string;
            set atlasText(value: string);
            /**
             * @en Texture array
             * @zh 纹理数组
             * @property {Texture2D[]} textures
             */
            textures: Texture2D[];
            /**
             * @property {String[]} textureNames
             * @private
             */
            textureNames: string[];
            /**
             * @en
             * A scale can be specified on the JSON or binary loader which will scale the bone positions,
             * image sizes, and animation translations.
             * This can be useful when using different sized images than were used when design ing the skeleton
             * in Spine. For example, if using images that are half the size than were used in Spine,
             * a scale of 0.5 can be used. This is commonly used for games that can run with either low or high
             * resolution texture atlases.
             * see http://en.esotericsoftware.com/spine-using-runtimes#Scaling
             * @zh 可查看 Spine 官方文档： http://zh.esotericsoftware.com/spine-using-runtimes#Scaling
             * @property {Number} scale
             */
            scale: number;
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            get _nativeAsset(): ArrayBuffer;
            set _nativeAsset(bin: ArrayBuffer);
            protected _atlasText: string;
            constructor();
            createNode(callback: (err: Error | null, node: Node) => void): void;
            reset(): void;
            resetEnums(): void;
            /**
             * @en Get the included SkeletonData used in spine runtime.<br>
             * Returns a {{#crossLinkModule "sp.spine"}}sp.spine{{/crossLinkModule}}.SkeletonData object.
             * @zh 获取 Spine Runtime 使用的 SkeletonData。<br>
             * 返回一个 {{#crossLinkModule "sp.spine"}}sp.spine{{/crossLinkModule}}.SkeletonData 对象。
             * @method getRuntimeData
             * @param {Boolean} [quiet=false]
             * @return {sp.spine.SkeletonData}
             */
            getRuntimeData(quiet?: boolean): spine.SkeletonData | null;
            getSkinsEnum(): {
                [key: string]: number;
            } | null;
            getAnimsEnum(): {
                [key: string]: number;
            } | null;
            destroy(): boolean;
        }
        export function convertFilter(filter: spine.TextureFilter): __private._cocos_core_assets_asset_enum__Filter;
        export function convertWraps(wrap: spine.TextureWrap): __private._cocos_core_assets_asset_enum__WrapMode;
        export class SkeletonTexture extends spine.Texture {
            name: string;
            _texture: Texture2D | null;
            _material: Material | null;
            constructor(opt: ImageBitmap | HTMLImageElement);
            setRealTexture(tex: Texture2D): void;
            getRealTexture(): Texture2D | null;
            setFilters(minFilter: spine.TextureFilter, magFilter: spine.TextureFilter): void;
            setWraps(uWrap: spine.TextureWrap, vWrap: spine.TextureWrap): void;
            dispose(): void;
        }
        /**
         * @en
         * The delegate of spine vertex effect
         * @zh
         * Spine 顶点动画代理
         * @class VertexEffectDelegate
         */
        export class VertexEffectDelegate {
            name: string;
            _vertexEffect: spine.VertexEffect | null;
            _interpolation: spine.Interpolation | null;
            _effectType: string;
            constructor();
            /**
             * @en Clears vertex effect.
             * @zh 清空顶点效果
             * @method clear
             */
            clear(): void;
            /**
             * @en Inits delegate with jitter effect
             * @zh 设置顶点抖动效果
             * @method initJitter
             * @param {Number} jitterX
             * @param {Number} jitterY
             */
            initJitter(jitterX: number, jitterY: number): spine.VertexEffect;
            /**
             * @en Inits delegate with swirl effect
             * @zh 设置顶点漩涡效果
             * @method initSwirlWithPow
             * @param {Number} radius
             * @param {Number} power
             * @return {sp.spine.JitterEffect}
             */
            initSwirlWithPow(radius: number, power: number): spine.VertexEffect;
            /**
             * @en Inits delegate with swirl effect
             * @zh 设置顶点漩涡效果
             * @method initSwirlWithPowOut
             * @param {Number} radius
             * @param {Number} power
             * @return {sp.spine.SwirlEffect}
             */
            initSwirlWithPowOut(radius: number, power: number): spine.VertexEffect;
            /**
             * @en Gets jitter vertex effect
             * @zh 获取顶点抖动效果
             * @method getJitterVertexEffect
             * @return {sp.spine.JitterEffect}
             */
            getJitterVertexEffect(): spine.VertexEffect | null;
            /**
             * @en Gets swirl vertex effect
             * @zh 获取顶点漩涡效果
             * @method getSwirlVertexEffect
             * @return {sp.spine.SwirlEffect}
             */
            getSwirlVertexEffect(): spine.VertexEffect | null;
            /**
             * @en Gets vertex effect
             * @zh 获取顶点效果
             * @method getVertexEffect
             * @return {sp.spine.JitterEffect|sp.spine.SwirlEffect}
             */
            getVertexEffect(): spine.VertexEffect | null;
            /**
             * @en Gets effect type
             * @zh 获取效果类型
             * @method getEffectType
             * @return {String}
             */
            getEffectType(): string;
        }
        export const simpleSpineAssembler: IAssemblerManager;
    }
    export class HeightField {
        data: Uint16Array;
        w: number;
        h: number;
        constructor(w: number, h: number);
        set(i: number, j: number, value: number): void;
        get(i: number, j: number): number;
        getClamp(i: number, j: number): number;
        getAt(x: number, y: number): number;
    }
    /**
     * @en Terrain info
     * @zh 地形信息
     */
    export class TerrainInfo {
        /**
         * @en tile size
         * @zh 栅格大小
         */
        tileSize: number;
        /**
         * @en block count
         * @zh 地形块的数量
         */
        blockCount: number[];
        /**
         * @en weight map size
         * @zh 权重图大小
         */
        weightMapSize: number;
        /**
         * @en light map size
         * @zh 光照图大小
         */
        lightMapSize: number;
        /**
         * @en terrain size
         * @zh 地形大小
         */
        get size(): math.Size;
        /**
         * @en tile count
         * @zh 栅格数量
         */
        get tileCount(): number[];
        /**
         * @en vertex count
         * @zh 顶点数量
         */
        get vertexCount(): number[];
    }
    /**
     * @en Terrain layer
     * @zh 地形纹理层
     */
    export class TerrainLayer {
        /**
         * @en detail texture
         * @zh 细节纹理
         */
        detailMap: Texture2D | null;
        /**
         * @en normal texture
         * @zh 法线纹理
         */
        normalMap: Texture2D | null;
        /**
         * @en tile size
         * @zh 平铺大小
         */
        tileSize: number;
        /**
         * @en metallic
         * @zh 金属性
         */
        metallic: number;
        /**
         * @en roughness
         * @zh 粗糙度
         */
        roughness: number;
    }
    /**
     * @en Terrain block light map info
     * @zh 地形块光照图信息
     */
    export class TerrainBlockLightmapInfo {
        texture: Texture2D | null;
        UOff: number;
        VOff: number;
        UScale: number;
        VScale: number;
    }
    /**
     * @en Terrain block
     * @zh 地形块
     */
    export class TerrainBlock {
        constructor(t: Terrain, i: number, j: number);
        build(): void;
        rebuild(): void;
        destroy(): void;
        update(): void;
        setBrushMaterial(mtl: Material | null): void;
        _getBrushMaterial(): Material | null;
        _getBrushPass(): renderer.Pass | null;
        /**
         * @en valid
         * @zh 是否有效
         */
        get valid(): boolean;
        /**
         * @en get current material
         * @zh 获得当前的材质
         */
        get material(): Material | null;
        /**
         * @en get layers
         * @zh 获得纹理层索引
         */
        get layers(): number[];
        /**
         * @en get weight map
         * @zh 获得权重图
         */
        get weightmap(): Texture2D | null;
        /**
         * @en get light map
         * @zh 获得光照图
         */
        get lightmap(): Texture2D | null;
        /**
         * @en get light map uv parameter
         * @zh 获得光照图纹理坐标参数
         */
        get lightmapUVParam(): math.Vec4;
        /**
         * @zh 地形块的可见性
         * @en The visibility of the block
         */
        set visible(val: boolean);
        get visible(): boolean;
        /**
         * @en get terrain owner
         * @zh 获得地形对象
         */
        getTerrain(): Terrain;
        /**
         * @en get index
         * @zh 获得地形索引
         */
        getIndex(): number[];
        /**
         * @en get rect bound
         * @zh 获得地形矩形包围体
         */
        getRect(): math.Rect;
        /**
         * @en set layer
         * @zh 设置纹理层
         */
        setLayer(index: number, layerId: number): void;
        /**
         * @en get layer
         * @zh 获得纹理层
         */
        getLayer(index: number): number;
        /**
         * @en get max layer index
         * @zh 获得最大纹理索引
         */
        getMaxLayer(): 0 | 1 | 3 | 2;
        _getMaterialDefines(nlayers: number): renderer.MacroRecord;
        _invalidMaterial(): void;
        _updateMaterial(init: boolean): void;
        _updateHeight(): void;
        _updateWeightMap(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _updateLightmap(info: TerrainBlockLightmapInfo): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _updateLod(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _resetLod(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _updateIndexBuffer(): void;
    }
    /**
     * @en Terrain
     * @zh 地形组件
     */
    export class Terrain extends Component {
        protected __asset: TerrainAsset | null;
        protected _effectAsset: EffectAsset | null;
        protected _lightmapInfos: TerrainBlockLightmapInfo[];
        protected _receiveShadow: boolean;
        protected _useNormalmap: boolean;
        protected _usePBR: boolean;
        protected _lodEnable: boolean;
        protected _lodBias: number;
        protected _buitinAsset: TerrainAsset | null;
        protected _tileSize: number;
        protected _blockCount: number[];
        protected _weightMapSize: number;
        protected _lightMapSize: number;
        protected _heights: Uint16Array;
        protected _weights: Uint8Array;
        protected _normals: Float32Array;
        protected _layerList: (TerrainLayer | null)[];
        protected _layerBuffer: number[];
        protected _blocks: TerrainBlock[];
        protected _lod: __private._cocos_terrain_terrain_lod__TerrainLod | null;
        protected _sharedIndexBuffer: gfx.Buffer | null;
        protected _sharedLodIndexBuffer: gfx.Buffer | null;
        constructor();
        set _asset(value: TerrainAsset | null);
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        get _asset(): TerrainAsset | null;
        /**
         * @en Terrain effect asset
         * @zh 地形特效资源
         */
        set effectAsset(value: EffectAsset | null);
        get effectAsset(): EffectAsset | null;
        /**
         * @en Receive shadow
         * @zh 是否接受阴影
         */
        get receiveShadow(): boolean;
        set receiveShadow(val: boolean);
        /**
         * @en Use normal map
         * @zh 是否使用法线贴图
         */
        get useNormalMap(): boolean;
        set useNormalMap(val: boolean);
        /**
         * @en Use pbr material
         * @zh 是否使用物理材质
         */
        get usePBR(): boolean;
        set usePBR(val: boolean);
        /**
         * @en Enable lod
         * @zh 是否允许lod
         */
        get lodEnable(): boolean;
        set lodEnable(val: boolean);
        /**
         * @en Lod bias
         * @zh Lod偏移距离
         */
        get LodBias(): number;
        set LodBias(val: number);
        /**
         * @en get terrain size
         * @zh 获得地形大小
         */
        get size(): math.Size;
        /**
         * @en get tile size
         * @zh 获得栅格大小
         */
        get tileSize(): number;
        /**
         * @en get tile count
         * @zh 获得栅格数量
         */
        get tileCount(): number[];
        /**
         * @en get vertex count
         * @zh 获得顶点数量
         */
        get vertexCount(): number[];
        /**
         * @en get block count
         * @zh 获得地形块数量
         */
        get blockCount(): number[];
        /**
         * @en get light map size
         * @zh 获得光照图大小
         */
        get lightMapSize(): number;
        /**
         * @en get weight map size
         * @zh 获得权重图大小
         */
        get weightMapSize(): number;
        /**
         * @en get height buffer
         * @zh 获得高度缓存
         */
        get heights(): Uint16Array;
        /**
         * @en get weight buffer
         * @zh 获得权重缓存
         */
        get weights(): Uint8Array;
        /**
         * @en check valid
         * @zh 检测是否有效
         */
        get valid(): boolean;
        /**
         * @en get terrain info
         * @zh 获得地形信息
         */
        get info(): TerrainInfo;
        /**
         * @en build
         * @zh 构建地形
         */
        build(info: TerrainInfo): void;
        /**
         * @en rebuild
         * @zh 重建地形
         */
        rebuild(info: TerrainInfo): void;
        /**
         * @en import height field
         * @zh 导入高度图
         */
        importHeightField(hf: HeightField, heightScale: number): void;
        /**
         * @en export height field
         * @zh 导出高度图
         */
        exportHeightField(hf: HeightField, heightScale: number): void;
        exportAsset(): TerrainAsset;
        exportLayerListToAsset(asset: TerrainAsset): void;
        getEffectAsset(): EffectAsset;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        onRestore(): void;
        update(deltaTime: number): void;
        onUpdateFromCamera(cam: renderer.scene.Camera): void;
        /**
         * @en add layer
         * @zh 添加纹理层
         */
        addLayer(layer: TerrainLayer): number;
        /**
         * @en set layer
         * @zh 设置纹理层
         */
        setLayer(i: number, layer: TerrainLayer): void;
        /**
         * @en remove layer
         * @zh 移除纹理层
         */
        removeLayer(id: number): void;
        /**
         * @en get layer
         * @zh 获得纹理层
         */
        getLayer(id: number): TerrainLayer | null;
        /**
         * @en get position
         * @zh 获得地形上的位置
         */
        getPosition(i: number, j: number): math.Vec3;
        getHeightField(): Uint16Array;
        /**
         * @en set height
         * @zh 设置地形上的高度
         */
        setHeight(i: number, j: number, h: number): void;
        /**
         * @en get height
         * @zh 获得地形上的高度
         */
        getHeight(i: number, j: number): number;
        /**
         * @en set height
         * @zh 设置高度
         */
        getHeightClamp(i: number, j: number): number;
        /**
         * @en get height by point
         * @zh 根据点的坐标获得高度
         */
        getHeightAt(x: number, y: number): number | null;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _setNormal(i: number, j: number, n: math.Vec3): void;
        /**
         * @en get normal
         * @zh 获得法线
         */
        getNormal(i: number, j: number): math.Vec3;
        /**
         * @en get normal by point
         * @zh 根据点的坐标获得法线
         */
        getNormalAt(x: number, y: number): math.Vec3 | null;
        /**
         * @en set weight
         * @zh 设置权重
         */
        setWeight(i: number, j: number, w: math.Vec4): void;
        /**
         * @en get weight
         * @zh 获得权重
         */
        getWeight(i: number, j: number): math.Vec4;
        /**
         * @en get normal by point
         * @zh 根据点的坐标获得权重
         */
        getWeightAt(x: number, y: number): math.Vec4 | null;
        /**
         * @en get max weight layer by point
         * @zh 根据点的坐标获得权重最大的纹理层
         */
        getMaxWeightLayerAt(x: number, y: number): TerrainLayer | null;
        /**
         * @en get block layers
         * @zh 获得地形块纹理层
         */
        getBlockLayers(i: number, j: number): number[];
        /**
         * @en get block layer
         * @zh 获得地形块纹理层
         */
        getBlockLayer(i: number, j: number, index: number): number;
        /**
         * @en set block layer
         * @zh 获得地形块层
         */
        setBlockLayer(i: number, j: number, index: number, layerId: number): void;
        /**
         * @en get block
         * @zh 获得地形块对象
         */
        getBlock(i: number, j: number): TerrainBlock;
        /**
         * @en get all blocks
         * @zh 获得地形块缓存
         */
        getBlocks(): TerrainBlock[];
        /**
         * @en ray check
         * @zh 射线检测
         * @param start ray start
         * @param dir ray direction
         * @param step ray step
         * @param worldSpace is world space
         */
        rayCheck(start: math.Vec3, dir: math.Vec3, step: number, worldSpace?: boolean): math.Vec3 | null;
        /**
         * @deprecated since v3.5.1, this is an engine private interface that will be removed in the future.
         */
        _createSharedIndexBuffer(): gfx.Buffer;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _getSharedIndexBuffer(): gfx.Buffer;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _getIndexData(key: __private._cocos_terrain_terrain_lod__TerrainLodKey): __private._cocos_terrain_terrain_lod__TerrainIndexData | null;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _resetLightmap(enble: boolean): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _updateLightmap(blockId: number, tex: Texture2D | null, uOff: number, vOff: number, uScale: number, vScale: number): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _getLightmapInfo(i: number, j: number): TerrainBlockLightmapInfo | null;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _calcNormal(x: number, z: number): math.Vec3;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _buildNormals(): void;
    }
    export const TERRAIN_MAX_LEVELS = 4;
    export const TERRAIN_MAX_BLEND_LAYERS = 4;
    export const TERRAIN_MAX_LAYER_COUNT = 256;
    export const TERRAIN_BLOCK_TILE_COMPLEXITY = 32;
    export const TERRAIN_BLOCK_VERTEX_COMPLEXITY = 33;
    export const TERRAIN_BLOCK_VERTEX_SIZE = 8;
    export const TERRAIN_HEIGHT_BASE = 32768;
    export const TERRAIN_HEIGHT_FACTORY: number;
    export const TERRAIN_HEIGHT_FMIN: number;
    export const TERRAIN_HEIGHT_FMAX: number;
    export const TERRAIN_NORTH_INDEX = 0;
    export const TERRAIN_SOUTH_INDEX = 1;
    export const TERRAIN_WEST_INDEX = 2;
    export const TERRAIN_EAST_INDEX = 3;
    export const TERRAIN_DATA_VERSION = 16842753;
    export const TERRAIN_DATA_VERSION2 = 16842754;
    export const TERRAIN_DATA_VERSION3 = 16842755;
    export const TERRAIN_DATA_VERSION4 = 16842756;
    export const TERRAIN_DATA_VERSION5 = 16842757;
    export const TERRAIN_DATA_VERSION6 = 16842758;
    export const TERRAIN_DATA_VERSION_DEFAULT = 16843025;
    /**
     * @en terrain layer info
     * @zh 地形纹理信息
     */
    export class TerrainLayerInfo {
        slot: number;
        tileSize: number;
        detailMap: Texture2D | null;
        normalMap: Texture2D | null;
        roughness: number;
        metallic: number;
    }
    /**
     * @en terrain layer binary info
     * @zh 地形纹理二进制信息
     */
    export class TerrainLayerBinaryInfo {
        slot: number;
        tileSize: number;
        roughness: number;
        metallic: number;
        detailMapId: string;
        normalMapId: string;
    }
    /**
     * @en terrain asset
     * @zh 地形资源
     */
    export class TerrainAsset extends Asset {
        protected _version: number;
        protected _data: Uint8Array | null;
        protected _tileSize: number;
        protected _blockCount: number[];
        protected _weightMapSize: number;
        protected _lightMapSize: number;
        protected _heights: Uint16Array;
        protected _normals: Float32Array;
        protected _weights: Uint8Array;
        protected _layerBuffer: number[];
        protected _layerBinaryInfos: TerrainLayerBinaryInfo[];
        protected _layerInfos: TerrainLayerInfo[];
        constructor();
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        get _nativeAsset(): ArrayBuffer;
        set _nativeAsset(value: ArrayBuffer);
        /**
         * @en version
         * @zh 版本
         */
        get version(): number;
        /**
         * @en tile size
         * @zh 栅格大小
         */
        set tileSize(value: number);
        get tileSize(): number;
        /**
         * @en block count
         * @zh 块数量
         */
        set blockCount(value: number[]);
        get blockCount(): number[];
        /**
         * @en light map size
         * @zh 光照图大小
         */
        set lightMapSize(value: number);
        get lightMapSize(): number;
        /**
         * @en weight map size
         * @zh 权重图大小
         */
        set weightMapSize(value: number);
        get weightMapSize(): number;
        /**
         * @en height buffer
         * @zh 高度缓存
         */
        set heights(value: Uint16Array);
        get heights(): Uint16Array;
        /**
         * @en normal buffer
         * @zh 法线缓存
         */
        set normals(value: Float32Array);
        get normals(): Float32Array;
        /**
         * @en weight buffer
         * @zh 权重缓存
         */
        set weights(value: Uint8Array);
        get weights(): Uint8Array;
        /**
         * @en layer buffer
         * @zh 纹理索引缓存
         */
        set layerBuffer(value: number[]);
        get layerBuffer(): number[];
        /**
         * @en layer info
         * @zh 纹理信息
         */
        set layerInfos(value: TerrainLayerInfo[]);
        get layerInfos(): TerrainLayerInfo[];
        get layerBinaryInfos(): TerrainLayerBinaryInfo[];
        /**
         * @en get layer
         * @zh 获得纹理索引
         * @param xBlock block index x
         * @param yBlock block index y
         * @param layerId layer id
         */
        getLayer(xBlock: number, yBlock: number, layerId: number): number;
        getHeight(i: number, j: number): number;
        getVertexCountI(): number;
        getVertexCountJ(): number;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _setNativeData(_nativeData: Uint8Array): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _loadNativeData(_nativeData: Uint8Array): boolean;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _exportNativeData(): Uint8Array;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _exportDefaultNativeData(): Uint8Array;
    }
    /**
     * @en Renders a TMX Tile Map in the scene.
     * @zh 在场景中渲染一个 tmx 格式的 Tile Map。
     * @class TiledMap
     * @extends Component
     */
    export class TiledMap extends Component {
        _texGrids: __private._cocos_tiledmap_tiled_types__TiledTextureGrids;
        _textures: SpriteFrame[];
        _tilesets: __private._cocos_tiledmap_tiled_types__TMXTilesetInfo[];
        _animations: __private._cocos_tiledmap_tiled_types__TiledAnimationType;
        _imageLayers: __private._cocos_tiledmap_tiled_types__TMXImageLayerInfo[];
        _layers: TiledLayer[];
        _groups: TiledObjectGroup[];
        _images: __private._cocos_tiledmap_tiled_map__ImageExtendedNode[];
        _properties: __private._cocos_tiledmap_tiled_types__PropertiesInfo;
        _tileProperties: Map<__private._cocos_tiledmap_tiled_types__GID, __private._cocos_tiledmap_tiled_types__PropertiesInfo>;
        _mapInfo: __private._cocos_tiledmap_tmx_xml_parser__TMXMapInfo | null;
        _mapSize: math.Size;
        _tileSize: math.Size;
        _mapOrientation: __private._cocos_tiledmap_tiled_types__Orientation;
        static Orientation: typeof __private._cocos_tiledmap_tiled_types__Orientation;
        static Property: typeof __private._cocos_tiledmap_tiled_types__Property;
        static TileFlag: typeof __private._cocos_tiledmap_tiled_types__TileFlag;
        static StaggerAxis: typeof __private._cocos_tiledmap_tiled_types__StaggerAxis;
        static StaggerIndex: typeof __private._cocos_tiledmap_tiled_types__StaggerIndex;
        static TMXObjectType: typeof __private._cocos_tiledmap_tiled_types__TMXObjectType;
        static RenderOrder: typeof __private._cocos_tiledmap_tiled_types__RenderOrder;
        _tmxFile: TiledMapAsset | null;
        /**
         * @en The TiledMap Asset.
         * @zh TiledMap 资源。
         * @property {TiledMapAsset} tmxAsset
         * @default ""
         */
        get tmxAsset(): TiledMapAsset;
        set tmxAsset(value: TiledMapAsset);
        /**
         * @en
         * Whether or not enabled tiled map auto culling. If you set the TiledMap skew or rotation, then need to manually
         *  disable this, otherwise, the rendering will be wrong.
         * @zh
         * 是否开启瓦片地图的自动裁减功能。瓦片地图如果设置了 skew, rotation 或者采用了摄像机的话，需要手动关闭，否则渲染会出错。
         */
        protected _enableCulling: boolean;
        get enableCulling(): boolean;
        set enableCulling(value: boolean);
        protected cleanupImageCache: boolean;
        /**
         * @en Gets the map size.
         * @zh 获取地图大小。
         * @method getMapSize
         * @return {Size}
         * @example
         * let mapSize = tiledMap.getMapSize();
         * cc.log("Map Size: " + mapSize);
         */
        getMapSize(): math.Size;
        /**
         * @en Gets the tile size.
         * @zh 获取地图背景中 tile 元素的大小。
         * @method getTileSize
         * @return {Size}
         * @example
         * let tileSize = tiledMap.getTileSize();
         * cc.log("Tile Size: " + tileSize);
         */
        getTileSize(): math.Size;
        /**
         * @en map orientation.
         * @zh 获取地图方向。
         * @method getMapOrientation
         * @return {Number}
         * @example
         * let mapOrientation = tiledMap.getMapOrientation();
         * cc.log("Map Orientation: " + mapOrientation);
         */
        getMapOrientation(): __private._cocos_tiledmap_tiled_types__Orientation;
        /**
         * @en object groups.
         * @zh 获取所有的对象层。
         * @method getObjectGroups
         * @return {TiledObjectGroup[]}
         * @example
         * let objGroups = titledMap.getObjectGroups();
         * for (let i = 0; i < objGroups.length; ++i) {
         *     cc.log("obj: " + objGroups[i]);
         * }
         */
        getObjectGroups(): TiledObjectGroup[];
        /**
         * @en Return the TMXObjectGroup for the specific group.
         * @zh 获取指定的 TMXObjectGroup。
         * @method getObjectGroup
         * @param {String} groupName
         * @return {TiledObjectGroup}
         * @example
         * let group = titledMap.getObjectGroup("Players");
         * cc.log("ObjectGroup: " + group);
         */
        getObjectGroup(groupName: string): TiledObjectGroup | null;
        /**
         * @en Gets the map properties.
         * @zh 获取地图的属性。
         * @method getProperties
         * @return {Object[]}
         * @example
         * let properties = titledMap.getProperties();
         * for (let i = 0; i < properties.length; ++i) {
         *     cc.log("Properties: " + properties[i]);
         * }
         */
        getProperties(): __private._cocos_tiledmap_tiled_types__PropertiesInfo;
        /**
         * @en Return All layers array.
         * @zh 返回包含所有 layer 的数组。
         * @method getLayers
         * @returns {TiledLayer[]}
         * @example
         * let layers = titledMap.getLayers();
         * for (let i = 0; i < layers.length; ++i) {
         *     cc.log("Layers: " + layers[i]);
         * }
         */
        getLayers(): TiledLayer[];
        /**
         * @en return the cc.TiledLayer for the specific layer.
         * @zh 获取指定名称的 layer。
         * @method getLayer
         * @param {String} layerName
         * @return {TiledLayer}
         * @example
         * let layer = titledMap.getLayer("Player");
         * cc.log(layer);
         */
        getLayer(layerName: any): TiledLayer | null;
        protected _changeLayer(layerName: any, replaceLayer: any): void;
        /**
         * @en Return the value for the specific property name.
         * @zh 通过属性名称，获取指定的属性。
         * @method getProperty
         * @param {String} propertyName
         * @return {String}
         * @example
         * let property = titledMap.getProperty("info");
         * cc.log("Property: " + property);
         */
        getProperty(propertyName: string): string | number;
        /**
         * @en Return properties dictionary for tile GID.
         * @zh 通过 GID ，获取指定的属性。
         * @method getPropertiesForGID
         * @param {Number} GID
         * @return {Object}
         * @example
         * let properties = titledMap.getPropertiesForGID(GID);
         * cc.log("Properties: " + properties);
         */
        getPropertiesForGID(gid: __private._cocos_tiledmap_tiled_types__GID): __private._cocos_tiledmap_tiled_types__PropertiesInfo | undefined;
        __preload(): void;
        onEnable(): void;
        onDisable(): void;
        _applyFile(): void;
        _releaseMapInfo(): void;
        _syncAnchorPoint(): void;
        _fillAniGrids(texGrids: __private._cocos_tiledmap_tiled_types__TiledTextureGrids, animations: __private._cocos_tiledmap_tiled_types__TiledAnimationType): void;
        _buildLayerAndGroup(): void;
        protected _buildWithMapInfo(mapInfo: __private._cocos_tiledmap_tmx_xml_parser__TMXMapInfo): void;
        doCleanupImageCache(texture: any): void;
        lateUpdate(dt: number): void;
    }
    /**
     * @en
     * Class for tiled map asset handling.
     * @zh
     * 用于获取 tiled map 资源类
     * @class TiledMapAsset
     * @extends Asset
     *
     */
    export class TiledMapAsset extends Asset {
        tmxXmlStr: string;
        tsxFiles: TextAsset[];
        tsxFileNames: string[];
        /**
         * @en
         * SpriteFrame array
         * @zh
         * SpriteFrame 数组
         */
        spriteFrames: SpriteFrame[];
        /**
         * @en
         * ImageLayerSpriteFrame array
         * @zh
         * ImageLayerSpriteFrame 数组
         * @property {SpriteFrame[]} imageLayerSpriteFrame
         */
        imageLayerSpriteFrame: SpriteFrame[];
        /**
         * @en
         * Name of each object in imageLayerSpriteFrame
         * @zh
         * 每个 imageLayerSpriteFrame 名称
         * @property {String[]} imageLayerTextureNames
         */
        imageLayerSpriteFrameNames: string[];
        /**
         * @en
         * Name of each object in spriteFrames
         * @zh
         * 每个 SpriteFrame 名称
         * @property {String[]} spriteFrameNames
         */
        spriteFrameNames: string[];
        /**
         * @en
         * Size of each object in spriteFrames
         * @zh
         * 每个 SpriteFrame 的大小
         * @property {Size[]} spriteFrameSizes
         */
        spriteFrameSizes: math.Size[];
    }
    export class TiledUserNodeData extends Component {
        _index: number;
        _row: number;
        _col: number;
        _tiledLayer: TiledLayer | null;
        constructor();
    }
    export interface TiledRenderData {
        renderData: RenderData | null;
        texture: Texture2D | null;
    }
    /**
     * @en Render the TMX layer.
     * @zh 渲染 TMX layer。
     * @class TiledLayer
     * @extends Component
     */
    export class TiledLayer extends UIRenderer {
        protected _userNodeGrid: {
            [key: number]: {
                count: number;
                [key: number]: {
                    count: number;
                    list: (TiledUserNodeData | null)[];
                };
            };
        };
        protected _userNodeMap: {
            [key: string]: TiledUserNodeData;
        };
        protected _userNodeDirty: boolean;
        tiledTiles: (TiledTile | null)[];
        protected _viewPort: {
            x: number;
            y: number;
            width: number;
            height: number;
        };
        protected _cullingRect: {
            leftDown: {
                row: number;
                col: number;
            };
            rightTop: {
                row: number;
                col: number;
            };
        };
        get cullingRect(): {
            leftDown: {
                row: number;
                col: number;
            };
            rightTop: {
                row: number;
                col: number;
            };
        };
        protected _cullingDirty: boolean;
        protected _rightTop: {
            row: number;
            col: number;
        };
        get rightTop(): {
            row: number;
            col: number;
        };
        protected _layerInfo: __private._cocos_tiledmap_tiled_types__TMXLayerInfo | null;
        protected _mapInfo: __private._cocos_tiledmap_tmx_xml_parser__TMXMapInfo | null;
        protected _topOffset: number;
        protected _downOffset: number;
        protected _leftOffset: number;
        protected _rightOffset: number;
        tiles: __private._cocos_tiledmap_tiled_types__MixedGID[];
        vertices: {
            minCol: number;
            maxCol: number;
            [key: number]: {
                left: number;
                bottom: number;
                index: number;
            };
        }[];
        protected _verticesDirty: boolean;
        protected _layerName: string;
        protected _layerSize?: math.Size;
        get layerSize(): math.Size;
        protected _minGID?: __private._cocos_tiledmap_tiled_types__GID;
        protected _maxGID?: __private._cocos_tiledmap_tiled_types__GID;
        protected _layerOrientation: null | __private._cocos_tiledmap_tiled_types__Orientation;
        protected _opacity?: number;
        protected _tintColor?: math.Color;
        texGrids: __private._cocos_tiledmap_tiled_types__TiledTextureGrids | null;
        protected _textures: SpriteFrame[];
        protected _tilesets: __private._cocos_tiledmap_tiled_types__TMXTilesetInfo[];
        protected _leftDownToCenterX: number;
        protected _leftDownToCenterY: number;
        protected _hasTiledNodeGrid: boolean;
        protected _hasAniGrid: boolean;
        protected _animations: __private._cocos_tiledmap_tiled_types__TiledAnimationType | null;
        protected _enableCulling?: boolean;
        colorChanged: boolean;
        protected _properties?: __private._cocos_tiledmap_tiled_types__PropertiesInfo;
        renderOrder?: __private._cocos_tiledmap_tiled_types__RenderOrder;
        protected _staggerAxis?: __private._cocos_tiledmap_tiled_types__StaggerAxis;
        protected _staggerIndex?: __private._cocos_tiledmap_tiled_types__StaggerIndex;
        protected _hexSideLength?: number;
        protected _mapTileSize?: math.Size;
        protected _odd_even?: number;
        protected _diffX1?: number;
        protected _diffY1?: number;
        protected _useAutomaticVertexZ?: boolean;
        protected _vertexZvalue?: number;
        protected _offset?: math.Vec2;
        protected _tiledDataArray: __private._cocos_tiledmap_tiled_layer__TiledDataArray;
        get tiledDataArray(): __private._cocos_tiledmap_tiled_layer__TiledDataArray;
        get leftDownToCenterX(): number;
        get leftDownToCenterY(): number;
        constructor();
        hasTiledNode(): boolean;
        hasAnimation(): boolean;
        /**
         * @en enable or disable culling
         * @zh 开启或关闭裁剪。
         * @method enableCulling
         * @param value
         */
        set enableCulling(value: boolean);
        get enableCulling(): boolean;
        /**
         * @en Adds user's node into layer.
         * @zh 添加用户节点。
         * @method addUserNode
         * @param {cc.Node} node
         * @return {Boolean}
         */
        addUserNode(node: Node): boolean;
        /**
         * @en Removes user's node.
         * @zh 移除用户节点。
         * @method removeUserNode
         * @param {cc.Node} node
         * @return {Boolean}
         */
        removeUserNode(node: Node): boolean;
        /**
         * @en Destroy user's node.
         * @zh 销毁用户节点。
         * @method destroyUserNode
         * @param {cc.Node} node
         */
        destroyUserNode(node: Node): void;
        protected _nodeLocalPosToLayerPos(nodePos: math.IVec2Like, out: math.IVec2Like): void;
        getNodesByRowCol(row: number, col: number): {
            count: number;
            list: (TiledUserNodeData | null)[];
        } | null;
        getNodesCountByRow(row: any): number;
        protected _updateAllUserNode(): void;
        protected _updateCullingOffsetByUserNode(node_: Node): void;
        protected _userNodeSizeChange(): void;
        protected _userNodePosChange(): void;
        protected _removeUserNodeFromGrid(dataComp: TiledUserNodeData): void;
        protected _limitInLayer(rowCol: {
            row: number;
            col: number;
        }): void;
        protected _addUserNodeToGrid(dataComp: TiledUserNodeData, tempRowCol: {
            col: number;
            row: number;
        }): void;
        isUserNodeDirty(): boolean;
        setUserNodeDirty(value: any): void;
        onEnable(): void;
        onDisable(): void;
        protected _syncAnchorPoint(): void;
        /**
         * @en Gets the layer name.
         * @zh 获取层的名称。
         * @method getLayerName
         * @return {String}
         * @example
         * let layerName = tiledLayer.getLayerName();
         * cc.log(layerName);
         */
        getLayerName(): string;
        /**
         * @en Set the layer name.
         * @zh 设置层的名称
         * @method setLayerName
         * @param {String} layerName
         * @example
         * tiledLayer.setLayerName("New Layer");
         */
        setLayerName(layerName: string): void;
        /**
         * @en Return the value for the specific property name.
         * @zh 获取指定属性名的值。
         * @method getProperty
         * @param {String} propertyName
         * @return {*}
         * @example
         * let property = tiledLayer.getProperty("info");
         * cc.log(property);
         */
        getProperty(propertyName: string): string | number;
        /**
         * @en Returns the position in pixels of a given tile coordinate.
         * @zh 获取指定 tile 的像素坐标。
         * @method getPositionAt
         * @param {Vec2|Number} pos position or x
         * @param {Number} [y]
         * @return {Vec2}
         * @example
         * let pos = tiledLayer.getPositionAt(cc.v2(0, 0));
         * cc.log("Pos: " + pos);
         * let pos = tiledLayer.getPositionAt(0, 0);
         * cc.log("Pos: " + pos);
         */
        getPositionAt(pos: math.IVec2Like | number, y?: number): math.Vec2 | null;
        isInvalidPosition(x: number, y: number): boolean;
        protected _positionForIsoAt(x: number, y: number): math.Vec2;
        protected _positionForOrthoAt(x: number, y: number): math.Vec2;
        protected _positionForHexAt(col: number, row: number): math.Vec2;
        /**
         * @en
         * Sets the tiles gid (gid = tile global id) at a given tiles rect.
         * @zh
         * 设置给定区域的 tile 的 gid (gid = tile 全局 id)，
         * @method setTilesGIDAt
         * @param {Array} gids an array contains gid
         * @param {Number} beginCol begin col number
         * @param {Number} beginRow begin row number
         * @param {Number} totalCols count of column
         * @example
         * tiledLayer.setTilesGIDAt([1, 1, 1, 1], 10, 10, 2)
         */
        setTilesGIDAt(gids: number[], beginCol: number, beginRow: number, totalCols: number): void;
        /**
         * @en
         * Sets the tile gid (gid = tile global id) at a given tile coordinate.<br />
         * The Tile GID can be obtained by using the method "tileGIDAt" or by using the TMX editor . Tileset Mgr +1.<br />
         * If a tile is already placed at that position, then it will be removed.
         * @zh
         * 设置给定坐标的 tile 的 gid (gid = tile 全局 id)，
         * tile 的 GID 可以使用方法 “tileGIDAt” 来获得。<br />
         * 如果一个 tile 已经放在那个位置，那么它将被删除。
         * @method setTileGIDAt
         * @param {Number} gid
         * @param {Vec2|Number} posOrX position or x
         * @param {Number} flagsOrY flags or y
         * @param {Number} [flags]
         * @example
         * tiledLayer.setTileGIDAt(1001, 10, 10, 1)
         */
        setTileGIDAt(gid: __private._cocos_tiledmap_tiled_types__MixedGID, x: number, y: number, flags?: number): void;
        protected _updateTileForGID(gidAndFlags: __private._cocos_tiledmap_tiled_types__MixedGID, x: number, y: number): void;
        /**
         * @en
         * Returns the tile gid at a given tile coordinate. <br />
         * if it returns 0, it means that the tile is empty. <br />
         * @zh
         * 通过给定的 tile 坐标、flags（可选）返回 tile 的 GID. <br />
         * 如果它返回 0，则表示该 tile 为空。<br />
         * @method getTileGIDAt
         * @param {Vec2} pos
         * @return {Number}
         * @example
         * let tileGid = tiledLayer.getTileGIDAt(0, 0);
         */
        getTileGIDAt(x: number, y: number): number | null;
        /**
         * @en
         * Returns the tile flags at a given tile coordinate. <br />
         * @zh
         * 通过给定的 tile 坐标, 返回 tile 的 flags. <br />
         * 如果它返回 null，则表示该 tile 为空。<br />
         * @method getTileGIDAt
         * @param {number}} x
         * @param {number}} y
         * @return {Number}
         * @example
         * let tileGid = tiledLayer.getTileGIDAt(0, 0);
         */
        getTileFlagsAt(x: number, y: number): number | null;
        setCullingDirty(value: boolean): void;
        isCullingDirty(): boolean;
        updateViewPort(x: number, y: number, width: number, height: number): void;
        protected _positionToRowCol(x: number, y: number, result: {
            col: number;
            row: number;
        }): {
            col: number;
            row: number;
        };
        updateCulling(): void;
        /**
         * @en Layer orientation, which is the same as the map orientation.
         * @zh 获取 Layer 方向(同地图方向)。
         * @method getLayerOrientation
         * @return {Number}
         * @example
         * let orientation = tiledLayer.getLayerOrientation();
         * cc.log("Layer Orientation: " + orientation);
         */
        getLayerOrientation(): __private._cocos_tiledmap_tiled_types__Orientation | null;
        /**
         * @en properties from the layer. They can be added using Tiled.
         * @zh 获取 layer 的属性，可以使用 Tiled 编辑器添加属性。
         * @method getProperties
         * @return {Object}
         * @example
         * let properties = tiledLayer.getProperties();
         * cc.log("Properties: " + properties);
         */
        getProperties(): __private._cocos_tiledmap_tiled_types__PropertiesInfo | undefined;
        protected _updateVertex(col: number, row: number): void;
        protected _updateVertices(): void;
        /**
         * @en
         * Get the TiledTile with the tile coordinate.<br/>
         * If there is no tile in the specified coordinate and forceCreate parameter is true, <br/>
         * then will create a new TiledTile at the coordinate.
         * The renderer will render the tile with the rotation, scale, position and color property of the TiledTile.
         * @zh
         * 通过指定的 tile 坐标获取对应的 TiledTile。 <br/>
         * 如果指定的坐标没有 tile，并且设置了 forceCreate 那么将会在指定的坐标创建一个新的 TiledTile 。<br/>
         * 在渲染这个 tile 的时候，将会使用 TiledTile 的节点的旋转、缩放、位移、颜色属性。<br/>
         * @method getTiledTileAt
         * @param {Integer} x
         * @param {Integer} y
         * @param {Boolean} forceCreate
         * @return {cc.TiledTile}
         * @example
         * let tile = tiledLayer.getTiledTileAt(100, 100, true);
         * cc.log(tile);
         */
        getTiledTileAt(x: number, y: number, forceCreate?: boolean): TiledTile | null;
        /**
         * @en
         * Change tile to TiledTile at the specified coordinate.
         * @zh
         * 将指定的 tile 坐标替换为指定的 TiledTile。
         * @method setTiledTileAt
         * @param {Integer} x
         * @param {Integer} y
         * @param {cc.TiledTile} tiledTile
         * @return {cc.TiledTile}
         */
        setTiledTileAt(x: number, y: number, tiledTile: TiledTile | null): TiledTile | null;
        /**
         * @en Return texture.
         * @zh 获取纹理。
         * @method getTexture
         * @param index The index of textures
         * @return {Texture2D}
         */
        getTexture(index?: number): SpriteFrame | null;
        /**
         * @en Return texture.
         * @zh 获取纹理。
         * @method getTextures
         * @return {Texture2D}
         */
        getTextures(): SpriteFrame[];
        /**
         * @en Set the texture.
         * @zh 设置纹理。
         * @method setTexture
         * @param {SpriteFrame} texture
         */
        setTexture(texture: SpriteFrame): void;
        /**
         * @en Set the texture.
         * @zh 设置纹理。
         * @method setTexture
         * @param {SpriteFrame} textures
         */
        setTextures(textures: SpriteFrame[]): void;
        /**
         * @en Gets layer size.
         * @zh 获得层大小。
         * @method getLayerSize
         * @return {Size}
         * @example
         * let size = tiledLayer.getLayerSize();
         * cc.log("layer size: " + size);
         */
        getLayerSize(): math.Size;
        /**
         * @en Size of the map's tile (could be different from the tile's size).
         * @zh 获取 tile 的大小( tile 的大小可能会有所不同)。
         * @method getMapTileSize
         * @return {Size}
         * @example
         * let mapTileSize = tiledLayer.getMapTileSize();
         * cc.log("MapTile size: " + mapTileSize);
         */
        getMapTileSize(): math.Size;
        /**
         * @en Gets Tile set first information for the layer.
         * @zh 获取 layer 索引位置为0的 Tileset 信息。
         * @method getTileSet
         * @param index The index of tilesets
         * @return {TMXTilesetInfo}
         */
        getTileSet(index: number): __private._cocos_tiledmap_tiled_types__TMXTilesetInfo | null;
        /**
         * @en Gets tile set all information for the layer.
         * @zh 获取 layer 所有的 Tileset 信息。
         * @method getTileSet
         * @return {TMXTilesetInfo}
         */
        getTileSets(): __private._cocos_tiledmap_tiled_types__TMXTilesetInfo[];
        /**
         * @en Sets tile set information for the layer.
         * @zh 设置 layer 的 tileset 信息。
         * @method setTileSet
         * @param {TMXTilesetInfo} tileset
         */
        setTileSet(tileset: __private._cocos_tiledmap_tiled_types__TMXTilesetInfo): void;
        /**
         * @en Sets Tile set information for the layer.
         * @zh 设置 layer 的 Tileset 信息。
         * @method setTileSets
         * @param {TMXTilesetInfo} tilesets
         */
        setTileSets(tilesets: __private._cocos_tiledmap_tiled_types__TMXTilesetInfo[]): void;
        init(layerInfo: __private._cocos_tiledmap_tiled_types__TMXLayerInfo, mapInfo: __private._cocos_tiledmap_tmx_xml_parser__TMXMapInfo, tilesets: __private._cocos_tiledmap_tiled_types__TMXTilesetInfo[], textures: SpriteFrame[], texGrids: __private._cocos_tiledmap_tiled_types__TiledTextureGrids): void;
        protected _prepareToRender(): void;
        requestTiledRenderData(): TiledRenderData;
        requestSubNodesData(): __private._cocos_tiledmap_tiled_layer__TiledSubNodeData;
        destroyRenderData(): void;
        protected _flushAssembler(): void;
        /**
         * @en
         * Index of mesh render data array
         * @zh
         * 网格渲染数据数组的索引
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _tiledDataArrayIdx: number;
        protected _render(ui: __private._cocos_2d_renderer_i_batcher__IBatcher): void;
        protected createRenderEntity(): __private._cocos_2d_renderer_render_entity__RenderEntity;
        prepareDrawData(): void;
    }
    /**
     * @en Renders the TMX object group.
     * @zh 渲染 tmx object group。
     * @class TiledObjectGroup
     * @extends Component
     */
    export class TiledObjectGroup extends Component {
        protected _premultiplyAlpha: boolean;
        get premultiplyAlpha(): boolean;
        set premultiplyAlpha(value: boolean);
        /**
         * @en Offset position of child objects.
         * @zh 获取子对象的偏移位置。
         * @method getPositionOffset
         * @return {Vec2}
         * @example
         * let offset = tMXObjectGroup.getPositionOffset();
         */
        getPositionOffset(): math.Vec2 | undefined;
        /**
         * @en List of properties stored in a dictionary.
         * @zh 以映射的形式获取属性列表。
         * @method getProperties
         * @return {Object}
         * @example
         * let offset = tMXObjectGroup.getProperties();
         */
        getProperties(): __private._cocos_tiledmap_tiled_types__PropertiesInfo | undefined;
        /**
         * @en Gets the Group name.
         * @zh 获取组名称。
         * @method getGroupName
         * @return {String}
         * @example
         * let groupName = tMXObjectGroup.getGroupName;
         */
        getGroupName(): string | undefined;
        /**
         * Return the value for the specific property name
         * @param {String} propertyName
         * @return {Object}
         */
        getProperty(propertyName: {
            toString(): string;
        } | string): string | number;
        /**
         * @en
         * Return the object for the specific object name. <br />
         * It will return the 1st object found on the array for the given name.
         * @zh 获取指定的对象。
         * @method getObject
         * @param {String} objectName
         * @return {Object|Null}
         * @example
         * let object = tMXObjectGroup.getObject("Group");
         */
        getObject(objectName: string): __private._cocos_tiledmap_tiled_types__TMXObject | null;
        /**
         * @en Gets the objects.
         * @zh 获取对象数组。
         * @method getObjects
         * @return {Array}
         * @example
         * let objects = tMXObjectGroup.getObjects();
         */
        getObjects(): __private._cocos_tiledmap_tiled_types__TMXObject[];
        protected _groupName?: string;
        protected _positionOffset?: math.Vec2;
        protected _mapInfo?: __private._cocos_tiledmap_tmx_xml_parser__TMXMapInfo;
        protected _properties?: __private._cocos_tiledmap_tiled_types__PropertiesInfo;
        protected _offset?: math.Vec2;
        get offset(): math.Vec2;
        protected _opacity?: number;
        protected _tintColor: math.Color | null;
        protected _animations?: __private._cocos_tiledmap_tiled_types__TiledAnimationType;
        protected _hasAniObj?: boolean;
        protected _texGrids?: __private._cocos_tiledmap_tiled_types__TiledTextureGrids;
        protected aniObjects?: {
            object: __private._cocos_tiledmap_tiled_types__TMXObject;
            imgNode: Node;
            gridGID: __private._cocos_tiledmap_tiled_types__GID;
        }[];
        protected _objects: __private._cocos_tiledmap_tiled_types__TMXObject[];
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _init(groupInfo: __private._cocos_tiledmap_tiled_types__TMXObjectGroupInfo, mapInfo: __private._cocos_tiledmap_tmx_xml_parser__TMXMapInfo, texGrids: __private._cocos_tiledmap_tiled_types__TiledTextureGrids): void;
        update(dt: number): void;
    }
    export class TiledTile extends Component {
        _layer: TiledLayer | null;
        constructor();
        _x: number;
        _y: number;
        /**
         * @en Specify the TiledTile horizontal coordinate，use map tile as the unit.
         * @zh 指定 TiledTile 的横向坐标，以地图块为单位
         * @property {Number} x
         * @default 0
         */
        get x(): number;
        set x(value: number);
        /**
         * @en Specify the TiledTile vertical coordinate，use map tile as the unit.
         * @zh 指定 TiledTile 的纵向坐标，以地图块为单位
         * @property {Number} y
         * @default 0
         */
        get y(): number;
        set y(value: number);
        /**
         * @en Specify the TiledTile gid.
         * @zh 指定 TiledTile 的 gid 值
         * @property {Number} gid
         * @default 0
         */
        get grid(): number;
        set grid(value: number);
        onEnable(): void;
        onDisable(): void;
        updateInfo(): void;
    }
    export const tiledLayerAssembler: IAssemblerManager;
    /**
     * @en
     * Tween system.
     * @zh
     * 缓动系统。
     */
    export class TweenSystem extends System {
        /**
         * @en
         * The ID flag of the system.
         * @zh
         * 此系统的 ID 标记。
         */
        static readonly ID = "TWEEN";
        /**
         * @en
         * Gets the instance of the tween system.
         * @zh
         * 获取缓动系统的实例。
         */
        static readonly instance: TweenSystem;
        /**
         * @en
         * Gets the action manager.
         * @zh
         * 获取动作管理器。
         */
        get ActionManager(): __private._cocos_tween_actions_action_manager__ActionManager;
        /**
         * @en
         * The update will auto execute after all components update.
         * @zh
         * 此方法会在组件 update 之后自动执行。
         * @param dt @en The delta time @zh 间隔时间
         */
        update(dt: number): void;
    }
    /**
     * @en
     * tween is a utility function that helps instantiate Tween instances.
     * @zh
     * tween 是一个工具函数，帮助实例化 Tween 实例。
     * @param target @en The target of the result tween @zh 缓动的目标
     * @returns Tween 实例
     * @example
     * tween(this.node)
     *   .to(1, {scale: new Vec3(2, 2, 2), position: new Vec3(5, 5, 5)})
     *   .call(() => { console.log('This is a callback'); })
     *   .by(1, {scale: new Vec3(-1, -1, -1)}, {easing: 'sineOutIn'})
     *   .start()
     */
    export function tween<T>(target?: T): Tween<T>;
    /**
     * @en
     * tweenUtil is a utility function that helps instantiate Tween instances.
     * @zh
     * tweenUtil 是一个工具函数，帮助实例化 Tween 实例。
     * @deprecated please use `tween` instead.
     */
    export function tweenUtil<T>(target?: T): Tween<T>;
    /**
     * @en
     * Tween provide a simple and flexible way to action, It's transplanted from cocos creator。
     * @zh
     * Tween 提供了一个简单灵活的方法来缓动目标，从 creator 移植而来。
     * @class Tween
     * @param [target]
     * @example
     * tween(this.node)
     *   .to(1, {scale: new Vec3(2, 2, 2), position: new Vec3(5, 5, 5)})
     *   .call(() => { console.log('This is a callback'); })
     *   .by(1, {scale: new Vec3(-1, -1, -1), position: new Vec3(-5, -5, -5)}, {easing: 'sineOutIn'})
     *   .start()
     */
    export class Tween<T> {
        constructor(target?: T | null);
        /**
         * @en Sets tween tag
         * @zh 设置缓动的标签
         * @method tag
         * @param tag @en The tag set for this tween @zh 为当前缓动设置的标签
         */
        tag(tag: number): this;
        /**
         * @en
         * Insert an action or tween to this sequence.
         * @zh
         * 插入一个 tween 到队列中。
         * @method then
         * @param other @en The rear tween of this tween @zh 当前缓动的后置缓动
         */
        then(other: Tween<T>): Tween<T>;
        /**
         * @en
         * Sets tween target.
         * @zh
         * 设置 tween 的 target。
         * @method target
         * @param target @en The target of this tween @zh 当前缓动的目标对象
         */
        target(target: T): Tween<T | undefined>;
        /**
         * @en
         * Start this tween.
         * @zh
         * 运行当前 tween。
         */
        start(): Tween<T>;
        /**
         * @en
         * Stop this tween.
         * @zh
         * 停止当前 tween。
         */
        stop(): Tween<T>;
        /**
         * @en
         * Clone a tween.
         * @zh
         * 克隆当前 tween。
         * @method clone
         * @param target @en The target of clone tween @zh 克隆缓动的目标对象
         */
        clone(target: T): Tween<T>;
        /**
         * @en
         * Integrate all previous actions to an action.
         * @zh
         * 将之前所有的 action 整合为一个 action。
         */
        union(): Tween<T>;
        /**
         * @en
         * Add an action which calculate with absolute value.
         * @zh
         * 添加一个对属性进行绝对值计算的 action。
         * @method to
         * @param duration @en Tween time, in seconds @zh 缓动时间，单位为秒
         * @param props @en List of properties of tween @zh 缓动的属性列表
         * @param opts @en Optional functions of tween @zh 可选的缓动功能
         * @param opts.progress @en Interpolation function @zh 缓动的速度插值函数
         * @param opts.easing @en Tween function or a lambda @zh 缓动的曲线函数或lambda表达式
         */
        to(duration: number, props: __private._cocos_tween_tween__ConstructorType<T>, opts?: ITweenOption): Tween<T>;
        /**
         * @en
         * Add an action which calculate with relative value.
         * @zh
         * 添加一个对属性进行相对值计算的 action。
         * @method by
         * @param duration @en Tween time, in seconds @zh 缓动时间，单位为秒
         * @param props @en List of properties of tween @zh 缓动的属性列表
         * @param opts @en Optional functions of tween @zh 可选的缓动功能
         * @param [opts.progress]
         * @param [opts.easing]
         * @return {Tween}
         */
        by(duration: number, props: __private._cocos_tween_tween__ConstructorType<T>, opts?: ITweenOption): Tween<T>;
        /**
         * @en
         * Directly set target properties.
         * @zh
         * 直接设置 target 的属性。
         * @method set
         * @param props @en List of properties of tween @zh 缓动的属性列表
         * @return {Tween}
         */
        set(props: __private._cocos_tween_tween__ConstructorType<T>): Tween<T>;
        /**
         * @en
         * Add an delay action.
         * @zh
         * 添加一个延时 action。
         * @method delay
         * @param duration @en Delay time of this tween @zh 当前缓动的延迟时间
         * @return {Tween}
         */
        delay(duration: number): Tween<T>;
        /**
         * @en
         * Add an callback action.
         * @zh
         * 添加一个回调 action。
         * @method call
         * @param callback @en Callback function at the end of this tween @zh 当前缓动结束时的回调函数
         * @return {Tween}
         */
        call(callback: Function): Tween<T>;
        /**
         * @en
         * Add an sequence action.
         * @zh
         * 添加一个队列 action。
         * @method sequence
         * @param args @en All tween that make up the sequence @zh 组成队列的所有缓动
         */
        sequence(...args: Tween<T>[]): Tween<T>;
        /**
         * @en
         * Add an parallel action.
         * @zh
         * 添加一个并行 action。
         * @method parallel
         * @param args @en The tween parallel to this tween @zh 与当前缓动并行的缓动
         */
        parallel(...args: Tween<T>[]): Tween<T>;
        /**
         * @en
         * Add an repeat action.
         * This action will integrate before actions to a sequence action as their parameters.
         * @zh
         * 添加一个重复 action，这个 action 会将前一个动作作为他的参数。
         * @param repeatTimes @en The repeat times of this tween @zh 重复次数
         * @param embedTween @en Optional, embedded tween of this tween @zh 可选，嵌入缓动
         */
        repeat(repeatTimes: number, embedTween?: Tween<T>): Tween<T>;
        /**
         * @en
         * Add an repeat forever action.
         * This action will integrate before actions to a sequence action as their parameters.
         * @zh
         * 添加一个永久重复 action，这个 action 会将前一个动作作为他的参数。
         * @method repeatForever
         * @param embedTween @en Optional, embedded tween of this tween @zh 可选，嵌入缓动
         */
        repeatForever(embedTween?: Tween<T>): Tween<T>;
        /**
         * @en
         * Add an reverse time action.
         * This action will integrate before actions to a sequence action as their parameters.
         * @zh
         * 添加一个倒置时间 action，这个 action 会将前一个动作作为他的参数。
         * @method reverseTime
         * @param embedTween @en Optional, embedded tween of this tween @zh 可选，嵌入缓动
         */
        reverseTime(embedTween?: Tween<T>): Tween<T>;
        /**
         * @en
         * Add an hide action, only for node target.
         * @zh
         * 添加一个隐藏 action，只适用于 target 是节点类型的。
         */
        hide(): Tween<T>;
        /**
         * @en
         * Add an show action, only for node target.
         * @zh
         * 添加一个显示 action，只适用于 target 是节点类型的。
         */
        show(): Tween<T>;
        /**
         * @en
         * Add an removeSelf action, only for node target.
         * @zh
         * 添加一个移除自己 action，只适用于 target 是节点类型的。
         */
        removeSelf(): Tween<T>;
        /**
         * @en
         * Stop all tweens
         * @zh
         * 停止所有缓动
         */
        static stopAll(): void;
        /**
         * @en
         * Stop all tweens by tag
         * @zh
         * 停止所有指定标签的缓动
         */
        static stopAllByTag(tag: number, target?: object): void;
        /**
         * @en
         * Stop all tweens by target
         * @zh
         * 停止所有指定对象的缓动
         */
        static stopAllByTarget(target?: object): void;
    }
    export class TweenAction extends __private._cocos_tween_actions_action_interval__ActionInterval {
        constructor(duration: number, props: any, opts?: ITweenOption);
        clone(): TweenAction;
        startWithTarget(target: Record<string, unknown>): void;
        update(t: number): void;
        progress(start: number, end: number, current: number, t: number): number;
    }
    /**
     * @en
     * Built-in string value definition for the cache function.
     * @zh
     * 内置缓动函数的字符串值定义。
     */
    export type TweenEasing = "linear" | "smooth" | "fade" | "constant" | "quadIn" | "quadOut" | "quadInOut" | "quadOutIn" | "cubicIn" | "cubicOut" | "cubicInOut" | "cubicOutIn" | "quartIn" | "quartOut" | "quartInOut" | "quartOutIn" | "quintIn" | "quintOut" | "quintInOut" | "quintOutIn" | "sineIn" | "sineOut" | "sineInOut" | "sineOutIn" | "expoIn" | "expoOut" | "expoInOut" | "expoOutIn" | "circIn" | "circOut" | "circInOut" | "circOutIn" | "elasticIn" | "elasticOut" | "elasticInOut" | "elasticOutIn" | "backIn" | "backOut" | "backInOut" | "backOutIn" | "bounceIn" | "bounceOut" | "bounceInOut" | "bounceOutIn";
    /**
     * @en
     * The interface of optional property.
     * @zh
     * 缓动的可选属性的接口定义。
     */
    export interface ITweenOption {
        /**
         * @en
         * Easing function, you can pass in a string or custom function.
         * @zh
         * 缓动函数，可以使用已有的，也可以传入自定义的函数。
         */
        easing?: TweenEasing | ((k: number) => number);
        /**
         * @en
         * Interpolation function, you can pass in a custom function.
         * @zh
         * 插值函数，参数的意义 start:起始值，end:目标值，current:当前值，ratio:当前进度
         */
        progress?: (start: number, end: number, current: number, ratio: number) => number;
        /**
         * @en
         * A callback that is triggered when a tween action is started.
         * @zh
         * 回调，当缓动动作启动时触发。
         */
        onStart?: (target?: object) => void;
        /**
         * @en
         * A callback that is triggered when a tween action is update.
         * @zh
         * 回调，当缓动动作更新时触发。
         */
        onUpdate?: (target?: object, ratio?: number) => void;
        /**
         * @en
         * A callback that is triggered when a tween action is completed.
         * @zh
         * 回调，当缓动动作完成时触发。
         */
        onComplete?: (target?: object) => void;
    }
    /**
     * @en
     * Button component. Can be pressed or clicked. Button has 4 Transition types:
     *
     *   - Button.Transition.NONE   // Button will do nothing
     *   - Button.Transition.COLOR  // Button will change target's color
     *   - Button.Transition.SPRITE // Button will change target Sprite's sprite
     *   - Button.Transition.SCALE  // Button will change target node's scale
     *
     * The button can bind events (but you must be on the button's node to bind events).<br/>
     * The following events can be triggered on all platforms.
     *
     *  - cc.Node.EventType.TOUCH_START  // Press
     *  - cc.Node.EventType.TOUCH_MOVE   // After pressing and moving
     *  - cc.Node.EventType.TOUCH_END    // After pressing and releasing
     *  - cc.Node.EventType.TOUCH_CANCEL // Press to cancel
     *
     * The following events are only triggered on the PC platform:
     *
     *   - cc.Node.EventType.MOUSE_DOWN
     *   - cc.Node.EventType.MOUSE_MOVE
     *   - cc.Node.EventType.MOUSE_ENTER
     *   - cc.Node.EventType.MOUSE_LEAVE
     *   - cc.Node.EventType.MOUSE_UP
     *
     * The developer can get the current clicked node with `event.target` from event object which is passed as parameter in the callback function of click event.
     *
     * @zh
     * 按钮组件。可以被按下，或者点击。<br>
     * 按钮可以通过修改 Transition 来设置按钮状态过渡的方式：
     *
     *   - Button.Transition.NONE   // 不做任何过渡
     *   - Button.Transition.COLOR  // 进行颜色之间过渡
     *   - Button.Transition.SPRITE // 进行精灵之间过渡
     *   - Button.Transition.SCALE // 进行缩放过渡
     *
     * 按钮可以绑定事件（但是必须要在按钮的 Node 上才能绑定事件）。<br/>
     * 以下事件可以在全平台上都触发：
     *
     *   - cc.Node.EventType.TOUCH_START  // 按下时事件
     *   - cc.Node.EventType.TOUCH_Move   // 按住移动后事件
     *   - cc.Node.EventType.TOUCH_END    // 按下后松开后事件
     *   - cc.Node.EventType.TOUCH_CANCEL // 按下取消事件
     *
     * 以下事件只在 PC 平台上触发：
     *
     *   - cc.Node.EventType.MOUSE_DOWN  // 鼠标按下时事件
     *   - cc.Node.EventType.MOUSE_MOVE  // 鼠标按住移动后事件
     *   - cc.Node.EventType.MOUSE_ENTER // 鼠标进入目标事件
     *   - cc.Node.EventType.MOUSE_LEAVE // 鼠标离开目标事件
     *   - cc.Node.EventType.MOUSE_UP    // 鼠标松开事件
     *
     * 开发者可以通过获取 **点击事件** 回调函数的参数 event 的 target 属性获取当前点击对象。
     *
     * @example
     * ```ts
     * import { log, Node } from 'cc';
     * // Add an event to the button.
     * button.node.on(Node.EventType.TOUCH_START, (event) => {
     *     log("This is a callback after the trigger event");
     * });
     * // You could also add a click event
     * // Note: In this way, you can't get the touch event info, so use it wisely.
     * button.node.on(Node.EventType.CLICK, (button) => {
     *    //The event is a custom event, you could get the Button component via first argument
     * })
     * ```
     */
    export class Button extends Component {
        /**
         * @en
         * Transition target.<br/>
         * When Button state changed:
         * - Button.Transition.NONE   // Button will do nothing
         * - Button.Transition.COLOR  // Button will change target's color
         * - Button.Transition.SPRITE // Button will change target Sprite's sprite
         * - Button.Transition.SCALE  // Button will change target node's scale
         *
         * @zh
         * 需要过渡的目标。<br/>
         * 按钮可以通过修改 Transition 来设置按钮状态过渡的方式：
         * - Button.Transition.NONE   // 不做任何过渡
         * - Button.Transition.COLOR  // 进行颜色之间过渡
         * - Button.Transition.SPRITE // 进行 Sprite 之间的过渡
         * - Button.Transition.SCALE // 进行缩放过渡
         */
        get target(): Node;
        set target(value: Node);
        /**
         * @en
         * Whether the Button is disabled.
         * If true, the Button will trigger event and do transition.
         *
         * @zh
         * 按钮事件是否被响应，如果为 false，则按钮将被禁用。
         */
        get interactable(): boolean;
        set interactable(value: boolean);
        set _resizeToTarget(value: boolean);
        /**
         * @en
         * Transition type.
         *
         * @zh
         * 按钮状态改变时过渡方式。
         */
        get transition(): __private._cocos_ui_button__Transition;
        set transition(value: __private._cocos_ui_button__Transition);
        /**
         * @en
         * Normal state color.
         *
         * @zh
         * 普通状态下按钮所显示的颜色。
         */
        get normalColor(): Readonly<math.Color>;
        set normalColor(value: Readonly<math.Color>);
        /**
         * @en
         * Pressed state color.
         *
         * @zh
         * 按下状态时按钮所显示的颜色。
         */
        get pressedColor(): Readonly<math.Color>;
        set pressedColor(value: Readonly<math.Color>);
        /**
         * @en
         * Hover state color.
         *
         * @zh
         * 悬停状态下按钮所显示的颜色。
         */
        get hoverColor(): Readonly<math.Color>;
        set hoverColor(value: Readonly<math.Color>);
        /**
         * @en
         * Disabled state color.
         *
         * @zh
         * 禁用状态下按钮所显示的颜色。
         */
        get disabledColor(): Readonly<math.Color>;
        set disabledColor(value: Readonly<math.Color>);
        /**
         * @en
         * Color and Scale transition duration.
         *
         * @zh
         * 颜色过渡和缩放过渡时所需时间。
         */
        get duration(): number;
        set duration(value: number);
        /**
         * @en
         * When user press the button, the button will zoom to a scale.
         * The final scale of the button equals (button original scale * zoomScale)
         * NOTE: Setting zoomScale less than 1 is not adviced, which could fire the touchCancel event if the touch point is out of touch area after scaling.
         * if you need to do so, you should set target as another background node instead of the button node.
         *
         * @zh
         * 当用户点击按钮后，按钮会缩放到一个值，这个值等于 Button 原始 scale * zoomScale。
         * 注意：不建议 zoomScale 的值小于 1, 否则缩放后如果触摸点在触摸区域外, 则会触发 touchCancel 事件。
         * 如果你需要这么做，你应该把 target 设置为另一个背景节点，而不是按钮节点。
         */
        get zoomScale(): number;
        set zoomScale(value: number);
        /**
         * @en
         * Normal state sprite.
         *
         * @zh
         * 普通状态下按钮所显示的 Sprite。
         */
        get normalSprite(): SpriteFrame | null;
        set normalSprite(value: SpriteFrame | null);
        /**
         * @en
         * Pressed state sprite.
         *
         * @zh
         * 按下状态时按钮所显示的 Sprite。
         */
        get pressedSprite(): SpriteFrame | null;
        set pressedSprite(value: SpriteFrame | null);
        /**
         * @en
         * Hover state sprite.
         *
         * @zh
         * 悬停状态下按钮所显示的 Sprite。
         */
        get hoverSprite(): SpriteFrame | null;
        set hoverSprite(value: SpriteFrame | null);
        /**
         * @en
         * Disabled state sprite.
         *
         * @zh
         * 禁用状态下按钮所显示的 Sprite。
         */
        get disabledSprite(): SpriteFrame | null;
        set disabledSprite(value: SpriteFrame | null);
        static Transition: typeof __private._cocos_ui_button__Transition;
        static EventType: typeof __private._cocos_ui_button__EventType;
        /**
         * @en
         * If Button is clicked, it will trigger event's handler.
         *
         * @zh
         * 按钮的点击事件列表。
         */
        clickEvents: EventHandler[];
        protected _interactable: boolean;
        protected _transition: __private._cocos_ui_button__Transition;
        protected _normalColor: math.Color;
        protected _hoverColor: math.Color;
        protected _pressedColor: math.Color;
        protected _disabledColor: math.Color;
        protected _normalSprite: SpriteFrame | null;
        protected _hoverSprite: SpriteFrame | null;
        protected _pressedSprite: SpriteFrame | null;
        protected _disabledSprite: SpriteFrame | null;
        protected _duration: number;
        protected _zoomScale: number;
        protected _target: Node | null;
        __preload(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        update(dt: number): void;
        protected _resizeNodeToTargetNode(): void;
        protected _resetState(): void;
        protected _registerNodeEvent(): void;
        protected _registerTargetEvent(target: any): void;
        protected _unregisterNodeEvent(): void;
        protected _unregisterTargetEvent(target: any): void;
        protected _getTargetSprite(target: Node | null): Sprite | null;
        protected _applyTarget(): void;
        protected _onTouchBegan(event?: EventTouch): void;
        protected _onTouchMove(event?: EventTouch): void;
        protected _onTouchEnded(event?: EventTouch): void;
        protected _onTouchCancel(event?: EventTouch): void;
        protected _onMouseMoveIn(event?: EventMouse): void;
        protected _onMouseMoveOut(event?: EventMouse): void;
        protected _updateState(): void;
        protected _getButtonState(): string;
        protected _updateColorTransition(state: string): void;
        protected _updateSpriteTransition(state: string): void;
        protected _updateScaleTransition(state: string): void;
        protected _zoomUp(): void;
        protected _zoomBack(): void;
        protected _applyTransition(state: string): void;
    }
    /**
     * @en
     * `EditBox` is a component for inputing text, you can use it to gather small amounts of text from users.
     *
     * @zh
     * `EditBox` 组件，用于获取用户的输入文本。
     */
    export class EditBox extends Component {
        /**
         * @en
         * Input string of EditBox.
         *
         * @zh
         * 输入框的初始输入内容，如果为空则会显示占位符的文本。
         */
        get string(): string;
        set string(value: string);
        /**
         * @en
         * The display text of placeholder.
         *
         * @zh
         * 输入框占位符的文本内容。
         */
        get placeholder(): string;
        set placeholder(value: string);
        /**
         * @en
         * The Label component attached to the node for EditBox's input text label
         *
         * @zh
         * 输入框输入文本节点上挂载的 Label 组件对象
         */
        get textLabel(): Label | null;
        set textLabel(oldValue: Label | null);
        /**
         * @en
         * The Label component attached to the node for EditBox's placeholder text label.
         *
         * @zh
         * 输入框占位符节点上挂载的 Label 组件对象。
         */
        get placeholderLabel(): Label | null;
        set placeholderLabel(oldValue: Label | null);
        /**
         * @en
         * The background image of EditBox.
         *
         * @zh
         * 输入框的背景图片。
         */
        get backgroundImage(): SpriteFrame | null;
        set backgroundImage(value: SpriteFrame | null);
        /**
         * @en
         * Set the input flags that are to be applied to the EditBox.
         *
         * @zh
         * 指定输入标志位，可以指定输入方式为密码或者单词首字母大写。
         */
        get inputFlag(): __private._cocos_ui_editbox_types__InputFlag;
        set inputFlag(value: __private._cocos_ui_editbox_types__InputFlag);
        /**
         * @en
         * Set the input mode of the edit box.
         * If you pass ANY, it will create a multiline EditBox.
         *
         * @zh
         * 指定输入模式: ANY表示多行输入，其它都是单行输入，移动平台上还可以指定键盘样式。
         */
        get inputMode(): __private._cocos_ui_editbox_types__InputMode;
        set inputMode(oldValue: __private._cocos_ui_editbox_types__InputMode);
        /**
         * @en
         * The return key type of EditBox.
         * Note: it is meaningless for web platforms and desktop platforms.
         *
         * @zh
         * 指定移动设备上面回车按钮的样式。
         * 注意：这个选项对 web 平台与 desktop 平台无效。
         */
        get returnType(): __private._cocos_ui_editbox_types__KeyboardReturnType;
        set returnType(value: __private._cocos_ui_editbox_types__KeyboardReturnType);
        /**
         * @en
         * The maximize input length of EditBox.
         * - If pass a value less than 0, it won't limit the input number of characters.
         * - If pass 0, it doesn't allow input any characters.
         *
         * @zh
         * 输入框最大允许输入的字符个数。
         * - 如果值为小于 0 的值，则不会限制输入字符个数。
         * - 如果值为 0，则不允许用户进行任何输入。
         */
        get maxLength(): number;
        set maxLength(value: number);
        /**
         * @en
         * Set the tabIndex of the DOM input element (only useful on Web).
         *
         * @zh
         * 修改 DOM 输入元素的 tabIndex（这个属性只有在 Web 上面修改有意义）。
         */
        get tabIndex(): number;
        set tabIndex(value: number);
        static _EditBoxImpl: typeof __private._cocos_ui_editbox_edit_box_impl_base__EditBoxImplBase;
        static KeyboardReturnType: typeof __private._cocos_ui_editbox_types__KeyboardReturnType;
        static InputFlag: typeof __private._cocos_ui_editbox_types__InputFlag;
        static InputMode: typeof __private._cocos_ui_editbox_types__InputMode;
        static EventType: typeof __private._cocos_ui_editbox_edit_box__EventType;
        /**
         * @en
         * The event handler to be called when EditBox began to edit text.
         *
         * @zh
         * 开始编辑文本输入框触发的事件回调。
         */
        editingDidBegan: EventHandler[];
        /**
         * @en
         * The event handler to be called when EditBox text changes.
         *
         * @zh
         * 编辑文本输入框时触发的事件回调。
         */
        textChanged: EventHandler[];
        /**
         * @en
         * The event handler to be called when EditBox edit ends.
         *
         * @zh
         * 结束编辑文本输入框时触发的事件回调。
         */
        editingDidEnded: EventHandler[];
        /**
         * @en
         * The event handler to be called when return key is pressed. Windows is not supported.
         *
         * @zh
         * 当用户按下回车按键时的事件回调，目前不支持 windows 平台
         */
        editingReturn: EventHandler[];
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _impl: __private._cocos_ui_editbox_edit_box_impl_base__EditBoxImplBase | null;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _background: Sprite | null;
        protected _textLabel: Label | null;
        protected _placeholderLabel: Label | null;
        protected _returnType: __private._cocos_ui_editbox_types__KeyboardReturnType;
        protected _string: string;
        protected _tabIndex: number;
        protected _backgroundImage: SpriteFrame | null;
        protected _inputFlag: __private._cocos_ui_editbox_types__InputFlag;
        protected _inputMode: __private._cocos_ui_editbox_types__InputMode;
        protected _maxLength: number;
        __preload(): void;
        onEnable(): void;
        update(): void;
        onDisable(): void;
        onDestroy(): void;
        /**
         * @en Let the EditBox get focus
         * @zh 让当前 EditBox 获得焦点。
         */
        setFocus(): void;
        /**
         * @en Let the EditBox get focus
         * @zh 让当前 EditBox 获得焦点
         */
        focus(): void;
        /**
         * @en Let the EditBox lose focus
         * @zh 让当前 EditBox 失去焦点
         */
        blur(): void;
        /**
         * @en Determine whether EditBox is getting focus or not.
         * @zh 判断 EditBox 是否获得了焦点。
         * Note: only available on Web at the moment.
         */
        isFocused(): boolean;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _editBoxEditingDidBegan(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _editBoxEditingDidEnded(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _editBoxTextChanged(text: string): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _editBoxEditingReturn(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _showLabels(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _hideLabels(): void;
        protected _onTouchBegan(event: EventTouch): void;
        protected _onTouchCancel(event: EventTouch): void;
        protected _onTouchEnded(event: EventTouch): void;
        protected _init(): void;
        protected _ensureBackgroundSprite(): void;
        protected _updateTextLabel(): void;
        protected _updatePlaceholderLabel(): void;
        protected _syncSize(): void;
        protected _updateLabels(): void;
        protected _updateString(text: string): void;
        protected _updateLabelStringStyle(text: string, ignorePassword?: boolean): string;
        protected _registerEvent(): void;
        protected _unregisterEvent(): void;
        protected _updateLabelPosition(size: math.Size): void;
        protected _resizeChildNodes(): void;
        protected _xrUnClick(): void;
        protected _xrKeyBoardInput(str: string): void;
    }
    /**
     * @en
     * The Layout is a container component, use it to arrange child elements easily.<br>
     * Note：<br>
     * 1.Scaling and rotation of child nodes are not considered.<br>
     * 2.After setting the Layout, the results need to be updated until the next frame,unless you manually call.[[updateLayout]]
     *
     * @zh
     * Layout 组件相当于一个容器，能自动对它的所有子节点进行统一排版。<br>
     * 注意：<br>
     * 1.不会考虑子节点的缩放和旋转。<br>
     * 2.对 Layout 设置后结果需要到下一帧才会更新，除非你设置完以后手动调用。[[updateLayout]]
     */
    export class Layout extends Component {
        /**
         * @en
         * Alignment horizontal. Fixed starting position in the same direction when Type is Horizontal.
         *
         * @zh
         * 横向对齐。在 Type 为 Horizontal 时按同个方向固定起始位置排列。
         */
        get alignHorizontal(): boolean;
        set alignHorizontal(value: boolean);
        /**
         * @en
         * Alignment vertical. Fixed starting position in the same direction when Type is Vertical.
         *
         * @zh
         * 纵向对齐。在 Type 为 Horizontal 或 Vertical 时按同个方向固定起始位置排列。
         */
        get alignVertical(): boolean;
        set alignVertical(value: boolean);
        /**
         * @en
         * The layout type.
         *
         * @zh
         * 布局类型。
         */
        get type(): __private._cocos_ui_layout__Type;
        set type(value: __private._cocos_ui_layout__Type);
        /**
         * @en
         * The are three resize modes for Layout. None, resize Container and resize children.
         *
         * @zh
         * 缩放模式。
         */
        get resizeMode(): __private._cocos_ui_layout__ResizeMode;
        set resizeMode(value: __private._cocos_ui_layout__ResizeMode);
        /**
         * @en
         * The cell size for grid layout.
         *
         * @zh
         * 每个格子的大小，只有布局类型为 GRID 的时候才有效。
         */
        get cellSize(): Readonly<math.Size>;
        set cellSize(value: Readonly<math.Size>);
        /**
         * @en
         * The start axis for grid layout. If you choose horizontal, then children will layout horizontally at first,
         * and then break line on demand. Choose vertical if you want to layout vertically at first .
         *
         * @zh
         * 起始轴方向类型，可进行水平和垂直布局排列，只有布局类型为 GRID 的时候才有效。
         */
        get startAxis(): __private._cocos_ui_layout__AxisDirection;
        set startAxis(value: __private._cocos_ui_layout__AxisDirection);
        /**
         * @en
         * The left padding of layout, it only effect the layout in one direction.
         *
         * @zh
         * 容器内左边距，只会在一个布局方向上生效。
         */
        get paddingLeft(): number;
        set paddingLeft(value: number);
        /**
         * @en
         * The right padding of layout, it only effect the layout in one direction.
         *
         * @zh
         * 容器内右边距，只会在一个布局方向上生效。
         */
        get paddingRight(): number;
        set paddingRight(value: number);
        /**
         * @en
         * The top padding of layout, it only effect the layout in one direction.
         *
         * @zh
         * 容器内上边距，只会在一个布局方向上生效。
         */
        get paddingTop(): number;
        set paddingTop(value: number);
        /**
         * @en
         * The bottom padding of layout, it only effect the layout in one direction.
         *
         * @zh
         * 容器内下边距，只会在一个布局方向上生效。
         */
        get paddingBottom(): number;
        set paddingBottom(value: number);
        /**
         * @en
         * The distance in x-axis between each element in layout.
         *
         * @zh
         * 子节点之间的水平间距。
         */
        get spacingX(): number;
        set spacingX(value: number);
        /**
         * @en
         * The distance in y-axis between each element in layout.
         *
         * @zh
         * 子节点之间的垂直间距。
         */
        get spacingY(): number;
        set spacingY(value: number);
        /**
         * @en
         * Only take effect in Vertical layout mode.
         * This option changes the start element's positioning.
         *
         * @zh
         * 垂直排列子节点的方向。
         */
        get verticalDirection(): __private._cocos_ui_layout__VerticalDirection;
        set verticalDirection(value: __private._cocos_ui_layout__VerticalDirection);
        /**
         * @en
         * Only take effect in horizontal layout mode.
         * This option changes the start element's positioning.
         *
         * @zh
         * 水平排列子节点的方向。
         */
        get horizontalDirection(): __private._cocos_ui_layout__HorizontalDirection;
        set horizontalDirection(value: __private._cocos_ui_layout__HorizontalDirection);
        /**
         * @en
         * The padding of layout, it will effect the layout in horizontal and vertical direction.
         *
         * @zh
         * 容器内边距，该属性会在四个布局方向上生效。
         */
        get padding(): number;
        set padding(value: number);
        /**
         * @en
         * The layout constraint inside the container.
         *
         * @zh
         * 容器内布局约束。
         */
        get constraint(): __private._cocos_ui_layout__Constraint;
        set constraint(value: __private._cocos_ui_layout__Constraint);
        /**
         * @en
         * The limit value used by the layout constraint inside the container.
         *
         * @zh
         * 容器内布局约束使用的限定值。
         */
        get constraintNum(): number;
        set constraintNum(value: number);
        /**
         * @en
         * Adjust the layout if the children scaled.
         *
         * @zh
         * 子节点缩放比例是否影响布局。
         */
        get affectedByScale(): boolean;
        set affectedByScale(value: boolean);
        static Type: typeof __private._cocos_ui_layout__Type;
        static VerticalDirection: typeof __private._cocos_ui_layout__VerticalDirection;
        static HorizontalDirection: typeof __private._cocos_ui_layout__HorizontalDirection;
        static ResizeMode: typeof __private._cocos_ui_layout__ResizeMode;
        static AxisDirection: typeof __private._cocos_ui_layout__AxisDirection;
        static Constraint: typeof __private._cocos_ui_layout__Constraint;
        protected _resizeMode: __private._cocos_ui_layout__ResizeMode;
        protected _layoutType: __private._cocos_ui_layout__Type;
        protected _cellSize: math.Size;
        protected _startAxis: __private._cocos_ui_layout__AxisDirection;
        protected _paddingLeft: number;
        protected _paddingRight: number;
        protected _paddingTop: number;
        protected _paddingBottom: number;
        protected _spacingX: number;
        protected _spacingY: number;
        protected _verticalDirection: __private._cocos_ui_layout__VerticalDirection;
        protected _horizontalDirection: __private._cocos_ui_layout__HorizontalDirection;
        protected _constraint: __private._cocos_ui_layout__Constraint;
        protected _constraintNum: number;
        protected _affectedByScale: boolean;
        protected _isAlign: boolean;
        protected _layoutSize: math.Size;
        protected _layoutDirty: boolean;
        protected _childrenDirty: boolean;
        protected _usefulLayoutObj: UITransform[];
        protected _init: boolean;
        /**
         * @en
         * Perform the layout update.
         *
         * @zh
         * 立即执行更新布局。
         *
         * @example
         * ```ts
         * import { Layout, log } from 'cc';
         * layout.type = Layout.Type.HORIZONTAL;
         * layout.node.addChild(childNode);
         * log(childNode.x); // not yet changed
         * layout.updateLayout();
         * log(childNode.x); // changed
         * ```
         */
        updateLayout(force?: boolean): void;
        protected onEnable(): void;
        protected onDisable(): void;
        protected _checkUsefulObj(): void;
        protected _addEventListeners(): void;
        protected _removeEventListeners(): void;
        protected _addChildrenEventListeners(): void;
        protected _removeChildrenEventListeners(): void;
        protected _childAdded(child: Node): void;
        protected _childRemoved(child: Node): void;
        protected _resized(): void;
        protected _doLayoutHorizontally(baseWidth: number, rowBreak: boolean, fnPositionY: (...args: any[]) => number, applyChildren: boolean): number;
        protected _doLayoutVertically(baseHeight: number, columnBreak: boolean, fnPositionX: (...args: any[]) => number, applyChildren: boolean): number;
        protected _doLayoutGridAxisHorizontal(layoutAnchor: math.Vec2 | Readonly<math.Vec2>, layoutSize: math.Size): void;
        protected _doLayoutGridAxisVertical(layoutAnchor: math.Vec2 | Readonly<math.Vec2>, layoutSize: math.Size): void;
        protected _doLayoutGrid(): void;
        protected _getHorizontalBaseWidth(horizontal?: boolean): number;
        protected _getVerticalBaseHeight(): number;
        protected _doLayout(): void;
        protected _getUsedScaleValue(value: number): number;
        protected _transformDirty(type: TransformBit): void;
        protected _doLayoutDirty(): void;
        protected _childrenChanged(): void;
        protected _getPaddingH(): number;
        protected _getPaddingV(): number;
        protected _getFixedBreakingNum(): number;
    }
    /**
     * @en
     * Visual indicator of progress in some operation.
     * Displays a bar to the user representing how far the operation has progressed.
     *
     * @zh
     * 进度条组件，可用于显示加载资源时的进度。
     *
     * @example
     * ```ts
     * // update progressBar
     * update(dt) {
     *     var progress = progressBar.progress;
     *     if (progress > 0) {
     *         progress += dt;
     *     }
     *     else {
     *         progress = 1;
     *     }
     *     progressBar.progress = progress;
     * }
     * ```
     */
    export class ProgressBar extends Component {
        /**
         * @en
         * The targeted Sprite which will be changed progressively.
         *
         * @zh
         * 用来显示进度条比例的 Sprite 对象。
         */
        get barSprite(): Sprite | null;
        set barSprite(value: Sprite | null);
        /**
         * @en
         * The progress mode, there are two modes supported now: horizontal and vertical.
         *
         * @zh
         * 进度条的模式。
         */
        get mode(): __private._cocos_ui_progress_bar__Mode;
        set mode(value: __private._cocos_ui_progress_bar__Mode);
        /**
         * @en
         * The total width or height of the bar sprite.
         *
         * @zh
         * 进度条实际的总长度。
         */
        get totalLength(): number;
        set totalLength(value: number);
        /**
         * @en
         * The current progress of the bar sprite. The valid value is between 0-1.
         *
         * @zh
         * 当前进度值，该数值的区间是 0-1 之间。
         */
        get progress(): number;
        set progress(value: number);
        /**
         * @en
         * Whether reverse the progress direction of the bar sprite.
         *
         * @zh
         * 进度条是否进行反方向变化。
         */
        get reverse(): boolean;
        set reverse(value: boolean);
        static Mode: typeof __private._cocos_ui_progress_bar__Mode;
        protected _barSprite: Sprite | null;
        protected _mode: __private._cocos_ui_progress_bar__Mode;
        protected _totalLength: number;
        protected _progress: number;
        protected _reverse: boolean;
        protected _initBarSprite(): void;
        protected _updateBarStatus(): void;
    }
    /**
     * @en
     * The ScrollBar control allows the user to scroll an image or other view that is too large to see completely.
     *
     * @zh
     * 滚动条组件。
     */
    export class ScrollBar extends Component {
        /**
         * @en
         * The "handle" part of the ScrollBar.
         *
         * @zh
         * 作为当前滚动区域位置显示的滑块 Sprite。
         */
        get handle(): Sprite | null;
        set handle(value: Sprite | null);
        /**
         * @en
         * The direction of scrolling.
         *
         * @zh
         * ScrollBar 的滚动方向。
         */
        get direction(): __private._cocos_ui_scroll_bar__Direction;
        set direction(value: __private._cocos_ui_scroll_bar__Direction);
        /**
         * @en
         * Whether enable auto hide or not.
         *
         * @zh
         * 是否在没有滚动动作时自动隐藏 ScrollBar。
         */
        get enableAutoHide(): boolean;
        set enableAutoHide(value: boolean);
        /**
         * @en
         * The time to hide ScrollBar when scroll finished.
         * Note: This value is only useful when enableAutoHide is true.
         *
         * @zh
         * 没有滚动动作后经过多久会自动隐藏。<br/>
         * 注意：只要当 “enableAutoHide” 为 true 时，才有效。
         */
        get autoHideTime(): number;
        set autoHideTime(value: number);
        static Direction: typeof __private._cocos_ui_scroll_bar__Direction;
        protected _scrollView: ScrollView | null;
        protected _handle: Sprite | null;
        protected _direction: __private._cocos_ui_scroll_bar__Direction;
        protected _enableAutoHide: boolean;
        protected _autoHideTime: number;
        protected _touching: boolean;
        protected _opacity: number;
        protected _autoHideRemainingTime: number;
        /**
         * @en
         * Hide ScrollBar.
         *
         * @zh
         * 滚动条隐藏。
         */
        hide(): void;
        /**
         * @en
         * Show ScrollBar.
         *
         * @zh
         * 滚动条显示。
         */
        show(): void;
        /**
         * @en
         * Reset the position of ScrollBar.
         *
         * @zh
         * 重置滚动条位置。
         *
         * @param outOfBoundary @en Rolling displacement @zh 滚动位移。
         */
        onScroll(outOfBoundary: math.Vec2 | Readonly<math.Vec2>): void;
        /**
         * @en
         * Sets the scroll view.
         *
         * @zh
         * 滚动视窗设置。
         *
         * @param scrollView @en The scroll view which is attached with this scroll bar @zh 当前滚动条附着的滚动视窗
         */
        setScrollView(scrollView: ScrollView): void;
        onTouchBegan(): void;
        onTouchEnded(): void;
        protected onEnable(): void;
        protected start(): void;
        protected update(dt: any): void;
        protected _convertToScrollViewSpace(out: math.Vec2, content: Node): void;
        protected _setOpacity(opacity: number): void;
        protected _updateHandlerPosition(position: math.Vec2): void;
        protected _fixupHandlerPosition(out: math.Vec3): void;
        protected _conditionalDisableScrollBar(contentSize: math.Size, scrollViewSize: math.Size): boolean;
        protected _calculateLength(contentMeasure: number, scrollViewMeasure: number, handleNodeMeasure: number, outOfBoundary: number): number;
        protected _calculatePosition(out: math.Vec2, contentMeasure: number, scrollViewMeasure: number, handleNodeMeasure: number, contentPosition: number, outOfBoundary: number, actualLenth: number): void;
        protected _updateLength(length: number): void;
        protected _processAutoHide(deltaTime: number): void;
    }
    /**
     * @en
     * Layout container for a view hierarchy that can be scrolled by the user,
     * allowing it to be larger than the physical display.
     *
     * @zh
     * 滚动视图组件。
     */
    export class ScrollView extends ViewGroup {
        static EventType: typeof __private._cocos_ui_scroll_view__EventType;
        /**
         * @en
         * The elapse time of bouncing back. A value of 0 will bounce back immediately.
         *
         * @zh
         * 回弹持续的时间，0 表示将立即反弹。
         */
        bounceDuration: number;
        /**
         * @en
         * It determines how quickly the content stop moving. A value of 1 will stop the movement immediately.
         * A value of 0 will never stop the movement until it reaches to the boundary of scrollview.
         *
         * @zh
         * 开启惯性后，在用户停止触摸后滚动多快停止，0表示永不停止，1表示立刻停止。
         */
        brake: number;
        /**
         * @en
         * When elastic is set, the content will be bounce back when move out of boundary.
         *
         * @zh
         * 是否允许滚动内容超过边界，并在停止触摸后回弹。
         */
        elastic: boolean;
        /**
         * @en
         * When inertia is set, the content will continue to move when touch ended.
         *
         * @zh
         * 是否开启滚动惯性。
         */
        inertia: boolean;
        /**
         * @en
         * This is a reference to the UI element to be scrolled.
         *
         * @zh
         * 可滚动展示内容的节点。
         */
        get content(): Node | null;
        set content(value: Node | null);
        /**
         * @en
         * Enable horizontal scroll.
         *
         * @zh
         * 是否开启水平滚动。
         */
        horizontal: boolean;
        /**
         * @en
         * The horizontal scrollbar reference.
         * @zh
         * 水平滚动的 ScrollBar。
         */
        get horizontalScrollBar(): ScrollBar | null;
        set horizontalScrollBar(value: ScrollBar | null);
        /**
         * @en
         * Enable vertical scroll.
         *
         * @zh
         * 是否开启垂直滚动。
         */
        vertical: boolean;
        /**
         * @en
         * The vertical scrollbar reference.
         *
         * @zh
         * 垂直滚动的 ScrollBar。
         */
        get verticalScrollBar(): ScrollBar | null;
        set verticalScrollBar(value: ScrollBar | null);
        /**
         * @en
         * If cancelInnerEvents is set to true, the scroll behavior will cancel touch events on inner content nodes
         * It's set to true by default.
         *
         * @zh
         * 如果这个属性被设置为 true，那么滚动行为会取消子节点上注册的触摸事件，默认被设置为 true。<br/>
         * 注意，子节点上的 touchstart 事件仍然会触发，触点移动距离非常短的情况下 touchmove 和 touchend 也不会受影响。
         */
        cancelInnerEvents: boolean;
        /**
         * @en
         * ScrollView events callback.
         *
         * @zh
         * 滚动视图的事件回调函数。
         */
        scrollEvents: EventHandler[];
        get view(): UITransform | null;
        protected _autoScrolling: boolean;
        protected _scrolling: boolean;
        protected _content: Node | null;
        protected _horizontalScrollBar: ScrollBar | null;
        protected _verticalScrollBar: ScrollBar | null;
        protected _topBoundary: number;
        protected _bottomBoundary: number;
        protected _leftBoundary: number;
        protected _rightBoundary: number;
        protected _touchMoveDisplacements: math.Vec3[];
        protected _touchMoveTimeDeltas: number[];
        protected _touchMovePreviousTimestamp: number;
        protected _touchMoved: boolean;
        protected _autoScrollAttenuate: boolean;
        protected _autoScrollStartPosition: math.Vec3;
        protected _autoScrollTargetDelta: math.Vec3;
        protected _autoScrollTotalTime: number;
        protected _autoScrollAccumulatedTime: number;
        protected _autoScrollCurrentlyOutOfBoundary: boolean;
        protected _autoScrollBraking: boolean;
        protected _autoScrollBrakingStartPosition: math.Vec3;
        protected _outOfBoundaryAmount: math.Vec3;
        protected _outOfBoundaryAmountDirty: boolean;
        protected _stopMouseWheel: boolean;
        protected _mouseWheelEventElapsedTime: number;
        protected _isScrollEndedWithThresholdEventFired: boolean;
        protected _scrollEventEmitMask: number;
        protected _isBouncing: boolean;
        protected _contentPos: math.Vec3;
        protected _deltaPos: math.Vec3;
        protected _hoverIn: __private._cocos_ui_scroll_view__XrhoverType;
        protected _scrollState: math.Vec2;
        /**
         * @en
         * Scroll the content to the bottom boundary of ScrollView.
         *
         * @zh
         * 视图内容将在规定时间内滚动到视图底部。
         *
         * @param timeInSecond
         * @en The rolling time(in seconds). If time is up, the content will slide to the bottom border. @zh 滚动时间（s）。 如果超时，内容将立即跳到底部边界。
         * @param attenuated @en Whether the rolling acceleration is attenuated(The default is true) @zh 滚动加速是否衰减，默认为 true
         * @example
         * ```ts
         * // Scroll to the bottom of the view.
         * scrollView.scrollToBottom(0.1);
         * ```
         */
        scrollToBottom(timeInSecond?: number, attenuated?: boolean): void;
        /**
         * @en
         * Scroll the content to the top boundary of ScrollView.
         *
         * @zh
         * 视图内容将在规定时间内滚动到视图顶部。
         *
         * @param timeInSecond
         * @en The rolling time(in seconds). If time is up, the content will slide to the bottom border. @zh 滚动时间（s）。 如果超时，内容将立即跳到底部边界。
         * @param attenuated @en Whether the rolling acceleration is attenuated(The default is true) @zh 滚动加速是否衰减，默认为 true
         * @example
         * ```ts
         * // Scroll to the top of the view.
         * scrollView.scrollToTop(0.1);
         * ```
         */
        scrollToTop(timeInSecond?: number, attenuated?: boolean): void;
        /**
         * @en
         * Scroll the content to the left boundary of ScrollView.
         *
         * @zh
         * 视图内容将在规定时间内滚动到视图左边。
         *
         * @param timeInSecond
         * @en The rolling time(in seconds). If time is up, the content will slide to the bottom border. @zh 滚动时间（s）。 如果超时，内容将立即跳到底部边界。
         * @param attenuated @en Whether the rolling acceleration is attenuated(The default is true) @zh 滚动加速是否衰减，默认为 true
         * @example
         * ```ts
         * // Scroll to the left of the view.
         * scrollView.scrollToLeft(0.1);
         * ```
         */
        scrollToLeft(timeInSecond?: number, attenuated?: boolean): void;
        /**
         * @en
         * Scroll the content to the right boundary of ScrollView.
         *
         * @zh
         * 视图内容将在规定时间内滚动到视图右边。
         *
         * @param timeInSecond
         * @en The rolling time(in seconds). If time is up, the content will slide to the bottom border. @zh 滚动时间（s）。 如果超时，内容将立即跳到底部边界。
         * @param attenuated @en Whether the rolling acceleration is attenuated(The default is true) @zh 滚动加速是否衰减，默认为 true
         * @example
         * ```ts
         * // Scroll to the right of the view.
         * scrollView.scrollToRight(0.1);
         * ```
         */
        scrollToRight(timeInSecond?: number, attenuated?: boolean): void;
        /**
         * @en
         * Scroll the content to the top left boundary of ScrollView.
         *
         * @zh
         * 视图内容将在规定时间内滚动到视图左上角。
         *
         * @param timeInSecond
         * @en The rolling time(in seconds). If time is up, the content will slide to the bottom border. @zh 滚动时间（s）。 如果超时，内容将立即跳到底部边界。
         * @param attenuated @en Whether the rolling acceleration is attenuated(The default is true) @zh 滚动加速是否衰减，默认为 true
         * @example
         * ```ts
         * // Scroll to the upper left corner of the view.
         * scrollView.scrollToTopLeft(0.1);
         * ```
         */
        scrollToTopLeft(timeInSecond?: number, attenuated?: boolean): void;
        /**
         * @en
         * Scroll the content to the top right boundary of ScrollView.
         *
         * @zh
         * 视图内容将在规定时间内滚动到视图右上角。
         *
         * @param timeInSecond
         * @en The rolling time(in seconds). If time is up, the content will slide to the bottom border. @zh 滚动时间（s）。 如果超时，内容将立即跳到底部边界。
         * @param attenuated @en Whether the rolling acceleration is attenuated(The default is true) @zh 滚动加速是否衰减，默认为 true
         * @example
         * ```ts
         * // Scroll to the top right corner of the view.
         * scrollView.scrollToTopRight(0.1);
         * ```
         */
        scrollToTopRight(timeInSecond?: number, attenuated?: boolean): void;
        /**
         * @en
         * Scroll the content to the bottom left boundary of ScrollView.
         *
         * @zh
         * 视图内容将在规定时间内滚动到视图左下角。
         *
         * @param timeInSecond
         * @en The rolling time(in seconds). If time is up, the content will slide to the bottom border. @zh 滚动时间（s）。 如果超时，内容将立即跳到底部边界。
         * @param attenuated @en Whether the rolling acceleration is attenuated(The default is true) @zh 滚动加速是否衰减，默认为 true
         * @example
         * ```ts
         * // Scroll to the lower left corner of the view.
         * scrollView.scrollToBottomLeft(0.1);
         * ```
         */
        scrollToBottomLeft(timeInSecond?: number, attenuated?: boolean): void;
        /**
         * @en
         * Scroll the content to the bottom right boundary of ScrollView.
         *
         * @zh
         * 视图内容将在规定时间内滚动到视图右下角。
         *
         * @param timeInSecond
         * @en The rolling time(in seconds). If time is up, the content will slide to the bottom border. @zh 滚动时间（s）。 如果超时，内容将立即跳到底部边界。
         * @param attenuated @en Whether the rolling acceleration is attenuated(The default is true) @zh 滚动加速是否衰减，默认为 true
         * @example
         * ```ts
         * // Scroll to the lower right corner of the view.
         * scrollView.scrollToBottomRight(0.1);
         * ```
         */
        scrollToBottomRight(timeInSecond?: number, attenuated?: boolean): void;
        /**
         * @en
         * Scroll with an offset related to the ScrollView's top left origin, if timeInSecond is omitted,
         * then it will jump to the specific offset immediately.
         *
         * @zh
         * 视图内容在规定时间内将滚动到 ScrollView 相对左上角原点的偏移位置, 如果 timeInSecond 参数不传，则立即滚动到指定偏移位置。
         *
         * @param offset
         * @en After scrolling the view, the position of the view content relative to the view window. @zh 滚动视图后，视图内容（content）相对于视图窗口（viewport）的位置。
         * @param timeInSecond
         * @en Scroll time (s). If it times out, the content immediately jumps to the specified offset. @zh 滚动时间（s）。 如果超时，内容将立即跳到指定偏移量处。
         * @param attenuated @en Whether the rolling acceleration is attenuated(The default is true) @zh 滚动加速是否衰减，默认为 true
         * @example
         * ```ts
         * // Scroll to middle position in 0.1 second in x-axis
         * let maxScrollOffset = this.getMaxScrollOffset();
         * scrollView.scrollToOffset(new Vec2(maxScrollOffset.x / 2, 0), 0.1);
         * ```
         */
        scrollToOffset(offset: math.Vec2, timeInSecond?: number, attenuated?: boolean): void;
        /**
         * @en
         * Get the position of the scrolling view relative to the origin in the upper-left corner of the viewport.
         *
         * @zh
         * 获取滚动视图相对于视图窗口左上角原点的位置。
         *
         * @return @en Current rolling offset @zh 当前滚动偏移量
         */
        getScrollOffset(): math.Vec2;
        /**
         * @en
         * Get the maximize available  scroll offset.
         *
         * @zh
         * 获取滚动视图最大可以滚动的偏移量。
         *
         * @return @en Maximum scrollable offset @zh 最大可滚动偏移量
         */
        getMaxScrollOffset(): Readonly<math.Vec2>;
        /**
         * @en
         * Scroll the content to the horizontal percent position of ScrollView.
         *
         * @zh
         * 视图内容在规定时间内将滚动到 ScrollView 水平方向的百分比位置上。
         *
         * @param percent
         * @en Scroll to the destination which is located at the percent interpolation from left border to the right border @zh 滚动到从左到右指定百分比插值的位置
         * @param timeInSecond
         * @en Scroll time (s). If it times out, the content immediately jumps to the specified offset. @zh 滚动时间（s）。 如果超时，内容将立即跳到指定偏移量处。
         * @param attenuated @en Whether the rolling acceleration is attenuated(The default is true) @zh 滚动加速是否衰减，默认为 true
         * @example
         * ```ts
         * // Scroll to middle position.
         * scrollView.scrollToBottomRight(0.5, 0.1);
         * ```
         */
        scrollToPercentHorizontal(percent: number, timeInSecond: number, attenuated: boolean): void;
        /**
         * @en
         * Scroll the content to the percent position of ScrollView in any direction.
         *
         * @zh
         * 视图内容在规定时间内进行垂直方向和水平方向的滚动，并且滚动到指定百分比位置上。
         *
         * @param anchor
         * @en Scroll to the destination which is located at the anchor interpolation from left/top border to the right/bottom border
         * @zh 滚动到从左/上到右/下指定锚点对应分量插值的位置
         * @param timeInSecond
         * @en Scroll time (s). If it times out, the content immediately jumps to the specified offset. @zh 滚动时间（s）。 如果超时，内容将立即跳到指定偏移量处。
         * @param attenuated @en Whether the rolling acceleration is attenuated(The default is true) @zh 滚动加速是否衰减，默认为 true
         * @example
         * ```ts
         * // Vertical scroll to the bottom of the view.
         * scrollView.scrollTo(new Vec2(0, 1), 0.1);
         *
         * // Horizontal scroll to view right.
         * scrollView.scrollTo(new Vec2(1, 0), 0.1);
         * ```
         */
        scrollTo(anchor: math.Vec2, timeInSecond?: number, attenuated?: boolean): void;
        /**
         * @en
         * Scroll the content to the vertical percent position of ScrollView.
         *
         * @zh
         * 视图内容在规定时间内滚动到 ScrollView 垂直方向的百分比位置上。
         *
         * @param percent
         * @en Scroll to the destination which is located at the percent interpolation from top border to the bottom border @zh 滚动到从上到下指定百分比插值的位置
         * @param timeInSecond
         * @en Scroll time (s). If it times out, the content immediately jumps to the specified offset. @zh 滚动时间（s）。 如果超时，内容将立即跳到指定偏移量处。
         * @param attenuated @en Whether the rolling acceleration is attenuated(The default is true) @zh 滚动加速是否衰减，默认为 true
         * @example
         * ```ts
         * scrollView.scrollToPercentVertical(0.5, 0.1);
         * ```
         */
        scrollToPercentVertical(percent: number, timeInSecond?: number, attenuated?: boolean): void;
        /**
         * @en
         * Stop auto scroll immediately.
         *
         * @zh
         * 停止自动滚动, 调用此 API 可以让 ScrollView 立即停止滚动。
         */
        stopAutoScroll(): void;
        /**
         * @en
         * Modify the content position.
         *
         * @zh
         * 设置当前视图内容的坐标点。
         *
         * @param position @en Current content position @zh 希望设置内容框体的位置
         * @deprecated Since 3.1.0, setContentPosition is deprecated, please use scrollToOffset instead.
         */
        setContentPosition(position: math.Vec3): void;
        /**
         * @en
         * Query the content's position in its parent space.
         *
         * @zh
         * 获取当前视图内容的坐标点。
         *
         * @returns - current content position.
         * @deprecated Since 3.1.0, getContentPosition is deprecated.
         */
        getContentPosition(): math.Vec3;
        /**
         * @en
         * Query whether the user is currently dragging the ScrollView to scroll it.
         *
         * @zh
         * 用户是否在拖拽当前滚动视图。
         *
         * @returns - 是否在拖拽当前滚动视图。
         */
        isScrolling(): boolean;
        /**
         * @en
         * Query whether the ScrollView is currently scrolling because of a bounceback or inertia slowdown.
         *
         * @zh
         * 当前滚动视图是否在惯性滚动。
         *
         * @returns - 滚动视图是否在惯性滚动。
         */
        isAutoScrolling(): boolean;
        getScrollEndedEventTiming(): number;
        start(): void;
        onEnable(): void;
        update(dt: number): void;
        onDisable(): void;
        protected _registerEvent(): void;
        protected _unregisterEvent(): void;
        protected _onMouseWheel(event: EventMouse, captureListeners?: Node[]): void;
        protected _onTouchBegan(event: EventTouch, captureListeners?: Node[]): void;
        protected _onTouchMoved(event: EventTouch, captureListeners?: Node[]): void;
        protected _onTouchEnded(event: EventTouch, captureListeners?: Node[]): void;
        protected _onTouchCancelled(event: EventTouch, captureListeners?: Node[]): void;
        protected _calculateBoundary(): void;
        protected _hasNestedViewGroup(event: Event, captureListeners?: Node[]): boolean;
        protected _startInertiaScroll(touchMoveVelocity: math.Vec3): void;
        protected _calculateAttenuatedFactor(distance: number): number;
        protected _startAttenuatingAutoScroll(deltaMove: math.Vec3, initialVelocity: math.Vec3): void;
        protected _calculateAutoScrollTimeByInitialSpeed(initialSpeed: number): number;
        protected _startAutoScroll(deltaMove: math.Vec3, timeInSecond: number, attenuated?: boolean): void;
        protected _calculateTouchMoveVelocity(): math.Vec3;
        protected _flattenVectorByDirection(vector: math.Vec3): math.Vec3;
        protected _moveContent(deltaMove: math.Vec3, canStartBounceBack?: boolean): void;
        protected _getContentLeftBoundary(): number;
        protected _getContentRightBoundary(): number;
        protected _getContentTopBoundary(): number;
        protected _getContentBottomBoundary(): number;
        protected _getHowMuchOutOfBoundary(addition?: math.Vec3): math.Vec3;
        protected _updateScrollBar(outOfBoundary: math.Vec2 | Readonly<math.Vec2>): void;
        protected _onScrollBarTouchBegan(): void;
        protected _onScrollBarTouchEnded(): void;
        protected _dispatchEvent(event: string): void;
        protected _adjustContentOutOfBoundary(): void;
        protected _hideScrollBar(): void;
        protected _updateScrollBarState(): void;
        protected _stopPropagationIfTargetIsMe(event: Event): void;
        protected _processDeltaMove(deltaMove: math.Vec3): void;
        protected _handleMoveLogic(touch: Touch): void;
        protected _handleReleaseLogic(touch: Touch): void;
        protected _getLocalAxisAlignDelta(out: math.Vec3, touch: Touch): void;
        protected _scrollChildren(deltaMove: math.Vec3): void;
        protected _handlePressLogic(): void;
        protected _clampDelta(out: math.Vec3): void;
        protected _gatherTouchMove(delta: math.Vec3): void;
        protected _startBounceBackIfNeeded(): boolean;
        protected _processInertiaScroll(): void;
        protected _isOutOfBoundary(): boolean;
        protected _isNecessaryAutoScrollBrake(): boolean;
        protected _processAutoScrolling(dt: any): void;
        protected _checkMouseWheel(dt: number): void;
        protected _calculateMovePercentDelta(options: any): math.Vec3;
        protected _moveContentToTopLeft(scrollViewSize: math.Size): void;
        protected _scaleChanged(value: TransformBit): void;
        protected _xrHoverEnter(event: XrUIPressEvent): void;
        protected _xrHoverExit(): void;
        protected _xrThumbStickMove(event: math.Vec2): void;
        protected _xrThumbStickMoveEnd(): void;
    }
    /**
     * @en
     * The Slider Control.
     *
     * @zh
     * 滑动器组件。
     */
    export class Slider extends Component {
        /**
         * @en
         * The "handle" part of the slider.
         *
         * @zh
         * 滑动器滑块按钮部件。
         */
        get handle(): Sprite | null;
        set handle(value: Sprite | null);
        /**
         * @en
         * The slider direction.
         *
         * @zh
         * 滑动器方向。
         */
        get direction(): number;
        set direction(value: number);
        /**
         * @en
         * The current progress of the slider. The valid value is between 0-1.
         *
         * @zh
         * 当前进度值，该数值的区间是 0-1 之间。
         */
        get progress(): number;
        set progress(value: number);
        static Direction: typeof __private._cocos_ui_slider__Direction;
        /**
         * @en
         * The slider slide events' callback array.
         *
         * @zh
         * 滑动器组件滑动事件回调函数数组。
         */
        slideEvents: EventHandler[];
        __preload(): void;
        onEnable(): void;
        onDisable(): void;
        protected _onHandleDragStart(event?: EventTouch): void;
        protected _onTouchBegan(event?: EventTouch): void;
        protected _onTouchMoved(event?: EventTouch): void;
        protected _onTouchEnded(event?: EventTouch): void;
        protected _onTouchCancelled(event?: EventTouch): void;
        protected _handleSliderLogic(touch: Touch | null): void;
        protected _emitSlideEvent(): void;
        protected _updateProgress(touch: Touch | null): void;
        protected _updateHandlePosition(): void;
        protected _xrHandleProgress(point: math.Vec3): void;
        protected _xrClick(event: XrUIPressEvent): void;
        protected _xrUnClick(): void;
        protected _xrHoverStay(event: XrUIPressEvent): void;
    }
    /**
     * @en
     * The toggle component is a CheckBox, when it used together with a ToggleGroup,
     * it could be treated as a RadioButton.
     *
     * @zh
     * Toggle 是一个 CheckBox，当它和 ToggleGroup 一起使用的时候，可以变成 RadioButton。
     */
    export class Toggle extends Button {
        /**
         * @en
         * When this value is true, the check mark component will be enabled,
         * otherwise the check mark component will be disabled.
         *
         * @zh
         * 如果这个设置为 true，则 check mark 组件会处于 enabled 状态，否则处于 disabled 状态。
         */
        get isChecked(): boolean;
        set isChecked(value: boolean);
        /**
         * @en
         * The image used for the checkmark.
         *
         * @zh
         * Toggle 处于选中状态时显示的图片。
         */
        get checkMark(): Sprite | null;
        set checkMark(value: Sprite | null);
        set _resizeToTarget(value: boolean);
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        get _toggleContainer(): ToggleContainer | null;
        static EventType: typeof __private._cocos_ui_toggle__EventType & typeof __private._cocos_ui_button__EventType;
        /**
         * @en
         * If Toggle is clicked, it will trigger event's handler.
         *
         * @zh
         * Toggle 按钮的点击事件列表。
         */
        checkEvents: EventHandler[];
        protected _isChecked: boolean;
        protected _checkMark: Sprite | null;
        protected _internalToggle(): void;
        protected _set(value: boolean, emitEvent?: boolean): void;
        playEffect(): void;
        /**
         * @en
         * Set isChecked without invoking checkEvents.
         *
         * @zh
         * 设置 isChecked 而不调用 checkEvents 回调。
         *
         * @param value @en Whether this toggle is pressed @zh 是否被按下
         */
        setIsCheckedWithoutNotify(value: boolean): void;
        onEnable(): void;
        onDisable(): void;
        OnDestroy(): void;
        protected _emitToggleEvents(): void;
    }
    /**
     * @en
     * ToggleContainer is not a visible UI component but a way to modify the behavior of a set of Toggles. <br/>
     * Toggles that belong to the same group could only have one of them to be switched on at a time.<br/>
     * Note: All the first layer child node containing the toggle component will auto be added to the container.
     *
     * @zh
     * ToggleGroup 不是一个可见的 UI 组件，它可以用来修改一组 Toggle  组件的行为。当一组 Toggle 属于同一个 ToggleGroup 的时候，<br/>
     * 任何时候只能有一个 Toggle 处于选中状态。
     */
    export class ToggleContainer extends Component {
        protected _allowSwitchOff: boolean;
        /**
         * @en
         * If this setting is true, a toggle could be switched off and on when pressed.
         * If it is false, it will make sure there is always only one toggle could be switched on
         * and the already switched on toggle can't be switched off.
         *
         * @zh
         * 如果这个设置为 true，那么 toggle 按钮在被点击的时候可以反复地被选中和未选中。
         */
        get allowSwitchOff(): boolean;
        set allowSwitchOff(value: boolean);
        /**
         * @en
         * If Toggle is clicked, it will trigger event's handler.
         *
         * @zh
         * Toggle 按钮的点击事件列表。
         */
        checkEvents: EventHandler[];
        /**
         * @en
         * Read only property, return the toggle items array reference managed by ToggleContainer.
         *
         * @zh
         * 只读属性，返回 toggleContainer 管理的 toggle 数组引用。
         */
        get toggleItems(): (Toggle | null)[];
        onEnable(): void;
        onDisable(): void;
        activeToggles(): any;
        anyTogglesChecked(): boolean;
        /**
         * @en
         * Refresh the state of the managed toggles.
         *
         * @zh
         * 刷新管理的 toggle 状态。
         *
         * @param toggle @en The toggle to be updated @zh 需要被更新的切换键
         * @param emitEvent @en Whether events are needed to be emitted @zh 是否需要触发事件
         */
        notifyToggleCheck(toggle: Toggle, emitEvent?: boolean): void;
        ensureValidState(): void;
    }
    export class ViewGroup extends Component {
    }
    /**
     * @en
     * Stores and manipulate the anchoring based on its parent.
     * Widget are used for GUI but can also be used for other things.
     * Widget will adjust current node's position and size automatically,
     * but the results after adjustment can not be obtained until the next frame unless you call [[updateAlignment]] manually.
     *
     * @zh Widget 组件，用于设置和适配其相对于父节点的边距，Widget 通常被用于 UI 界面，也可以用于其他地方。<br/>
     * Widget 会自动调整当前节点的坐标和宽高，不过目前调整后的结果要到下一帧才能在脚本里获取到，除非你先手动调用 [[updateAlignment]]。
     */
    export class Widget extends Component {
        /**
         * @en
         * Specifies an alignment target that can only be one of the parent nodes of the current node.
         * The default value is null, and when null, indicates the current parent.
         *
         * @zh
         * 指定一个对齐目标，只能是当前节点的其中一个父节点，默认为空，为空时表示当前父节点。
         */
        get target(): Node | null;
        set target(value: Node | null);
        /**
         * @en
         * Whether to align to the top.
         *
         * @zh
         * 是否对齐上边。
         */
        get isAlignTop(): boolean;
        set isAlignTop(value: boolean);
        /**
         * @en
         * Whether to align to the bottom.
         *
         * @zh
         * 是否对齐下边。
         */
        get isAlignBottom(): boolean;
        set isAlignBottom(value: boolean);
        /**
         * @en
         * Whether to align to the left.
         *
         * @zh
         * 是否对齐左边。
         */
        get isAlignLeft(): boolean;
        set isAlignLeft(value: boolean);
        /**
         * @en
         * Whether to align to the right.
         *
         * @zh
         * 是否对齐右边。
         */
        get isAlignRight(): boolean;
        set isAlignRight(value: boolean);
        /**
         * @en
         * Whether to align vertically.
         *
         * @zh
         * 是否垂直方向对齐中点，开启此项会将垂直方向其他对齐选项取消。
         */
        get isAlignVerticalCenter(): boolean;
        set isAlignVerticalCenter(value: boolean);
        /**
         * @en
         * Whether to align horizontally.
         *
         * @zh
         * 是否水平方向对齐中点，开启此选项会将水平方向其他对齐选项取消。
         */
        get isAlignHorizontalCenter(): boolean;
        set isAlignHorizontalCenter(value: boolean);
        /**
         * @en
         * Whether to stretch horizontally, when enable the left and right alignment will be stretched horizontally,
         * the width setting is invalid (read only).
         *
         * @zh
         * 当前是否水平拉伸。当同时启用左右对齐时，节点将会被水平拉伸。此时节点的宽度（只读）。
         */
        get isStretchWidth(): boolean;
        /**
         * @en
         * Whether to stretch vertically, when enable the left and right alignment will be stretched vertically,
         * then height setting is invalid (read only).
         *
         * @zh
         * 当前是否垂直拉伸。当同时启用上下对齐时，节点将会被垂直拉伸，此时节点的高度（只读）。
         */
        get isStretchHeight(): boolean;
        /**
         * @en
         * The margins between the top of this node and the top of parent node,
         * the value can be negative, Only available in 'isAlignTop' open.
         *
         * @zh
         * 本节点顶边和父节点顶边的距离，可填写负值，只有在 isAlignTop 开启时才有作用。
         */
        get top(): number;
        set top(value: number);
        /**
         * @EditorOnly Not for user
         */
        get editorTop(): number;
        set editorTop(value: number);
        /**
         * @en
         * The margins between the bottom of this node and the bottom of parent node,
         * the value can be negative, Only available in 'isAlignBottom' open.
         *
         * @zh
         * 本节点底边和父节点底边的距离，可填写负值，只有在 isAlignBottom 开启时才有作用。
         */
        get bottom(): number;
        set bottom(value: number);
        /**
         * @EditorOnly Not for user
         */
        get editorBottom(): number;
        set editorBottom(value: number);
        /**
         * @en
         * The margins between the left of this node and the left of parent node,
         * the value can be negative, Only available in 'isAlignLeft' open.
         *
         * @zh
         * 本节点左边和父节点左边的距离，可填写负值，只有在 isAlignLeft 开启时才有作用。
         */
        get left(): number;
        set left(value: number);
        /**
         * @EditorOnly Not for user
         */
        get editorLeft(): number;
        set editorLeft(value: number);
        /**
         * @en
         * The margins between the right of this node and the right of parent node,
         * the value can be negative, Only available in 'isAlignRight' open.
         *
         * @zh
         * 本节点右边和父节点右边的距离，可填写负值，只有在 isAlignRight 开启时才有作用。
         */
        get right(): number;
        set right(value: number);
        /**
         * @EditorOnly Not for user
         */
        get editorRight(): number;
        set editorRight(value: number);
        /**
         * @en
         * Horizontally aligns the midpoint offset value,
         * the value can be negative, Only available in 'isAlignHorizontalCenter' open.
         *
         * @zh
         * 水平居中的偏移值，可填写负值，只有在 isAlignHorizontalCenter 开启时才有作用。
         */
        get horizontalCenter(): number;
        set horizontalCenter(value: number);
        /**
         * @EditorOnly Not for user
         */
        get editorHorizontalCenter(): number;
        set editorHorizontalCenter(value: number);
        /**
         * @en
         * Vertically aligns the midpoint offset value,
         * the value can be negative, Only available in 'isAlignVerticalCenter' open.
         *
         * @zh
         * 垂直居中的偏移值，可填写负值，只有在 isAlignVerticalCenter 开启时才有作用。
         */
        get verticalCenter(): number;
        set verticalCenter(value: number);
        /**
         * @EditorOnly Not for user
         */
        get editorVerticalCenter(): number;
        set editorVerticalCenter(value: number);
        /**
         * @en
         * If true, top is pixel margin, otherwise is percentage (0 - 1) margin relative to the parent's height.
         *
         * @zh
         * 如果为 true，"top" 将会以像素作为边距，否则将会以相对父物体高度的比例（0 到 1）作为边距。
         */
        get isAbsoluteTop(): boolean;
        set isAbsoluteTop(value: boolean);
        /**
         * @en
         * If true, bottom is pixel margin, otherwise is percentage (0 - 1) margin relative to the parent's height.
         *
         * @zh
         * 如果为 true，"bottom" 将会以像素作为边距，否则将会以相对父物体高度的比例（0 到 1）作为边距。
         */
        get isAbsoluteBottom(): boolean;
        set isAbsoluteBottom(value: boolean);
        /**
         * @en
         * If true, left is pixel margin, otherwise is percentage (0 - 1) margin relative to the parent's width.
         *
         * @zh
         * 如果为 true，"left" 将会以像素作为边距，否则将会以相对父物体宽度的比例（0 到 1）作为边距。
         */
        get isAbsoluteLeft(): boolean;
        set isAbsoluteLeft(value: boolean);
        /**
         * @en
         * If true, right is pixel margin, otherwise is percentage (0 - 1) margin relative to the parent's width.
         *
         * @zh
         * 如果为 true，"right" 将会以像素作为边距，否则将会以相对父物体宽度的比例（0 到 1）作为边距。
         */
        get isAbsoluteRight(): boolean;
        set isAbsoluteRight(value: boolean);
        /**
         * @en
         * If true, horizontalCenter is pixel margin, otherwise is percentage (0 - 1) margin.
         *
         * @zh
         * 如果为 true，"horizontalCenter" 将会以像素作为偏移值，反之为比例（0 到 1）。
         */
        get isAbsoluteHorizontalCenter(): boolean;
        set isAbsoluteHorizontalCenter(value: boolean);
        /**
         * @en
         * If true, verticalCenter is pixel margin, otherwise is percentage (0 - 1) margin.
         *
         * @zh
         * 如果为 true，"verticalCenter" 将会以像素作为偏移值，反之为比例（0 到 1）。
         */
        get isAbsoluteVerticalCenter(): boolean;
        set isAbsoluteVerticalCenter(value: boolean);
        /**
         * @en
         * Specifies the alignment mode of the Widget, which determines when the widget should refresh.
         *
         * @zh
         * 指定 Widget 的对齐模式，用于决定 Widget 应该何时刷新。
         *
         * @example
         * ```
         * import { Widget } from 'cc';
         * widget.alignMode = Widget.AlignMode.ON_WINDOW_RESIZE;
         * ```
         */
        get alignMode(): __private._cocos_ui_widget__AlignMode;
        set alignMode(value: __private._cocos_ui_widget__AlignMode);
        /**
         * @zh
         * 对齐开关，由 AlignFlags 组成
         */
        get alignFlags(): number;
        set alignFlags(value: number);
        static AlignMode: typeof __private._cocos_ui_widget__AlignMode;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _lastPos: math.Vec3;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _lastSize: math.Size;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _dirty: boolean;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _hadAlignOnce: boolean;
        /**
         * @en
         * Immediately perform the widget alignment. You need to manually call this method only if
         * you need to get the latest results after the alignment before the end of current frame.
         *
         * @zh
         * 立刻执行 widget 对齐操作。这个接口一般不需要手工调用。
         * 只有当你需要在当前帧结束前获得 widget 对齐后的最新结果时才需要手动调用这个方法。
         *
         * @example
         * ```ts
         * import { log } from 'cc';
         * widget.top = 10;       // change top margin
         * log(widget.node.y); // not yet changed
         * widget.updateAlignment();
         * log(widget.node.y); // changed
         * ```
         */
        updateAlignment(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _validateTargetInDEV(): void;
        setDirty(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _adjustWidgetToAllowMovingInEditor(eventType: TransformBit): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _adjustWidgetToAllowResizingInEditor(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _adjustWidgetToAnchorChanged(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _adjustTargetToParentChanged(oldParent: Node): void;
        protected _registerEvent(): void;
        protected _unregisterEvent(): void;
        protected _removeParentEvent(): void;
        protected _autoChangedValue(flag: __private._cocos_ui_widget__AlignFlags, isAbs: boolean): void;
        protected _registerTargetEvents(): void;
        protected _unregisterTargetEvents(): void;
        protected _unregisterOldParentEvents(oldParent: Node): void;
        protected _setDirtyByMode(): void;
    }
    export namespace Widget {
        export type AlignMode = __private._types_globals__EnumAlias<typeof __private._cocos_ui_widget__AlignMode>;
    }
    /**
     * @en
     * The PageView control.
     *
     * @zh
     * 页面视图组件
     */
    export class PageView extends ScrollView {
        /**
         * @en
         * Specify the size type of each page in PageView.
         *
         * @zh
         * 页面视图中每个页面大小类型
         */
        get sizeMode(): __private._cocos_ui_page_view__SizeMode;
        set sizeMode(value: __private._cocos_ui_page_view__SizeMode);
        /**
         * @en
         * The page view direction.
         *
         * @zh
         * 页面视图滚动类型
         */
        get direction(): __private._cocos_ui_page_view__Direction;
        set direction(value: __private._cocos_ui_page_view__Direction);
        /**
         * @en
         * The scroll threshold value, when drag exceeds this value,
         * release the next page will automatically scroll, less than the restore.
         *
         * @zh
         * 滚动临界值，默认单位百分比，当拖拽超出该数值时，松开会自动滚动下一页，小于时则还原。
         */
        get scrollThreshold(): number;
        set scrollThreshold(value: number);
        /**
         * @en
         * Change the PageTurning event timing of PageView.
         *
         * @zh
         * 设置 PageView PageTurning 事件的发送时机。
         */
        get pageTurningEventTiming(): number;
        set pageTurningEventTiming(value: number);
        /**
         * @en
         * The Page View Indicator.
         *
         * @zh
         * 页面视图指示器组件
         */
        get indicator(): PageViewIndicator | null;
        set indicator(value: PageViewIndicator | null);
        get curPageIdx(): number;
        static SizeMode: typeof __private._cocos_ui_page_view__SizeMode;
        static Direction: typeof __private._cocos_ui_page_view__Direction;
        static EventType: typeof __private._cocos_ui_page_view__EventType & typeof __private._cocos_ui_scroll_view__EventType;
        /**
         * @en
         * Auto page turning velocity threshold. When users swipe the PageView quickly,
         * it will calculate a velocity based on the scroll distance and time,
         * if the calculated velocity is larger than the threshold, then it will trigger page turning.
         *
         * @zh
         * 快速滑动翻页临界值。
         * 当用户快速滑动时，会根据滑动开始和结束的距离与时间计算出一个速度值，
         * 该值与此临界值相比较，如果大于临界值，则进行自动翻页。
         */
        autoPageTurningThreshold: number;
        get verticalScrollBar(): ScrollBar | null;
        set verticalScrollBar(value: ScrollBar | null);
        get horizontalScrollBar(): ScrollBar | null;
        set horizontalScrollBar(value: ScrollBar | null);
        horizontal: boolean;
        vertical: boolean;
        cancelInnerEvents: boolean;
        scrollEvents: EventHandler[];
        /**
         * @en The time required to turn over a page. unit: second
         * @zh 每个页面翻页时所需时间。单位：秒
         */
        pageTurningSpeed: number;
        /**
         * @en PageView events callback
         * @zh 滚动视图的事件回调函数
         */
        pageEvents: EventHandler[];
        protected _sizeMode: __private._cocos_ui_page_view__SizeMode;
        protected _direction: __private._cocos_ui_page_view__Direction;
        protected _scrollThreshold: number;
        protected _pageTurningEventTiming: number;
        protected _indicator: PageViewIndicator | null;
        protected _curPageIdx: number;
        protected _lastPageIdx: number;
        protected _pages: Node[];
        protected _initContentPos: math.Vec3;
        protected _scrollCenterOffsetX: number[];
        protected _scrollCenterOffsetY: number[];
        protected _touchBeganPosition: math.Vec2;
        protected _touchEndPosition: math.Vec2;
        onEnable(): void;
        onDisable(): void;
        onLoad(): void;
        /**
         * @en
         * Returns current page index.
         *
         * @zh
         * 返回当前页面索引。
         *
         * @returns @en Current page index of this page view @zh 当前页面索引。
         */
        getCurrentPageIndex(): number;
        /**
         * @en
         * Set current page index.
         *
         * @zh
         * 设置当前页面索引。
         * @param index @en The page index to scroll to @zh 需要滚动到的页面索引
         */
        setCurrentPageIndex(index: number): void;
        /**
         * @en
         * Returns all pages of pageview.
         *
         * @zh
         * 返回视图中的所有页面。
         *
         * @returns @en return all pages of this page view @zh 返回当前视图所有页面
         */
        getPages(): Node[];
        /**
         * @en
         * At the end of the current page view to insert a new view.
         *
         * @zh
         * 在当前页面视图的尾部插入一个新视图。
         *
         * @param page @en New page to add to this page view @zh 新加入的视图
         */
        addPage(page: Node): void;
        /**
         * @en
         * Inserts a page in the specified location.
         *
         * @zh
         * 将页面插入指定位置中。
         *
         * @param page @en New page to insert to this page view @zh 新插入的视图
         * @param index @en The index of new page to be inserted @zh 新插入视图的索引
         */
        insertPage(page: Node, index: number): void;
        /**
         * @en
         * Removes a page from PageView.
         *
         * @zh
         * 移除指定页面。
         *
         * @param page @en The page to be removed @zh 将被移除的页面
         */
        removePage(page: Node): void;
        /**
         * @en
         * Removes a page at index of PageView.
         *
         * @zh
         * 移除指定下标的页面。
         *
         * @param index @en The index of the page to be removed @zh 将被移除界面的页面下标
         */
        removePageAtIndex(index: number): void;
        /**
         * @en
         * Removes all pages from PageView.
         *
         * @zh
         * 移除所有页面。
         */
        removeAllPages(): void;
        /**
         * @en
         * Scroll PageView to index.
         *
         * @zh
         * 滚动到指定页面
         *
         * @param idx @en The index of page to be scroll to @zh 希望滚动到的页面下标
         * @param timeInSecond @en How long time to scroll to the page, in seconds @zh 滚动到指定页面所需时间，单位：秒
         */
        scrollToPage(idx: number, timeInSecond?: number): void;
        getScrollEndedEventTiming(): number;
        protected _updatePageView(): void;
        protected _updateAllPagesSize(): void;
        protected _handleReleaseLogic(): void;
        protected _onTouchBegan(event: EventTouch, captureListeners: any): void;
        protected _onTouchMoved(event: EventTouch, captureListeners: any): void;
        protected _onTouchEnded(event: EventTouch, captureListeners: any): void;
        protected _onTouchCancelled(event: EventTouch, captureListeners: any): void;
        protected _onMouseWheel(): void;
        protected _syncScrollDirection(): void;
        protected _syncSizeMode(): void;
        protected _initPages(): void;
        protected _dispatchPageTurningEvent(): void;
        protected _isQuicklyScrollable(touchMoveVelocity: math.Vec3): boolean;
        protected _moveOffsetValue(idx: number): math.Vec2;
        protected _getDragDirection(moveOffset: math.Vec2): 0 | 1 | -1;
        protected _isScrollable(offset: math.Vec2, index: number, nextIndex: number): boolean;
        protected _autoScrollToPage(): void;
    }
    /**
     * @en
     * The Page View Indicator Component.
     *
     * @zh
     * 页面视图每页标记组件
     */
    export class PageViewIndicator extends Component {
        /**
         * @en
         * The spriteFrame for each element.
         *
         * @zh
         * 每个页面标记显示的图片
         */
        get spriteFrame(): SpriteFrame | null;
        set spriteFrame(value: SpriteFrame | null);
        /**
         * @en
         * The location direction of PageViewIndicator.
         *
         * @zh
         * 页面标记摆放方向
         *
         * @param direction @en The direction of the PageViewIndicator @zh 页面标记的摆放方向
         */
        get direction(): __private._cocos_ui_page_view_indicator__Direction;
        set direction(value: __private._cocos_ui_page_view_indicator__Direction);
        /**
         * @en
         * The cellSize for each element.
         *
         * @zh
         * 每个页面标记的大小
         */
        get cellSize(): math.Size;
        set cellSize(value: math.Size);
        static Direction: typeof __private._cocos_ui_page_view_indicator__Direction;
        /**
         * @en
         * The distance between each element.
         *
         * @zh
         * 每个页面标记之间的边距
         */
        spacing: number;
        protected _spriteFrame: SpriteFrame | null;
        protected _direction: __private._cocos_ui_page_view_indicator__Direction;
        protected _cellSize: math.Size;
        protected _layout: Layout | null;
        protected _pageView: PageView | null;
        protected _indicators: Node[];
        onLoad(): void;
        /**
         * @en
         * Set Page View.
         *
         * @zh
         * 设置页面视图
         *
         * @param target @en The page view which is attached with this indicator  @zh 当前标记对象附着到的页面视图对象
         */
        setPageView(target: PageView): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _updateLayout(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _createIndicator(): Node;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _changedState(): void;
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        _refresh(): void;
    }
    /**
     * @en
     * This component is used to adjust the layout of current node to respect the safe area of a notched mobile device such as the iPhone X.
     * It is typically used for the top node of the UI interaction area. For specific usage, refer to the official [test-cases-3d/assets/cases/ui/20.safe-area/safe-area.scene](https://github.com/cocos-creator/test-cases-3d).
     *
     * The concept of safe area is to give you a fixed inner rectangle in which you can safely display content that will be drawn on screen.
     * You are strongly discouraged from providing controls outside of this area. But your screen background could embellish edges.
     *
     * This component internally uses the API `sys.getSafeAreaRect();` to obtain the safe area of the current iOS or Android device,
     * and implements the adaptation by using the Widget component and set anchor.
     *
     * @zh
     * 该组件会将所在节点的布局适配到 iPhone X 等异形屏手机的安全区域内，通常用于 UI 交互区域的顶层节点，具体用法可参考官方范例 [test-cases-3d/assets/cases/ui/20.safe-area/safe-area.scene](https://github.com/cocos-creator/test-cases-3d)。
     *
     * 该组件内部通过 API `sys.getSafeAreaRect();` 获取到当前 iOS 或 Android 设备的安全区域，并通过 Widget 组件实现适配。
     *
     */
    export class SafeArea extends Component {
        onEnable(): void;
        onDisable(): void;
        /**
         * @en Adapt to safe area
         * @zh 立即适配安全区域
         * @method updateArea
         * @example
         * let safeArea = this.node.addComponent(cc.SafeArea);
         * safeArea.updateArea();
         */
        updateArea(): void;
    }
    /**
     * @en The component that converts 3D node coordinates to UI node coordinates.
     * It mainly provides the converted world coordinates after mapping and the perspective ratio of the simulated perspective camera.
     * @zh 3D 节点坐标转换到 UI 节点坐标组件
     * 主要提供映射后的转换世界坐标以及模拟透视相机远近比。
     */
    export class UICoordinateTracker extends Component {
        /**
         * @en
         * Target node.
         *
         * @zh
         * 目标对象。
         */
        get target(): Node | null;
        set target(value: Node | null);
        /**
         * @en
         * The 3D camera representing the original coordinate system.
         *
         * @zh
         * 照射相机。
         */
        get camera(): Camera | null;
        set camera(value: Camera | null);
        /**
         * @en
         * Whether to scale the converted 2d node's size according to the distance between the camera and the 3d node.
         *
         * @zh
         * 是否是缩放映射。
         */
        get useScale(): boolean;
        set useScale(value: boolean);
        /**
         * @en
         * The distance from the camera for displaying the 2d node in normal size.
         *
         * @zh
         * 距相机多少距离为正常显示计算大小。
         */
        get distance(): number;
        set distance(value: number);
        /**
         * @en
         * Event callback after coordinates synchronization.
         * The first parameter of the callback is the mapped local coordinate in UI camera.
         * The second parameter is the distance scale of the 3d node from the 3d camera viewport.
         *
         * @zh
         * 映射数据事件。回调的第一个参数是映射后的本地坐标，第二个是距相机距离比。
         */
        syncEvents: EventHandler[];
        protected _target: Node | null;
        protected _camera: Camera | null;
        protected _useScale: boolean;
        protected _distance: number;
        protected _transformPos: math.Vec3;
        protected _viewPos: math.Vec3;
        protected _canMove: boolean;
        protected _lastWPos: math.Vec3;
        protected _lastCameraPos: math.Vec3;
        onEnable(): void;
        update(): void;
        protected _checkCanMove(): void;
    }
    /**
     * @en
     * This component will block all input events (mouse and touch) within the size of the node,
     * preventing the input from penetrating into the underlying node, typically for the background of the top UI.<br>
     * This component does not have any API interface and can be added directly to the scene to take effect.
     * @zh
     * 该组件将拦截所属节点尺寸内的所有输入事件（鼠标和触摸），防止输入穿透到下层节点，一般用于上层 UI 的背景。<br>
     * 该组件没有任何 API 接口，直接添加到场景即可生效。
     */
    export class BlockInputEvents extends Component {
        onEnable(): void;
        onDisable(): void;
    }
    /**
     * @en SubContextView is a view component which controls open data context viewport in WeChat game platform.<br/>
     * The component's node size decide the viewport of the sub context content in main context,
     * the entire sub context texture will be scaled to the node's bounding box area.<br/>
     * This component provides multiple important features:<br/>
     * 1. Sub context could use its own resolution size and policy.<br/>
     * 2. Sub context could be minized to smallest size it needed.<br/>
     * 3. Resolution of sub context content could be increased.<br/>
     * 4. User touch input is transformed to the correct viewport.<br/>
     * 5. Texture update is handled by this component. User don't need to worry.<br/>
     * One important thing to be noted, whenever the node's bounding box change,
     * you need to manually reset the viewport of sub context using updateSubContextViewport.
     * @zh SubContextView 可以用来控制微信小游戏平台开放数据域在主域中的视窗的位置。<br/>
     * 这个组件的节点尺寸决定了开放数据域内容在主域中的尺寸，整个开放数据域会被缩放到节点的包围盒范围内。<br/>
     * 在这个组件的控制下，用户可以更自由得控制开放数据域：<br/>
     * 1. 子域中可以使用独立的设计分辨率和适配模式<br/>
     * 2. 子域区域尺寸可以缩小到只容纳内容即可<br/>
     * 3. 子域的分辨率也可以被放大，以便获得更清晰的显示效果<br/>
     * 4. 用户输入坐标会被自动转换到正确的子域视窗中<br/>
     * 5. 子域内容贴图的更新由组件负责，用户不需要处理<br/>
     * 唯一需要注意的是，当子域节点的包围盒发生改变时，开发者需要使用 `updateSubContextViewport` 来手动更新子域视窗。
     */
    export class SubContextView extends Component {
        /**
         * @en Specify a reference value of canvas size for style editing in Open Data Context.
         * The width and height setting of CSS style should not exceed this size, otherwise the rendered content will exceed the canvas.
         * NOTE: This property is read-only at runtime. Please configure the design resolution in the Editor.
         *
         * @zh 为开放数据域的样式编辑指定一个画布尺寸的参考值，CSS 样式的宽高设置不应该超过这个尺寸，否则渲染的内容会超出画布。
         * 注意：该属性在运行时是只读的，请在编辑器环境下配置好设计分辨率。
         */
        get designResolutionSize(): math.Size;
        set designResolutionSize(value: math.Size);
        /**
         * @en Setting frame rate in Open Data Context.
         *
         * @zh 设置开放数据域的渲染帧率。
         */
        get fps(): number;
        set fps(value: number);
        constructor();
        onLoad(): void;
        onEnable(): void;
        onDisable(): void;
        update(dt?: number): void;
        onDestroy(): void;
    }
    export const widgetManager: {
        isAligning: boolean;
        _nodesOrderDirty: boolean;
        _activeWidgetsIterator: __private._cocos_core_utils_mutable_forward_iterator__default<Widget>;
        animationState: {
            previewing: boolean;
            time: number;
            animatedSinceLastFrame: boolean;
        } | null;
        init(): void;
        add(widget: Widget): void;
        remove(widget: Widget): void;
        onResized(): void;
        refreshWidgetOnResized(node: Node): void;
        updateOffsetsToStayPut(widget: Widget, e?: __private._cocos_ui_widget__AlignFlags): void;
        updateAlignment: typeof __private._cocos_ui_widget_manager__updateAlignment;
        AlignMode: typeof __private._cocos_ui_widget__AlignMode;
        AlignFlags: typeof __private._cocos_ui_widget__AlignFlags;
    };
    /**
     * @deprecated Since v1.2
     */
    export class UIReorderComponent {
        constructor();
    }
    /**
     * @en
     * The video clip asset.
     * @zh
     * 视频片段资源。
     */
    export class VideoClip extends Asset {
        protected _duration: number;
        protected _video: HTMLVideoElement | null;
        constructor();
        /**
         * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
         */
        set _nativeAsset(clip: HTMLVideoElement | null);
        get _nativeAsset(): HTMLVideoElement | null;
    }
    /**
     * @en
     * VideoPlayer is a component for playing videos, you can use it for showing videos in your game.
     * Because different platforms have different authorization, API and control methods for VideoPlayer component.
     * And have not yet formed a unified standard, only Web, iOS, and Android platforms are currently supported.
     * @zh
     * Video 组件，用于在游戏中播放视频。
     * 由于不同平台对于 VideoPlayer 组件的授权、API、控制方式都不同，还没有形成统一的标准，所以目前只支持 Web、iOS 和 Android 平台。
     */
    export class VideoPlayer extends Component {
        protected _resourceType: number;
        protected _remoteURL: string;
        protected _clip: VideoClip | null;
        protected _playOnAwake: boolean;
        protected _volume: number;
        protected _mute: boolean;
        protected _playbackRate: number;
        protected _loop: boolean;
        protected _fullScreenOnAwake: boolean;
        protected _stayOnBottom: boolean;
        protected _keepAspectRatio: boolean;
        protected _impl: __private._cocos_video_video_player_impl_web__VideoPlayerImplWeb | null;
        protected _cachedCurrentTime: number;
        /**
         * @en
         * The resource type of video player, REMOTE for remote url and LOCAL for local file path.
         * @zh
         * 视频来源：REMOTE 表示远程视频 URL，LOCAL 表示本地视频地址。
         */
        get resourceType(): number;
        set resourceType(val: number);
        /**
         * @en
         * The remote URL of video.
         * @zh
         * 远程视频的 URL
         */
        get remoteURL(): string;
        set remoteURL(val: string);
        /**
         * @en
         * The local video clip
         * @zh
         * 本地视频剪辑。
         */
        get clip(): VideoClip | null;
        set clip(val: VideoClip | null);
        /**
         * @en
         * Whether the video start playing automatically after loaded?
         * @zh
         * 视频加载后是否自动开始播放？
         */
        get playOnAwake(): boolean;
        set playOnAwake(value: boolean);
        /**
         * @en
         * The Video playback rate
         * @zh
         * 视频播放时的速率（0.0 ~ 10.0）
         */
        get playbackRate(): number;
        set playbackRate(value: number);
        /**
         * @en
         * The volume of the video.
         * @zh
         * 视频的音量（0.0 ~ 1.0）
         */
        get volume(): number;
        set volume(value: number);
        /**
         * @en
         * Mutes the VideoPlayer. Mute sets the volume=0, Un-Mute restore the original volume.
         * @zh
         * 是否静音视频。静音时设置音量为 0，取消静音是恢复原来的音量。
         */
        get mute(): boolean;
        set mute(value: boolean);
        /**
         * @en
         * Whether the video should be played again at the end
         * @zh
         * 视频是否应在结束时再次播放
         */
        get loop(): boolean;
        set loop(value: boolean);
        /**
         * @en
         * Whether keep the aspect ration of the original video.
         * @zh
         * 是否保持视频原来的宽高比
         */
        get keepAspectRatio(): boolean;
        set keepAspectRatio(value: boolean);
        /**
         * @en
         * Whether play video in fullscreen mode.
         * @zh
         * 是否全屏播放视频
         */
        get fullScreenOnAwake(): boolean;
        set fullScreenOnAwake(value: boolean);
        /**
         * @en
         * Always below the game view (only useful on Web.
         * Note: The specific effects are not guaranteed to be consistent, depending on whether each browser supports or restricts).
         * Note: This property depends on the translucency of Canvas, please enable ENABLE_TRANSPARENT_CANVAS in the project preferences
         * @zh
         * 永远在游戏视图最底层（这个属性只有在 Web 平台上有效果。注意：具体效果无法保证一致，跟各个浏览器是否支持与限制有关）
         * 注意：该属性依赖 Canvas 的半透明特性，请在项目偏好设置里开启 ENABLE_TRANSPARENT_CANVAS
         */
        get stayOnBottom(): boolean;
        set stayOnBottom(value: boolean);
        static EventType: typeof __private._cocos_video_video_player_enums__EventType;
        static ResourceType: {
            REMOTE: number;
            LOCAL: number;
        };
        /**
         * @en
         * The video player's callback, it will be triggered when certain event occurs, like: playing, paused, stopped and completed.
         * @zh
         * 视频播放回调函数，该回调函数会在特定情况被触发，比如播放中，暂时，停止和完成播放。
         */
        videoPlayerEvent: EventHandler[];
        /**
         * @en
         * Raw video objects for user customization
         * @zh
         * 原始视频对象，用于用户定制
         */
        get nativeVideo(): HTMLVideoElement | null;
        /**
         * @en
         * The current playback time of the now playing item in seconds, you could also change the start playback time.
         * @zh
         * 指定视频从什么时间点开始播放，单位是秒，也可以用来获取当前视频播放的时间进度。
         */
        get currentTime(): number;
        set currentTime(val: number);
        /**
         * @en
         * Get the audio duration, in seconds.
         * @zh
         * 获取以秒为单位的视频总时长。
         */
        get duration(): number;
        /**
         * @en
         * Get current audio state.
         * @zh
         * 获取当前视频状态。
         */
        get state(): __private._cocos_video_video_player_enums__EventType;
        /**
         * @en
         * Is the audio currently playing?
         * @zh
         * 当前视频是否正在播放？
         */
        get isPlaying(): boolean;
        protected syncSource(): void;
        __preload(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        update(dt: number): void;
        onMetaLoaded(): void;
        onReadyToPlay(): void;
        onPlaying(): void;
        onPaused(): void;
        onStopped(): void;
        onCompleted(): void;
        onError(): void;
        /**
         * @en
         * Play the clip.<br>
         * Restart if already playing.<br>
         * Resume if paused.
         * @zh
         * 开始播放。<br>
         * 如果视频处于正在播放状态，将会重新开始播放视频。<br>
         * 如果视频处于暂停状态，则会继续播放视频。
         */
        play(): void;
        /**
         * @en
         * If a video is paused, call this method to resume playing.
         * @zh
         * 如果一个视频播放被暂停播放了，调用这个接口可以继续播放。
         */
        resume(): void;
        /**
         * @en
         * Pause the clip.
         * @zh
         * 暂停播放。
         */
        pause(): void;
        /**
         * @en
         * Stop the clip.
         * @zh
         * 停止播放。
         */
        stop(): void;
    }
    /**
     * @en
     * WebView is a component for display web pages in the game.
     * Because different platforms have different authorization,
     * API and control methods for WebView component.
     * And have not yet formed a unified standard, only Web, iOS, and Android platforms are currently supported.
     * @zh
     * WebView 组件，用于在游戏中显示网页。
     * 由于不同平台对于 WebView 组件的授权、API、控制方式都不同，还没有形成统一的标准，所以目前只支持 Web、iOS 和 Android 平台。
     */
    export class WebView extends Component {
        protected _url: string;
        protected _impl: __private._cocos_web_view_web_view_impl__WebViewImpl | null;
        /**
         * @en WebView event type
         * @zh 网页视图事件类型
         */
        static EventType: typeof __private._cocos_web_view_web_view_enums__EventType;
        /**
         * @en
         * A given URL to be loaded by the WebView, it should have a http or https prefix.
         * @zh
         * 指定 WebView 加载的网址，它应该是一个 http 或者 https 开头的字符串
         */
        get url(): string;
        set url(val: string);
        /**
         * @en
         * The webview's event callback , it will be triggered when certain webview event occurs.
         * @zh
         * WebView 的回调事件，当网页加载过程中，加载完成后或者加载出错时都会回调此函数
         */
        webviewEvents: EventHandler[];
        /**
         * @en
         * Raw webview objects for user customization
         * @zh
         * 原始网页对象，用于用户定制
         */
        get nativeWebView(): HTMLIFrameElement | null;
        /**
         * @en
         * Get current audio state.
         * @zh
         * 获取当前网页视图状态。
         */
        get state(): __private._cocos_web_view_web_view_enums__EventType;
        /**
         * @en
         * Set javascript interface scheme (see also setOnJSCallback). <br>
         * Note: Supports only on the Android and iOS. For HTML5, please refer to the official documentation.<br>
         * Please refer to the official documentation for more details.
         * @zh
         * 设置 JavaScript 接口方案（与 'setOnJSCallback' 配套使用）。<br>
         * 注意：只支持 Android 和 iOS ，Web 端用法请前往官方文档查看。<br>
         * 详情请参阅官方文档
         * @method setJavascriptInterfaceScheme
         * @param {String} scheme
         */
        setJavascriptInterfaceScheme(scheme: string): void;
        /**
         * @en
         * This callback called when load URL that start with javascript
         * interface scheme (see also setJavascriptInterfaceScheme). <br>
         * Note: Supports only on the Android and iOS. For HTML5, please refer to the official documentation. <br>
         * Please refer to the official documentation for more details.
         * @zh
         * 当加载 URL 以 JavaScript 接口方案开始时调用这个回调函数。<br>
         * 注意：只支持 Android 和 iOS，Web 端用法请前往官方文档查看。
         * 详情请参阅官方文档
         * @method setOnJSCallback
         * @param {Function} callback
         */
        setOnJSCallback(callback: () => void): void;
        /**
         * @en
         * Evaluates JavaScript in the context of the currently displayed page. <br>
         * Please refer to the official document for more details <br>
         * Note: Cross domain issues need to be resolved by yourself <br>
         * @zh
         * 执行 WebView 内部页面脚本（详情请参阅官方文档） <br>
         * 注意：需要自行解决跨域问题
         * @method evaluateJS
         * @param {String} str
         */
        evaluateJS(str: string): void;
        __preload(): void;
        onLoading(): void;
        onLoaded(): void;
        onError(...args: any[any]): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        update(dt: number): void;
    }
    export enum DeviceType {
        Other = 0,
        Left = 1,
        Right = 2
    }
    /**
     * @en Xr 3DUI event type
     * @zh xr的3DUI事件类型
     */
    export enum XrUIPressEventType {
        XRUI_HOVER_ENTERED = "xrui-hover-entered",
        XRUI_HOVER_EXITED = "xrui-hover-exited",
        XRUI_HOVER_STAY = "xrui-hover-stay",
        XRUI_CLICK = "xrui-click",
        XRUI_UNCLICK = "xrui-unclick"
    }
    /**
     * @en Xr Keyboard event type
     * @zh xr的虚拟键盘事件类型
     */
    export enum XrKeyboardEventType {
        /**
         * @en
         * The event type for XR keyboard case switching event
         *
         * @zh
         * XR键盘大小写切换事件
         */
        XR_CAPS_LOCK = "xr-caps-lock",
        /**
         * @en
         * The event type for XR keyboard initialization event
         *
         * @zh
         * XR键盘初始化事件
         */
        XR_KEYBOARD_INIT = "xr-keyboard-init",
        /**
         * @en
         * The event type for XR keyboard input event
         *
         * @zh
         * XR键盘input事件
         */
        XR_KEYBOARD_INPUT = "xr-keyboard-input",
        /**
         * @en
         * The event type for XR keyboard to latin
         *
         * @zh
         * 转latin
         */
        TO_LATIN = "to-latin",
        /**
         * @en
         * The event type for XR keyboard to symbol
         *
         * @zh
         * 转symbol
         */
        TO_SYMBOL = "to-symbol",
        /**
         * @en
         * The event type for XR keyboard to math_symbol
         *
         * @zh
         * 转math_symbol
         */
        TO_MATH_SYMBOL = "to-math-symbol"
    }
    /**
     * @en Xr 3DUI event.
     *
     * @zh xr的3DUI事件。
     */
    export class XrUIPressEvent extends Event {
        /**
         * @en Event trigger
         * @zh 事件触发者（左右手柄等）
         */
        deviceType: DeviceType;
        /**
         * @en Collision detection point
         * @zh 碰撞检测点
         */
        hitPoint: math.Vec3;
    }
    export import find = utils.find;
    export import bits = math.bits;
    export import Vec2 = math.Vec2;
    export import v2 = math.v2;
    export import Vec3 = math.Vec3;
    export import v3 = math.v3;
    export import Vec4 = math.Vec4;
    export import v4 = math.v4;
    export import Quat = math.Quat;
    export import quat = math.quat;
    export import Mat3 = math.Mat3;
    export import Mat4 = math.Mat4;
    export import mat4 = math.mat4;
    export import AffineTransform = math.AffineTransform;
    export import Size = math.Size;
    export import size = math.size;
    export import Rect = math.Rect;
    export import rect = math.rect;
    export import Color = math.Color;
    export import color = math.color;
    export import equals = math.equals;
    export import approx = math.approx;
    export import clamp = math.clamp;
    export import clamp01 = math.clamp01;
    export import lerp = math.lerp;
    export import toRadian = math.toRadian;
    export import toDegree = math.toDegree;
    export import randomRange = math.randomRange;
    export import randomRangeInt = math.randomRangeInt;
    export import pseudoRandom = math.pseudoRandom;
    export import pseudoRandomRange = math.pseudoRandomRange;
    export import pseudoRandomRangeInt = math.pseudoRandomRangeInt;
    export import nextPow2 = math.nextPow2;
    export import repeat = math.repeat;
    export import pingPong = math.pingPong;
    export import inverseLerp = math.inverseLerp;
    export import absMaxComponent = math.absMaxComponent;
    export import absMax = math.absMax;
    export import enumerableProps = math.enumerableProps;
    export import EPSILON = math.EPSILON;
    export import random = math.random;
    export import IColorLike = math.IColorLike;
    export import IMat3Like = math.IMat3Like;
    export import IMat4Like = math.IMat4Like;
    export import IQuatLike = math.IQuatLike;
    export import IRectLike = math.IRectLike;
    export import ISizeLike = math.ISizeLike;
    export import IVec2Like = math.IVec2Like;
    export import IVec3Like = math.IVec3Like;
    export import IVec4Like = math.IVec4Like;
    export import FloatArray = math.FloatArray;
    export import IVec2 = math.IVec2;
    export import IVec3 = math.IVec3;
    export import IVec4 = math.IVec4;
    export import IMat3 = math.IMat3;
    export import IMat4 = math.IMat4;
    export import IRect = math.IRect;
    export import IQuat = math.IQuat;
    export import IColor = math.IColor;
    export import MATH_FLOAT_ARRAY = math.MATH_FLOAT_ARRAY;
    export import MathBase = math.MathBase;
    export import Pool = memop.Pool;
    export import RecyclePool = memop.RecyclePool;
    export import CachedArray = memop.CachedArray;
    export import PhysicsSystem = physics.PhysicsSystem;
    export import PhysicsRayResult = physics.PhysicsRayResult;
    export import Collider = physics.Collider;
    export import ColliderComponent = physics.Collider;
    export import BoxCollider = physics.BoxCollider;
    export import BoxColliderComponent = physics.BoxCollider;
    export import SphereCollider = physics.SphereCollider;
    export import SphereColliderComponent = physics.SphereCollider;
    export import CapsuleCollider = physics.CapsuleCollider;
    export import CapsuleColliderComponent = physics.CapsuleCollider;
    export import MeshCollider = physics.MeshCollider;
    export import MeshColliderComponent = physics.MeshCollider;
    export import CylinderCollider = physics.CylinderCollider;
    export import CylinderColliderComponent = physics.CylinderCollider;
    export import ConeCollider = physics.ConeCollider;
    export import TerrainCollider = physics.TerrainCollider;
    export import SimplexCollider = physics.SimplexCollider;
    export import PlaneCollider = physics.PlaneCollider;
    export import Constraint = physics.Constraint;
    export import HingeConstraint = physics.HingeConstraint;
    export import PointToPointConstraint = physics.PointToPointConstraint;
    export import RigidBody = physics.RigidBody;
    export import RigidBodyComponent = physics.RigidBody;
    export import PhysicsMaterial = physics.PhysicsMaterial;
    export import PhysicMaterial = physics.PhysicsMaterial;
    export import ConstantForce = physics.ConstantForce;
    export import ERigidBodyType = physics.ERigidBodyType;
    export import EAxisDirection = physics.EAxisDirection;
    export namespace __private {
        /**
         * Engine classes with this kind of signatures are integrated with editor extendability.
         * @internal
         */
        export interface _cocos_core_data_editor_extras_tag__EditorExtendableObject {
            /**
             * @en
             * The editor extras on this object.
             *
             * BE CAREFUL: this property is currently governed by Cocos Creator Editor.
             * Its definition is not visible and is unknown to both engine code or users codes,
             * they SHALL NOT operates it.
             *
             * You should use editor extras tag to visit this property.
             * @example
             * ```ts
             * import { editorExtrasTag } from 'cc';
             * node[editorExtrasTag] = {};
             * node[editorExtrasTag].someWhat;
             * ```
             * Even if you know `editorExtrasTag === '__editorExtras__'` in current,
             * don't access the property through that:
             * ```ts
             * node.__editorExtras__ = {}; // Error: might be break in future.
             * ```
             * @zh
             * 此对象的编辑器额外数据。
             *
             * **注意**：此属性目前由 Cocos Creator 编辑器管理。
             * 它的定义不管是对于引擎还是用户代码都是不可见的，也 **不应该** 操作该数据。
             *
             * 你应该仅使用编辑器额外数据标签来访问此数据。
             * @example
             * ```ts
             * import { editorExtrasTag } from 'cc';
             * node[editorExtrasTag] = {};
             * node[editorExtrasTag].someWhat;
             * ```
             * 即使你知道目前 `editorExtrasTag === '__editorExtras__'`，
             * 也不要通过字符串属性来访问：
             * ```ts
             * node.__editorExtras__ = {}; // 错误：在未来可能无法生效
             * ```
             */
            [editorExtrasTag]: unknown;
        }
        /**
         * Class which implements the `EditorExtendableObject` interface.
         */
        export const _cocos_core_data_editor_extendable__EditorExtendable: new (...args: any[]) => _cocos_core_data_editor_extras_tag__EditorExtendableObject;
        export type _cocos_core_data_editor_extendable__EditorExtendable = InstanceType<typeof _cocos_core_data_editor_extendable__EditorExtendable>;
        export abstract class _cocos_core_animation_embedded_player_embedded_player__EmbeddedPlayableState {
            constructor(randomAccess: boolean);
            /**
             * @zh
             * 是否可以随意调整此播放器到任何时间。
             * @en
             * Indicates if this player can be adjusted to any time.
             */
            get randomAccess(): boolean;
            /**
             * @zh
             * 销毁此播放器。
             * @zh
             * Destroys this player state.
             */
            abstract destroy(): void;
            /**
             * @zh
             * 该方法在此播放器开始播放时触发。
             * @en
             * This method is called when this player gets to play.
             */
            abstract play(): void;
            /**
             * @zh
             * 该方法在此播放器暂停播放时触发。
             * @en
             * This method is called when this player pauses.
             */
            abstract pause(): void;
            /**
             * @zh
             * 该方法在此播放器结束播放时触发，或在宿主动画剪辑本身停止播放时触发。
             * @en
             * This method is called when this player ends its playback, and is called when the host animation clip is stopped.
             */
            abstract stop(): void;
            /**
             * @zh
             * 如果 [[`EmbeddedPlayer.reconciledSpeed`]] 为 `true`，则在宿主的播放速度改变时触发。
             * @en
             * If [[`EmbeddedPlayer.reconciledSpeed`]] is `true`, is called when the host changes its speed.
             * @param speed The speed.
             */
            abstract setSpeed(speed: number): void;
            setTime(_time: number): void;
        }
        export class _cocos_core_animation_embedded_player_embedded_particle_system_player__EmbeddedParticleSystemPlayableState extends _cocos_core_animation_embedded_player_embedded_player__EmbeddedPlayableState {
            constructor(particleSystem: ParticleSystem);
            destroy(): void;
            /**
             * Plays the particle system from the beginning no matter current time.
             */
            play(): void;
            /**
             * Pause the particle system no matter current time.
             */
            pause(): void;
            /**
             * Stops the particle system.
             */
            stop(): void;
            /**
             * Sets the speed of the particle system.
             * @param speed The speed.
             */
            setSpeed(speed: number): void;
        }
        export class _cocos_core_animation_embedded_player_embedded_animation_clip_player__EmbeddedAnimationClipPlayableState extends _cocos_core_animation_embedded_player_embedded_player__EmbeddedPlayableState {
            constructor(animationState: AnimationState);
            destroy(): void;
            /**
             * Plays the animation state at specified time.
             */
            play(): void;
            /**
             * Pause the animation state.
             */
            pause(): void;
            /**
             * Stops the animation state.
             */
            stop(): void;
            /**
             * Sets the speed of the animation state.
             */
            setSpeed(speed: number): void;
            setTime(time: number): void;
        }
        export type _cocos_3d_skeletal_animation_skeletal_animation_blending__BlendingPropertyName = "position" | "scale" | "rotation" | "eulerAngles";
        export interface _cocos_3d_skeletal_animation_skeletal_animation_blending__BlendStateWriterHost {
            readonly weight: number;
        }
        export interface _cocos_3d_skeletal_animation_skeletal_animation_blending__PropertyBlendState<TValue> {
            /**
             * How many writer reference this property.
             */
            refCount: number;
            readonly result: Readonly<TValue>;
            blend(value: Readonly<TValue>, weight: number): void;
        }
        export interface _cocos_3d_skeletal_animation_skeletal_animation_blending__PropertyBlendStateTypeMap<TVec3PropertyBlendState, TQuatPropertyBlendState> {
            "rotation": TQuatPropertyBlendState;
            "position": TVec3PropertyBlendState;
            "scale": TVec3PropertyBlendState;
            "eulerAngles": TVec3PropertyBlendState;
        }
        export type _cocos_core_animation_tracks_track__RuntimeBinding = {
            setValue(value: unknown): void;
            getValue?(): unknown;
        };
        export class _cocos_3d_skeletal_animation_skeletal_animation_blending__BlendStateWriterInternal<P extends _cocos_3d_skeletal_animation_skeletal_animation_blending__BlendingPropertyName> implements _cocos_core_animation_tracks_track__RuntimeBinding {
            protected _node: Node;
            protected _property: P;
            protected _propertyBlendState: _cocos_3d_skeletal_animation_skeletal_animation_blending__PropertyBlendStateTypeMap<_cocos_3d_skeletal_animation_skeletal_animation_blending__PropertyBlendState<math.Vec3>, _cocos_3d_skeletal_animation_skeletal_animation_blending__PropertyBlendState<math.Quat>>[P];
            protected _host: _cocos_3d_skeletal_animation_skeletal_animation_blending__BlendStateWriterHost;
            protected _constants: boolean;
            constructor(_node: Node, _property: P, _propertyBlendState: _cocos_3d_skeletal_animation_skeletal_animation_blending__PropertyBlendStateTypeMap<_cocos_3d_skeletal_animation_skeletal_animation_blending__PropertyBlendState<math.Vec3>, _cocos_3d_skeletal_animation_skeletal_animation_blending__PropertyBlendState<math.Quat>>[P], _host: _cocos_3d_skeletal_animation_skeletal_animation_blending__BlendStateWriterHost, _constants: boolean);
            get node(): Node;
            get property(): P;
            getValue(): Node[P];
            setValue(value: _cocos_3d_skeletal_animation_skeletal_animation_blending__PropertyBlendStateTypeMap<_cocos_3d_skeletal_animation_skeletal_animation_blending__PropertyBlendState<math.Vec3>, _cocos_3d_skeletal_animation_skeletal_animation_blending__PropertyBlendState<math.Quat>>[P]["result"]): void;
        }
        export type _cocos_3d_skeletal_animation_skeletal_animation_blending__BlendStateWriter<P extends _cocos_3d_skeletal_animation_skeletal_animation_blending__BlendingPropertyName> = Omit<_cocos_3d_skeletal_animation_skeletal_animation_blending__BlendStateWriterInternal<P>, "node" | "property">;
        export abstract class _cocos_3d_skeletal_animation_skeletal_animation_blending__NodeBlendState<TVec3PropertyBlendState extends _cocos_3d_skeletal_animation_skeletal_animation_blending__PropertyBlendState<math.Vec3>, TQuatPropertyBlendState extends _cocos_3d_skeletal_animation_skeletal_animation_blending__PropertyBlendState<math.Quat>> {
            get empty(): boolean;
            refProperty<P extends _cocos_3d_skeletal_animation_skeletal_animation_blending__BlendingPropertyName>(node: Node, property: _cocos_3d_skeletal_animation_skeletal_animation_blending__BlendingPropertyName): _cocos_3d_skeletal_animation_skeletal_animation_blending__NodeBlendState<TVec3PropertyBlendState, TQuatPropertyBlendState>["_properties"][P];
            deRefProperty(property: _cocos_3d_skeletal_animation_skeletal_animation_blending__BlendingPropertyName): void;
            apply(node: Node): void;
            protected _transformApplyFlags: number;
            protected _properties: {
                position?: TVec3PropertyBlendState;
                rotation?: TQuatPropertyBlendState;
                eulerAngles?: TVec3PropertyBlendState;
                scale?: TVec3PropertyBlendState;
            };
            protected abstract _createVec3BlendState(currentValue: Readonly<math.Vec3>): TVec3PropertyBlendState;
            protected abstract _createQuatBlendState(currentValue: Readonly<math.Quat>): TQuatPropertyBlendState;
        }
        export abstract class _cocos_3d_skeletal_animation_skeletal_animation_blending__BlendStateBuffer<TNodeBlendState extends _cocos_3d_skeletal_animation_skeletal_animation_blending__NodeBlendState<_cocos_3d_skeletal_animation_skeletal_animation_blending__PropertyBlendState<math.Vec3>, _cocos_3d_skeletal_animation_skeletal_animation_blending__PropertyBlendState<math.Quat>> = _cocos_3d_skeletal_animation_skeletal_animation_blending__NodeBlendState<_cocos_3d_skeletal_animation_skeletal_animation_blending__PropertyBlendState<math.Vec3>, _cocos_3d_skeletal_animation_skeletal_animation_blending__PropertyBlendState<math.Quat>>> {
            protected _nodeBlendStates: Map<Node, TNodeBlendState>;
            createWriter<P extends _cocos_3d_skeletal_animation_skeletal_animation_blending__BlendingPropertyName>(node: Node, property: P, host: _cocos_3d_skeletal_animation_skeletal_animation_blending__BlendStateWriterHost, constants: boolean): _cocos_3d_skeletal_animation_skeletal_animation_blending__BlendStateWriter<P>;
            destroyWriter<P extends _cocos_3d_skeletal_animation_skeletal_animation_blending__BlendingPropertyName>(writer: _cocos_3d_skeletal_animation_skeletal_animation_blending__BlendStateWriter<P>): void;
            ref<P extends _cocos_3d_skeletal_animation_skeletal_animation_blending__BlendingPropertyName>(node: Node, property: P): _cocos_3d_skeletal_animation_skeletal_animation_blending__PropertyBlendStateTypeMap<_cocos_3d_skeletal_animation_skeletal_animation_blending__PropertyBlendState<math.Vec3>, _cocos_3d_skeletal_animation_skeletal_animation_blending__PropertyBlendState<math.Quat>>[P];
            deRef(node: Node, property: _cocos_3d_skeletal_animation_skeletal_animation_blending__BlendingPropertyName): void;
            apply(): void;
            protected abstract createNodeBlendState(): TNodeBlendState;
        }
        export type _cocos_core_animation_pose_output__Pose = _cocos_3d_skeletal_animation_skeletal_animation_blending__BlendStateBuffer;
        export class _cocos_core_animation_pose_output__PoseOutput {
            weight: number;
            constructor(pose: _cocos_core_animation_pose_output__Pose);
            destroy(): void;
            createPoseWriter(node: Node, property: _cocos_3d_skeletal_animation_skeletal_animation_blending__BlendingPropertyName, constants: boolean): _cocos_3d_skeletal_animation_skeletal_animation_blending__BlendStateWriter<_cocos_3d_skeletal_animation_skeletal_animation_blending__BlendingPropertyName>;
        }
        /**
         * Composite of track path and value proxy.
         * Not exposed to external. If there is any reason it should be exposed,
         * please redesign the public interfaces.
         */
        export class _cocos_core_animation_tracks_track__TrackBinding {
            path: Readonly<animation.TrackPath>;
            proxy: animation.IValueProxyFactory | undefined;
            parseTrsPath(): {
                node: string;
                property: "position" | "scale" | "eulerAngles" | "rotation";
            } | null;
            createRuntimeBinding(target: unknown, poseOutput: _cocos_core_animation_pose_output__PoseOutput | undefined, isConstant: boolean): _cocos_core_animation_tracks_track__RuntimeBinding | {
                target: any;
                setValue: any;
                getValue: any;
            } | null;
            isMaskedOff(mask: AnimationMask): boolean;
        }
        export type _cocos_core_animation_tracks_track__Binder = (binding: _cocos_core_animation_tracks_track__TrackBinding) => undefined | _cocos_core_animation_tracks_track__RuntimeBinding;
        export type _cocos_core_animation_exotic_animation_exotic_animation__FloatArray = Float32Array | Float64Array;
        export enum _cocos_core_animation_exotic_animation_exotic_animation__FloatPrecision {
            FLOAT_32 = 0,
            FLOAT_64 = 1
        }
        export type _cocos_core_animation_exotic_animation_exotic_animation__QuantizationType = "uint8" | "uint16";
        export type _cocos_core_animation_exotic_animation_exotic_animation__UintArray = Uint8Array | Uint16Array | Uint32Array;
        export class _cocos_core_animation_exotic_animation_exotic_animation__QuantizedFloatArray {
            originalPrecision: _cocos_core_animation_exotic_animation_exotic_animation__FloatPrecision;
            min: number;
            extent: number;
            values: _cocos_core_animation_exotic_animation_exotic_animation__UintArray;
            get quantizationType(): _cocos_core_animation_exotic_animation_exotic_animation__QuantizationType;
            constructor(originalPrecision: _cocos_core_animation_exotic_animation_exotic_animation__FloatPrecision, values: _cocos_core_animation_exotic_animation_exotic_animation__UintArray, extent: number, min?: number);
            /**
             * @internal
             */
            toHashString(): string;
        }
        export type _cocos_core_animation_exotic_animation_exotic_animation__MayBeQuantized = _cocos_core_animation_exotic_animation_exotic_animation__FloatArray | _cocos_core_animation_exotic_animation_exotic_animation__QuantizedFloatArray;
        export class _cocos_core_animation_exotic_animation_exotic_animation__ExoticVectorLikeTrackValues {
            constructor(values: _cocos_core_animation_exotic_animation_exotic_animation__FloatArray);
            get precision(): _cocos_core_animation_exotic_animation_exotic_animation__FloatPrecision;
            quantize(type: _cocos_core_animation_exotic_animation_exotic_animation__QuantizationType): void;
            /**
             * @internal
             */
            toHashString(): string;
            protected _values: _cocos_core_animation_exotic_animation_exotic_animation__MayBeQuantized;
            protected _isQuantized: boolean;
        }
        export interface _cocos_core_animation_exotic_animation_exotic_animation__ExoticTrackValues<TValue> {
            readonly precision: _cocos_core_animation_exotic_animation_exotic_animation__FloatPrecision;
            get(index: number, resultValue: TValue): void;
            lerp(prevIndex: number, nextIndex: number, ratio: number, prevValue: TValue, nextValue: TValue, resultValue: TValue): void;
        }
        export class _cocos_core_animation_exotic_animation_exotic_animation__ExoticVec3TrackValues extends _cocos_core_animation_exotic_animation_exotic_animation__ExoticVectorLikeTrackValues implements _cocos_core_animation_exotic_animation_exotic_animation__ExoticTrackValues<math.Vec3> {
            static imitate(values: _cocos_core_animation_exotic_animation_exotic_animation__FloatArray, model: _cocos_core_animation_exotic_animation_exotic_animation__ExoticVec3TrackValues): _cocos_core_animation_exotic_animation_exotic_animation__ExoticVec3TrackValues;
            get(index: number, resultValue: math.Vec3): void;
            lerp(prevIndex: number, nextIndex: number, ratio: number, prevValue: math.Vec3, nextValue: math.Vec3, resultValue: math.Vec3): void;
        }
        export class _cocos_core_animation_exotic_animation_exotic_animation__ExoticTrack<TTrackValues extends {
            toHashString(): string;
        }> {
            constructor(times: _cocos_core_animation_exotic_animation_exotic_animation__FloatArray, values: TTrackValues);
            times: _cocos_core_animation_exotic_animation_exotic_animation__FloatArray;
            values: TTrackValues;
            /**
             * @internal
             */
            toHashString(): string;
        }
        export type _cocos_core_animation_exotic_animation_exotic_animation__ExoticVec3Track = _cocos_core_animation_exotic_animation_exotic_animation__ExoticTrack<_cocos_core_animation_exotic_animation_exotic_animation__ExoticVec3TrackValues>;
        export class _cocos_core_animation_exotic_animation_exotic_animation__ExoticQuatTrackValues extends _cocos_core_animation_exotic_animation_exotic_animation__ExoticVectorLikeTrackValues implements _cocos_core_animation_exotic_animation_exotic_animation__ExoticTrackValues<math.Quat> {
            static imitate(values: _cocos_core_animation_exotic_animation_exotic_animation__FloatArray, model: _cocos_core_animation_exotic_animation_exotic_animation__ExoticQuatTrackValues): _cocos_core_animation_exotic_animation_exotic_animation__ExoticQuatTrackValues;
            get(index: number, resultValue: math.Quat): void;
            lerp(prevIndex: number, nextIndex: number, ratio: number, prevValue: math.Quat, nextValue: math.Quat, resultValue: math.Quat): void;
        }
        export type _cocos_core_animation_exotic_animation_exotic_animation__ExoticQuatTrack = _cocos_core_animation_exotic_animation_exotic_animation__ExoticTrack<_cocos_core_animation_exotic_animation_exotic_animation__ExoticQuatTrackValues>;
        export class _cocos_core_animation_exotic_animation_exotic_animation__ExoticNodeAnimationEvaluator {
            constructor(path: string, position: _cocos_core_animation_exotic_animation_exotic_animation__ExoticVec3Track | null, rotation: _cocos_core_animation_exotic_animation_exotic_animation__ExoticQuatTrack | null, scale: _cocos_core_animation_exotic_animation_exotic_animation__ExoticVec3Track | null, binder: _cocos_core_animation_tracks_track__Binder);
            evaluate(time: number): void;
        }
        export class _cocos_core_animation_exotic_animation_exotic_animation__SplitInfo {
            preLerpIndex: number;
            preLerpRatio: number;
            directKeyframesBegin: number;
            directKeyframesEnd: number;
            postLerpIndex: number;
            postLerpRatio: number;
            constructor();
            get keyframesCount(): number;
            transformTime(input: number): number;
            calculate(times: ArrayLike<number>, from: number, to: number): void;
        }
        export class _cocos_core_animation_exotic_animation_exotic_animation__ExoticNodeAnimation {
            constructor(path: string);
            createPosition(times: _cocos_core_animation_exotic_animation_exotic_animation__FloatArray, values: _cocos_core_animation_exotic_animation_exotic_animation__FloatArray): void;
            createRotation(times: _cocos_core_animation_exotic_animation_exotic_animation__FloatArray, values: _cocos_core_animation_exotic_animation_exotic_animation__FloatArray): void;
            createScale(times: _cocos_core_animation_exotic_animation_exotic_animation__FloatArray, values: _cocos_core_animation_exotic_animation_exotic_animation__FloatArray): void;
            createEvaluator(binder: _cocos_core_animation_tracks_track__Binder): _cocos_core_animation_exotic_animation_exotic_animation__ExoticNodeAnimationEvaluator;
            split(from: number, to: number, splitInfoCache: _cocos_core_animation_exotic_animation_exotic_animation__SplitInfo): _cocos_core_animation_exotic_animation_exotic_animation__ExoticNodeAnimation;
            get path(): string;
            /**
             * @internal
             */
            toHashString(): string;
        }
        export class _cocos_core_animation_exotic_animation_exotic_animation__ExoticTrsAnimationEvaluator {
            constructor(nodeAnimations: _cocos_core_animation_exotic_animation_exotic_animation__ExoticNodeAnimation[], binder: _cocos_core_animation_tracks_track__Binder);
            evaluate(time: number): void;
        }
        export type _cocos_core_animation_tracks_track__Curve = RealCurve | QuatCurve | ObjectCurve<unknown>;
        /**
         * @en
         * Channel contains a curve.
         * @zh
         * 通道包含了一条曲线。
         */
        export class _cocos_core_animation_tracks_track__Channel<T = _cocos_core_animation_tracks_track__Curve> {
            constructor(curve: T);
            /**
             * @internal Not used for now.
             */
            name: string;
            /**
             * @en The curve within the channel.
             * @zh 通道中的曲线。
             */
            get curve(): T;
        }
        export type _cocos_core_animation_tracks_track__RealChannel = _cocos_core_animation_tracks_track__Channel<RealCurve>;
        export const _cocos_core_animation_define__createEvalSymbol: unique symbol;
        export class _cocos_core_animation_tracks_array_track__RealArrayTrackEval {
            constructor(_curves: RealCurve[]);
            evaluate(time: number, _runtimeBinding: _cocos_core_animation_tracks_track__RuntimeBinding): number[];
        }
        export class _editor_src_marionette_preview__AnimationGraphPartialPreviewer {
            constructor(root: Node);
            destroy(): void;
            evaluate(): void;
            addVariable(id: string, type: animation.VariableType, value: animation.Value): void;
            removeVariable(id: string): void;
            updateVariable(id: string, value: animation.Value): void;
            protected createMotionEval(motion: ____private._cocos_core_animation_marionette_motion__Motion): ____private._cocos_core_animation_marionette_motion__MotionEval | null;
        }
        export const _cocos_core_data_deserialize_symbols__onAfterDeserializedTag: unique symbol;
        export type _types_globals__Constructor<T = unknown> = new (...args: any[]) => T;
        export const _cocos_core_platform_macro__KEY: {
            /**
             * @en None
             * @zh 没有分配
             * @readonly
             */
            none: number;
            /**
             * @en The back key on mobile phone
             * @zh 移动端返回键
             * @readonly
             * @deprecated since v3.3, please use KeyCode.MOBILE_BACK instead.
             */
            back: number;
            /**
             * @en The menu key on mobile phone
             * @zh 移动端菜单键
             * @readonly
             * @deprecated since v3.3
             */
            menu: number;
            /**
             * @en The backspace key
             * @zh 退格键
             * @readonly
             */
            backspace: number;
            /**
             * @en The tab key
             * @zh Tab 键
             * @readonly
             */
            tab: number;
            /**
             * @en The enter key
             * @zh 回车键
             * @readonly
             */
            enter: number;
            /**
             * @en The shift key
             * @zh Shift 键
             * @readonly
             * @deprecated since v3.3, please use KeyCode.SHIFT_LEFT instead.
             */
            shift: number;
            /**
             * @en The ctrl key
             * @zh Ctrl 键
             * @readonly
             * @deprecated since v3.3, please use KeyCode.CTRL_LEFT instead.
             */
            ctrl: number;
            /**
             * @en The alt key
             * @zh Alt 键
             * @readonly
             * @deprecated since v3.3, please use KeyCode.ALT_LEFT instead.
             */
            alt: number;
            /**
             * @en The pause key
             * @zh 暂停键
             * @readonly
             */
            pause: number;
            /**
             * @en The caps lock key
             * @zh 大写锁定键
             * @readonly
             */
            capslock: number;
            /**
             * @en The esc key
             * @zh ESC 键
             * @readonly
             */
            escape: number;
            /**
             * @en The space key
             * @zh 空格键
             * @readonly
             */
            space: number;
            /**
             * @en The page up key
             * @zh 向上翻页键
             * @readonly
             */
            pageup: number;
            /**
             * @en The page down key
             * @zh 向下翻页键
             * @readonly
             */
            pagedown: number;
            /**
             * @en The end key
             * @zh 结束键
             * @readonly
             */
            end: number;
            /**
             * @en The home key
             * @zh 主菜单键
             * @readonly
             */
            home: number;
            /**
             * @en The left key
             * @zh 向左箭头键
             * @readonly
             */
            left: number;
            /**
             * @en The up key
             * @zh 向上箭头键
             * @readonly
             */
            up: number;
            /**
             * @en The right key
             * @zh 向右箭头键
             * @readonly
             */
            right: number;
            /**
             * @en The down key
             * @zh 向下箭头键
             * @readonly
             */
            down: number;
            /**
             * @en The select key
             * @zh Select 键
             * @readonly
             * @deprecated since v3.3
             */
            select: number;
            /**
             * @en The insert key
             * @zh 插入键
             * @readonly
             */
            insert: number;
            /**
             * @en The Delete key
             * @zh 删除键
             * @readonly
             */
            Delete: number;
            /**
             * @en The '0' key on the top of the alphanumeric keyboard.
             * @zh 字母键盘上的 0 键
             * @readonly
             * @deprecated since v3.3
             */
            0: number;
            /**
             * @en The '1' key on the top of the alphanumeric keyboard.
             * @zh 字母键盘上的 1 键
             * @readonly
             * @deprecated since v3.3
             */
            1: number;
            /**
             * @en The '2' key on the top of the alphanumeric keyboard.
             * @zh 字母键盘上的 2 键
             * @readonly
             * @deprecated since v3.3
             */
            2: number;
            /**
             * @en The '3' key on the top of the alphanumeric keyboard.
             * @zh 字母键盘上的 3 键
             * @readonly
             * @deprecated since v3.3
             */
            3: number;
            /**
             * @en The '4' key on the top of the alphanumeric keyboard.
             * @zh 字母键盘上的 4 键
             * @readonly
             * @deprecated since v3.3
             */
            4: number;
            /**
             * @en The '5' key on the top of the alphanumeric keyboard.
             * @zh 字母键盘上的 5 键
             * @readonly
             * @deprecated since v3.3
             */
            5: number;
            /**
             * @en The '6' key on the top of the alphanumeric keyboard.
             * @zh 字母键盘上的 6 键
             * @readonly
             * @deprecated since v3.3
             */
            6: number;
            /**
             * @en The '7' key on the top of the alphanumeric keyboard.
             * @zh 字母键盘上的 7 键
             * @readonly
             * @deprecated since v3.3
             */
            7: number;
            /**
             * @en The '8' key on the top of the alphanumeric keyboard.
             * @zh 字母键盘上的 8 键
             * @readonly
             * @deprecated since v3.3
             */
            8: number;
            /**
             * @en The '9' key on the top of the alphanumeric keyboard.
             * @zh 字母键盘上的 9 键
             * @readonly
             * @deprecated since v3.3
             */
            9: number;
            /**
             * @en The a key
             * @zh A 键
             * @readonly
             */
            a: number;
            /**
             * @en The b key
             * @zh B 键
             * @readonly
             */
            b: number;
            /**
             * @en The c key
             * @zh C 键
             * @readonly
             */
            c: number;
            /**
             * @en The d key
             * @zh D 键
             * @readonly
             */
            d: number;
            /**
             * @en The e key
             * @zh E 键
             * @readonly
             */
            e: number;
            /**
             * @en The f key
             * @zh F 键
             * @readonly
             */
            f: number;
            /**
             * @en The g key
             * @zh G 键
             * @readonly
             */
            g: number;
            /**
             * @en The h key
             * @zh H 键
             * @readonly
             */
            h: number;
            /**
             * @en The i key
             * @zh I 键
             * @readonly
             */
            i: number;
            /**
             * @en The j key
             * @zh J 键
             * @readonly
             */
            j: number;
            /**
             * @en The k key
             * @zh K 键
             * @readonly
             */
            k: number;
            /**
             * @en The l key
             * @zh L 键
             * @readonly
             */
            l: number;
            /**
             * @en The m key
             * @zh M 键
             * @readonly
             */
            m: number;
            /**
             * @en The n key
             * @zh N 键
             * @readonly
             */
            n: number;
            /**
             * @en The o key
             * @zh O 键
             * @readonly
             */
            o: number;
            /**
             * @en The p key
             * @zh P 键
             * @readonly
             */
            p: number;
            /**
             * @en The q key
             * @zh Q 键
             * @readonly
             */
            q: number;
            /**
             * @en The r key
             * @zh R 键
             * @readonly
             */
            r: number;
            /**
             * @en The s key
             * @zh S 键
             * @readonly
             */
            s: number;
            /**
             * @en The t key
             * @zh T 键
             * @readonly
             */
            t: number;
            /**
             * @en The u key
             * @zh U 键
             * @readonly
             */
            u: number;
            /**
             * @en The v key
             * @zh V 键
             * @readonly
             */
            v: number;
            /**
             * @en The w key
             * @zh W 键
             * @readonly
             */
            w: number;
            /**
             * @en The x key
             * @zh X 键
             * @readonly
             */
            x: number;
            /**
             * @en The y key
             * @zh Y 键
             * @readonly
             */
            y: number;
            /**
             * @en The z key
             * @zh Z 键
             * @readonly
             */
            z: number;
            /**
             * @en The numeric keypad 0
             * @zh 数字键盘 0
             * @readonly
             */
            num0: number;
            /**
             * @en The numeric keypad 1
             * @zh 数字键盘 1
             * @readonly
             */
            num1: number;
            /**
             * @en The numeric keypad 2
             * @zh 数字键盘 2
             * @readonly
             */
            num2: number;
            /**
             * @en The numeric keypad 3
             * @zh 数字键盘 3
             * @readonly
             */
            num3: number;
            /**
             * @en The numeric keypad 4
             * @zh 数字键盘 4
             * @readonly
             */
            num4: number;
            /**
             * @en The numeric keypad 5
             * @zh 数字键盘 5
             * @readonly
             */
            num5: number;
            /**
             * @en The numeric keypad 6
             * @zh 数字键盘 6
             * @readonly
             */
            num6: number;
            /**
             * @en The numeric keypad 7
             * @zh 数字键盘 7
             * @readonly
             */
            num7: number;
            /**
             * @en The numeric keypad 8
             * @zh 数字键盘 8
             * @readonly
             */
            num8: number;
            /**
             * @en The numeric keypad 9
             * @zh 数字键盘 9
             * @readonly
             */
            num9: number;
            /**
             * @en The numeric keypad '*'
             * @zh 数字键盘 *
             * @readonly
             * @deprecated since v3.3
             */
            "*": number;
            /**
             * @en The numeric keypad '+'
             * @zh 数字键盘 +
             * @readonly
             * @deprecated since v3.3
             */
            "+": number;
            /**
             * @en The numeric keypad '-'
             * @zh 数字键盘 -
             * @readonly
             * @deprecated since v3.3
             */
            "-": number;
            /**
             * @en The numeric keypad 'delete'
             * @zh 数字键盘删除键
             * @readonly
             */
            numdel: number;
            /**
             * @en The numeric keypad '/'
             * @zh 数字键盘 /
             * @readonly
             * @deprecated since v3.3
             */
            "/": number;
            /**
             * @en The F1 function key
             * @zh F1 功能键
             * @readonly
             */
            f1: number;
            /**
             * @en The F2 function key
             * @zh F2 功能键
             * @readonly
             */
            f2: number;
            /**
             * @en The F3 function key
             * @zh F3 功能键
             * @readonly
             */
            f3: number;
            /**
             * @en The F4 function key
             * @zh F4 功能键
             * @readonly
             */
            f4: number;
            /**
             * @en The F5 function key
             * @zh F5 功能键
             * @readonly
             */
            f5: number;
            /**
             * @en The F6 function key
             * @zh F6 功能键
             * @readonly
             */
            f6: number;
            /**
             * @en The F7 function key
             * @zh F7 功能键
             * @readonly
             */
            f7: number;
            /**
             * @en The F8 function key
             * @zh F8 功能键
             * @readonly
             */
            f8: number;
            /**
             * @en The F9 function key
             * @zh F9 功能键
             * @readonly
             */
            f9: number;
            /**
             * @en The F10 function key
             * @zh F10 功能键
             * @readonly
             */
            f10: number;
            /**
             * @en The F11 function key
             * @zh F11 功能键
             * @readonly
             */
            f11: number;
            /**
             * @en The F12 function key
             * @zh F12 功能键
             * @readonly
             */
            f12: number;
            /**
             * @en The numlock key
             * @zh 数字锁定键
             * @readonly
             */
            numlock: number;
            /**
             * @en The scroll lock key
             * @zh 滚动锁定键
             * @readonly
             */
            scrolllock: number;
            /**
             * @en The ';' key.
             * @zh 分号键
             * @readonly
             * @deprecated since v3.3
             */
            ";": number;
            /**
             * @en The ';' key.
             * @zh 分号键
             * @readonly
             */
            semicolon: number;
            /**
             * @en The '=' key.
             * @zh 等于号键
             * @readonly
             */
            equal: number;
            /**
             * @en The '=' key.
             * @zh 等于号键
             * @readonly
             * @deprecated since v3.3
             */
            "=": number;
            /**
             * @en The ',' key.
             * @zh 逗号键
             * @readonly
             * @deprecated since v3.3
             */
            ",": number;
            /**
             * @en The ',' key.
             * @zh 逗号键
             * @readonly
             */
            comma: number;
            /**
             * @en The dash '-' key.
             * @zh 中划线键
             * @readonly
             */
            dash: number;
            /**
             * @en The '.' key.
             * @zh 句号键
             * @readonly
             * @deprecated since v3.3
             */
            ".": number;
            /**
             * @en The '.' key
             * @zh 句号键
             * @readonly
             */
            period: number;
            /**
             * @en The forward slash key
             * @zh 正斜杠键
             * @readonly
             */
            forwardslash: number;
            /**
             * @en The grave key
             * @zh 按键 `
             * @readonly
             */
            grave: number;
            /**
             * @en The '[' key
             * @zh 按键 [
             * @readonly
             * @deprecated since v3.3
             */
            "[": number;
            /**
             * @en The '[' key
             * @zh 按键 [
             * @readonly
             */
            openbracket: number;
            /**
             * @en The '\' key
             * @zh 反斜杠键
             * @readonly
             */
            backslash: number;
            /**
             * @en The ']' key
             * @zh 按键 ]
             * @readonly
             * @deprecated since v3.3
             */
            "]": number;
            /**
             * @en The ']' key
             * @zh 按键 ]
             * @readonly
             */
            closebracket: number;
            /**
             * @en The quote key
             * @zh 单引号键
             * @readonly
             */
            quote: number;
            /**
             * @en The dpad left key
             * @zh 导航键 向左
             * @readonly
             * @deprecated since v3.3
             */
            dpadLeft: number;
            /**
             * @en The dpad right key
             * @zh 导航键 向右
             * @readonly
             * @deprecated since v3.3
             */
            dpadRight: number;
            /**
             * @en The dpad up key
             * @zh 导航键 向上
             * @readonly
             * @deprecated since v3.3
             */
            dpadUp: number;
            /**
             * @en The dpad down key
             * @zh 导航键 向下
             * @readonly
             * @deprecated since v3.3
             */
            dpadDown: number;
            /**
             * @en The dpad center key
             * @zh 导航键 确定键
             * @readonly
             * @deprecated since v3.3
             */
            dpadCenter: number;
        };
        export type _types_globals__TypedArray = Uint8Array | Uint8ClampedArray | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array;
        export class _cocos_2d_renderer_native_2d__NativeUIMeshBuffer {
            get vData(): Float32Array;
            set vData(val: Float32Array);
            get iData(): Uint16Array;
            set iData(val: Uint16Array);
            syncSharedBufferToNative(data: _types_globals__TypedArray): any;
            initialize(attrs: gfx.Attribute[]): any;
            reset(): any;
            destroy(): any;
            setDirty(): any;
            recycleIA(): any;
            uploadBuffers(): any;
        }
        export enum _cocos_2d_renderer_stencil_manager__Stage {
            DISABLED = 0,
            CLEAR = 1,
            ENTER_LEVEL = 2,
            ENABLED = 3,
            EXIT_LEVEL = 4,
            CLEAR_INVERTED = 5,
            ENTER_LEVEL_INVERTED = 6
        }
        export interface _cocos_2d_assembler_label_font_utils__ISharedLabelData {
            canvas: HTMLCanvasElement;
            context: CanvasRenderingContext2D | null;
        }
        export interface _cocos_2d_assets_sprite_atlas__ISpriteFrameList {
            [key: string]: SpriteFrame | null;
        }
        /**
         * @en
         * The texture pixel format, default value is RGBA8888,<br>
         * you should note that textures loaded by normal image files (png, jpg) can only support RGBA8888 format,<br>
         * other formats are supported by compressed file types or raw data.
         * @zh
         * 纹理像素格式，默认值为RGBA8888，<br>
         * 你应该注意到普通图像文件（png，jpg）加载的纹理只能支持RGBA8888格式，<br>
         * 压缩文件类型或原始数据支持其他格式。
         */
        export enum _cocos_core_assets_asset_enum__PixelFormat {
            /**
             * @en
             * 16-bit pixel format containing red, green and blue channels
             * @zh
             * 包含 RGB 通道的 16 位纹理。
             */
            RGB565 = 47,
            /**
             * @en
             * 16-bit pixel format containing red, green, blue channels with 5 bits per channel and one bit alpha channel: RGB5A1
             * @zh
             * 包含 RGB（分别占 5 bits）和 1 bit 的 alpha 通道的 16 位纹理：RGB5A1。
             */
            RGB5A1 = 49,
            /**
             * @en
             * 16-bit pixel format containing red, green, blue and alpha channels: RGBA4444
             * @zh
             * 包含 RGBA 通道的 16 位纹理：RGBA4444。
             */
            RGBA4444 = 50,
            /**
             * @en
             * 24-bit pixel format containing red, green and blue channels: RGB888
             * @zh
             * 包含 RGB 通道的 24 位纹理：RGB888。
             */
            RGB888 = 24,
            /**
             * @en
             * 32-bit float pixel format containing red, green and blue channels: RGBA32F
             * @zh
             * 包含 RGB 通道的 32 位浮点数像素格式：RGBA32F。
             */
            RGB32F = 32,
            /**
             * @en
             * 32-bit pixel format containing red, green, blue and alpha channels: RGBA8888
             * @zh
             * 包含 RGBA 四通道的 32 位整形像素格式：RGBA8888。
             */
            RGBA8888 = 35,
            /**
             * @en
             * 32-bit float pixel format containing red, green, blue and alpha channels: RGBA32F
             * @zh
             * 32位浮点数像素格式：RGBA32F。
             */
            RGBA32F = 44,
            /**
             * @en
             * 8-bit pixel format used as masks
             * @zh
             * 用作蒙版的8位纹理。
             */
            A8 = 1,
            /**
             * @en
             * 8-bit intensity pixel format
             * @zh
             * 8位强度纹理。
             */
            I8 = 2,
            /**
             * @en
             * 16-bit pixel format used as masks
             * @zh
             * 用作蒙版的16位纹理。
             */
            AI8 = 3,
            /**
             * @en A pixel format containing red, green, and blue channels that is PVR 2bpp compressed.
             * @zh 包含 RGB 通道的 PVR 2BPP 压缩纹理格式
             */
            RGB_PVRTC_2BPPV1 = 83,
            /**
             * @en A pixel format containing red, green, blue, and alpha channels that is PVR 2bpp compressed.
             * @zh 包含 RGBA 通道的 PVR 2BPP 压缩纹理格式
             */
            RGBA_PVRTC_2BPPV1 = 84,
            /**
             * @en A pixel format containing red, green, blue, and alpha channels that is PVR 2bpp compressed.
             * RGB_A_PVRTC_2BPPV1 texture is a 2x height RGB_PVRTC_2BPPV1 format texture.
             * It separate the origin alpha channel to the bottom half atlas, the origin rgb channel to the top half atlas.
             * @zh 包含 RGBA 通道的 PVR 2BPP 压缩纹理格式
             * 这种压缩纹理格式贴图的高度是普通 RGB_PVRTC_2BPPV1 贴图高度的两倍，使用上半部分作为原始 RGB 通道数据，下半部分用来存储透明通道数据。
             */
            RGB_A_PVRTC_2BPPV1,
            /**
             * @en A pixel format containing red, green, and blue channels that is PVR 4bpp compressed.
             * @zh 包含 RGB 通道的 PVR 4BPP 压缩纹理格式
             */
            RGB_PVRTC_4BPPV1 = 85,
            /**
             * @en A pixel format containing red, green, blue and alpha channels that is PVR 4bpp compressed.
             * @zh 包含 RGBA 通道的 PVR 4BPP 压缩纹理格式
             */
            RGBA_PVRTC_4BPPV1 = 86,
            /**
             * @en A pixel format containing red, green, blue, and alpha channels that is PVR 4bpp compressed.
             * RGB_A_PVRTC_4BPPV1 texture is a 2x height RGB_PVRTC_4BPPV1 format texture.
             * It separate the origin alpha channel to the bottom half atlas, the origin rgb channel to the top half atlas.
             * @zh 包含 RGBA 通道的 PVR 4BPP 压缩纹理格式
             * 这种压缩纹理格式贴图的高度是普通 RGB_PVRTC_4BPPV1 贴图高度的两倍，使用上半部分作为原始 RGB 通道数据，下半部分用来存储透明通道数据。
             */
            RGB_A_PVRTC_4BPPV1,
            /**
             * @en A pixel format containing red, green, and blue channels that is ETC1 compressed.
             * @zh 包含 RGB 通道的 ETC1 压缩纹理格式
             */
            RGB_ETC1 = 72,
            /**
             * @en A pixel format containing red, green, blue, and alpha channels that is ETC1 compressed.
             * @zh 包含 RGBA 通道的 ETC1 压缩纹理格式
             */
            RGBA_ETC1,
            /**
             * @en A pixel format containing red, green, and blue channels that is ETC2 compressed.
             * @zh 包含 RGB 通道的 ETC2 压缩纹理格式
             */
            RGB_ETC2 = 73,
            /**
             * @en A pixel format containing red, green, blue, and alpha channels that is ETC2 compressed.
             * @zh 包含 RGBA 通道的 ETC2 压缩纹理格式
             */
            RGBA_ETC2 = 77,
            /**
             * @en A pixel format containing red, green, blue, and alpha channels that is ASTC compressed with 4x4 block size.
             * @zh 包含 RGBA 通道的 ASTC 压缩纹理格式，压缩分块大小为 4x4
             */
            RGBA_ASTC_4x4 = 89,
            /**
             * @en A pixel format containing red, green, blue, and alpha channels that is ASTC compressed with 5x4 block size.
             * @zh 包含 RGBA 通道的 ASTC 压缩纹理格式，压缩分块大小为 5x4
             */
            RGBA_ASTC_5x4 = 90,
            /**
             * @en A pixel format containing red, green, blue, and alpha channels that is ASTC compressed with 5x5 block size.
             * @zh 包含 RGBA 通道的 ASTC 压缩纹理格式，压缩分块大小为 5x5
             */
            RGBA_ASTC_5x5 = 91,
            /**
             * @en A pixel format containing red, green, blue, and alpha channels that is ASTC compressed with 6x5 block size.
             * @zh 包含 RGBA 通道的 ASTC 压缩纹理格式，压缩分块大小为 6x5
             */
            RGBA_ASTC_6x5 = 92,
            /**
             * @en A pixel format containing red, green, blue, and alpha channels that is ASTC compressed with 6x6 block size.
             * @zh 包含 RGBA 通道的 ASTC 压缩纹理格式，压缩分块大小为 6x6
             */
            RGBA_ASTC_6x6 = 93,
            /**
             * @en A pixel format containing red, green, blue, and alpha channels that is ASTC compressed with 8x5 block size.
             * @zh 包含 RGBA 通道的 ASTC 压缩纹理格式，压缩分块大小为 8x5
             */
            RGBA_ASTC_8x5 = 94,
            /**
             * @en A pixel format containing red, green, blue, and alpha channels that is ASTC compressed with 8x6 block size.
             * @zh 包含 RGBA 通道的 ASTC 压缩纹理格式，压缩分块大小为 8x6
             */
            RGBA_ASTC_8x6 = 95,
            /**
             * @en A pixel format containing red, green, blue, and alpha channels that is ASTC compressed with 8x8 block size.
             * @zh 包含 RGBA 通道的 ASTC 压缩纹理格式，压缩分块大小为 8x8
             */
            RGBA_ASTC_8x8 = 96,
            /**
             * @en A pixel format containing red, green, blue, and alpha channels that is ASTC compressed with 10x5 block size.
             * @zh 包含 RGBA 通道的 ASTC 压缩纹理格式，压缩分块大小为 10x5
             */
            RGBA_ASTC_10x5 = 97,
            /**
             * @en A pixel format containing red, green, blue, and alpha channels that is ASTC compressed with 10x6 block size.
             * @zh 包含 RGBA 通道的 ASTC 压缩纹理格式，压缩分块大小为 10x6
             */
            RGBA_ASTC_10x6 = 98,
            /**
             * @en A pixel format containing red, green, blue, and alpha channels that is ASTC compressed with 10x8 block size.
             * @zh 包含 RGBA 通道的 ASTC 压缩纹理格式，压缩分块大小为 10x8
             */
            RGBA_ASTC_10x8 = 99,
            /**
             * @en A pixel format containing red, green, blue, and alpha channels that is ASTC compressed with 10x10 block size.
             * @zh 包含 RGBA 通道的 ASTC 压缩纹理格式，压缩分块大小为 10x10
             */
            RGBA_ASTC_10x10 = 100,
            /**
             * @en A pixel format containing red, green, blue, and alpha channels that is ASTC compressed with 12x10 block size.
             * @zh 包含 RGBA 通道的 ASTC 压缩纹理格式，压缩分块大小为 12x10
             */
            RGBA_ASTC_12x10 = 101,
            /**
             * @en A pixel format containing red, green, blue, and alpha channels that is ASTC compressed with 12x12 block size.
             * @zh 包含 RGBA 通道的 ASTC 压缩纹理格式，压缩分块大小为 12x12
             */
            RGBA_ASTC_12x12 = 102
        }
        /**
         * @en
         * The texture wrap mode.
         * @zh
         * 纹理环绕方式。
         */
        export enum _cocos_core_assets_asset_enum__WrapMode {
            /**
             * @en
             * Specifies that the repeat warp mode will be used.
             * @zh
             * 指定环绕模式：重复纹理图像。
             */
            REPEAT = 0,
            /**
             * @en
             * Specifies that the clamp to edge warp mode will be used.
             * @zh
             * 指定环绕模式：纹理边缘拉伸效果。
             */
            CLAMP_TO_EDGE = 2,
            /**
             * @en
             * Specifies that the mirrored repeat warp mode will be used.
             * @zh
             * 指定环绕模式：以镜像模式重复纹理图像。
             */
            MIRRORED_REPEAT = 1,
            /**
             * @en
             * Specifies that the  clamp to border wrap mode will be used.
             * @zh
             * 指定环绕模式：超出纹理坐标部分以用户指定颜色填充。
             */
            CLAMP_TO_BORDER = 3
        }
        /**
         * @en
         * The texture filter mode
         * @zh
         * 纹理过滤模式。
         */
        export enum _cocos_core_assets_asset_enum__Filter {
            NONE = 0,
            /**
             * @en
             * Specifies linear filtering.
             * @zh
             * 线性过滤模式。
             */
            LINEAR = 2,
            /**
             * @en
             * Specifies nearest filtering.
             * @zh
             * 临近过滤模式。
             */
            NEAREST = 1
        }
        /**
         * @en The base texture class, it defines features shared by all textures.
         * @zh 贴图资源基类。它定义了所有贴图共用的概念。
         */
        export class _cocos_core_assets_texture_base__TextureBase extends Asset {
            /**
             * @en Whether the pixel data is compressed.
             * @zh 此贴图是否为压缩的像素格式。
             */
            get isCompressed(): boolean;
            /**
             * @en Pixel width of the texture
             * @zh 此贴图的像素宽度。
             */
            get width(): number;
            /**
             * @en Pixel height of the texture
             * @zh 此贴图的像素高度。
             */
            get height(): number;
            /**
             * @en The pixel format enum.
             * @zh 像素格式枚举类型
             */
            static PixelFormat: typeof _cocos_core_assets_asset_enum__PixelFormat;
            /**
             * @en The wrap mode enum.
             * @zh 环绕模式枚举类型
             */
            static WrapMode: typeof _cocos_core_assets_asset_enum__WrapMode;
            /**
             * @en The texture filter mode enum
             * @zh 纹理过滤模式枚举类型
             */
            static Filter: typeof _cocos_core_assets_asset_enum__Filter;
            protected _format: _cocos_core_assets_asset_enum__PixelFormat;
            protected _minFilter: _cocos_core_assets_asset_enum__Filter;
            protected _magFilter: _cocos_core_assets_asset_enum__Filter;
            protected _mipFilter: _cocos_core_assets_asset_enum__Filter;
            protected _wrapS: _cocos_core_assets_asset_enum__WrapMode;
            protected _wrapT: _cocos_core_assets_asset_enum__WrapMode;
            protected _wrapR: _cocos_core_assets_asset_enum__WrapMode;
            protected _anisotropy: number;
            protected _width: number;
            protected _height: number;
            constructor();
            /**
             * @en Gets the id of the texture
             * @zh 获取标识符。
             * @returns The id
             */
            getId(): string;
            /**
             * @en Gets the pixel format
             * @zh 获取像素格式。
             * @returns The pixel format
             */
            getPixelFormat(): _cocos_core_assets_asset_enum__PixelFormat;
            /**
             * @en Gets the anisotropy
             * @zh 获取各向异性。
             * @returns The anisotropy
             */
            getAnisotropy(): number;
            /**
             * @en Sets the wrap mode of the texture.
             * Be noted, if the size of the texture is not power of two, only [[WrapMode.CLAMP_TO_EDGE]] is allowed.
             * @zh 设置此贴图的缠绕模式。
             * 注意，若贴图尺寸不是 2 的整数幂，缠绕模式仅允许 [[WrapMode.CLAMP_TO_EDGE]]。
             * @param wrapS S(U) coordinate wrap mode
             * @param wrapT T(V) coordinate wrap mode
             * @param wrapR R(W) coordinate wrap mode
             */
            setWrapMode(wrapS: _cocos_core_assets_asset_enum__WrapMode, wrapT: _cocos_core_assets_asset_enum__WrapMode, wrapR?: _cocos_core_assets_asset_enum__WrapMode): void;
            /**
             * @en Sets the texture's filter mode
             * @zh 设置此贴图的过滤算法。
             * @param minFilter Filter mode for scale down
             * @param magFilter Filter mode for scale up
             */
            setFilters(minFilter: _cocos_core_assets_asset_enum__Filter, magFilter: _cocos_core_assets_asset_enum__Filter): void;
            /**
             * @en Sets the texture's mip filter
             * @zh 设置此贴图的缩小过滤算法。
             * @param mipFilter Filter mode for scale down
             */
            setMipFilter(mipFilter: _cocos_core_assets_asset_enum__Filter): void;
            /**
             * @en Sets the texture's anisotropy
             * @zh 设置此贴图的各向异性。
             * @param anisotropy
             */
            setAnisotropy(anisotropy: number): void;
            /**
             * @en Destroy the current texture, clear up the related GPU resources.
             * @zh 销毁此贴图，并释放占用的 GPU 资源。
             */
            destroy(): boolean;
            /**
             * @en Gets the texture hash.
             * @zh 获取此贴图的哈希值。
             */
            getHash(): number;
            /**
             * @en Gets the GFX Texture resource
             * @zh 获取此贴图底层的 GFX 贴图对象。
             */
            getGFXTexture(): gfx.Texture | null;
            /**
             * @en Gets the internal GFX sampler hash.
             * @zh 获取此贴图内部使用的 GFX 采样器信息。
             * @private
             */
            getSamplerInfo(): Readonly<gfx.SamplerInfo>;
            /**
             * @en Gets the sampler resource for the texture
             * @zh 获取此贴图底层的 GFX 采样信息。
             */
            getGFXSampler(): gfx.Sampler;
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _serialize(ctxForExporting: any): any;
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _deserialize(serializedData: any, handle: any): void;
            protected _getGFXDevice(): gfx.Device | null;
            protected _getGFXFormat(): gfx.Format;
            protected _setGFXFormat(format?: _cocos_core_assets_asset_enum__PixelFormat): void;
            protected _getGFXPixelFormat(format: _cocos_core_assets_asset_enum__PixelFormat): gfx.Format;
        }
        export interface _cocos_2d_assets_bitmap_font__IConfig {
            [key: string]: any;
        }
        export class _cocos_2d_assets_bitmap_font__FontLetterDefinition {
            u: number;
            v: number;
            w: number;
            h: number;
            offsetX: number;
            offsetY: number;
            textureID: number;
            valid: boolean;
            xAdvance: number;
        }
        export interface _cocos_2d_assets_bitmap_font__ILetterDefinition {
            [key: string]: _cocos_2d_assets_bitmap_font__FontLetterDefinition;
        }
        export class _cocos_2d_assets_bitmap_font__FontAtlas {
            letterDefinitions: any;
            texture: any;
            constructor(texture: any);
            addLetterDefinitions(letter: any, letterDefinition: any): void;
            cloneLetterDefinition(): _cocos_2d_assets_bitmap_font__ILetterDefinition;
            getTexture(): any;
            getLetter(key: any): any;
            getLetterDefinitionForChar(char: any, labelInfo?: any): any;
            clear(): void;
        }
        /**
         * @en Image source in memory
         * @zh 内存图像源。
         */
        export interface _cocos_core_assets_image_asset__IMemoryImageSource {
            _data: ArrayBufferView | null;
            _compressed: boolean;
            width: number;
            height: number;
            format: number;
        }
        /**
         * @en The image source, can be HTML canvas, image type or image in memory data
         * @zh 图像资源的原始图像源。可以来源于 HTML 元素也可以来源于内存。
         */
        export type _cocos_core_assets_image_asset__ImageSource = HTMLCanvasElement | HTMLImageElement | _cocos_core_assets_image_asset__IMemoryImageSource | ImageBitmap;
        export enum _cocos_2d_assets_sprite_frame__MeshType {
            RECT = 0,
            POLYGON = 1
        }
        export interface _cocos_2d_assets_sprite_frame__IVertices {
            rawPosition: math.Vec3[];
            positions: number[];
            indexes: number[];
            uv: number[];
            nuv: number[];
            minPos: math.Vec3;
            maxPos: math.Vec3;
        }
        /**
         * @en Information object interface for initialize a [[SpriteFrame]] asset
         * @zh 用于初始化 [[SpriteFrame]] 资源的对象接口描述
         */
        export interface _cocos_2d_assets_sprite_frame__ISpriteFrameInitInfo {
            /**
             * @en The texture of the sprite frame, could be `TextureBase`
             * @zh 贴图对象资源，可以是 `TextureBase` 类型
             */
            texture?: _cocos_core_assets_texture_base__TextureBase;
            /**
             * @en The original size of the sprite frame
             * @zh 精灵帧原始尺寸。
             */
            originalSize?: math.Size;
            /**
             * @en The rect of the sprite frame in atlas texture
             * @zh 精灵帧裁切矩形。
             */
            rect?: math.Rect;
            /**
             * @en The offset of the sprite frame center from the original center of the original rect.
             * Sprite frame in an atlas texture could be trimmed for clipping the transparent pixels, so the trimmed rect is smaller than the original one,
             * the offset defines the distance from the original center to the trimmed center.
             * @zh 精灵帧偏移量。
             * 在图集中的精灵帧可能会被剔除透明像素以获得更高的空间利用李，剔除后的矩形尺寸比剪裁前更小，偏移量指的是从原始矩形的中心到剪裁后的矩形中心的距离。
             */
            offset?: math.Vec2;
            /**
             * @en Top side border for sliced 9 frame.
             * @zh 九宫格精灵帧的上边界。
             * @default 0
             */
            borderTop?: number;
            /**
             * @en Bottom side border for sliced 9 frame.
             * @zh 九宫格精灵帧的下边界。
             * @default 0
             */
            borderBottom?: number;
            /**
             * @en Left side border for sliced 9 frame.
             * @zh 九宫格精灵帧的左边界。
             * @default 0
             */
            borderLeft?: number;
            /**
             * @en Right side border for sliced 9 frame.
             * @zh 九宫格精灵帧的右边界。
             * @default 0
             */
            borderRight?: number;
            /**
             * @en Whether the content of sprite frame is rotated.
             * @zh 是否旋转。
             */
            isRotate?: boolean;
            /**
             * @en Whether the uv is flipped
             * @zh 是否转置 UV。
             */
            isFlipUv?: boolean;
        }
        /**
         * @internal
         */
        export class _cocos_2d_renderer_static_vb_accessor__StaticVBChunk {
            vertexAccessor: _cocos_2d_renderer_static_vb_accessor__StaticVBAccessor;
            bufferId: number;
            meshBuffer: MeshBuffer;
            vertexOffset: number;
            vb: Float32Array;
            indexCount: number;
            get ib(): Readonly<Uint16Array>;
            constructor(vertexAccessor: _cocos_2d_renderer_static_vb_accessor__StaticVBAccessor, bufferId: number, meshBuffer: MeshBuffer, vertexOffset: number, vb: Float32Array, indexCount: number);
            setIndexBuffer(indices: ArrayLike<number>): void;
        }
        export class _cocos_2d_renderer_buffer_accessor__BufferAccessor {
            get attributes(): Readonly<gfx.Attribute[]>;
            get vertexFormatBytes(): number;
            get floatsPerVertex(): number;
            protected _device: gfx.Device;
            protected _attributes: gfx.Attribute[];
            protected _vertexFormatBytes: number;
            protected _floatsPerVertex: number;
            protected _buffers: MeshBuffer[];
            constructor(device: gfx.Device, attributes: gfx.Attribute[]);
            initialize(): void;
            reset(): void;
            request(vertexCount?: number, indexCount?: number): void;
            appendBuffers(vertices: Float32Array, indices: Uint16Array): void;
            uploadBuffers(): void;
            destroy(): void;
        }
        export class _cocos_2d_renderer_static_vb_accessor__StaticVBAccessor extends _cocos_2d_renderer_buffer_accessor__BufferAccessor {
            static IB_SCALE: number;
            static ID_COUNT: number;
            get id(): number;
            constructor(device: gfx.Device, attributes: gfx.Attribute[], vCount?: number, iCount?: number);
            destroy(): void;
            reset(): void;
            getVertexBuffer(bid: number): Float32Array;
            getIndexBuffer(bid: number): Uint16Array;
            getMeshBuffer(bid: number): MeshBuffer;
            uploadBuffers(): void;
            appendIndices(bufferId: number, indices: Uint16Array): void;
            allocateChunk(vertexCount: number, indexCount: number): _cocos_2d_renderer_static_vb_accessor__StaticVBChunk | null;
            recycleChunk(chunk: _cocos_2d_renderer_static_vb_accessor__StaticVBChunk): void;
            static generateID(): number;
        }
        export class _cocos_2d_renderer_draw_batch__DrawBatch2D {
            get inputAssembler(): gfx.InputAssembler | null;
            set inputAssembler(ia: gfx.InputAssembler | null);
            get descriptorSet(): gfx.DescriptorSet | null;
            set descriptorSet(ds: gfx.DescriptorSet | null);
            get visFlags(): number;
            set visFlags(vis: number);
            get passes(): renderer.Pass[];
            get shaders(): gfx.Shader[];
            model: renderer.scene.Model | null;
            texture: gfx.Texture | null;
            sampler: gfx.Sampler | null;
            useLocalData: Node | null;
            isStatic: boolean;
            textureHash: number;
            samplerHash: number;
            destroy(ui: _cocos_2d_renderer_i_batcher__IBatcher): void;
            clear(): void;
            fillPasses(mat: Material | null, dss: any, dssHash: any, patches: any): void;
        }
        export interface _cocos_2d_renderer_i_batcher__IBatcher {
            currBufferAccessor: _cocos_2d_renderer_static_vb_accessor__StaticVBAccessor;
            readonly batches: memop.CachedArray<_cocos_2d_renderer_draw_batch__DrawBatch2D>;
            currStaticRoot: UIStaticBatch | null;
            currIsStatic: boolean;
            device: gfx.Device;
            initialize(): boolean;
            destroy(): any;
            addScreen(comp: RenderRoot2D): any;
            getFirstRenderCamera(node: Node): renderer.scene.Camera | null;
            removeScreen(comp: RenderRoot2D): any;
            sortScreens(): any;
            update(): any;
            uploadBuffers(): any;
            reset(): any;
            switchBufferAccessor(attributes?: gfx.Attribute[]): _cocos_2d_renderer_static_vb_accessor__StaticVBAccessor;
            commitComp(comp: UIRenderer, renderData: BaseRenderData | null, frame: _cocos_core_assets_texture_base__TextureBase | SpriteFrame | null, assembler: any, transform: Node | null): any;
            commitModel(comp: UIMeshRenderer | UIRenderer, model: renderer.scene.Model | null, mat: Material | null): any;
            setupStaticBatch(staticComp: UIStaticBatch, bufferAccessor: _cocos_2d_renderer_static_vb_accessor__StaticVBAccessor): any;
            endStaticBatch(): any;
            commitStaticBatch(comp: UIStaticBatch): any;
            autoMergeBatches(renderComp?: UIRenderer): any;
            forceMergeBatches(material: Material, frame: _cocos_core_assets_texture_base__TextureBase | SpriteFrame | null, renderComp: UIRenderer): any;
            finishMergeBatches(): any;
            flushMaterial(mat: Material): any;
            walk(node: Node, level?: number): any;
        }
        export enum _cocos_2d_renderer_render_entity__MaskMode {
            NONE = 0,
            MASK = 1,
            MASK_INVERTED = 2,
            MASK_NODE = 3,
            MASK_NODE_INVERTED = 4
        }
        export class _cocos_2d_renderer_native_2d__NativeRenderDrawInfo {
            constructor();
            get vbBuffer(): ArrayBufferLike;
            set vbBuffer(vbBuffer: ArrayBufferLike);
            get ibBuffer(): ArrayBufferLike;
            set ibBuffer(ibBuffer: ArrayBufferLike);
            get vDataBuffer(): ArrayBufferLike;
            set vDataBuffer(vDataBuffer: ArrayBufferLike);
            get iDataBuffer(): ArrayBufferLike;
            set iDataBuffer(iDataBuffer: ArrayBufferLike);
            get material(): Material | null;
            set material(material: Material | null);
            get texture(): gfx.Texture | null;
            set texture(texture: gfx.Texture | null);
            get sampler(): gfx.Sampler | null;
            set sampler(sampler: gfx.Sampler | null);
            get model(): renderer.scene.Model | null;
            set model(model: renderer.scene.Model | null);
            get subNode(): Node;
            set subNode(node: Node);
            changeMeshBuffer(): any;
            setRender2dBufferToNative(data: _types_globals__TypedArray): any;
            syncSharedBufferToNative(data: _types_globals__TypedArray): any;
            getAttrSharedBufferForJS(): ArrayBufferLike;
        }
        export class _cocos_2d_renderer_native_2d__NativeRenderEntity {
            constructor(type: number);
            addDynamicRenderDrawInfo(drawInfo: _cocos_2d_renderer_native_2d__NativeRenderDrawInfo): any;
            setDynamicRenderDrawInfo(drawInfo: _cocos_2d_renderer_native_2d__NativeRenderDrawInfo, index: number): any;
            removeDynamicRenderDrawInfo(): any;
            clearDynamicRenderDrawInfos(): any;
            clearStaticRenderDrawInfos(): any;
            get node(): Node | null;
            set node(node: Node | null);
            get renderTransform(): Node | null;
            set renderTransform(node: Node | null);
            get stencilStage(): number;
            set stencilStage(stage: number);
            get staticDrawInfoSize(): number;
            set staticDrawInfoSize(size: number);
            getStaticRenderDrawInfo(index: number): _cocos_2d_renderer_native_2d__NativeRenderDrawInfo;
            getEntitySharedBufferForJS(): ArrayBufferLike;
        }
        export enum _cocos_2d_renderer_render_draw_info__RenderDrawInfoType {
            COMP = 0,
            MODEL = 1,
            MIDDLEWARE = 2,
            SUB_NODE = 3
        }
        export class _cocos_2d_renderer_render_draw_info__RenderDrawInfo {
            protected _accId: number;
            protected _bufferId: number;
            protected _vertexOffset: number;
            protected _indexOffset: number;
            protected _vb: Float32Array | null;
            protected _ib: Uint16Array | null;
            protected _vData: Float32Array | null;
            protected _iData: Uint16Array | null;
            protected _vertDirty: boolean;
            protected _vbCount: number;
            protected _ibCount: number;
            protected _dataHash: number;
            protected _isMeshBuffer: boolean;
            protected _material: Material | null;
            protected _texture: gfx.Texture | null;
            protected _sampler: gfx.Sampler | null;
            protected _stride: number;
            protected _useLocal: boolean;
            protected _model: renderer.scene.Model | null;
            protected _drawInfoType: _cocos_2d_renderer_render_draw_info__RenderDrawInfoType;
            protected _subNode: Node | null;
            protected _nativeObj: _cocos_2d_renderer_native_2d__NativeRenderDrawInfo;
            protected _uint8SharedBuffer: Uint8Array;
            protected _uint16SharedBuffer: Uint16Array;
            protected _uint32SharedBuffer: Uint32Array;
            protected _render2dBuffer: Float32Array;
            constructor(nativeDrawInfo?: _cocos_2d_renderer_native_2d__NativeRenderDrawInfo);
            get nativeObj(): _cocos_2d_renderer_native_2d__NativeRenderDrawInfo;
            get render2dBuffer(): Float32Array;
            clear(): void;
            setAccId(accId: any): void;
            setBufferId(bufferId: any): void;
            setAccAndBuffer(accId: any, bufferId: any): void;
            setVertexOffset(vertexOffset: any): void;
            setIndexOffset(indexOffset: any): void;
            setVB(vbBuffer: Float32Array): void;
            setIB(ibBuffer: Uint16Array): void;
            setVData(vDataBuffer: ArrayBufferLike): void;
            setIData(iDataBuffer: ArrayBufferLike): void;
            setVBCount(vbCount: any): void;
            setIBCount(ibCount: any): void;
            setVertDirty(val: boolean): void;
            setDataHash(dataHash: number): void;
            setIsMeshBuffer(isMeshBuffer: boolean): void;
            setMaterial(material: Material): void;
            setTexture(texture: gfx.Texture | null): void;
            setSampler(sampler: gfx.Sampler | null): void;
            setModel(model: renderer.scene.Model): void;
            setDrawInfoType(drawInfoType: _cocos_2d_renderer_render_draw_info__RenderDrawInfoType): void;
            setSubNode(node: Node): void;
            setStride(stride: number): void;
            initRender2dBuffer(): void;
            fillRender2dBuffer(vertexDataArr: IRenderData[]): void;
        }
        export enum _cocos_2d_renderer_render_entity__RenderEntityType {
            STATIC = 0,
            DYNAMIC = 1,
            CROSSED = 2
        }
        export class _cocos_2d_renderer_render_entity__RenderEntity {
            protected _node: Node | null;
            protected _renderTransform: Node | null;
            protected _stencilStage: _cocos_2d_renderer_stencil_manager__Stage;
            protected _useLocal: boolean;
            protected _maskMode: _cocos_2d_renderer_render_entity__MaskMode;
            protected _floatSharedBuffer: Float32Array;
            protected _uint8SharedBuffer: Uint8Array;
            protected _boolSharedBuffer: Uint8Array;
            get nativeObj(): _cocos_2d_renderer_native_2d__NativeRenderEntity;
            get renderDrawInfoArr(): _cocos_2d_renderer_render_draw_info__RenderDrawInfo[];
            get renderEntityType(): _cocos_2d_renderer_render_entity__RenderEntityType;
            protected _color: math.Color;
            get color(): math.Color;
            set color(val: math.Color);
            protected _localOpacity: number;
            get localOpacity(): number;
            set localOpacity(val: number);
            protected _colorDirty: boolean;
            get colorDirty(): boolean;
            set colorDirty(val: boolean);
            protected _enabled: boolean;
            get enabled(): boolean;
            set enabled(val: boolean);
            constructor(entityType: _cocos_2d_renderer_render_entity__RenderEntityType);
            addDynamicRenderDrawInfo(renderDrawInfo: _cocos_2d_renderer_render_draw_info__RenderDrawInfo | null): void;
            removeDynamicRenderDrawInfo(): void;
            clearDynamicRenderDrawInfos(): void;
            clearStaticRenderDrawInfos(): void;
            setDynamicRenderDrawInfo(renderDrawInfo: _cocos_2d_renderer_render_draw_info__RenderDrawInfo | null, index: number): void;
            setMaskMode(mode: _cocos_2d_renderer_render_entity__MaskMode): void;
            getStaticRenderDrawInfo(): _cocos_2d_renderer_render_draw_info__RenderDrawInfo | null;
            setNode(node: Node | null): void;
            setRenderTransform(renderTransform: Node | null): void;
            setStencilStage(stage: _cocos_2d_renderer_stencil_manager__Stage): void;
            setUseLocal(useLocal: boolean): void;
        }
        export enum _cocos_2d_framework_sprite_renderer__SpriteMode {
            SIMPLE = 0,
            SLICED = 1,
            TILED = 2
        }
        /**
         * @en The type for mask.
         *
         * @zh 遮罩组件类型。
         */
        export enum _cocos_2d_components_mask__MaskType {
            /**
             * @en Rect mask.
             *
             * @zh
             * 使用矩形作为遮罩。
             */
            GRAPHICS_RECT = 0,
            /**
             * @en Ellipse Mask.
             *
             * @zh
             * 使用椭圆作为遮罩。
             */
            GRAPHICS_ELLIPSE = 1,
            /**
             * @en Graphics Mask.
             *
             * @zh
             * 使用图像模版作为遮罩。
             */
            GRAPHICS_STENCIL = 2,
            /**
             * @en SpriteFrame Mask.
             *
             * @zh
             * 使用图片模版作为遮罩。
             */
            SPRITE_STENCIL = 3
        }
        export interface _cocos_2d_components_rich_text__ISegment {
            node: Node;
            comp: Label | Sprite | null;
            lineCount: number;
            styleIndex: number;
            imageOffset: string;
            clickParam: string;
            clickHandler: string;
            type: string;
        }
        /**
         * @en
         * Enum for sprite type.
         *
         * @zh
         * Sprite 类型。
         */
        export enum _cocos_2d_components_sprite__SpriteType {
            /**
             * @en
             * The simple type.
             *
             * @zh
             * 普通类型。
             */
            SIMPLE = 0,
            /**
             * @en
             * The sliced type.
             *
             * @zh
             * 切片（九宫格）类型。
             */
            SLICED = 1,
            /**
             * @en
             * The tiled type.
             *
             * @zh  平铺类型
             */
            TILED = 2,
            /**
             * @en
             * The filled type.
             *
             * @zh
             * 填充类型。
             */
            FILLED = 3
        }
        /**
         * @en
         * Enum for fill type.
         *
         * @zh
         * 填充类型。
         */
        export enum _cocos_2d_components_sprite__FillType {
            /**
             * @en
             * The horizontal fill.
             *
             * @zh
             * 水平方向填充。
             */
            HORIZONTAL = 0,
            /**
             * @en
             * The vertical fill.
             *
             * @zh
             * 垂直方向填充。
             */
            VERTICAL = 1,
            /**
             * @en
             * The radial fill.
             *
             * @zh  径向填充
             */
            RADIAL = 2
        }
        /**
         * @en
         * Sprite Size can track trimmed size, raw size or none.
         *
         * @zh
         * 精灵尺寸调整模式。
         */
        export enum _cocos_2d_components_sprite__SizeMode {
            /**
             * @en
             * Use the customized node size.
             *
             * @zh
             * 使用节点预设的尺寸。
             */
            CUSTOM = 0,
            /**
             * @en
             * Match the trimmed size of the sprite frame automatically.
             *
             * @zh
             * 自动适配为精灵裁剪后的尺寸。
             */
            TRIMMED = 1,
            /**
             * @en
             * Match the raw size of the sprite frame automatically.
             *
             * @zh
             * 自动适配为精灵原图尺寸。
             */
            RAW = 2
        }
        export enum _cocos_2d_components_sprite__EventType {
            SPRITE_FRAME_CHANGED = "spriteframe-changed"
        }
        /**
         * @en Enum for LineJoin.
         * @zh 线段拐角属性
         * @enum Graphics.LineJoin
         */
        export enum _cocos_2d_assembler_graphics_types__LineJoin {
            /**
             * @en Fills an additional triangular area between the common endpoint of connected segments, and the separate outside rectangular corners of each segment.
             * @zh 在相连部分的末端填充一个额外的以三角形为底的区域， 每个部分都有各自独立的矩形拐角。
             */
            BEVEL = 0,
            /**
             * @en Rounds off the corners of a shape by filling an additional sector of disc centered at the common endpoint of connected segments.
             * The radius for these rounded corners is equal to the line width.
             * @zh 通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状。 圆角的半径是线段的宽度。
             */
            ROUND = 1,
            /**
             * @en Connected segments are joined by extending their outside edges to connect at a single point,
             * with the effect of filling an additional lozenge-shaped area.
             * @zh 通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域。
             */
            MITER = 2
        }
        /**
         * @en Enum for LineCap.
         * @zh 线段末端属性
         * @enum Graphics.LineCap
         */
        export enum _cocos_2d_assembler_graphics_types__LineCap {
            /**
             * @en The ends of lines are squared off at the endpoints.
             * @zh 线段末端以方形结束。
             */
            BUTT = 0,
            /**
             * @en The ends of lines are rounded.
             * @zh 线段末端以圆形结束。
             */
            ROUND = 1,
            /**
             * @en The ends of lines are squared off by adding a box with an equal width and half the height of the line's thickness.
             * @zh 线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域。
             */
            SQUARE = 2
        }
        export class _cocos_2d_assembler_graphics_webgl_impl__Point extends math.Vec2 {
            dx: number;
            dy: number;
            dmx: number;
            dmy: number;
            flags: number;
            len: number;
            constructor(x: number, y: number);
            reset(): void;
        }
        export class _cocos_2d_assembler_graphics_webgl_impl__Path {
            closed: boolean;
            bevel: number;
            complex: boolean;
            points: _cocos_2d_assembler_graphics_webgl_impl__Point[];
            constructor();
            reset(): void;
        }
        export enum _cocos_2d_assembler_graphics_types__PointFlags {
            PT_CORNER = 1,
            PT_LEFT = 2,
            PT_BEVEL = 4,
            PT_INNERBEVEL = 8
        }
        export class _cocos_2d_assembler_graphics_webgl_impl__Impl {
            dataOffset: number;
            updatePathOffset: boolean;
            pathLength: number;
            pathOffset: number;
            paths: _cocos_2d_assembler_graphics_webgl_impl__Path[];
            tessTol: number;
            distTol: number;
            fillColor: math.Color;
            lineCap: _cocos_2d_assembler_graphics_types__LineCap;
            strokeColor: math.Color;
            lineJoin: _cocos_2d_assembler_graphics_types__LineJoin;
            lineWidth: number;
            pointsOffset: number;
            constructor(comp: Graphics);
            moveTo(x: number, y: number): void;
            lineTo(x: number, y: number): void;
            bezierCurveTo(c1x: number, c1y: number, c2x: number, c2y: number, x: number, y: number): void;
            quadraticCurveTo(cx: number, cy: number, x: number, y: number): void;
            arc(cx: number, cy: number, r: number, startAngle: number, endAngle: number, counterclockwise: boolean): void;
            ellipse(cx: number, cy: number, rx: number, ry: number): void;
            circle(cx: number, cy: number, r: number): void;
            rect(x: number, y: number, w: number, h: number): void;
            roundRect(x: number, y: number, w: number, h: number, r: number): void;
            clear(): void;
            close(): void;
            requestRenderData(): MeshRenderData;
            getRenderDataList(): MeshRenderData[];
            addPoint(x: number, y: number, flags: _cocos_2d_assembler_graphics_types__PointFlags): void;
        }
        export class _cocos_2d_renderer_native_2d__NativeUIModelProxy {
            initModel(node: any): any;
            activeSubModels(): any;
            uploadData(): any;
            destroy(): any;
            clear(): any;
            getModel(): renderer.scene.Model;
            updateModels(model: any): any;
            attachDrawInfo(): any;
            attachNode(node: any): any;
        }
        export class _cocos_2d_assembler_label_font_utils__LetterRenderTexture extends Texture2D {
            /**
             * @en
             * Init the render texture with size.
             * @zh
             * 初始化 render texture。
             * @param [width]
             * @param [height]
             * @param [string]
             */
            initWithSize(width: number, height: number, format?: number): void;
            /**
             * @en Draw a texture to the specified position
             * @zh 将指定的图片渲染到指定的位置上。
             * @param {Texture2D} image
             * @param {Number} x
             * @param {Number} y
             */
            drawTextureAt(image: ImageAsset, x: number, y: number): void;
        }
        export class _cocos_2d_renderer_native_2d__NativeBatcher2d {
            syncMeshBuffersToNative(accId: number, buffers: _cocos_2d_renderer_native_2d__NativeUIMeshBuffer[]): any;
            update(): any;
            uploadBuffers(): any;
            reset(): any;
            syncRootNodesToNative(nodes: Node[]): any;
            releaseDescriptorSetCache(texture: gfx.Texture, sampler: gfx.Sampler): any;
        }
        export class _cocos_2d_utils_dynamic_atlas_atlas__DynamicAtlasTexture extends Texture2D {
            /**
             * @en
             * Initialize the render texture.
             *
             * @zh
             * 初始化 render texture。
             *
             * @method initWithSize
             */
            initWithSize(width: number, height: number, format?: number): void;
            /**
             * @en
             * Draw a texture to the specified position.
             *
             * @zh
             * 将指定的图片渲染到指定的位置上。
             *
             * @method drawTextureAt
             * @param {Texture2D} image
             * @param {Number} x
             * @param {Number} y
             */
            drawTextureAt(image: ImageAsset, x: number, y: number): void;
        }
        export class _cocos_2d_utils_dynamic_atlas_atlas_manager__DynamicAtlasManager extends System {
            static instance: _cocos_2d_utils_dynamic_atlas_atlas_manager__DynamicAtlasManager;
            /**
             * @en
             * Enable or disable the dynamic atlas.
             *
             * @zh
             * 开启或关闭动态图集。
             */
            get enabled(): boolean;
            set enabled(value: boolean);
            /**
             * @en
             * The maximum number of atlases that can be created.
             *
             * @zh
             * 可以创建的最大图集数量。
             */
            get maxAtlasCount(): number;
            set maxAtlasCount(value: number);
            /**
             * @en
             * Get the current created atlas count.
             *
             * @zh
             * 获取当前已经创建的图集数量。
             */
            get atlasCount(): number;
            /**
             * @en
             * Whether to enable textureBleeding.
             *
             * @zh
             * 是否开启 textureBleeding。
             */
            get textureBleeding(): boolean;
            set textureBleeding(enable: boolean);
            /**
             * @en
             * The size of the created atlas.
             *
             * @zh
             * 创建的图集的宽高。
             */
            get textureSize(): number;
            set textureSize(value: number);
            /**
             * @en
             * The maximum size of the picture that can be added to the atlas.
             *
             * @zh
             * 可以添加进图集的图片的最大尺寸。
             */
            get maxFrameSize(): number;
            set maxFrameSize(value: number);
            /**
             * @internal
             */
            init(): void;
            /**
             * @en
             * Append a sprite frame into the dynamic atlas.
             *
             * @zh
             * 添加碎图进入动态图集。
             *
             * @method insertSpriteFrame
             * @param spriteFrame  the sprite frame that will be inserted in the atlas.
             */
            insertSpriteFrame(spriteFrame: any): {
                x: number;
                y: number;
                texture: _cocos_2d_utils_dynamic_atlas_atlas__DynamicAtlasTexture;
            } | null;
            /**
             * @en
             * Reset all dynamic atlases, and all existing ones will be destroyed.
             *
             * @zh
             * 重置所有动态图集，已有的动态图集会被销毁。
             *
             * @method reset
             */
            reset(): void;
            /**
             * @en
             * Delete a sprite from the atlas.
             *
             * @zh
             * 从动态图集中删除某张碎图。
             *
             * @method deleteAtlasSpriteFrame
             * @param spriteFrame  the sprite frame that will be removed from the atlas.
             */
            deleteAtlasSpriteFrame(spriteFrame: any): void;
            /**
             * @en
             * Delete a texture from the atlas.
             *
             * @zh
             * 从动态图集中删除某张纹理。
             *
             * @method deleteAtlasTexture
             * @param texture  the texture that will be removed from the atlas.
             */
            deleteAtlasTexture(texture: any): void;
            /**
             * @en
             * Pack the sprite in the dynamic atlas and update the atlas information of the sprite frame.
             *
             * @zh
             * 将图片打入动态图集，并更新该图片的图集信息。
             *
             * @method packToDynamicAtlas
             * @param frame  the sprite frame that will be packed in the dynamic atlas.
             */
            packToDynamicAtlas(comp: any, frame: any): void;
        }
        /**
         * @en The instance of [[MorphRendering]] for dedicated control in the mesh renderer.
         * The root [[MorphRendering]] is owned by [[Mesh]] asset, each [[MeshRenderer]] can have its own morph rendering instance.
         * @zh 用于网格渲染器中独立控制 [[MorphRendering]] 的实例。原始 [[MorphRendering]] 被 [[Mesh]] 资源持有，每个 [[MeshRenderer]] 都持有自己的形变网格渲染实例。
         */
        export interface _cocos_3d_assets_morph_rendering__MorphRenderingInstance {
            /**
             * Sets weights of targets of specified sub mesh.
             * @param subMeshIndex
             * @param weights
             */
            setWeights(subMeshIndex: number, weights: number[]): void;
            /**
             * Adapts pipeline state to do the rendering.
             * @param subMeshIndex
             * @param pipelineState
             */
            adaptPipelineState(subMeshIndex: number, descriptorSet: gfx.DescriptorSet): void;
            /**
             * Acquire the define overrides needed to do the rendering.
             */
            requiredPatches(subMeshIndex: number): renderer.IMacroPatch[] | null;
            /**
             * Destroy the rendering instance.
             */
            destroy(): void;
        }
        /**
         * @en Interface for classes which control the rendering of morph resources.
         * @zh 支持形变网格渲染的基类。
         */
        export interface _cocos_3d_assets_morph_rendering__MorphRendering {
            createInstance(): _cocos_3d_assets_morph_rendering__MorphRenderingInstance;
        }
        /**
         * @en Model's light map settings.
         * @zh 模型光照图设置
         */
        export class _cocos_3d_framework_mesh_renderer__ModelLightmapSettings {
            texture: Texture2D | null;
            uvParam: math.Vec4;
            protected _bakeable: boolean;
            protected _castShadow: boolean;
            protected _receiveShadow: boolean;
            protected _lightmapSize: number;
            /**
             * @en Whether the model is static and bake-able with light map.
             * Notice: the model's vertex data must have the second UV attribute to enable light map baking.
             * @zh 模型是否是静态的并可以烘培光照贴图。
             * 注意：模型顶点数据必须包含第二套 UV 属性来支持光照贴图烘焙。
             */
            get bakeable(): boolean;
            set bakeable(val: boolean);
            /**
             * @en Whether to cast shadow in light map baking.
             * @zh 在光照贴图烘焙中是否投射阴影。
             */
            get castShadow(): boolean;
            set castShadow(val: boolean);
            /**
             * @en Whether to receive shadow in light map baking.
             * @zh 在光照贴图烘焙中是否接受阴影。
             */
            get receiveShadow(): boolean;
            set receiveShadow(val: boolean);
            /**
             * @en The lightmap size.
             * @zh 光照图大小。
             */
            get lightmapSize(): number;
            set lightmapSize(val: number);
        }
        /**
         * @en Shadow projection mode.
         * @zh 阴影投射方式。
         */
        export const _cocos_3d_framework_mesh_renderer__ModelShadowCastingMode: {
            /**
             * @en Disable shadow projection.
             * @zh 不投射阴影。
             */
            OFF: number;
            /**
             * @en Enable shadow projection.
             * @zh 开启阴影投射。
             */
            ON: number;
        };
        export type _types_globals__EnumAlias<EnumT> = EnumT[keyof EnumT];
        /**
         * @en Shadow receive mode.
         * @zh 阴影接收方式。
         */
        export const _cocos_3d_framework_mesh_renderer__ModelShadowReceivingMode: {
            /**
             * @en Disable shadow receiving.
             * @zh 不接收阴影。
             */
            OFF: number;
            /**
             * @en Enable shadow receiving.
             * @zh 开启阴影投射。
             */
            ON: number;
        };
        /**
         * @en Static light settings.
         * @zh 静态灯光设置
         */
        export class _cocos_3d_lights_light_component__StaticLightSettings {
            protected _baked: boolean;
            protected _editorOnly: boolean;
            protected _bakeable: boolean;
            protected _castShadow: boolean;
            /**
             * @en Whether the light is editor only.
             * @zh 是否只在编辑器里生效。
             */
            get editorOnly(): boolean;
            set editorOnly(val: boolean);
            /**
             * @en Whether the light is baked
             * @zh 光源是否被烘焙
             */
            get baked(): boolean;
            set baked(val: boolean);
            /**
             * @en Whether the light is bake-able.
             * @zh 光源是否可烘培。
             */
            get bakeable(): boolean;
            set bakeable(val: boolean);
            /**
             * @en Whether the light will cast shadow during baking process.
             * @zh 光源在烘焙时是否投射阴影。
             */
            get castShadow(): boolean;
            set castShadow(val: boolean);
        }
        /**
         * @en The physical term used for light.
         * @zh 光源所使用的物理计量单位。
         */
        export const _cocos_3d_lights_light_component__PhotometricTerm: {
            LUMINOUS_FLUX: number;
            LUMINANCE: number;
        };
        /**
         * @en
         * The model that support morph target rendering.
         * @zh
         * 支持渲染蒙皮形变的模型。
         */
        export class _cocos_3d_models_morph_model__MorphModel extends renderer.scene.Model {
            /**
             * @en Acquire the material's macro patches for the given sub model.
             * @zh 获取指定子模型的材质宏组合。
             * @param subModelIndex @en The index for the requested sub model. @zh 子模型的序号。
             * @returns @en The macro patches. @zh 材质宏组合
             */
            getMacroPatches(subModelIndex: number): renderer.IMacroPatch[] | null;
            /**
             * @en Initialize a sub model with the sub mesh data and the material.
             * @zh 用子网格数据和材质初始化一个子模型。
             * @param idx @en The index of the sub model @zh 子模型的序号
             * @param subMeshData @en The sub mesh data to be set @zh 需要设置的子网格
             * @param mat sub material
             */
            initSubModel(subModelIndex: number, subMeshData: RenderingSubMesh, material: Material): void;
            destroy(): void;
            /**
             * @en Sets the material for a given sub model.
             * @zh 给指定的子模型设置材质。
             * @param subModelIndex @en The index of the sub model @zh 子模型的序号
             * @param material @en The material to be set @zh 需要设置的材质
             * @returns void
             */
            setSubModelMaterial(subModelIndex: number, material: Material): void;
            /**
             * Sets morph rendering instance for the model, it's managed by the MeshRenderer
             * @internal
             */
            setMorphRendering(morphRendering: _cocos_3d_assets_morph_rendering__MorphRenderingInstance): void;
            protected _updateLocalDescriptors(submodelIdx: number, descriptorSet: gfx.DescriptorSet): void;
        }
        /**
         * @en
         * The skinning model that is using real-time pose calculation.
         * @zh
         * 实时计算动画的蒙皮模型。
         */
        export class _cocos_3d_models_skinning_model__SkinningModel extends _cocos_3d_models_morph_model__MorphModel {
            constructor();
            destroy(): void;
            /**
             * @en Abstract function for [[BakedSkinningModel]], empty implementation.
             * @zh 由 [[BakedSkinningModel]] 继承的空函数。
             */
            uploadAnimation(): void;
            /**
             * @en Bind the skeleton with its skinning root node and the mesh data.
             * @zh 在模型中绑定一个骨骼，需要提供骨骼的蒙皮根节点和蒙皮网格数据。
             * @param skeleton @en The skeleton to be bound @zh 要绑定的骨骼
             * @param skinningRoot @en The skinning root of the skeleton @zh 骨骼的蒙皮根节点
             * @param mesh @en The mesh @zh 蒙皮网格
             * @returns void
             */
            bindSkeleton(skeleton?: Skeleton | null, skinningRoot?: Node | null, mesh?: Mesh | null): void;
            /**
             * @en Update world transform and bounding boxes for the model
             * @zh 更新模型的世界矩阵和包围盒
             * @param stamp @en The update time stamp @zh 更新的时间戳
             */
            updateTransform(stamp: number): void;
            /**
             * @en Update uniform buffer objects for rendering.
             * @zh 更新用于渲染的 UBO
             * @param stamp @en The update time stamp @zh 更新的时间戳
             * @returns @en successful or not @zh 更新是否成功
             */
            updateUBOs(stamp: number): boolean;
            /**
             * @en Initialize sub model with the sub mesh data and the material
             * @zh 用子网格数据和材质初始化一个子模型
             * @param idx @en The index of the sub model to be initialized @zh 需要初始化的子模型序号
             * @param subMeshData @en The sub mesh data @zh 子网格数据
             * @param mat @en The material @zh 子模型材质
             */
            initSubModel(idx: number, subMeshData: RenderingSubMesh, mat: Material): void;
            getMacroPatches(subModelIndex: number): renderer.IMacroPatch[] | null;
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _updateLocalDescriptors(submodelIdx: number, descriptorSet: gfx.DescriptorSet): void;
            protected _updateInstancedAttributes(attributes: gfx.Attribute[], subModel: renderer.scene.SubModel): void;
        }
        export interface _cocos_3d_skeletal_animation_skeletal_animation_utils__IInternalJointAnimInfo {
            downstream?: math.Mat4;
            curveData?: math.Mat4[];
            bindposeIdx: number;
            bindposeCorrection?: math.Mat4;
        }
        export interface _cocos_3d_skeletal_animation_skeletal_animation_utils__IJointTextureHandle {
            pixelOffset: number;
            refCount: number;
            clipHash: number;
            skeletonHash: number;
            readyToBeDeleted: boolean;
            handle: renderer.ITextureBufferHandle;
            bounds: Map<number, geometry.AABB[]>;
            animInfos?: _cocos_3d_skeletal_animation_skeletal_animation_utils__IInternalJointAnimInfo[];
        }
        /**
         * @en
         * The skinning model that is using GPU baked animation.
         * @zh
         * GPU 预烘焙动画的蒙皮模型。
         */
        export class _cocos_3d_models_baked_skinning_model__BakedSkinningModel extends _cocos_3d_models_morph_model__MorphModel {
            /**
             * @en The animation clip that have been uploaded
             * @zh 已被上传的动画片段
             */
            uploadedAnim: AnimationClip | null | undefined;
            constructor();
            destroy(): void;
            bindSkeleton(skeleton?: Skeleton | null, skinningRoot?: Node | null, mesh?: Mesh | null): void;
            updateTransform(stamp: number): void;
            updateUBOs(stamp: number): boolean;
            getMacroPatches(subModelIndex: number): renderer.IMacroPatch[] | null;
            /**
             * @en Pre-simulate and store the frames data of the given animation clip to a joint texture and upload it to GPU.
             * Normally, it's automatically managed by [[SkeletalAnimationState]].
             * But user can also use Joint Texture Layout Settings in the editor to manually organize the joint textures.
             * @zh 预计算并存储一个指定动画片段的完整帧数据到一张骨骼贴图上，并将其上传到 GPU。
             * 一般情况下 [[SkeletalAnimationState]] 会自动管理所有骨骼贴图，但用户也可以使用编辑器的骨骼贴图布局设置面板来手动管理所有骨骼贴图。
             * @param anim @en The animation clip to be uploaded to the joint texture. @zh 需要上传到骨骼贴图上的动画片段。
             * @returns void
             */
            uploadAnimation(anim: AnimationClip | null): void;
            protected _applyJointTexture(texture?: _cocos_3d_skeletal_animation_skeletal_animation_utils__IJointTextureHandle | null): void;
            protected _updateLocalDescriptors(submodelIdx: number, descriptorSet: gfx.DescriptorSet): void;
            protected _updateInstancedAttributes(attributes: gfx.Attribute[], subModel: renderer.scene.SubModel): void;
        }
        /**
         * 动画使用的循环模式。
         */
        export enum _cocos_core_animation_types__WrapMode {
            /**
             * 向 Animation Component 或者 AnimationClip 查找 wrapMode
             */
            Default = 0,
            /**
             * 动画只播放一遍
             */
            Normal = 1,
            /**
             * 从最后一帧或结束位置开始反向播放，到第一帧或开始位置停止
             */
            Reverse = 36,
            /**
             * 循环播放
             */
            Loop = 2,
            /**
             * 反向循环播放
             */
            LoopReverse = 38,
            /**
             * 从第一帧播放到最后一帧，然后反向播放回第一帧，到第一帧后再正向播放，如此循环
             */
            PingPong = 22,
            /**
             * 从最后一帧开始反向播放，其他同 PingPong
             */
            PingPongReverse = 54
        }
        export interface _cocos_core_animation_tracks_utils__Range {
            min: number;
            max: number;
        }
        export interface _cocos_core_animation_animation_clip__IAnimationEvent {
            functionName: string;
            parameters: string[];
        }
        export interface _cocos_core_animation_animation_clip__IAnimationEventGroup {
            events: _cocos_core_animation_animation_clip__IAnimationEvent[];
        }
        export class _cocos_core_animation_animation_clip__EventEvaluator {
            constructor(_targetNode: Node, _ratios: readonly number[], _eventGroups: readonly _cocos_core_animation_animation_clip__IAnimationEventGroup[], _wrapMode: _cocos_core_animation_types__WrapMode);
            setWrapMode(wrapMode: _cocos_core_animation_types__WrapMode): void;
            ignore(ratio: number, direction: number): void;
            sample(ratio: number, direction: number, iterations: number): void;
        }
        export class _cocos_core_animation_animation_clip__EmbeddedPlayerEvaluation {
            constructor(embeddedPlayers: ReadonlyArray<EmbeddedPlayer>, rootNode: Node);
            destroy(): void;
            /**
             * Evaluates the embedded players.
             * @param time The time([0, clipDuration]).
             * @param iterations The iterations the evaluation occurred. Should be integral.
             */
            evaluate(time: number, iterations: number): void;
            notifyHostSpeedChanged(speed: number): void;
            /**
             * Notifies that the host has ran into **playing** state.
             * @param time The time where host ran into playing state.
             */
            notifyHostPlay(time: number): void;
            /**
             * Notifies that the host has ran into **pause** state.
             */
            notifyHostPause(time: number): void;
            /**
             * Notifies that the host has ran into **stopped** state.
             */
            notifyHostStop(): void;
        }
        export interface _cocos_core_animation_animation_clip__RootMotionOptions {
        }
        export interface _cocos_core_animation_animation_clip__AnimationClipEvalContext {
            /**
             * The output pose.
             */
            pose?: _cocos_core_animation_pose_output__PoseOutput;
            /**
             * The root animating target(should be scene node now).
             */
            target: unknown;
            /**
             * The animation mask applied.
             */
            mask?: AnimationMask;
            /**
             * Path to the root bone.
             */
            rootMotion?: _cocos_core_animation_animation_clip__RootMotionOptions;
        }
        export interface _cocos_core_animation_tracks_track__TrackEval {
            /**
             * Evaluates the track.
             * @param time The time.
             */
            evaluate(time: number, runtimeBinding: _cocos_core_animation_tracks_track__RuntimeBinding): unknown;
        }
        export interface _cocos_core_animation_animation_clip__TrackEvalStatus {
            binding: _cocos_core_animation_tracks_track__RuntimeBinding;
            trackEval: _cocos_core_animation_tracks_track__TrackEval;
        }
        export type _cocos_core_animation_animation_clip__ExoticAnimationEvaluator = ReturnType<ExoticAnimation["createEvaluator"]>;
        export class _cocos_core_animation_animation_clip__BoneTransform {
            position: math.Vec3;
            scale: math.Vec3;
            rotation: math.Quat;
            eulerAngles: math.Vec3;
            getTransform(out: math.Mat4): void;
        }
        export class _cocos_core_animation_animation_clip__RootMotionEvaluation {
            constructor(_rootBone: Node, _duration: number, _boneTransform: _cocos_core_animation_animation_clip__BoneTransform, _trackEvalStatuses: _cocos_core_animation_animation_clip__TrackEvalStatus[]);
            evaluate(time: number, motionLength: number): void;
        }
        export class _cocos_core_animation_animation_clip__AnimationClipEvaluation {
            constructor(trackEvalStatuses: _cocos_core_animation_animation_clip__TrackEvalStatus[], exoticAnimationEvaluator: _cocos_core_animation_animation_clip__ExoticAnimationEvaluator | undefined, rootMotionEvaluation: _cocos_core_animation_animation_clip__RootMotionEvaluation | undefined);
            /**
             * Evaluates this animation.
             * @param time The time.
             */
            evaluate(time: number): void;
            /**
             * Gets the root bone motion.
             * @param startTime Start time.
             * @param endTime End time.
             */
            evaluateRootMotion(time: number, motionLength: number): void;
        }
        export const _cocos_core_animation_internal_symbols__BAKE_SKELETON_CURVE_SYMBOL: unique symbol;
        export interface _cocos_core_animation_animation_clip__SkeletonAnimationBakeInfo {
            samples: number;
            frames: number;
            joints: Record<string, {
                transforms?: math.Mat4[];
            }>;
        }
        export type _cocos_core_animation_tracks_untyped_track__UntypedTrackRefine = (path: Readonly<animation.TrackPath>, proxy: animation.IValueProxyFactory | undefined) => "vec2" | "vec3" | "vec4" | "color" | "size";
        export const _cocos_core_animation_animation_clip__searchForRootBonePathSymbol: unique symbol;
        export type _cocos_core_animation_animation_clip__WrapMode_ = _cocos_core_animation_types__WrapMode;
        /**
         * For internal
         */
        export class _cocos_core_animation_types__WrappedInfo {
            ratio: number;
            time: number;
            direction: number;
            stopped: boolean;
            iterations: number;
            frameIndex: number;
            constructor(info?: _cocos_core_animation_types__WrappedInfo);
            set(info: _cocos_core_animation_types__WrappedInfo): void;
        }
        export class _cocos_core_animation_playable__Playable {
            /**
             * @en Whether if this `Playable` is in playing.
             * @zh 该 `Playable` 是否正在播放状态。
             * @default false
             */
            get isPlaying(): boolean;
            /**
             * @en Whether if this `Playable` has been paused. This can be true even if in edit mode(isPlaying == false).
             * @zh 该 `Playable` 是否已被暂停。
             * @default false
             */
            get isPaused(): boolean;
            /**
             * @en Whether if this `Playable` has been paused or stopped.
             * @zh 该 `Playable` 是否已被暂停或停止。
             */
            get isMotionless(): boolean;
            /**
             * @en Play this animation.
             * @zh 播放动画。
             */
            play(): void;
            /**
             * @en Stop this animation.
             * @zh 停止动画播放。
             */
            stop(): void;
            /**
             * @en Pause this animation.
             * @zh 暂停动画。
             */
            pause(): void;
            /**
             * @en Resume this animation.
             * @zh 重新播放动画。
             */
            resume(): void;
            /**
             * @en Perform a single frame step.
             * @zh 执行一帧动画。
             */
            step(): void;
            update(deltaTime: number): void;
            protected onPlay(): void;
            protected onPause(): void;
            protected onResume(): void;
            protected onStop(): void;
            protected onError(message: string): void;
        }
        /**
         * @en The event type supported by Animation
         * @zh Animation 支持的事件类型。
         */
        export enum _cocos_core_animation_animation_state__EventType {
            /**
             * @en Emit when begin playing animation
             * @zh 开始播放时触发。
             */
            PLAY = "play",
            /**
             * @en Emit when stop playing animation
             * @zh 停止播放时触发。
             */
            STOP = "stop",
            /**
             * @en Emit when pause animation
             * @zh 暂停播放时触发。
             */
            PAUSE = "pause",
            /**
             * @en Emit when resume animation
             * @zh 恢复播放时触发。
             */
            RESUME = "resume",
            /**
             * @en If animation repeat count is larger than 1, emit when animation play to the last frame.
             * @zh 假如动画循环次数大于 1，当动画播放到最后一帧时触发。
             */
            LASTFRAME = "lastframe",
            /**
             * @en Triggered when finish playing animation.
             * @zh 动画完成播放时触发。
             */
            FINISHED = "finished"
        }
        export interface _cocos_core_animation_cross_fade__CrossFadeScheduler {
            addCrossFade(crossFade: _cocos_core_animation_cross_fade__CrossFade): void;
            removeCrossFade(crossFade: _cocos_core_animation_cross_fade__CrossFade): void;
        }
        export class _cocos_core_animation_cross_fade__CrossFade extends _cocos_core_animation_playable__Playable {
            constructor(scheduler?: _cocos_core_animation_cross_fade__CrossFadeScheduler);
            update(deltaTime: number): void;
            /**
             * 在指定时间内将从当前动画状态切换到指定的动画状态。
             * @param state 指定的动画状态。
             * @param duration 切换时间。
             */
            crossFade(state: AnimationState | null, duration: number): void;
            clear(): void;
            protected onPlay(): void;
            /**
             * 停止我们淡入淡出的所有动画状态并停止淡入淡出。
             */
            protected onPause(): void;
            /**
             * 恢复我们淡入淡出的所有动画状态并继续淡入淡出。
             */
            protected onResume(): void;
            /**
             * 停止所有淡入淡出的动画状态。
             */
            protected onStop(): void;
        }
        export type _cocos_core_event_eventify__EventType = string | number;
        /**
         * @zh
         * 实现该接口的对象具有处理事件的能力。
         * @en
         * Objects those implement this interface have essentially the capability to process events.
         */
        export interface _cocos_core_event_eventify__IEventified {
            /**
             * @zh 检查指定事件是否已注册回调。
             * @en Checks whether there is correspond event listener registered on the given event.
             * @param type - Event type.
             * @param callback - Callback function when event triggered.
             * @param target - Callback callee.
             */
            hasEventListener(type: string, callback?: (...any: any[]) => void, target?: any): boolean;
            /**
             * @en
             * Register an callback of a specific event type on the EventTarget.
             * This type of event should be triggered via `emit`.
             * @zh
             * 注册事件目标的特定事件类型回调。这种类型的事件应该被 `emit` 触发。
             *
             * @param type - A string representing the event type to listen for.
             * @param callback - The callback that will be invoked when the event is dispatched.
             *                              The callback is ignored if it is a duplicate (the callbacks are unique).
             * @param thisArg - The target (this object) to invoke the callback, can be null
             * @return - Just returns the incoming callback so you can save the anonymous function easier.
             * @example
             * import { log } from 'cc';
             * eventTarget.on('fire', function () {
             *     log("fire in the hole");
             * }, node);
             */
            on<TFunction extends (...any: any[]) => void>(type: _cocos_core_event_eventify__EventType, callback: TFunction, thisArg?: any, once?: boolean): typeof callback;
            /**
             * @en
             * Register an callback of a specific event type on the EventTarget,
             * the callback will remove itself after the first time it is triggered.
             * @zh
             * 注册事件目标的特定事件类型回调，回调会在第一时间被触发后删除自身。
             *
             * @param type - A string representing the event type to listen for.
             * @param callback - The callback that will be invoked when the event is dispatched.
             *                              The callback is ignored if it is a duplicate (the callbacks are unique).
             * @param target - The target (this object) to invoke the callback, can be null
             * @example
             * import { log } from 'cc';
             * eventTarget.once('fire', function () {
             *     log("this is the callback and will be invoked only once");
             * }, node);
             */
            once<TFunction extends (...any: any[]) => void>(type: _cocos_core_event_eventify__EventType, callback: TFunction, thisArg?: any): typeof callback;
            /**
             * @en
             * Removes the listeners previously registered with the same type, callback, target and or useCapture,
             * if only type is passed as parameter, all listeners registered with that type will be removed.
             * @zh
             * 删除之前用同类型，回调，目标或 useCapture 注册的事件监听器，如果只传递 type，将会删除 type 类型的所有事件监听器。
             *
             * @param type - A string representing the event type being removed.
             * @param callback - The callback to remove.
             * @param target - The target (this object) to invoke the callback, if it's not given, only callback without target will be removed
             * @example
             * import { log } from 'cc';
             * // register fire eventListener
             * var callback = eventTarget.on('fire', function () {
             *     log("fire in the hole");
             * }, target);
             * // remove fire event listener
             * eventTarget.off('fire', callback, target);
             * // remove all fire event listeners
             * eventTarget.off('fire');
             */
            off<TFunction extends (...any: any[]) => void>(type: _cocos_core_event_eventify__EventType, callback?: TFunction, thisArg?: any): void;
            /**
             * @en Removes all callbacks previously registered with the same target (passed as parameter).
             * This is not for removing all listeners in the current event target,
             * and this is not for removing all listeners the target parameter have registered.
             * It's only for removing all listeners (callback and target couple) registered on the current event target by the target parameter.
             * @zh 在当前 EventTarget 上删除指定目标（target 参数）注册的所有事件监听器。
             * 这个函数无法删除当前 EventTarget 的所有事件监听器，也无法删除 target 参数所注册的所有事件监听器。
             * 这个函数只能删除 target 参数在当前 EventTarget 上注册的所有事件监听器。
             * @param typeOrTarget - The target to be searched for all related listeners
             */
            targetOff(typeOrTarget: any): void;
            /**
             * @zh 移除在特定事件类型中注册的所有回调或在某个目标中注册的所有回调。
             * @en Removes all callbacks registered in a certain event type or all callbacks registered with a certain target
             * @param typeOrTarget - The event type or target with which the listeners will be removed
             */
            removeAll(typeOrTarget: any): void;
            /**
             * @zh 派发一个指定事件，并传递需要的参数
             * @en Trigger an event directly with the event name and necessary arguments.
             * @param type - event type
             * @param args - Arguments when the event triggered
             */
            emit(type: _cocos_core_event_eventify__EventType, arg0?: any, arg1?: any, arg2?: any, arg3?: any, arg4?: any): void;
        }
        export const _cocos_core_animation_animation_component__Animation_base: new (...args: any[]) => Component & _cocos_core_event_eventify__IEventified;
        export type _cocos_core_animation_animation_component__EventType_ = _cocos_core_animation_animation_state__EventType;
        export const _cocos_core_animation_tracks_track__trackBindingTag: unique symbol;
        export interface _cocos_core_animation_tracks_track__CustomizedTrackPathResolver {
            get(target: unknown): unknown;
        }
        export const _cocos_core_animation_tracks_track__parseTrsPathTag: unique symbol;
        export const _cocos_core_animation_tracks_track__normalizedFollowTag: unique symbol;
        /**
         * @en 表示一个包含了单条通道的轨道。
         * @zh Describes a track which contains only single channel.
         */
        export abstract class _cocos_core_animation_tracks_track__SingleChannelTrack<TCurve extends _cocos_core_animation_tracks_track__Curve> extends animation.Track {
            constructor();
            /**
             * @en The channel within the track.
             * @zh 轨道包含的通道。
             */
            get channel(): _cocos_core_animation_tracks_track__Channel<TCurve>;
            channels(): Iterable<_cocos_core_animation_tracks_track__Channel<TCurve>>;
            /**
             * @internal
             */
            protected createCurve(): TCurve;
            /**
             * @internal
             */
            [_cocos_core_animation_define__createEvalSymbol](_runtimeBinding: _cocos_core_animation_tracks_track__RuntimeBinding): _cocos_core_animation_tracks_track__TrackEval;
        }
        export class _cocos_core_animation_tracks_vector_track__Vec2TrackEval {
            constructor(_x: RealCurve | undefined, _y: RealCurve | undefined);
            evaluate(time: number, runtimeBinding: _cocos_core_animation_tracks_track__RuntimeBinding): math.Vec2;
        }
        export class _cocos_core_animation_tracks_vector_track__Vec3TrackEval {
            constructor(_x: RealCurve | undefined, _y: RealCurve | undefined, _z: RealCurve | undefined);
            evaluate(time: number, runtimeBinding: _cocos_core_animation_tracks_track__RuntimeBinding): math.Vec3;
        }
        export class _cocos_core_animation_tracks_vector_track__Vec4TrackEval {
            constructor(_x: RealCurve | undefined, _y: RealCurve | undefined, _z: RealCurve | undefined, _w: RealCurve | undefined);
            evaluate(time: number, runtimeBinding: _cocos_core_animation_tracks_track__RuntimeBinding): math.Vec4;
        }
        export class _cocos_core_animation_tracks_quat_track__QuatTrackEval {
            constructor(_curve: QuatCurve);
            evaluate(time: number): math.Quat;
        }
        export class _cocos_core_animation_tracks_color_track__ColorTrackEval {
            constructor(_x: RealCurve | undefined, _y: RealCurve | undefined, _z: RealCurve | undefined, _w: RealCurve | undefined);
            evaluate(time: number, runtimeBinding: _cocos_core_animation_tracks_track__RuntimeBinding): math.Color;
        }
        export class _cocos_core_animation_tracks_size_track__SizeTrackEval {
            constructor(_width: RealCurve | undefined, _height: RealCurve | undefined);
            evaluate(time: number, runtimeBinding: _cocos_core_animation_tracks_track__RuntimeBinding): math.Size;
        }
        export interface _cocos_core_animation_cubic_spline_value__ICubicSplineValue<T> extends ILerpable {
            dataPoint: T;
            inTangent: T;
            outTangent: T;
            lerp(to: _cocos_core_animation_cubic_spline_value__ICubicSplineValue<T>, t: number, dt: number): T;
            getNoLerp(): T;
        }
        export type _cocos_core_animation_cubic_spline_value__CubicSplineValueConstructor<T> = new (dataPoint: T, inTangent: T, outTangent: T) => _cocos_core_animation_cubic_spline_value__ICubicSplineValue<T>;
        export class _cocos_3d_skeletal_animation_skeletal_animation_blending__LegacyVec3PropertyBlendState implements _cocos_3d_skeletal_animation_skeletal_animation_blending__PropertyBlendState<math.Vec3> {
            refCount: number;
            accumulatedWeight: number;
            result: math.Vec3;
            blend(value: Readonly<math.Vec3>, weight: number): void;
            reset(): void;
        }
        export class _cocos_3d_skeletal_animation_skeletal_animation_blending__LegacyQuatPropertyBlendState implements _cocos_3d_skeletal_animation_skeletal_animation_blending__PropertyBlendState<math.Quat> {
            refCount: number;
            accumulatedWeight: number;
            result: math.Quat;
            blend(value: Readonly<math.Quat>, weight: number): void;
            reset(): void;
        }
        export class _cocos_3d_skeletal_animation_skeletal_animation_blending__LegacyNodeBlendState extends _cocos_3d_skeletal_animation_skeletal_animation_blending__NodeBlendState<_cocos_3d_skeletal_animation_skeletal_animation_blending__LegacyVec3PropertyBlendState, _cocos_3d_skeletal_animation_skeletal_animation_blending__LegacyQuatPropertyBlendState> {
            apply(node: Node): void;
            protected _createVec3BlendState(_currentValue: Readonly<math.Vec3>): _cocos_3d_skeletal_animation_skeletal_animation_blending__LegacyVec3PropertyBlendState;
            protected _createQuatBlendState(_currentValue: Readonly<math.Quat>): _cocos_3d_skeletal_animation_skeletal_animation_blending__LegacyQuatPropertyBlendState;
        }
        export class _cocos_3d_skeletal_animation_skeletal_animation_blending__LegacyBlendStateBuffer extends _cocos_3d_skeletal_animation_skeletal_animation_blending__BlendStateBuffer<_cocos_3d_skeletal_animation_skeletal_animation_blending__LegacyNodeBlendState> {
            protected createNodeBlendState(): _cocos_3d_skeletal_animation_skeletal_animation_blending__LegacyNodeBlendState;
        }
        export enum _pal_audio_type__AudioType {
            DOM_AUDIO = 0,
            WEB_AUDIO = 1,
            MINIGAME_AUDIO = 2,
            NATIVE_AUDIO = 3,
            UNKNOWN_AUDIO = 4
        }
        /**
         * Each audio instance needs to be managed, but should not take up too much memory.
         * The `OneShotAudio` is a lite version of audio class designed for audio manager.
         */
        export class _pal_audio__OneShotAudio {
            /**
             * Play the audio.
             */
            public play(): void;
            /**
             * Stops playing the audio.
             */
            public stop(): void;
            /**
             * Get or set the onPlay callback.
             */
            get onPlay(): () => void | undefined;
            set onPlay(cb: () => void | undefined);
            /**
             * Get or set the onEnd callback.
             */
            get onEnd(): () => void | undefined;
            set onEnd(cb: () => void | undefined);
        }
        export class _pal_audio__AudioPlayer {
            /**
             * Destroys the player.
             */
            destroy(): void;
            /**
             * Asynchronously creates an audio player to load an audio.
             * @param url URL to the audio.
             * @param opts Load options.
             * @returns The audio player.
             */
            static load(url: string, opts?: import('pal/audio/type').AudioLoadOptions): Promise<_pal_audio__AudioPlayer>;
            /**
             * Asynchronously load a native audio for playing one shot.
             * This is a basic loading method for AudioPlayer.
             * @param url URL to the audio.
             * @param opts Load options.
             * @returns The native audio such as `HTMLAudioElement` or `AudioBuffer`.
             */
            static loadNative(url: string, opts?: import('pal/audio/type').AudioLoadOptions): Promise<unknown>;
            /**
             * Asynchronously load an OneShotAudio instance.
             * @param url URL to the audio.
             * @param volume Specify the volume.
             * @param opts Load options.
             * @returns The OneShotAudio instance.
             */
            static loadOneShotAudio(url: string, volume: number, opts?: import('pal/audio/type').AudioLoadOptions): Promise<_pal_audio__OneShotAudio>;
            /**
             * Max audio channel count allowed on current platform.
             * If the amount of playing audios exceeds the limit,
             * some audio instances would be discarded by audio manager.
             */
            static readonly maxAudioChannel: number;
            /**
             * Readonly property to get the url of audio src.
             */
            get src(): string;
            /**
             * The type of this player.
             * For WEB platform, it can be `WEB_AUDIO` or `DOM_AUDIO`.
             */
            get type(): import('pal/audio/type').AudioType;
            /**
             * The state of this player.
             * The state would be restored to `INIT` when the audio finished its playing.
             */
            get state(): import('pal/audio/type').AudioState;
            /**
             * Gets or sets whether if the playing audio should be looped.
             */
            get loop(): boolean;
            set loop(val: boolean);
            /**
             * The volume of this player, ranged from 0 to 1.
             */
            get volume(): number;
            set volume(val: number);
            /**
             * The duration of this audio player.
             */
            get duration(): number;
            /**
             * The current time of this player, in seconds, ranged from 0 to its total duration.
             * Note this field is immutable, if you want to set the current time, please call the seek() method instead.
             */
            get currentTime(): number;
            /**
             * Get the sample rate.
             */
            get sampleRate(): number;
            /**
             * Get pcm data view from specified channel.
             * @param channelIndex The channel index. 0 is left channel, 1 is right channel.
             */
            public getPCMData(channelIndex: number): import('pal/audio/type').AudioPCMDataView | undefined;
            /**
             * Asynchronously seeks the player's playing time onto specified location.
             * @param time Desired playing time.
             */
            seek(time: number): Promise<void>;
            /**
             * Asynchronously plays the audio or resumes the audio while it is paused.
             */
            play(): Promise<void>;
            /**
             * Asynchronously pauses the playing.
             */
            pause(): Promise<void>;
            /**
             * Asynchronously stops the playing.
             */
            stop(): Promise<void>;
            /**
             * Registers an callback which would be called at an interruption begin.
             * The interruption includes the show/hide events, phone call/alarm, earphones un-plugging.
             * @param cb The callback.
             */
            onInterruptionBegin(cb: () => void): void;
            /**
             * Unregister the callback that registered to `onInterruptionBegin`.
             * @param cb  The callback. If not specified, all callback would be unregistered.
             */
            offInterruptionBegin(cb?: () => void): void;
            /**
             * Register an callback which would be called at an interruption end.
             * @param cb The callback.
             */
            onInterruptionEnd(cb: () => void): void;
            /**
             * Unregister the callback that registered to `onInterruptionEnd`.
             * @param cb The callback. If not specified, all callback would be unregistered.
             */
            offInterruptionEnd(cb?: () => void): void;
            /**
             * Register an callback which would be called when the player finished its playing.
             * @param cb The callback.
             */
            onEnded(cb: () => void): void;
            /**
             * Unregister the callback that registered to `onEnded`.
             * @param cb The callback. If not specified, all callback would be unregistered.
             */
            offEnded(cb?: () => void): void;
        }
        export interface _cocos_audio_audio_clip__AudioMeta {
            player: _pal_audio__AudioPlayer | null;
            url: string;
            type: _pal_audio_type__AudioType;
            duration: number;
        }
        export enum _pal_audio_type__AudioState {
            INIT = 0,
            PLAYING = 1,
            PAUSED = 2,
            STOPPED = 3,
            INTERRUPTED = 4
        }
        export enum _cocos_audio_audio_source__AudioSourceEventType {
            STARTED = "started",
            ENDED = "ended"
        }
        export type _pal_audio_type__AudioBufferView = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array;
        export interface _cocos_core_renderer_core_render_window__IRenderWindowInfo {
            title?: string;
            width: number;
            height: number;
            renderPassInfo: gfx.RenderPassInfo;
            swapchain?: gfx.Swapchain;
        }
        /**
         * @en The render window represents the render target, it could be an off screen frame buffer or the on screen buffer.
         * @zh 渲染窗口代表了一个渲染目标，可以是离屏的帧缓冲，也可以是屏幕缓冲
         */
        export class _cocos_core_renderer_core_render_window__RenderWindow {
            /**
             * @en Get window width. Pre-rotated (i.e. rotationally invariant, always in identity/portrait mode) if possible.
             * If you want to get oriented size instead, you should use [[renderer.scene.Camera.width]] which corresponds to the current screen rotation.
             * @zh 获取窗口宽度。如果支持交换链预变换，返回值将始终处于单位旋转（竖屏）坐标系下。如果需要获取旋转后的尺寸，请使用 [[renderer.scene.Camera.width]]。
             */
            get width(): number;
            /**
             * @en Get window height. Pre-rotated (i.e. rotationally invariant, always in identity/portrait mode) if possible.
             * If you want to get oriented size instead, you should use [[renderer.scene.Camera.width]] which corresponds to the current screen rotation.
             * @zh 获取窗口高度。如果支持交换链预变换，返回值将始终处于单位旋转（竖屏）坐标系下。如果需要获取旋转后的尺寸，请使用 [[renderer.scene.Camera.height]]。
             */
            get height(): number;
            /**
             * @en Get the swapchain for this window, if there is one
             * @zh 如果存在的话，获取此窗口的交换链
             */
            get swapchain(): gfx.Swapchain;
            /**
             * @en Get window frame buffer.
             * @zh 帧缓冲对象。
             */
            get framebuffer(): gfx.Framebuffer;
            get cameras(): renderer.scene.Camera[];
            protected _title: string;
            protected _width: number;
            protected _height: number;
            protected _swapchain: gfx.Swapchain;
            protected _renderPass: gfx.RenderPass | null;
            protected _colorTextures: gfx.Texture[];
            protected _depthStencilTexture: gfx.Texture | null;
            protected _cameras: renderer.scene.Camera[];
            protected _hasOnScreenAttachments: boolean;
            protected _hasOffScreenAttachments: boolean;
            protected _framebuffer: gfx.Framebuffer | null;
            protected _device: gfx.Device | null;
            /**
             * @private
             */
            static registerCreateFunc(root: Root): void;
            initialize(device: gfx.Device, info: _cocos_core_renderer_core_render_window__IRenderWindowInfo): boolean;
            destroy(): void;
            /**
             * @en Resize window.
             * @zh 重置窗口大小。
             * @param width The new width.
             * @param height The new height.
             */
            resize(width: number, height: number): void;
            /**
             * @en Extract all render cameras attached to the render window to the output cameras list
             * @zh 将所有挂载到当前渲染窗口的摄像机存储到输出列表参数中
             * @param cameras @en The output cameras list, should be empty before invoke this function
             *                @zh 输出相机列表参数，传入时应该为空
             */
            extractRenderCameras(cameras: renderer.scene.Camera[]): void;
            /**
             * @en Attach a new camera to the render window
             * @zh 添加渲染相机
             * @param camera @en The camera to attach @zh 要挂载的相机
             */
            attachCamera(camera: renderer.scene.Camera): void;
            /**
             * @en Detach a camera from the render window
             * @zh 移除场景中的渲染相机
             * @param camera @en The camera to detach @zh 要移除的相机
             */
            detachCamera(camera: renderer.scene.Camera): void;
            /**
             * @en Clear all attached cameras
             * @zh 清空全部渲染相机
             */
            clearCameras(): void;
            /**
             * @en Sort all attached cameras with priority
             * @zh 按照优先级对所有挂载的相机排序
             */
            sortCameras(): void;
        }
        export class _cocos_core_pipeline_global_descriptor_set_manager__GlobalDSManager {
            get descriptorSetMap(): Map<renderer.scene.Light, gfx.DescriptorSet>;
            get linearSampler(): gfx.Sampler;
            get pointSampler(): gfx.Sampler;
            get descriptorSetLayout(): gfx.DescriptorSetLayout;
            get globalDescriptorSet(): gfx.DescriptorSet;
            constructor(device: gfx.Device);
            regenLayout(): void;
            /**
             * @en Bind buffer for all descriptorSets, so that all created descriptorSet buffer are consistent
             * @zh 为所有的 descriptorSet 绑定 buffer，使得所有已创建的 descriptorSet buffer 保持一致
             * @param binding The target binding.
             * @param buffer The buffer to be bound.
             */
            bindBuffer(binding: number, buffer: gfx.Buffer): void;
            /**
             * @en Bind sampler for all descriptorSets, so that all created descriptorSet sampler are consistent
             * @zh 为所有的 descriptorSet 绑定 sampler，使得所有已创建的 descriptorSet sampler 保持一致
             * @param binding The target binding.
             * @param sampler The sampler to be bound.
             */
            bindSampler(binding: number, sampler: gfx.Sampler): void;
            /**
             * @en Bind texture for all descriptorSets, so that all created descriptorSet texture are consistent
             * @zh 为所有的 descriptorSet 绑定 texture，使得所有已创建的 descriptorSet texture 保持一致
             * @param binding The target binding.
             * @param texture The texture to be bound.
             */
            bindTexture(binding: number, texture: gfx.Texture): void;
            /**
             * @en Update all descriptorSet
             * @zh 更新所有的 descriptorSet
             */
            update(): void;
            /**
             * @en The layout of all created descriptorSets in buffer, sampler, and texture (except shadow) is consistent with the globalDescriptorSet
             * @zh 所有创建出来的 descriptorSet 在 buffer、 sampler、 texture（shadow 除外）的布局与 globalDescriptorSet 保持一致
             * @param idx Specify index creation
             * @return descriptorSet
             */
            getOrCreateDescriptorSet(light: renderer.scene.Light): gfx.DescriptorSet | undefined;
            destroy(): void;
        }
        export type _types_globals__RecursivePartial<T> = {
            [P in keyof T]?: T[P] extends Array<infer U> ? Array<_types_globals__RecursivePartial<U>> : T[P] extends ReadonlyArray<infer V> ? ReadonlyArray<_types_globals__RecursivePartial<V>> : _types_globals__RecursivePartial<T[P]>;
        };
        export interface _cocos_core_renderer_core_pass__IPassDynamics {
            [type: number]: {
                dirty: boolean;
                value: number;
            };
        }
        export interface _cocos_core_pipeline_batched_buffer__IBatchedItem {
            vbs: gfx.Buffer[];
            vbDatas: Uint8Array[];
            vbIdx: gfx.Buffer;
            vbIdxData: Float32Array;
            vbCount: number;
            mergeCount: number;
            ia: gfx.InputAssembler;
            ubo: gfx.Buffer;
            uboData: Float32Array;
            descriptorSet: gfx.DescriptorSet;
            pass: renderer.Pass;
            shader: gfx.Shader | null;
        }
        export class _cocos_core_pipeline_batched_buffer__BatchedBuffer {
            batches: _cocos_core_pipeline_batched_buffer__IBatchedItem[];
            dynamicOffsets: number[];
            constructor(pass: renderer.Pass);
            destroy(): void;
            merge(subModel: renderer.scene.SubModel, passIdx: number, model: renderer.scene.Model): void;
            clear(): void;
        }
        export interface _cocos_core_renderer_core_program_lib__IDefineRecord extends EffectAsset.IDefineInfo {
            _map: (value: any) => number;
            _offset: number;
        }
        export abstract class _cocos_core_pipeline_custom_pipeline__PipelineRuntime {
            abstract activate(swapchain: gfx.Swapchain): boolean;
            abstract destroy(): boolean;
            abstract render(cameras: renderer.scene.Camera[]): void;
            abstract get device(): gfx.Device;
            abstract get globalDSManager(): _cocos_core_pipeline_global_descriptor_set_manager__GlobalDSManager;
            abstract get descriptorSetLayout(): gfx.DescriptorSetLayout;
            abstract get descriptorSet(): gfx.DescriptorSet;
            abstract get commandBuffers(): gfx.CommandBuffer[];
            abstract get pipelineSceneData(): PipelineSceneData;
            abstract get constantMacros(): string;
            abstract get profiler(): renderer.scene.Model | null;
            abstract set profiler(profiler: renderer.scene.Model | null);
            abstract get geometryRenderer(): GeometryRenderer | null;
            abstract get shadingScale(): number;
            abstract set shadingScale(scale: number);
            abstract getMacroString(name: string): string;
            abstract getMacroInt(name: string): number;
            abstract getMacroBool(name: string): boolean;
            abstract setMacroString(name: string, value: string): void;
            abstract setMacroInt(name: string, value: number): void;
            abstract setMacroBool(name: string, value: boolean): void;
            abstract onGlobalPipelineStateChanged(): void;
            abstract get macros(): renderer.MacroRecord;
        }
        /**
         * @en The global maintainer of all shader resources.
         * @zh 维护 shader 资源实例的全局管理器。
         */
        export class _cocos_core_renderer_core_program_lib__ProgramLib {
            protected _templates: Record<string, renderer.IProgramInfo>;
            protected _cache: Record<string, gfx.Shader>;
            protected _templateInfos: Record<number, renderer.ITemplateInfo>;
            register(effect: EffectAsset): void;
            /**
             * @en Register the shader template with the given info
             * @zh 注册 shader 模板。
             */
            define(shader: EffectAsset.IShaderInfo): renderer.IProgramInfo;
            /**
             * @en Gets the shader template with its name
             * @zh 通过名字获取 Shader 模板
             * @param name Target shader name
             */
            getTemplate(name: string): renderer.IProgramInfo;
            /**
             * @en Gets the shader template info with its name
             * @zh 通过名字获取 Shader 模版信息
             * @param name Target shader name
             */
            getTemplateInfo(name: string): renderer.ITemplateInfo;
            /**
             * @en Gets the pipeline layout of the shader template given its name
             * @zh 通过名字获取 Shader 模板相关联的管线布局
             * @param name Target shader name
             */
            getDescriptorSetLayout(device: gfx.Device, name: string, isLocal?: boolean): gfx.DescriptorSetLayout;
            /**
             * @en
             * Does this library has the specified program
             * @zh
             * 当前是否有已注册的指定名字的 shader
             * @param name Target shader name
             */
            hasProgram(name: string): boolean;
            /**
             * @en Gets the shader key with the name and a macro combination
             * @zh 根据 shader 名和预处理宏列表获取 shader key。
             * @param name Target shader name
             * @param defines The combination of preprocess macros
             */
            getKey(name: string, defines: renderer.MacroRecord): string;
            /**
             * @en Destroy all shader instance match the preprocess macros
             * @zh 销毁所有完全满足指定预处理宏特征的 shader 实例。
             * @param defines The preprocess macros as filter
             */
            destroyShaderByDefines(defines: renderer.MacroRecord): void;
            /**
             * @en Gets the shader resource instance with given information
             * @zh 获取指定 shader 的渲染资源实例
             * @param name Shader name
             * @param defines Preprocess macros
             * @param pipeline The [[RenderPipeline]] which owns the render command
             * @param key The shader cache key, if already known
             */
            getGFXShader(device: gfx.Device, name: string, defines: renderer.MacroRecord, pipeline: _cocos_core_pipeline_custom_pipeline__PipelineRuntime, key?: string): gfx.Shader;
        }
        export interface _cocos_core_renderer_core_memory_pools__IHandle<P extends renderer.PoolType> extends Number {
            _: P;
        }
        export type _cocos_core_renderer_core_memory_pools__BufferManifest = {
            [key: string]: number | string;
            COUNT: number;
        };
        export enum _cocos_core_renderer_core_memory_pools__BufferDataType {
            UINT32 = 0,
            FLOAT32 = 1,
            NEVER = 2
        }
        export type _cocos_core_renderer_core_memory_pools__BufferDataTypeManifest<E extends _cocos_core_renderer_core_memory_pools__BufferManifest> = {
            [key in E[keyof E]]: _cocos_core_renderer_core_memory_pools__BufferDataType;
        };
        export type _cocos_core_renderer_core_memory_pools__BufferDataMembersManifest<E extends _cocos_core_renderer_core_memory_pools__BufferManifest> = {
            [key in E[keyof E]]: number;
        };
        export type _cocos_core_renderer_core_memory_pools__BufferArrayType = Float32Array | Uint32Array;
        export interface _cocos_core_renderer_core_memory_pools__IMemoryPool<P extends renderer.PoolType> {
            free(handle: _cocos_core_renderer_core_memory_pools__IHandle<P>): void;
        }
        export class _cocos_core_renderer_core_memory_pools__BufferPool<P extends renderer.PoolType, E extends _cocos_core_renderer_core_memory_pools__BufferManifest> implements _cocos_core_renderer_core_memory_pools__IMemoryPool<P> {
            constructor(poolType: P, dataType: _cocos_core_renderer_core_memory_pools__BufferDataTypeManifest<E>, dataMembers: _cocos_core_renderer_core_memory_pools__BufferDataMembersManifest<E>, enumType: E, entryBits?: number);
            alloc(): _cocos_core_renderer_core_memory_pools__IHandle<P>;
            getBuffer(handle: _cocos_core_renderer_core_memory_pools__IHandle<P>): _cocos_core_renderer_core_memory_pools__BufferArrayType;
            getTypedArray<K extends E[keyof E]>(handle: _cocos_core_renderer_core_memory_pools__IHandle<P>, element: K): _cocos_core_renderer_core_memory_pools__BufferArrayType;
            free(handle: _cocos_core_renderer_core_memory_pools__IHandle<P>): void;
        }
        export interface _types_globals__IWritableArrayLike<T> {
            readonly length: number;
            [index: number]: T;
        }
        export abstract class _cocos_core_memop_scalable_container__ScalableContainer {
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _poolHandle: number;
            constructor();
            abstract tryShrink(): void;
            destroy(): void;
        }
        /**
         * @en
         * line-sphere intersect detect.
         * @zh
         * 线段与球的相交性检测
         * @param line @zh 线段 @en The line to test
         * @param sphere @zh 球 @en The sphere to test
         * @return @zh 0 或非 0 @en 0 or not 0, 0 indicates there is no intersection
         */
        function _cocos_core_geometry_intersect__lineSphere(line: geometry.Line, sphere: geometry.Sphere): number;
        /**
         * @en
         * line-aabb intersect detect.
         * @zh
         * 线段与轴对齐包围盒的相交性检测
         * @param line @zh 线段 @en The line to test
         * @param aabb @zh 轴对齐包围盒 @en The aabb to test
         * @return @zh 0 或非 0 @en 0 or not 0, 0 indicates there is no intersection
         */
        function _cocos_core_geometry_intersect__lineAABB(line: geometry.Line, aabb: geometry.AABB): number;
        /**
         * @en
         * line-obb intersect detect.
         * @zh
         * 线段与方向包围盒的相交性检测
         * @param line @zh 线段 @en The line to test
         * @param obb @zh 方向包围盒 @en The obb
         * @return @zh 0 或非 0 @en 0 or not 0, 0 indicates there is no intersection
         */
        function _cocos_core_geometry_intersect__lineOBB(line: geometry.Line, obb: geometry.OBB): number;
        export enum _cocos_core_animation_types__WrapModeMask {
            Default = 0,
            Normal = 1,
            Loop = 2,
            ShouldWrap = 4,
            Clamp = 8,
            PingPong = 22,
            Reverse = 36
        }
        export class _cocos_core_geometry_curve__OptimizedKey {
            index: number;
            time: number;
            endTime: number;
            coefficient: Float32Array;
            constructor();
            evaluate(T: number): number;
        }
        /**
         * @en GFX buffer barrier.
         * @zh GFX buffer内存屏障。
         */
        export class _cocos_core_gfx_base_states_buffer_barrier__BufferBarrier extends gfx.GFXObject {
            get info(): Readonly<gfx.BufferBarrierInfo>;
            get hash(): number;
            protected _info: gfx.BufferBarrierInfo;
            protected _hash: number;
            constructor(info: Readonly<gfx.BufferBarrierInfo>, hash: number);
            static computeHash(info: Readonly<gfx.BufferBarrierInfo>): number;
        }
        export type _types_globals__TypedArrayConstructor = Uint8ArrayConstructor | Uint8ClampedArrayConstructor | Int8ArrayConstructor | Uint16ArrayConstructor | Int16ArrayConstructor | Uint32ArrayConstructor | Int32ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor;
        export class _cocos_core_data_gc_object__GCObject {
            constructor();
            destroy(): void;
        }
        export const enum _cocos_core_pipeline_custom_types__ResourceResidency {
            MANAGED = 0,
            MEMORYLESS = 1,
            PERSISTENT = 2,
            EXTERNAL = 3,
            BACKBUFFER = 4
        }
        export const enum _cocos_core_pipeline_custom_types__AccessType {
            READ = 0,
            READ_WRITE = 1,
            WRITE = 2
        }
        export const enum _cocos_core_pipeline_custom_types__AttachmentType {
            RENDER_TARGET = 0,
            DEPTH_STENCIL = 1
        }
        export class _cocos_core_pipeline_custom_types__RasterView {
            constructor(slotName?: string, accessType?: _cocos_core_pipeline_custom_types__AccessType, attachmentType?: _cocos_core_pipeline_custom_types__AttachmentType, loadOp?: gfx.LoadOp, storeOp?: gfx.StoreOp, clearFlags?: gfx.ClearFlagBit, clearColor?: gfx.Color);
            slotName: string;
            accessType: _cocos_core_pipeline_custom_types__AccessType;
            attachmentType: _cocos_core_pipeline_custom_types__AttachmentType;
            loadOp: gfx.LoadOp;
            storeOp: gfx.StoreOp;
            clearFlags: gfx.ClearFlagBit;
            readonly clearColor: gfx.Color;
        }
        export const enum _cocos_core_pipeline_custom_types__ClearValueType {
            FLOAT_TYPE = 0,
            INT_TYPE = 1
        }
        export class _cocos_core_pipeline_custom_types__ComputeView {
            name: string;
            accessType: _cocos_core_pipeline_custom_types__AccessType;
            clearFlags: gfx.ClearFlagBit;
            readonly clearColor: gfx.Color;
            clearValueType: _cocos_core_pipeline_custom_types__ClearValueType;
        }
        export const enum _cocos_core_pipeline_custom_types__QueueHint {
            NONE = 0,
            RENDER_OPAQUE = 1,
            RENDER_CUTOUT = 2,
            RENDER_TRANSPARENT = 3
        }
        export class _cocos_core_pipeline_custom_types__LightInfo {
            constructor(light?: renderer.scene.Light | null, level?: number);
            light: renderer.scene.Light | null;
            level: number;
        }
        export const enum _cocos_core_pipeline_custom_types__SceneFlags {
            NONE = 0,
            OPAQUE_OBJECT = 1,
            CUTOUT_OBJECT = 2,
            TRANSPARENT_OBJECT = 4,
            SHADOW_CASTER = 8,
            UI = 16,
            DEFAULT_LIGHTING = 32,
            VOLUMETRIC_LIGHTING = 64,
            CLUSTERED_LIGHTING = 128,
            PLANAR_SHADOW = 256,
            GEOMETRY = 512,
            PROFILER = 1024,
            ALL = 4294967295
        }
        export abstract class _cocos_core_pipeline_custom_pipeline__Setter {
            abstract setMat4(name: string, mat: math.Mat4): void;
            abstract setQuaternion(name: string, quat: math.Quat): void;
            abstract setColor(name: string, color: gfx.Color): void;
            abstract setVec4(name: string, vec: math.Vec4): void;
            abstract setVec2(name: string, vec: math.Vec2): void;
            abstract setFloat(name: string, v: number): void;
            abstract setBuffer(name: string, buffer: gfx.Buffer): void;
            abstract setTexture(name: string, texture: gfx.Texture): void;
            abstract setReadWriteBuffer(name: string, buffer: gfx.Buffer): void;
            abstract setReadWriteTexture(name: string, texture: gfx.Texture): void;
            abstract setSampler(name: string, sampler: gfx.Sampler): void;
        }
        export abstract class _cocos_core_pipeline_custom_pipeline__RasterQueueBuilder extends _cocos_core_pipeline_custom_pipeline__Setter {
            abstract addSceneOfCamera(camera: renderer.scene.Camera, light: _cocos_core_pipeline_custom_types__LightInfo, sceneFlags: _cocos_core_pipeline_custom_types__SceneFlags, name: string): void;
            abstract addSceneOfCamera(camera: renderer.scene.Camera, light: _cocos_core_pipeline_custom_types__LightInfo, sceneFlags: _cocos_core_pipeline_custom_types__SceneFlags): void;
            abstract addScene(name: string, sceneFlags: _cocos_core_pipeline_custom_types__SceneFlags): void;
            abstract addFullscreenQuad(material: Material, sceneFlags: _cocos_core_pipeline_custom_types__SceneFlags, name: string): void;
            abstract addFullscreenQuad(material: Material, sceneFlags: _cocos_core_pipeline_custom_types__SceneFlags): void;
            abstract addCameraQuad(camera: renderer.scene.Camera, material: Material, sceneFlags: _cocos_core_pipeline_custom_types__SceneFlags, name: string): void;
            abstract addCameraQuad(camera: renderer.scene.Camera, material: Material, sceneFlags: _cocos_core_pipeline_custom_types__SceneFlags): void;
            abstract clearRenderTarget(name: string, color: gfx.Color): void;
            abstract setViewport(viewport: gfx.Viewport): void;
        }
        export abstract class _cocos_core_pipeline_custom_pipeline__RasterPassBuilder extends _cocos_core_pipeline_custom_pipeline__Setter {
            abstract addRasterView(name: string, view: _cocos_core_pipeline_custom_types__RasterView): void;
            abstract addComputeView(name: string, view: _cocos_core_pipeline_custom_types__ComputeView): void;
            abstract addQueue(hint: _cocos_core_pipeline_custom_types__QueueHint, name: string): _cocos_core_pipeline_custom_pipeline__RasterQueueBuilder;
            abstract addQueue(hint: _cocos_core_pipeline_custom_types__QueueHint): _cocos_core_pipeline_custom_pipeline__RasterQueueBuilder;
            abstract addFullscreenQuad(material: Material, sceneFlags: _cocos_core_pipeline_custom_types__SceneFlags, name: string): void;
            abstract addFullscreenQuad(material: Material, sceneFlags: _cocos_core_pipeline_custom_types__SceneFlags): void;
            abstract addCameraQuad(camera: renderer.scene.Camera, material: Material, sceneFlags: _cocos_core_pipeline_custom_types__SceneFlags, name: string): void;
            abstract addCameraQuad(camera: renderer.scene.Camera, material: Material, sceneFlags: _cocos_core_pipeline_custom_types__SceneFlags): void;
            abstract setViewport(viewport: gfx.Viewport): void;
        }
        export abstract class _cocos_core_pipeline_custom_pipeline__ComputeQueueBuilder extends _cocos_core_pipeline_custom_pipeline__Setter {
            abstract addDispatch(shader: string, threadGroupCountX: number, threadGroupCountY: number, threadGroupCountZ: number, name: string): void;
            abstract addDispatch(shader: string, threadGroupCountX: number, threadGroupCountY: number, threadGroupCountZ: number): void;
        }
        export abstract class _cocos_core_pipeline_custom_pipeline__ComputePassBuilder extends _cocos_core_pipeline_custom_pipeline__Setter {
            abstract addComputeView(name: string, view: _cocos_core_pipeline_custom_types__ComputeView): void;
            abstract addQueue(name: string): _cocos_core_pipeline_custom_pipeline__ComputeQueueBuilder;
            abstract addQueue(): _cocos_core_pipeline_custom_pipeline__ComputeQueueBuilder;
            abstract addDispatch(shader: string, threadGroupCountX: number, threadGroupCountY: number, threadGroupCountZ: number, name: string): void;
            abstract addDispatch(shader: string, threadGroupCountX: number, threadGroupCountY: number, threadGroupCountZ: number): void;
        }
        export class _cocos_core_pipeline_custom_render_graph__MovePair {
            constructor(source?: string, target?: string, mipLevels?: number, numSlices?: number, targetMostDetailedMip?: number, targetFirstSlice?: number, targetPlaneSlice?: number);
            source: string;
            target: string;
            mipLevels: number;
            numSlices: number;
            targetMostDetailedMip: number;
            targetFirstSlice: number;
            targetPlaneSlice: number;
        }
        export abstract class _cocos_core_pipeline_custom_pipeline__MovePassBuilder {
            abstract addPair(pair: _cocos_core_pipeline_custom_render_graph__MovePair): void;
        }
        export class _cocos_core_pipeline_custom_render_graph__CopyPair {
            constructor(source?: string, target?: string, mipLevels?: number, numSlices?: number, sourceMostDetailedMip?: number, sourceFirstSlice?: number, sourcePlaneSlice?: number, targetMostDetailedMip?: number, targetFirstSlice?: number, targetPlaneSlice?: number);
            source: string;
            target: string;
            mipLevels: number;
            numSlices: number;
            sourceMostDetailedMip: number;
            sourceFirstSlice: number;
            sourcePlaneSlice: number;
            targetMostDetailedMip: number;
            targetFirstSlice: number;
            targetPlaneSlice: number;
        }
        export abstract class _cocos_core_pipeline_custom_pipeline__CopyPassBuilder {
            abstract addPair(pair: _cocos_core_pipeline_custom_render_graph__CopyPair): void;
        }
        export abstract class _cocos_core_pipeline_custom_pipeline__SceneVisitor {
            abstract get pipelineSceneData(): PipelineSceneData;
            abstract setViewport(vp: gfx.Viewport): void;
            abstract setScissor(rect: gfx.Rect): void;
            abstract bindPipelineState(pso: gfx.PipelineState): void;
            abstract bindInputAssembler(ia: gfx.InputAssembler): void;
            abstract draw(info: gfx.DrawInfo): void;
            abstract bindDescriptorSet(set: number, descriptorSet: gfx.DescriptorSet, dynamicOffsets?: number[]): void;
            abstract updateBuffer(buffer: gfx.Buffer, data: ArrayBuffer, size?: number): void;
        }
        export const enum _cocos_core_pipeline_custom_types__TaskType {
            SYNC = 0,
            ASYNC = 1
        }
        export abstract class _cocos_core_pipeline_custom_pipeline__SceneTask {
            abstract get taskType(): _cocos_core_pipeline_custom_types__TaskType;
            abstract start(): void;
            abstract join(): void;
            abstract submit(): void;
        }
        export abstract class _cocos_core_pipeline_custom_pipeline__SceneTransversal {
            abstract transverse(visitor: _cocos_core_pipeline_custom_pipeline__SceneVisitor): _cocos_core_pipeline_custom_pipeline__SceneTask;
        }
        export const enum _cocos_core_pipeline_custom_types__UpdateFrequency {
            PER_INSTANCE = 0,
            PER_BATCH = 1,
            PER_QUEUE = 2,
            PER_PASS = 3,
            COUNT = 4
        }
        export const enum _cocos_core_pipeline_custom_types__ParameterType {
            CONSTANTS = 0,
            CBV = 1,
            UAV = 2,
            SRV = 3,
            TABLE = 4,
            SSV = 5
        }
        export const enum _cocos_core_pipeline_custom_layout_graph__DescriptorTypeOrder {
            UNIFORM_BUFFER = 0,
            DYNAMIC_UNIFORM_BUFFER = 1,
            SAMPLER_TEXTURE = 2,
            SAMPLER = 3,
            TEXTURE = 4,
            STORAGE_BUFFER = 5,
            DYNAMIC_STORAGE_BUFFER = 6,
            STORAGE_IMAGE = 7,
            INPUT_ATTACHMENT = 8
        }
        export class _cocos_core_pipeline_custom_layout_graph__DescriptorBlockIndex {
            constructor(updateFrequency?: _cocos_core_pipeline_custom_types__UpdateFrequency, parameterType?: _cocos_core_pipeline_custom_types__ParameterType, descriptorType?: _cocos_core_pipeline_custom_layout_graph__DescriptorTypeOrder, visibility?: gfx.ShaderStageFlagBit);
            updateFrequency: _cocos_core_pipeline_custom_types__UpdateFrequency;
            parameterType: _cocos_core_pipeline_custom_types__ParameterType;
            descriptorType: _cocos_core_pipeline_custom_layout_graph__DescriptorTypeOrder;
            visibility: gfx.ShaderStageFlagBit;
        }
        export class _cocos_core_pipeline_custom_layout_graph__Descriptor {
            constructor(type?: gfx.Type);
            type: gfx.Type;
            count: number;
        }
        export class _cocos_core_pipeline_custom_layout_graph__DescriptorBlockFlattened {
            readonly descriptorNames: string[];
            readonly uniformBlockNames: string[];
            readonly descriptors: _cocos_core_pipeline_custom_layout_graph__Descriptor[];
            readonly uniformBlocks: gfx.UniformBlock[];
            capacity: number;
            count: number;
        }
        export abstract class _cocos_core_pipeline_custom_pipeline__LayoutGraphBuilder {
            abstract clear(): void;
            abstract addRenderStage(name: string): number;
            abstract addRenderPhase(name: string, parentID: number): number;
            abstract addShader(name: string, parentPhaseID: number): void;
            abstract addDescriptorBlock(nodeID: number, index: _cocos_core_pipeline_custom_layout_graph__DescriptorBlockIndex, block: _cocos_core_pipeline_custom_layout_graph__DescriptorBlockFlattened): void;
            abstract addUniformBlock(nodeID: number, index: _cocos_core_pipeline_custom_layout_graph__DescriptorBlockIndex, name: string, uniformBlock: gfx.UniformBlock): void;
            abstract reserveDescriptorBlock(nodeID: number, index: _cocos_core_pipeline_custom_layout_graph__DescriptorBlockIndex, block: _cocos_core_pipeline_custom_layout_graph__DescriptorBlockFlattened): void;
            abstract compile(): number;
            abstract print(): string;
        }
        export abstract class _cocos_core_pipeline_custom_pipeline__Pipeline extends _cocos_core_pipeline_custom_pipeline__PipelineRuntime {
            abstract containsResource(name: string): boolean;
            abstract addRenderTexture(name: string, format: gfx.Format, width: number, height: number, renderWindow: _cocos_core_renderer_core_render_window__RenderWindow): number;
            abstract addRenderTarget(name: string, format: gfx.Format, width: number, height: number, residency: _cocos_core_pipeline_custom_types__ResourceResidency): number;
            abstract addDepthStencil(name: string, format: gfx.Format, width: number, height: number, residency: _cocos_core_pipeline_custom_types__ResourceResidency): number;
            abstract beginFrame(): void;
            abstract endFrame(): void;
            abstract addRasterPass(width: number, height: number, layoutName: string, name: string): _cocos_core_pipeline_custom_pipeline__RasterPassBuilder;
            abstract addRasterPass(width: number, height: number, layoutName: string): _cocos_core_pipeline_custom_pipeline__RasterPassBuilder;
            abstract addComputePass(layoutName: string, name: string): _cocos_core_pipeline_custom_pipeline__ComputePassBuilder;
            abstract addComputePass(layoutName: string): _cocos_core_pipeline_custom_pipeline__ComputePassBuilder;
            abstract addMovePass(name: string): _cocos_core_pipeline_custom_pipeline__MovePassBuilder;
            abstract addCopyPass(name: string): _cocos_core_pipeline_custom_pipeline__CopyPassBuilder;
            abstract presentAll(): void;
            abstract createSceneTransversal(camera: renderer.scene.Camera, scene: renderer.RenderScene): _cocos_core_pipeline_custom_pipeline__SceneTransversal;
            abstract get layoutGraphBuilder(): _cocos_core_pipeline_custom_pipeline__LayoutGraphBuilder;
            abstract getDescriptorSetLayout(shaderName: string, freq: _cocos_core_pipeline_custom_types__UpdateFrequency): gfx.DescriptorSetLayout | null;
        }
        export interface _cocos_core_pipeline_pipeline_event__IPipelineEvent {
            on(type: PipelineEventType, callback: any, target?: any, once?: boolean): typeof callback;
            once(type: PipelineEventType, callback: any, target?: any): typeof callback;
            off(type: PipelineEventType, callback?: any, target?: any): any;
            emit(type: PipelineEventType, arg0?: any, arg1?: any, arg2?: any, arg3?: any, arg4?: any): any;
            targetOff(typeOrTarget: any): void;
            removeAll(typeOrTarget: any): void;
            hasEventListener(type: PipelineEventType, callback?: any, target?: any): boolean;
        }
        export interface _cocos_3d_skeletal_animation_skeletal_animation_utils__IChunkContent {
            skeleton: number;
            clips: number[];
        }
        export interface _cocos_3d_skeletal_animation_skeletal_animation_utils__ICustomJointTextureLayout {
            textureLength: number;
            contents: _cocos_3d_skeletal_animation_skeletal_animation_utils__IChunkContent[];
        }
        /**
         * The pool for joint textures.
         * @internal
         */
        export class _cocos_3d_skeletal_animation_skeletal_animation_utils__JointTexturePool {
            get pixelsPerJoint(): number;
            constructor(device: gfx.Device);
            clear(): void;
            registerCustomTextureLayouts(layouts: _cocos_3d_skeletal_animation_skeletal_animation_utils__ICustomJointTextureLayout[]): void;
            /**
             * @en
             * Get joint texture for the default pose.
             * @zh
             * 获取默认姿势的骨骼贴图。
             */
            getDefaultPoseTexture(skeleton: Skeleton, mesh: Mesh, skinningRoot: Node): _cocos_3d_skeletal_animation_skeletal_animation_utils__IJointTextureHandle | null;
            /**
             * @en
             * Get joint texture for the specified animation clip.
             * @zh
             * 获取指定动画片段的骨骼贴图。
             */
            getSequencePoseTexture(skeleton: Skeleton, clip: AnimationClip, mesh: Mesh, skinningRoot: Node): _cocos_3d_skeletal_animation_skeletal_animation_utils__IJointTextureHandle | null;
            releaseHandle(handle: _cocos_3d_skeletal_animation_skeletal_animation_utils__IJointTextureHandle): void;
            releaseSkeleton(skeleton: Skeleton): void;
            releaseAnimationClip(clip: AnimationClip): void;
        }
        export interface _cocos_3d_skeletal_animation_skeletal_animation_utils__IAnimInfo {
            buffer: gfx.Buffer;
            data: Float32Array;
            dirty: boolean;
            dirtyForJSB: Uint8Array;
            currentClip: AnimationClip | null;
        }
        export class _cocos_3d_skeletal_animation_skeletal_animation_utils__JointAnimationInfo {
            constructor(device: gfx.Device);
            getData(nodeID?: string): _cocos_3d_skeletal_animation_skeletal_animation_utils__IAnimInfo;
            destroy(nodeID: string): void;
            switchClip(info: _cocos_3d_skeletal_animation_skeletal_animation_utils__IAnimInfo, clip: AnimationClip | null): _cocos_3d_skeletal_animation_skeletal_animation_utils__IAnimInfo;
            clear(): void;
        }
        export class _cocos_3d_skeletal_animation_data_pool_manager__DataPoolManager {
            jointTexturePool: _cocos_3d_skeletal_animation_skeletal_animation_utils__JointTexturePool;
            jointAnimationInfo: _cocos_3d_skeletal_animation_skeletal_animation_utils__JointAnimationInfo;
            constructor(device: gfx.Device);
            releaseSkeleton(skeleton: Skeleton): void;
            releaseAnimationClip(clip: AnimationClip): void;
            clear(): void;
        }
        /**
         * @en Initialization information for the Root
         * @zh Root 初始化描述信息
         */
        export interface _cocos_core_root__IRootInfo {
            enableHDR?: boolean;
        }
        /**
         * @en
         * Define an enum type. <br/>
         * If a enum item has a value of -1, it will be given an Integer number according to it's order in the list.<br/>
         * Otherwise it will use the value specified by user who writes the enum definition.
         *
         * @zh
         * 定义一个枚举类型。<br/>
         * 用户可以把枚举值设为任意的整数，如果设为 -1，系统将会分配为上一个枚举值 + 1。
         *
         * @param obj
         * @en A JavaScript literal object containing enum names and values, or a TypeScript enum type.
         * @zh 包含枚举名和值的 JavaScript literal 对象，或者是一个 TypeScript enum 类型。
         * @return @en The defined enum type. @zh 定义的枚举类型。
         */
        export function _cocos_core_value_types_enum__Enum<T>(obj: T): T;
        export namespace _cocos_core_value_types_enum__Enum {
            var update: <T>(obj: T) => T;
            var isEnum: <EnumT extends {}>(enumType: EnumT) => boolean;
            var getList: <EnumT extends {}>(enumType: EnumT) => readonly _cocos_core_value_types_enum__Enum.Enumerator<EnumT>[];
        }
        export namespace _cocos_core_value_types_enum__Enum {
            interface Enumerator<EnumT> {
                /**
                 * The name of the enumerator.
                 */
                name: keyof EnumT;
                /**
                 * The value of the numerator.
                 */
                value: EnumT[keyof EnumT];
            }
        }
        export type _cocos_core_utils_pool__CleanUpFunction<T> = (value: T) => boolean | void;
        namespace _cocos_core_utils_array {
            export function removeAt<T>(array: T[], index: number): void;
            export function fastRemoveAt<T>(array: T[], index: number): void;
            export function remove<T>(array: T[], value: T): boolean;
            export function fastRemove<T>(array: T[], value: T): void;
            export function removeIf<T>(array: T[], predicate: (value: T) => boolean): T | undefined;
            export function verifyType<T extends Function>(array: any[], type: T): array is T[];
            export function removeArray<T>(array: T[], removals: T[]): void;
            export function appendObjectsAt<T>(array: T[], objects: T[], index: number): T[];
            export function contains<T>(array: T[], value: T): boolean;
            export function copy<T>(array: T[]): T[];
        }
        export type _types_globals__Getter = () => any;
        export type _types_globals__Setter = (value: any) => void;
        export interface _cocos_core_utils_x_deprecated__IReplacement {
            /** 废弃属性的名称 */
            name: string;
            /** 警告的次数 */
            logTimes?: number;
            /** 替换属性的名称 */
            newName?: string;
            /** 废弃属性的所属对象 */
            target?: object;
            /** 废弃属性的所属对象的名称 */
            targetName?: string;
            /** 自定义替换属性（函数） */
            customFunction?: Function;
            /** 自定义替换属性的 setter */
            customSetter?: (v: any) => void;
            /** 自定义替换属性的 getter */
            customGetter?: () => any;
            /** 额外建议 */
            suggest?: string;
        }
        export interface _cocos_core_utils_x_deprecated__IRemoveItem {
            /** 废弃属性的名称 */
            name: string;
            /** 警告的次数 */
            logTimes?: number;
            /** 额外建议 */
            suggest?: string;
        }
        export interface _cocos_core_utils_x_deprecated__IMarkItem {
            /** 废弃属性的名称 */
            name: string;
            /** 警告的次数 */
            logTimes?: number;
            /** 额外建议 */
            suggest?: string;
        }
        export type _cocos_core_data_utils_attribute_defines__GroupOptions = {
            name: string;
        } & Partial<{
            id: string;
            name: string;
            displayOrder: number;
            style: string;
        }>;
        export interface _cocos_core_data_utils_attribute_defines__IExposedAttributes {
            /**
             * 指定属性的类型。
             */
            type?: any;
            /**
             * 控制是否在编辑器中显示该属性。
             */
            visible?: boolean | (() => boolean);
            /**
             * 该属性在编辑器中的显示名称。
             */
            displayName?: string;
            /**
             *
             */
            displayOrder?: number;
            /**
             * @en Editor tooltip of this property.
             * @zh 该属性在编辑器中的工具提示内容。
             */
            tooltip?: string;
            /**
             * @en The group name where this property is organized into, on property inspector.
             * @zh 在属性检查器上该属性所属的分类标签名。
             */
            group?: string | _cocos_core_data_utils_attribute_defines__GroupOptions;
            /**
             *
             */
            multiline?: boolean;
            /**
             * 指定该属性是否为可读的。
             * 将 `readonly` 指定为 `true` 或选项对象时都将标记为该属性是可读的；
             * 当指定为 `true` 时将应用所有默认的只读性质。
             * @default false
             */
            readonly?: boolean | {
                /**
                 * 如果该属性是对象或数组，指定该对象的属性或该数组的元素是否是只读的。
                 * 若为 `true`，递归的所有属性或元素都将是只读的。
                 * @default true
                 */
                deep?: boolean;
            };
            /**
             * 当该属性为数值类型时，指定了该属性允许的最小值。
             */
            min?: number;
            /**
             * 当该属性为数值类型时，指定了该属性允许的最大值。
             */
            max?: number;
            /**
             * 当该属性为数值类型时并在编辑器中提供了滑动条时，指定了滑动条的步长。
             */
            step?: number;
            /**
             * 当该属性为数值类型时，指定了该属性允许的范围。
             */
            range?: number[];
            /**
             * 当该属性为数值类型时，是否在编辑器中提供滑动条来调节值。
             */
            slide?: boolean;
            /**
             * 该属性是否参与序列化和反序列化。
             */
            serializable?: boolean;
            /**
             * 该属性的曾用名。
             */
            formerlySerializedAs?: string;
            /**
             * 该属性是否仅仅在编辑器环境中生效。
             */
            editorOnly?: boolean;
            /**
             * 是否覆盖基类中的同名属性。
             */
            override?: boolean;
            /**
             *
             */
            animatable?: boolean;
            /**
             *
             */
            unit?: string;
            /**
             * 转换为弧度
             */
            radian?: boolean;
        }
        /**
         * @zh CCClass 属性选项。
         * @en CCClass property options
         */
        export type _cocos_core_data_decorators_property__IPropertyOptions = _cocos_core_data_utils_attribute_defines__IExposedAttributes;
        export type _cocos_core_data_decorators_utils__BabelPropertyDecoratorDescriptor = PropertyDescriptor & {
            initializer?: any;
        };
        /**
         * @en
         * The signature compatible with both TypeScript legacy decorator and Babel legacy decorator.
         * The `descriptor` argument will only appear in Babel case.
         * @zh
         * 该签名同时兼容 TypeScript legacy 装饰器以及 Babel legacy 装饰器。
         * `descriptor` 参数只会在 Babel 情况下出现。
         */
        export type _cocos_core_data_decorators_utils__LegacyPropertyDecorator = (target: Object, propertyKey: string | symbol, descriptor?: _cocos_core_data_decorators_utils__BabelPropertyDecoratorDescriptor) => void;
        export type _cocos_core_data_decorators_property__SimplePropertyType = Function | string | typeof CCString | typeof CCInteger | typeof CCFloat | typeof CCBoolean;
        export type _cocos_core_data_decorators_property__PropertyType = _cocos_core_data_decorators_property__SimplePropertyType | _cocos_core_data_decorators_property__SimplePropertyType[];
        export class _cocos_core_data_utils_attribute__PrimitiveType<T> {
            name: string;
            default: T;
            constructor(name: string, defaultValue: T);
            toString(): string;
        }
        namespace _cocos_core_data_utils_attribute {
            export const DELIMETER = "$_$";
            export function createAttrsSingle(owner: Object, superAttrs?: any): any;
            export function createAttrs(subclass: any): any;
            export function attr(constructor: any, propertyName: string): {
                [attributeName: string]: any;
            };
            export function getClassAttrs(constructor: any): any;
            export function setClassAttr(ctor: any, propName: any, key: any, value: any): void;
            export class PrimitiveType<T> {
                name: string;
                default: T;
                constructor(name: string, defaultValue: T);
                toString(): string;
            }
            export const CCInteger: _cocos_core_data_utils_attribute__PrimitiveType<number>;
            export const CCFloat: _cocos_core_data_utils_attribute__PrimitiveType<number>;
            export const CCBoolean: _cocos_core_data_utils_attribute__PrimitiveType<boolean>;
            export const CCString: _cocos_core_data_utils_attribute__PrimitiveType<string>;
            export function getTypeChecker_ET(type: string, attributeName: string): (constructor: Function, mainPropertyName: string) => void;
            export function getObjTypeChecker_ET(typeCtor: any): (classCtor: any, mainPropName: any) => void;
        }
        /**
         * Tag the class with any meta attributes, then return all current attributes assigned to it.
         * This function holds only the attributes, not their implementations.
         * @param constructor The class or instance. If instance, the attribute will be dynamic and only available for the specified instance.
         * @param propertyName The name of property or function, used to retrieve the attributes.
         * @private
         */
        export function _cocos_core_data_utils_attribute__attr(constructor: any, propertyName: string): {
            [attributeName: string]: any;
        };
        /**
         * Returns if the class is a cc-class or is fast defined.
         * @param constructor The constructor of the class.
         * @returns Judge result.
         */
        export function _cocos_core_data_class__isCCClassOrFastDefined<T>(constructor: _types_globals__Constructor<T>): boolean;
        export class _cocos_core_data_deserialize__FileInfo {
            version: number;
            preprocessed: boolean;
            constructor(version: number);
        }
        export type _cocos_core_data_deserialize__SharedString = string;
        export const _cocos_core_data_deserialize__EMPTY_PLACEHOLDER = 0;
        export type _cocos_core_data_deserialize__Empty = typeof _cocos_core_data_deserialize__EMPTY_PLACEHOLDER;
        export type _cocos_core_data_deserialize__Ctor<T> = new () => T;
        export type _cocos_core_data_deserialize__AnyCtor = _cocos_core_data_deserialize__Ctor<Object>;
        export type _cocos_core_data_deserialize__IClass = [
            string | _cocos_core_data_deserialize__AnyCtor,
            string[],
            number,
            ...deserialize.Internal.DataTypeID_[]
        ];
        export type _cocos_core_data_deserialize_dynamic__ClassFinder = deserialize.ClassFinder;
        export type _cocos_core_data_deserialize_dynamic__ReportMissingClass = deserialize.ReportMissingClass;
        export class _cocos_core_data_deserialize_dynamic__DeserializerPool extends js.Pool<_cocos_core_data_deserialize_dynamic___Deserializer> {
            constructor();
            get(details: Details, classFinder: _cocos_core_data_deserialize_dynamic__ClassFinder, reportMissingClass: _cocos_core_data_deserialize_dynamic__ReportMissingClass, customEnv: unknown, ignoreEditorOnly: boolean | undefined): _cocos_core_data_deserialize_dynamic___Deserializer;
        }
        export type _cocos_core_data_deserialize_dynamic__TypedArrayViewConstructorName = "Uint8Array" | "Int8Array" | "Uint16Array" | "Int16Array" | "Uint32Array" | "Int32Array" | "Float32Array" | "Float64Array";
        export type _cocos_core_data_deserialize_dynamic__SerializedTypedArray = {
            __id__: never;
            __uuid__: never;
            __type__: "TypedArray";
            array: number[];
            ctor: _cocos_core_data_deserialize_dynamic__TypedArrayViewConstructorName;
        };
        export type _cocos_core_data_deserialize_dynamic__SerializedTypedArrayRef = {
            __id__: never;
            __uuid__: never;
            __type__: "TypedArrayRef";
            ctor: _cocos_core_data_deserialize_dynamic__TypedArrayViewConstructorName;
            offset: number;
            length: number;
        };
        export type _cocos_core_data_deserialize_dynamic__NotA<T, ReservedNames> = T extends ReservedNames ? never : T;
        export type _cocos_core_data_deserialize_dynamic__NotB<T, ReservedNames> = ReservedNames extends T ? never : T;
        export type _cocos_core_data_deserialize_dynamic__FooName<T, ReservedNames> = _cocos_core_data_deserialize_dynamic__NotA<T, ReservedNames> & _cocos_core_data_deserialize_dynamic__NotB<T, ReservedNames>;
        export type _cocos_core_data_deserialize_dynamic__NotKnownTypeTag = _cocos_core_data_deserialize_dynamic__FooName<string, "TypedArray" | "TypedArrayRef">;
        export type _cocos_core_data_deserialize_dynamic__NotTypeTag = _cocos_core_data_deserialize_dynamic__FooName<string, "__type__">;
        export type _cocos_core_data_deserialize_dynamic__SerializedObjectReference = {
            __type__: never;
            __uuid__: never;
            __id__: number;
        };
        export type _cocos_core_data_deserialize_dynamic__SerializedUUIDReference = {
            __type__: never;
            __id__: never;
            __uuid__: string;
            __expectedType__: string;
        };
        export type _cocos_core_data_deserialize_dynamic__SerializedFieldObjectValue = _cocos_core_data_deserialize_dynamic__SerializedObjectReference | _cocos_core_data_deserialize_dynamic__SerializedUUIDReference | unknown;
        export type _cocos_core_data_deserialize_dynamic__SerializedFieldValue = string | number | boolean | null | _cocos_core_data_deserialize_dynamic__SerializedFieldObjectValue;
        export type _cocos_core_data_deserialize_dynamic__SerializedGeneralTypedObject = {
            __id__: never;
            __uuid__: never;
            __type__?: _cocos_core_data_deserialize_dynamic__NotKnownTypeTag;
        } & Record<_cocos_core_data_deserialize_dynamic__NotTypeTag, _cocos_core_data_deserialize_dynamic__SerializedFieldValue>;
        export type _cocos_core_data_deserialize_dynamic__SerializedObject = _cocos_core_data_deserialize_dynamic__SerializedTypedArray | _cocos_core_data_deserialize_dynamic__SerializedTypedArrayRef | _cocos_core_data_deserialize_dynamic__SerializedGeneralTypedObject;
        export type _cocos_core_data_deserialize_dynamic__SerializedData = _cocos_core_data_deserialize_dynamic__SerializedObject | _cocos_core_data_deserialize_dynamic__SerializedObject[];
        export class _cocos_core_data_deserialize_dynamic___Deserializer {
            static pool: _cocos_core_data_deserialize_dynamic__DeserializerPool;
            result: Details;
            customEnv: unknown;
            deserializedList: Array<Record<PropertyKey, unknown> | undefined>;
            deserializedData: any;
            constructor(result: Details, classFinder: _cocos_core_data_deserialize_dynamic__ClassFinder, reportMissingClass: _cocos_core_data_deserialize_dynamic__ReportMissingClass, customEnv: unknown, ignoreEditorOnly: unknown);
            reset(result: Details, classFinder: _cocos_core_data_deserialize_dynamic__ClassFinder, reportMissingClass: _cocos_core_data_deserialize_dynamic__ReportMissingClass, customEnv: unknown, ignoreEditorOnly: unknown): void;
            clear(): void;
            deserialize(serializedData: _cocos_core_data_deserialize_dynamic__SerializedData | CCON): any;
        }
        /**
         * Alias of `Function` but suppress eslint warning.
         * Please avoid using it and explicitly specify function signatures as possible.
         */
        // eslint-disable-next-line @typescript-eslint/ban-types
        export type _types_globals__AnyFunction = Function;
        export type _cocos_core_data_deserialize_dynamic__CompiledDeserializeFn = (deserializer: _cocos_core_data_deserialize_dynamic___Deserializer, object: Record<string, unknown>, deserialized: Record<string, unknown>, constructor: _types_globals__AnyFunction) => void;
        export interface _cocos_core_data_deserialize__CCClassConstructor<T> extends _cocos_core_data_deserialize__Ctor<T> {
            __values__: string[];
            __deserialize__?: _cocos_core_data_deserialize_dynamic__CompiledDeserializeFn;
        }
        export type _cocos_core_data_deserialize__AnyCCClass = _cocos_core_data_deserialize__CCClassConstructor<Object>;
        export type _cocos_core_data_deserialize__IMask = [
            number,
            ...number[]
        ];
        export type _cocos_core_data_deserialize__InstanceIndex = number;
        export type _cocos_core_data_deserialize__ReverseIndex = number;
        /** **************************************************************************
         * TYPE DECLARATIONS
         *************************************************************************** */
        export type _cocos_core_data_deserialize__Bnot<T extends number, U extends number> = T | U;
        export type _cocos_core_data_deserialize__InstanceBnotReverseIndex = _cocos_core_data_deserialize__Bnot<_cocos_core_data_deserialize__InstanceIndex, _cocos_core_data_deserialize__ReverseIndex>;
        export type _cocos_core_data_deserialize__IValueTypeData = [
            number,
            ...number[]
        ];
        export type _cocos_core_data_deserialize__ITRSData = [
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number
        ];
        export const _cocos_core_data_deserialize__CUSTOM_OBJ_DATA_CLASS = 0;
        export const _cocos_core_data_deserialize__CUSTOM_OBJ_DATA_CONTENT = 1;
        export type _cocos_core_data_deserialize__ICustomObjectDataContent = any;
        export interface _cocos_core_data_deserialize__ICustomObjectData extends Array<any> {
            [_cocos_core_data_deserialize__CUSTOM_OBJ_DATA_CLASS]: number;
            [_cocos_core_data_deserialize__CUSTOM_OBJ_DATA_CONTENT]: _cocos_core_data_deserialize__ICustomObjectDataContent;
        }
        export const _cocos_core_data_deserialize__DICT_JSON_LAYOUT = 0;
        export type _cocos_core_data_deserialize__AdvancedTypeID = Exclude<deserialize.Internal.DataTypeID_, deserialize.Internal.DataTypeID_.SimpleType>;
        export type _cocos_core_data_deserialize__AdvancedData = _cocos_core_data_deserialize__DataTypes[Exclude<keyof _cocos_core_data_deserialize__DataTypes, deserialize.Internal.DataTypeID_.SimpleType>];
        export interface _cocos_core_data_deserialize__IDictData extends Array<any> {
            [_cocos_core_data_deserialize__DICT_JSON_LAYOUT]: any;
            [1]: string;
            [2]: _cocos_core_data_deserialize__AdvancedTypeID;
            [3]: _cocos_core_data_deserialize__AdvancedData;
            [index: number]: any;
        }
        export type _cocos_core_data_deserialize__IArrayData = [
            _cocos_core_data_deserialize__AnyData[],
            ...deserialize.Internal.DataTypeID_[]
        ];
        export interface _cocos_core_data_deserialize__DataTypes {
            [deserialize.Internal.DataTypeID_.SimpleType]: number | string | boolean | null | object;
            [deserialize.Internal.DataTypeID_.InstanceRef]: _cocos_core_data_deserialize__InstanceBnotReverseIndex;
            [deserialize.Internal.DataTypeID_.Array_InstanceRef]: _cocos_core_data_deserialize__DataTypes[deserialize.Internal.DataTypeID_.InstanceRef][];
            [deserialize.Internal.DataTypeID_.Array_AssetRefByInnerObj]: _cocos_core_data_deserialize__DataTypes[deserialize.Internal.DataTypeID_.AssetRefByInnerObj][];
            [deserialize.Internal.DataTypeID_.Class]: _cocos_core_data_deserialize__IClassObjectData;
            [deserialize.Internal.DataTypeID_.ValueTypeCreated]: _cocos_core_data_deserialize__IValueTypeData;
            [deserialize.Internal.DataTypeID_.AssetRefByInnerObj]: number;
            [deserialize.Internal.DataTypeID_.TRS]: _cocos_core_data_deserialize__ITRSData;
            [deserialize.Internal.DataTypeID_.ValueType]: _cocos_core_data_deserialize__IValueTypeData;
            [deserialize.Internal.DataTypeID_.Array_Class]: _cocos_core_data_deserialize__DataTypes[deserialize.Internal.DataTypeID_.Class][];
            [deserialize.Internal.DataTypeID_.CustomizedClass]: _cocos_core_data_deserialize__ICustomObjectData;
            [deserialize.Internal.DataTypeID_.Dict]: _cocos_core_data_deserialize__IDictData;
            [deserialize.Internal.DataTypeID_.Array]: _cocos_core_data_deserialize__IArrayData;
        }
        export type _cocos_core_data_deserialize__AnyData = _cocos_core_data_deserialize__DataTypes[keyof _cocos_core_data_deserialize__DataTypes];
        export type _cocos_core_data_deserialize__IClassObjectData = [
            number,
            ..._cocos_core_data_deserialize__AnyData[]
        ];
        export type _cocos_core_data_deserialize__PrimitiveObjectTypeID = (deserialize.Internal.DataTypeID_.SimpleType | deserialize.Internal.DataTypeID_.Array | deserialize.Internal.DataTypeID_.Array_Class | deserialize.Internal.DataTypeID_.Array_AssetRefByInnerObj | deserialize.Internal.DataTypeID_.Array_InstanceRef | deserialize.Internal.DataTypeID_.Dict);
        export type _cocos_core_data_deserialize__OtherObjectData = _cocos_core_data_deserialize__ICustomObjectDataContent | Exclude<_cocos_core_data_deserialize__DataTypes[_cocos_core_data_deserialize__PrimitiveObjectTypeID], (number | string | boolean | null)>;
        export type _cocos_core_data_deserialize__NoNativeDep = boolean;
        export type _cocos_core_data_deserialize__RootInstanceIndex = _cocos_core_data_deserialize__InstanceIndex;
        export type _cocos_core_data_deserialize__BoolAndNum<B extends boolean, N extends number> = _cocos_core_data_deserialize__Bnot<N, N>;
        export type _cocos_core_data_deserialize__RootInfo = _cocos_core_data_deserialize__BoolAndNum<_cocos_core_data_deserialize__NoNativeDep, _cocos_core_data_deserialize__RootInstanceIndex>;
        export type _cocos_core_data_deserialize__OtherObjectTypeID = _cocos_core_data_deserialize__Bnot<number, _cocos_core_data_deserialize__PrimitiveObjectTypeID>;
        export type _cocos_core_data_deserialize__StringIndex = number;
        export type _cocos_core_data_deserialize__StringIndexBnotNumber = _cocos_core_data_deserialize__Bnot<_cocos_core_data_deserialize__StringIndex, number>;
        export interface _cocos_core_data_deserialize__IRefs extends Array<number> {
            [0]: (object | _cocos_core_data_deserialize__InstanceIndex);
            [1]?: _cocos_core_data_deserialize__StringIndexBnotNumber;
            [2]?: _cocos_core_data_deserialize__InstanceIndex;
            [index: number]: any;
        }
        export interface _cocos_core_data_deserialize__IFileData extends Array<any> {
            [deserialize.Internal.File_.Version]: number | _cocos_core_data_deserialize__FileInfo | any;
            [deserialize.Internal.File_.SharedUuids]: _cocos_core_data_deserialize__SharedString[] | _cocos_core_data_deserialize__Empty;
            [deserialize.Internal.File_.SharedStrings]: _cocos_core_data_deserialize__SharedString[] | _cocos_core_data_deserialize__Empty;
            [deserialize.Internal.File_.SharedClasses]: (_cocos_core_data_deserialize__IClass | string | _cocos_core_data_deserialize__AnyCCClass)[];
            [deserialize.Internal.File_.SharedMasks]: _cocos_core_data_deserialize__IMask[] | _cocos_core_data_deserialize__Empty;
            [deserialize.Internal.File_.Instances]: (_cocos_core_data_deserialize__IClassObjectData | _cocos_core_data_deserialize__OtherObjectData | _cocos_core_data_deserialize__RootInfo)[];
            [deserialize.Internal.File_.InstanceTypes]: _cocos_core_data_deserialize__OtherObjectTypeID[] | _cocos_core_data_deserialize__Empty;
            [deserialize.Internal.File_.Refs]: _cocos_core_data_deserialize__IRefs | _cocos_core_data_deserialize__Empty;
            [deserialize.Internal.File_.DependObjs]: (object | _cocos_core_data_deserialize__InstanceIndex)[];
            [deserialize.Internal.File_.DependKeys]: (_cocos_core_data_deserialize__StringIndexBnotNumber | string)[];
            [deserialize.Internal.File_.DependUuidIndices]: (_cocos_core_data_deserialize__StringIndex | string)[];
        }
        export interface _cocos_core_data_deserialize__ICustomHandler {
            result: Details;
            customEnv: any;
        }
        export type _cocos_core_data_deserialize__ClassFinder = (type: string) => _cocos_core_data_deserialize__AnyCtor;
        export interface _cocos_core_data_deserialize__IOptions extends Partial<_cocos_core_data_deserialize__ICustomHandler> {
            classFinder?: _cocos_core_data_deserialize__ClassFinder;
            reportMissingClass: deserialize.ReportMissingClass;
            _version?: number;
        }
        export type _cocos_core_data_deserialize__Shared = Pick<_cocos_core_data_deserialize__IFileData, deserialize.Internal.File_.Version | deserialize.Internal.File_.SharedUuids | deserialize.Internal.File_.SharedStrings | deserialize.Internal.File_.SharedClasses | deserialize.Internal.File_.SharedMasks>;
        export const _cocos_core_data_deserialize__PACKED_SECTIONS = deserialize.Internal.File_.Instances;
        export interface _cocos_core_data_deserialize__IPackedFileData extends _cocos_core_data_deserialize__Shared {
            [_cocos_core_data_deserialize__PACKED_SECTIONS]: _cocos_core_data_deserialize__IFileData[];
        }
        export function _cocos_core_data_report_missing_class__reportMissingClass(id: string): void;
        export function _cocos_core_data_deserialize__isCompiledJson(json: unknown): boolean;
        function _cocos_core_data_deserialize__serializeBuiltinValueTypes(obj: ValueType): _cocos_core_data_deserialize__IValueTypeData | null;
        function _cocos_core_data_instantiate__doInstantiate(obj: any, parent?: any): any;
        export enum _cocos_core_data_utils_compact_value_type_array__StorageUnit {
            Uint8 = 0,
            Uint16 = 1,
            Uint32 = 2,
            Int8 = 3,
            Int16 = 4,
            Int32 = 5,
            Float32 = 6,
            Float64 = 7
        }
        export enum _cocos_core_data_utils_compact_value_type_array__ElementType {
            Scalar = 0,
            Vec2 = 1,
            Vec3 = 2,
            Vec4 = 3,
            Quat = 4,
            Mat4 = 5
        }
        export type _cocos_core_data_custom_serializable__DeserializationContext = {
            /**
             * True if the deserialization procedure is deserializing from CCON.
             */
            fromCCON: boolean;
        };
        export class _cocos_core_event_event_target__Empty {
        }
        export type _cocos_core_event_eventify__Constructor<T> = new (...args: any[]) => T;
        /**
         * @param error - null or the error info
         * @param node - the created node or null
         */
        export type _cocos_core_assets_asset__CreateNodeCallback = (error: Error | null, node: Node) => void;
        export const _cocos_core_assets_asset__Asset_base: new (...args: any[]) => CCObject & _cocos_core_event_eventify__IEventified;
        /**
         * @en Array views for index buffer
         * @zh 允许存储索引的数组视图。
         */
        export type _cocos_core_assets_rendering_sub_mesh__IBArray = Uint8Array | Uint16Array | Uint32Array;
        /**
         * @en The interface of geometric information
         * @zh 几何信息。
         */
        export interface _cocos_core_assets_rendering_sub_mesh__IGeometricInfo {
            /**
             * @en Vertex positions
             * @zh 顶点位置。
             */
            positions: Float32Array;
            /**
             * @en Indices data
             * @zh 索引数据。
             */
            indices?: _cocos_core_assets_rendering_sub_mesh__IBArray;
            /**
             * @en Whether the geometry is treated as double sided
             * @zh 是否将图元按双面对待。
             */
            doubleSided?: boolean;
            /**
             * @en The bounding box
             * @zh 此几何体的轴对齐包围盒。
             */
            boundingBox: {
                max: math.Vec3 | Readonly<math.Vec3>;
                min: math.Vec3 | Readonly<math.Vec3>;
            };
        }
        /**
         * @en Flat vertex buffer
         * @zh 扁平化顶点缓冲区
         */
        export interface _cocos_core_assets_rendering_sub_mesh__IFlatBuffer {
            stride: number;
            count: number;
            buffer: Uint8Array;
        }
        /**
         * @en The create information for [[Texture2D]]
         * @zh 用来创建贴图的信息。
         */
        export interface _cocos_core_assets_texture_2d__ITexture2DCreateInfo {
            /**
             * @en The pixel width
             * @zh 像素宽度。
             */
            width: number;
            /**
             * @en The pixel height
             * @zh 像素高度。
             */
            height: number;
            /**
             * @en The pixel format
             * @zh 像素格式。
             * @default PixelFormat.RGBA8888
             */
            format?: _cocos_core_assets_asset_enum__PixelFormat;
            /**
             * @en The mipmap level count
             * @zh mipmap 层级。
             * @default 1
             */
            mipmapLevel?: number;
            /**
             * @en The selected base mipmap level
             * @zh 选择使用的最小 mipmap 层级。
             * @default 1
             */
            baseLevel?: number;
            /**
             * @en The selected maximum mipmap level
             * @zh 选择使用的最大 mipmap 层级。
             * @default 1000
             */
            maxLevel?: number;
        }
        export type _cocos_core_assets_simple_texture__PresumedGFXTextureInfo = Pick<gfx.TextureInfo, "usage" | "flags" | "format" | "levelCount">;
        export type _cocos_core_assets_simple_texture__PresumedGFXTextureViewInfo = Pick<gfx.TextureViewInfo, "texture" | "format" | "baseLevel" | "levelCount">;
        /**
         * @en The simple texture base class.
         * It create the GFX Texture and can set mipmap levels.
         * @zh 简单贴图基类。
         * 简单贴图内部创建了 GFX 贴图和该贴图上的 GFX 贴图视图。
         * 简单贴图允许指定不同的 Mipmap 层级。
         */
        export class _cocos_core_assets_simple_texture__SimpleTexture extends _cocos_core_assets_texture_base__TextureBase {
            protected _gfxTexture: gfx.Texture | null;
            protected _gfxTextureView: gfx.Texture | null;
            protected _baseLevel: number;
            protected _maxLevel: number;
            /**
             * @en The mipmap level of the texture
             * @zh 贴图中的 Mipmap 层级数量
             */
            get mipmapLevel(): number;
            /**
             * @en The GFX Texture resource
             * @zh 获取此贴图底层的 GFX 贴图对象。
             */
            getGFXTexture(): gfx.Texture | null;
            destroy(): boolean;
            /**
             * @en Update the level 0 mipmap image.
             * @zh 更新 0 级 Mipmap。
             */
            updateImage(): void;
            /**
             * @en Update the given level mipmap image.
             * @zh 更新指定层级范围内的 Mipmap。当 Mipmap 数据发生了改变时应调用此方法提交更改。
             * 若指定的层级范围超出了实际已有的层级范围，只有覆盖的那些层级范围会被更新。
             * @param firstLevel First level to be updated
             * @param count Mipmap level count to be updated
             */
            updateMipmaps(firstLevel?: number, count?: number): void;
            /**
             * @en Upload data to the given mipmap level.
             * The size of the image will affect how the mipmap is updated.
             * - When the image is an ArrayBuffer, the size of the image must match the mipmap size.
             * - If the image size matches the mipmap size, the mipmap data will be updated entirely.
             * - If the image size is smaller than the mipmap size, the mipmap will be updated from top left corner.
             * - If the image size is larger, an error will be raised
             * @zh 上传图像数据到指定层级的 Mipmap 中。
             * 图像的尺寸影响 Mipmap 的更新范围：
             * - 当图像是 `ArrayBuffer` 时，图像的尺寸必须和 Mipmap 的尺寸一致；否则，
             * - 若图像的尺寸与 Mipmap 的尺寸相同，上传后整个 Mipmap 的数据将与图像数据一致；
             * - 若图像的尺寸小于指定层级 Mipmap 的尺寸（不管是长或宽），则从贴图左上角开始，图像尺寸范围内的 Mipmap 会被更新；
             * - 若图像的尺寸超出了指定层级 Mipmap 的尺寸（不管是长或宽），都将引起错误。
             * @param source The source image or image data
             * @param level Mipmap level to upload the image to
             * @param arrayIndex The array index
             */
            uploadData(source: HTMLCanvasElement | HTMLImageElement | ArrayBufferView | ImageBitmap, level?: number, arrayIndex?: number): void;
            protected _assignImage(image: ImageAsset, level: number, arrayIndex?: number): void;
            protected _checkTextureLoaded(): void;
            protected _textureReady(): void;
            /**
             * @en
             * Set mipmap level of this texture.
             * The value is passes as presumed info to `this._getGfxTextureCreateInfo()`.
             * @zh
             * 设置此贴图的 mipmap 层级
             * @param value The mipmap level.
             */
            protected _setMipmapLevel(value: number): void;
            protected _setMipRange(baseLevel: number, maxLevel: number): void;
            /**
             * @en Set mipmap level range for this texture.
             * @zh 设置当前贴图的 mipmap 范围。
             * @param baseLevel The base mipmap level.
             * @param maxLevel The maximum mipmap level.
             */
            setMipRange(baseLevel: number, maxLevel: number): void;
            /**
             * @en This method is override by derived classes to provide GFX texture info.
             * @zh 这个方法被派生类重写以提供 GFX 纹理信息。
             * @param presumed The presumed GFX texture info.
             */
            protected _getGfxTextureCreateInfo(presumed: _cocos_core_assets_simple_texture__PresumedGFXTextureInfo): gfx.TextureInfo | null;
            /**
             * @en This method is overrided by derived classes to provide GFX TextureViewInfo.
             * @zh 这个方法被派生类重写以提供 GFX 纹理视图信息。
             * @param presumed The presumed GFX TextureViewInfo.
             */
            protected _getGfxTextureViewCreateInfo(presumed: _cocos_core_assets_simple_texture__PresumedGFXTextureViewInfo): gfx.TextureViewInfo | null;
            protected _tryReset(): void;
            /**
             * @en Whether mipmaps are baked convolutional maps.
             * @zh mipmaps是否为烘焙出来的卷积图。
             */
            isUsingOfflineMipmaps(): boolean;
            protected _createTexture(device: gfx.Device): void;
            protected _createTextureView(device: gfx.Device): gfx.Texture | null;
            protected _tryDestroyTexture(): void;
            protected _tryDestroyTextureView(): void;
        }
        /**
         * @en The index for all faces of the cube
         * @zh 立方体每个面的约定索引。
         */
        export enum _cocos_core_assets_texture_cube__FaceIndex {
            right = 0,
            left = 1,
            top = 2,
            bottom = 3,
            front = 4,
            back = 5
        }
        /**
         * @en The texture cube mipmap interface
         * @zh 立方体贴图的 Mipmap 接口。
         */
        export interface _cocos_core_assets_texture_cube__ITextureCubeMipmap {
            front: ImageAsset;
            back: ImageAsset;
            left: ImageAsset;
            right: ImageAsset;
            top: ImageAsset;
            bottom: ImageAsset;
        }
        /**
         * @en The MipmapAtlas region interface
         * @zh MipmapAtlas的region接口。
         */
        export interface _cocos_core_assets_texture_cube__IMipmapAtlasLayout {
            left: number;
            top: number;
            width: number;
            height: number;
            level: number;
        }
        /**
         * @en The texture cube MipmapAtlas interface
         * @zh 立方体贴图的 MipmapAtlas 接口。
         */
        export interface _cocos_core_assets_texture_cube__ITextureCubeMipmapAtlas {
            atlas: _cocos_core_assets_texture_cube__ITextureCubeMipmap;
            layout: _cocos_core_assets_texture_cube__IMipmapAtlasLayout[];
        }
        /**
         * @en The way to fill mipmaps.
         * @zh 填充mipmaps的方式。
         */
        export enum _cocos_core_assets_texture_cube__MipmapMode {
            /**
             * @zh
             * 不使用mipmaps
             * @en
             * Not using mipmaps
             * @readonly
             */
            NONE = 0,
            /**
             * @zh
             * 使用自动生成的mipmaps
             * @en
             * Using the automatically generated mipmaps
             * @readonly
             */
            AUTO = 1,
            /**
             * @zh
             * 使用卷积图填充mipmaps
             * @en
             * Filling mipmaps with convolutional maps
             * @readonly
             */
            BAKED_CONVOLUTION_MAP = 2
        }
        export type _cocos_core_assets_texture_cube__ITextureCubeCreateInfo = _cocos_core_assets_texture_2d__ITexture2DCreateInfo;
        export interface _cocos_core_assets_texture_cube__ITextureCubeSerializeData {
            base: string;
            rgbe: boolean;
            mipmapMode: number;
            mipmapAtlas: {
                front: string;
                back: string;
                left: string;
                right: string;
                top: string;
                bottom: string;
            };
            mipmapLayout: [
            ];
            mipmaps: {
                front: string;
                back: string;
                left: string;
                right: string;
                top: string;
                bottom: string;
            }[];
        }
        export type _cocos_core_assets_material__MaterialPropertyFull = renderer.MaterialProperty | _cocos_core_assets_texture_base__TextureBase | gfx.Texture | null;
        export interface _cocos_core_assets_render_texture__IRenderTextureCreateInfo {
            name?: string;
            width: number;
            height: number;
            passInfo?: gfx.RenderPassInfo;
        }
        /**
         * @en The screen API provides an easy way to do some screen managing stuff.
         * @zh screen 单例对象提供简单的方法来做屏幕管理相关的工作。
         */
        export class _cocos_core_platform_screen__Screen {
            /**
             * @internal
             */
            init(): void;
            /**
             * @en the ratio of the resolution in physical pixels to the resolution in CSS pixels for the current display device
             * NOTE: For performance reasons, the engine will limit the maximum value of DPR on some platforms.
             * This property returns the DPR after the engine limit.
             * @zh 当前显示设备的物理像素分辨率与 CSS 像素分辨率之比
             * 注意：出于性能考虑，引擎在一些平台会限制 DPR 的最高值，这个属性返回的是引擎限制后的 DPR。
             */
            get devicePixelRatio(): number;
            /**
             * @en Get and set the size of current window in physical pixels.
             * NOTE:
             * - Setting window size is only supported on Web platform for now.
             * - On Web platform, if the ContainerStrategy is PROPORTIONAL_TO_FRAME, we set windowSize on game frame,
             *    and get windowSize from the game container after adaptation.
             * @zh 获取和设置当前窗口的物理像素尺寸。
             * 注意
             * - 设置窗口尺寸目前只在 Web 平台上支持。
             * - Web 平台上，如果 ContainerStrategy 为 PROPORTIONAL_TO_FRAME, 则设置 windowSize 作用于 game frame, 而从适配之后 game container 尺寸获取 windowSize.
             */
            get windowSize(): math.Size;
            set windowSize(size: math.Size);
            /**
             * @en Get the current resolution of game.
             * This is a readonly property.
             * @zh 获取当前游戏的分辨率。
             * 这是一个只读属性。
             *
             * @readonly
             */
            get resolution(): math.Size;
            /**
             * @en Whether it supports full screen？
             * @zh 是否支持全屏？
             * @returns {Boolean}
             */
            get supportsFullScreen(): boolean;
            /**
             * @en Return true if it's in full screen state now.
             * @zh 当前是否处在全屏状态下
             * @returns {boolean}
             */
            fullScreen(): boolean;
            /**
             * @en Request to enter full screen mode with the given element.
             * Many browsers forbid to enter full screen mode without an user intended interaction.
             * If failed to request fullscreen, another attempt will be made to request fullscreen the next time a user interaction occurs.
             * @zh 尝试使当前节点进入全屏模式，很多浏览器不允许程序触发这样的行为，必须在一个用户交互回调中才会生效。
             * 如果进入全屏失败，会在下一次用户发生交互时，再次尝试进入全屏。
             * @param element The element to request full screen state
             * @param onFullScreenChange callback function when full screen state changed
             * @param onFullScreenError callback function when full screen error
             * @return {Promise|undefined}
             * @deprecated since v3.3, please use `screen.requestFullScreen(): Promise<void>` instead.
             */
            requestFullScreen(element: HTMLElement, onFullScreenChange?: (this: Document, ev: any) => any, onFullScreenError?: (this: Document, ev: any) => any): Promise<any> | undefined;
            /**
             * @en Request to enter full screen mode.
             * Many browsers forbid to enter full screen mode without an user intended interaction.
             * If failed to request fullscreen, another attempt will be made to request fullscreen the next time a user interaction occurs.
             * @zh 尝试使当前屏幕进入全屏模式，很多浏览器不允许程序触发这样的行为，必须在一个用户交互回调中才会生效。
             * 如果进入全屏失败，会在下一次用户发生交互时，再次尝试进入全屏。
             * @return {Promise}
             */
            requestFullScreen(): Promise<void>;
            /**
             * @en Exit the full mode.
             * @zh 退出全屏模式
             * @return {Promise}
             */
            exitFullScreen(): Promise<any>;
            /**
             * @en Automatically request full screen during the next touch/click event
             * @zh 自动监听触摸、鼠标事件并在下一次事件触发时尝试进入全屏模式
             * @param element The element to request full screen state
             * @param onFullScreenChange callback function when full screen state changed
             *
             * @deprecated since v3.3, please use screen.requestFullScreen() instead.
             */
            autoFullScreen(element: HTMLElement, onFullScreenChange: (this: Document, ev: any) => any): void;
            /**
             * @param element
             * @deprecated since v3.3
             */
            disableAutoFullScreen(element: any): void;
        }
        export enum _pal_system_info_enum_type_feature__Feature {
            /**
             * @en Feature to support Webp.
             * @zh 是否支持 Webp 特性。
             */
            WEBP = "WEBP",
            /**
             * @en Feature to support Image Bitmap.
             * @zh 是否支持 Image Bitmap 特性。
             */
            IMAGE_BITMAP = "IMAGE_BITMAP",
            /**
             * @en Feature to support Web View.
             * @zh 是否支持 Web View 特性。
             */
            WEB_VIEW = "WEB_VIEW",
            /**
             * @en Feature to support Video Player.
             * @zh 是否支持 Video Player 特性。
             */
            VIDEO_PLAYER = "VIDEO_PLAYER",
            /**
             * @en Feature to support Safe Area.
             * @zh 是否支持 Safe Area 特性。
             */
            SAFE_AREA = "SAFE_AREA",
            /**
             * @en Feature to support Touch Input.
             * Touch Input is only supported on some devices with touch screen.
             * This feature tells that whether the device has a touch screen.
             * @zh 是否支持触摸输入。
             * 触摸输入只在一些带触摸屏的设备上支持。
             * 这个特性旨在说明设备上是否带触摸屏。
             */
            INPUT_TOUCH = "INPUT_TOUCH",
            /**
             * @en Feature to support dispatching EventKeyboard.
             * @zh 是否支持派发 EventKeyboard。
             */
            EVENT_KEYBOARD = "EVENT_KEYBOARD",
            /**
             * @en Feature to support dispatching EventMouse.
             * @zh 是否支持派发 EventMouse。
             */
            EVENT_MOUSE = "EVENT_MOUSE",
            /**
             * @en Feature to support dispatching EventTouch.
             * On some devices without touch screen, we still can simulate dispatching EventTouch from EventMouse.
             * @zh 是否支持派发 EventTouch。
             * 在一些不带触摸屏的设备上，我们仍然会从 EventMouse 模拟派发 EventTouch。
             */
            EVENT_TOUCH = "EVENT_TOUCH",
            /**
             * @en Feature to support dispatching EventAcceleration.
             * @zh 是否支持派发 EventAcceleration。
             */
            EVENT_ACCELEROMETER = "EVENT_ACCELEROMETER",
            /**
             * @en Feature to support dispatching EventGamepad.
             * @zh 是否支持派发 EventGamepad.
             */
            EVENT_GAMEPAD = "EVENT_GAMEPAD",
            /**
             * @en Feature to support dispatching EventHandle.
             * @zh 是否支持派发 EventHandle
             */
            EVENT_HANDLE = "EVENT_HANDLE",
            /**
             * @en Feature to support dispatching EventHMD.
             * @zh 是否支持派发 EventHMD
             */
            EVENT_HMD = "EVENT_HMD"
        }
        export enum _pal_system_info_enum_type_network_type__NetworkType {
            /**
             * @en Network is unreachable.
             * @zh 网络不通
             */
            NONE = 0,
            /**
             * @en Network is reachable via WiFi or cable.
             * @zh 通过无线或者有线本地网络连接因特网
             */
            LAN = 1,
            /**
             * @en Network is reachable via Wireless Wide Area Network
             * @zh 通过蜂窝移动网络连接因特网
             */
            WWAN = 2
        }
        export enum _pal_system_info_enum_type_language__Language {
            /**
             * @en Unknown language code
             * @zh 语言代码 - 未知
             */
            UNKNOWN = "unknown",
            /**
             * @en English language code
             * @zh 语言代码 - 英语
             */
            ENGLISH = "en",
            /**
             * @en Chinese language code
             * @zh 语言代码 - 中文
             */
            CHINESE = "zh",
            /**
             * @en French language code
             * @zh 语言代码 - 法语
             */
            FRENCH = "fr",
            /**
             * @en Italian language code
             * @zh 语言代码 - 意大利语
             */
            ITALIAN = "it",
            /**
             * @en German language code
             * @zh 语言代码 - 德语
             */
            GERMAN = "de",
            /**
             * @en Spanish language code
             * @zh 语言代码 - 西班牙语
             */
            SPANISH = "es",
            /**
             * @en Spanish language code
             * @zh 语言代码 - 荷兰语
             */
            DUTCH = "du",
            /**
             * @en Russian language code
             * @zh 语言代码 - 俄罗斯语
             */
            RUSSIAN = "ru",
            /**
             * @en Korean language code
             * @zh 语言代码 - 韩语
             */
            KOREAN = "ko",
            /**
             * @en Japanese language code
             * @zh 语言代码 - 日语
             */
            JAPANESE = "ja",
            /**
             * @en Hungarian language code
             * @zh 语言代码 - 匈牙利语
             */
            HUNGARIAN = "hu",
            /**
             * @en Portuguese language code
             * @zh 语言代码 - 葡萄牙语
             */
            PORTUGUESE = "pt",
            /**
             * @en Arabic language code
             * @zh 语言代码 - 阿拉伯语
             */
            ARABIC = "ar",
            /**
             * @en Norwegian language code
             * @zh 语言代码 - 挪威语
             */
            NORWEGIAN = "no",
            /**
             * @en Polish language code
             * @zh 语言代码 - 波兰语
             */
            POLISH = "pl",
            /**
             * @en Turkish language code
             * @zh 语言代码 - 土耳其语
             */
            TURKISH = "tr",
            /**
             * @en Ukrainian language code
             * @zh 语言代码 - 乌克兰语
             */
            UKRAINIAN = "uk",
            /**
             * @en Romanian language code
             * @zh 语言代码 - 罗马尼亚语
             */
            ROMANIAN = "ro",
            /**
             * @en Bulgarian language code
             * @zh 语言代码 - 保加利亚语
             */
            BULGARIAN = "bg"
        }
        export enum _pal_system_info_enum_type_operating_system__OS {
            /**
             * @en Operating System - Unknown
             * @zh 操作系统 - 未知
             */
            UNKNOWN = "Unknown",
            /**
             * @en Operating System - iOS
             * @zh 操作系统 - iOS
             */
            IOS = "iOS",
            /**
             * @en Operating System - Android
             * @zh 操作系统 - 安卓
             */
            ANDROID = "Android",
            /**
             * @en Operating System - Windows
             * @zh 操作系统 - Windows
             */
            WINDOWS = "Windows",
            /**
             * @en Operating System - Linux
             * @zh 操作系统 - Linux
             */
            LINUX = "Linux",
            /**
             * @en Operating System - Mac OS X
             * @zh 操作系统 - Mac OS X
             */
            OSX = "OS X",
            /**
             * @en Operating System - Huawei Open Harmony OS
             * @zh 操作系统 - 鸿蒙
             */
            OHOS = "OHOS"
        }
        export enum _pal_system_info_enum_type_platform__Platform {
            UNKNOWN = "UNKNOWN",
            EDITOR_PAGE = "EDITOR_PAGE",
            EDITOR_CORE = "EDITOR_CORE",
            MOBILE_BROWSER = "MOBILE_BROWSER",
            DESKTOP_BROWSER = "DESKTOP_BROWSER",
            WIN32 = "WIN32",
            ANDROID = "ANDROID",
            IOS = "IOS",
            MACOS = "MACOS",
            OHOS = "OHOS",
            WECHAT_GAME = "WECHAT_GAME",
            BAIDU_MINI_GAME = "BAIDU_MINI_GAME",
            XIAOMI_QUICK_GAME = "XIAOMI_QUICK_GAME",
            ALIPAY_MINI_GAME = "ALIPAY_MINI_GAME",
            TAOBAO_CREATIVE_APP = "TAOBAO_CREATIVE_APP",
            BYTEDANCE_MINI_GAME = "BYTEDANCE_MINI_GAME",
            OPPO_MINI_GAME = "OPPO_MINI_GAME",
            VIVO_MINI_GAME = "VIVO_MINI_GAME",
            HUAWEI_QUICK_GAME = "HUAWEI_QUICK_GAME",
            COCOSPLAY = "COCOSPLAY",
            LINKSURE_MINI_GAME = "LINKSURE_MINI_GAME",
            QTT_MINI_GAME = "QTT_MINI_GAME"
        }
        export enum _pal_system_info_enum_type_browser_type__BrowserType {
            /**
             * @en Browser Type - Unknown
             * @zh 浏览器类型 - 未知
             */
            UNKNOWN = "unknown",
            /**
             * @en Browser Type - WeChat inner browser
             * @zh 浏览器类型 - 微信内置浏览器
             */
            WECHAT = "wechat",
            /**
             * @en Browser Type - Android Browser
             * @zh 浏览器类型 - 安卓浏览器
             */
            ANDROID = "androidbrowser",
            /**
             * @en Browser Type - Internet Explorer
             * @zh 浏览器类型 - 微软 IE
             */
            IE = "ie",
            /**
             * @en Browser Type - Microsoft Edge
             * @zh 浏览器类型 - 微软 Edge
             */
            EDGE = "edge",
            /**
             * @en Browser Type - QQ Browser
             * @zh 浏览器类型 - QQ 浏览器
             */
            QQ = "qqbrowser",
            /**
             * @en Browser Type - Mobile QQ Browser
             * @zh 浏览器类型 - 手机 QQ 浏览器
             */
            MOBILE_QQ = "mqqbrowser",
            /**
             * @en Browser Type - UC Browser
             * @zh 浏览器类型 - UC 浏览器
             */
            UC = "ucbrowser",
            /**
             * @en Browser Type - Third party integrated UC browser
             * @zh 浏览器类型 - 第三方应用中集成的 UC 浏览器
             */
            UCBS = "ucbs",
            /**
             * @en Browser Type - 360 Browser
             * @zh 浏览器类型 - 360 浏览器
             */
            BROWSER_360 = "360browser",
            /**
             * @en Browser Type - Baidu Box App
             * @zh 浏览器类型 - Baidu Box App
             */
            BAIDU_APP = "baiduboxapp",
            /**
             * @en Browser Type - Baidu Browser
             * @zh 浏览器类型 - 百度浏览器
             */
            BAIDU = "baidubrowser",
            /**
             * @en Browser Type - Maxthon Browser
             * @zh 浏览器类型 - 傲游浏览器
             */
            MAXTHON = "maxthon",
            /**
             * @en Browser Type - Opera Browser
             * @zh 浏览器类型 - Opera 浏览器
             */
            OPERA = "opera",
            /**
             * @en Browser Type - Oupeng Browser
             * @zh 浏览器类型 - 欧朋浏览器
             */
            OUPENG = "oupeng",
            /**
             * @en Browser Type - MI UI Browser
             * @zh 浏览器类型 - MIUI 内置浏览器
             */
            MIUI = "miuibrowser",
            /**
             * @en Browser Type - Firefox Browser
             * @zh 浏览器类型 - Firefox 浏览器
             */
            FIREFOX = "firefox",
            /**
             * @en Browser Type - Safari Browser
             * @zh 浏览器类型 - Safari 浏览器
             */
            SAFARI = "safari",
            /**
             * @en Browser Type - Chrome Browser
             * @zh 浏览器类型 - Chrome 浏览器
             */
            CHROME = "chrome",
            /**
             * @en Browser Type - Cheetah Browser
             * @zh 浏览器类型 - 猎豹浏览器
             */
            LIEBAO = "liebao",
            /**
             * @en Browser Type - QZone Inner Browser
             * @zh 浏览器类型 - QZone 内置浏览器
             */
            QZONE = "qzone",
            /**
             * @en Browser Type - Sogou Browser
             * @zh 浏览器类型 - 搜狗浏览器
             */
            SOUGOU = "sogou",
            /**
             * @en Browser Type - Huawei Browser
             * @zh 浏览器类型 - 华为浏览器
             */
            HUAWEI = "huawei"
        }
        export const _cocos_core_platform_view__View_base: new (...args: any[]) => System & _cocos_core_event_eventify__IEventified;
        /**
         * ContainerStrategy class is the root strategy class of container's scale strategy,
         * it controls the behavior of how to scale the cc.game.container and cc.game.canvas object
         */
        export class _cocos_core_platform_view__ContainerStrategy {
            static EQUAL_TO_FRAME: any;
            static PROPORTION_TO_FRAME: any;
            name: string;
            /**
             * @en Manipulation before appling the strategy
             * @zh 在应用策略之前的操作
             * @param view - The target view
             */
            preApply(_view: View): void;
            /**
             * @en Function to apply this strategy
             * @zh 策略应用方法
             * @param view
             * @param designedResolution
             */
            apply(_view: View, designedResolution: math.Size): void;
            /**
             * @en
             * Manipulation after applying the strategy
             * @zh 策略调用之后的操作
             * @param view  The target view
             */
            postApply(_view: View): void;
            protected _setupCanvas(): void;
        }
        /**
         * !en
         * Emit when design resolution changed.
         * !zh
         * 当设计分辨率改变时发送。
         * @event design-resolution-changed
         */
        export interface _cocos_core_platform_view__AdaptResult {
            scale: number[];
            viewport?: null | math.Rect;
        }
        /**
         * @en
         * Emit when canvas resize.
         * @zh
         * 当画布大小改变时发送。
         * @event canvas-resize
         */
        /**
         * ContentStrategy class is the root strategy class of content's scale strategy,
         * it controls the behavior of how to scale the scene and setup the viewport for the game
         *
         * @class ContentStrategy
         */
        export class _cocos_core_platform_view__ContentStrategy {
            static EXACT_FIT: any;
            static SHOW_ALL: any;
            static NO_BORDER: any;
            static FIXED_HEIGHT: any;
            static FIXED_WIDTH: any;
            name: string;
            constructor();
            /**
             * @en Manipulation before applying the strategy
             * @zh 策略应用前的操作
             * @param view - The target view
             */
            preApply(_view: View): void;
            /**
             * @en Function to apply this strategy
             * The return value is {scale: [scaleX, scaleY], viewport: {new Rect}},
             * The target view can then apply these value to itself, it's preferred not to modify directly its private variables
             * @zh 调用策略方法
             * @return The result scale and viewport rect
             */
            apply(_view: View, designedResolution: math.Size): _cocos_core_platform_view__AdaptResult;
            /**
             * @en Manipulation after applying the strategy
             * @zh 策略调用之后的操作
             * @param view - The target view
             */
            postApply(_view: View): void;
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _buildResult(containerW: any, containerH: any, contentW: any, contentH: any, scaleX: any, scaleY: any): _cocos_core_platform_view__AdaptResult;
        }
        namespace _cocos_core_platform_debug {
            export function log(message?: any, ...optionalParams: any[]): void;
            export function warn(message?: any, ...optionalParams: any[]): void;
            export function error(message?: any, ...optionalParams: any[]): void;
            export function assert(value: any, message?: string, ...optionalParams: any[]): asserts value;
            export function debug(...data: any[]): void;
            export function _resetDebugSetting(mode: DebugMode): void;
            export function _throw(error_: any): void;
            export function logID(id: number, ...optionalParams: any[]): void;
            export function warnID(id: number, ...optionalParams: any[]): void;
            export function errorID(id: number, ...optionalParams: any[]): void;
            export function assertID(condition: any, id: number, ...optionalParams: any[]): void;
            export enum DebugMode {
                /**
                 * @en The debug mode none.
                 * @zh 禁止模式，禁止显示任何日志消息。
                 */
                NONE = 0,
                /**
                 * @en The debug mode none.
                 * @zh 调试模式，显示所有日志消息。
                 */
                VERBOSE = 1,
                /**
                 * @en Information mode, which display messages with level higher than "information" level.
                 * @zh 信息模式，显示“信息”级别以上的日志消息。
                 */
                INFO = 2,
                /**
                 * @en Information mode, which display messages with level higher than "warning" level.
                 * @zh 警告模式，显示“警告”级别以上的日志消息。
                 */
                WARN = 3,
                /**
                 * @en Information mode, which display only messages with "error" level.
                 * @zh 错误模式，仅显示“错误”级别的日志消息。
                 */
                ERROR = 4,
                /**
                 * @en The debug mode info for web page.
                 * @zh 信息模式（仅 WEB 端有效），在画面上输出所有信息。
                 */
                INFO_FOR_WEB_PAGE = 5,
                /**
                 * @en The debug mode warn for web page.
                 * @zh 警告模式（仅 WEB 端有效），在画面上输出 warn 级别以上的（包含 error）信息。
                 */
                WARN_FOR_WEB_PAGE = 6,
                /**
                 * @en The debug mode error for web page.
                 * @zh 错误模式（仅 WEB 端有效），在画面上输出 error 信息。
                 */
                ERROR_FOR_WEB_PAGE = 7
            }
            export function getError(errorId: number, ...param: any[]): string;
            export function isDisplayStats(): boolean;
            export function setDisplayStats(displayStats: boolean): void;
        }
        /**
         * @zh
         * AssetManager 配置。
         * @en
         * AssetManager configuration.
         */
        export interface _cocos_core_asset_manager_asset_manager__IAssetManagerOptions {
            importBase?: string;
            nativeBase?: string;
            jsbDownloaderMaxTasks?: number;
            jsbDownloaderTimeout?: number;
            /**
             * @zh
             * 所有 bundle 的版本信息
             * @en
             * Version for all bundles
             */
            bundleVers?: Record<string, string>;
            /**
             * @zh
             * 远程服务器地址
             * @en
             * Remote server address
             */
            server?: string;
            /**
             * @zh
             * 配置为子包的 bundle
             * @en
             * All subpackages
             */
            subpackages?: string[];
            /**
             * @zh
             * 配置为远程包的 bundle
             * @en
             * All remote bundles
             */
            remoteBundles?: string[];
        }
        export type _pal_screen_adapter__ConfigOrientation = "auto" | "landscape" | "portrait";
        function _cocos_core_scene_graph_component_scheduler__stableRemoveInactive(iterator: any, flagToClear: any): void;
        /**
         * @example
         * ```
         * import { js } from 'cc';
         * var array = [0, 1, 2, 3, 4];
         * var iterator = new js.array.MutableForwardIterator(array);
         * for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
         *     var item = array[iterator.i];
         *     ...
         * }
         * ```
         */
        export class _cocos_core_utils_mutable_forward_iterator__default<T> {
            array: T[];
            i: number;
            constructor(array: T[]);
            get length(): number;
            set length(value: number);
            remove(value: T): void;
            removeAt(i: number): void;
            fastRemove(value: T): void;
            fastRemoveAt(i: number): void;
            push(item: T): void;
        }
        export class _cocos_core_scene_graph_component_scheduler__LifeCycleInvoker {
            static stableRemoveInactive: typeof _cocos_core_scene_graph_component_scheduler__stableRemoveInactive;
            protected _zero: _cocos_core_utils_mutable_forward_iterator__default<any>;
            protected _neg: _cocos_core_utils_mutable_forward_iterator__default<any>;
            protected _pos: _cocos_core_utils_mutable_forward_iterator__default<any>;
            protected _invoke: any;
            constructor(invokeFunc: any);
        }
        export class _cocos_core_scene_graph_component_scheduler__OneOffInvoker extends _cocos_core_scene_graph_component_scheduler__LifeCycleInvoker {
            add(comp: any): void;
            remove(comp: any): void;
            cancelInactive(flagToClear: any): void;
            invoke(): void;
        }
        export class _cocos_core_scene_graph_component_scheduler__ReusableInvoker extends _cocos_core_scene_graph_component_scheduler__LifeCycleInvoker {
            add(comp: any): void;
            remove(comp: any): void;
            invoke(dt: any): void;
        }
        /**
         * @en The Manager for Component's life-cycle methods.
         * It collaborates with [[NodeActivator]] to schedule and invoke life cycle methods for components
         * @zh 组件生命周期函数的调度器。
         * 它和 [[NodeActivator]] 一起调度并执行组件的生命周期函数。
         */
        export class _cocos_core_scene_graph_component_scheduler__ComponentScheduler {
            /**
             * @en The invoker of `start` callback
             * @zh `start` 回调的调度器
             */
            startInvoker: _cocos_core_scene_graph_component_scheduler__OneOffInvoker;
            /**
             * @en The invoker of `update` callback
             * @zh `update` 回调的调度器
             */
            updateInvoker: _cocos_core_scene_graph_component_scheduler__ReusableInvoker;
            /**
             * @en The invoker of `lateUpdate` callback
             * @zh `lateUpdate` 回调的调度器
             */
            lateUpdateInvoker: _cocos_core_scene_graph_component_scheduler__ReusableInvoker;
            constructor();
            /**
             * @en Cancel all future callbacks, including `start`, `update` and `lateUpdate`
             * @zh 取消所有未来的函数调度，包括 `start`，`update` 和 `lateUpdate`
             */
            unscheduleAll(): void;
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _onEnabled(comp: any): void;
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _onDisabled(comp: any): void;
            /**
             * @en Enable a component
             * @zh 启用一个组件
             * @param comp The component to be enabled
             * @param invoker The invoker which is responsible to schedule the `onEnable` call
             */
            enableComp(comp: any, invoker?: any): void;
            /**
             * @en Disable a component
             * @zh 禁用一个组件
             * @param comp The component to be disabled
             */
            disableComp(comp: any): void;
            /**
             * @en Process start phase for registered components
             * @zh 为当前注册的组件执行 start 阶段任务
             */
            startPhase(): void;
            /**
             * @en Process update phase for registered components
             * @zh 为当前注册的组件执行 update 阶段任务
             * @param dt @en Time passed after the last frame in seconds @zh 距离上一帧的时间，以秒计算
             */
            updatePhase(dt: number): void;
            /**
             * @en Process late update phase for registered components
             * @zh 为当前注册的组件执行 late update 阶段任务
             * @param dt @en Time passed after the last frame in seconds @zh 距离上一帧的时间，以秒计算
             */
            lateUpdatePhase(dt: number): void;
        }
        export class _cocos_core_pipeline_render_pipeline__BloomRenderData {
            renderPass: gfx.RenderPass;
            sampler: gfx.Sampler;
            prefiterTex: gfx.Texture;
            downsampleTexs: gfx.Texture[];
            upsampleTexs: gfx.Texture[];
            combineTex: gfx.Texture;
            prefilterFramebuffer: gfx.Framebuffer;
            downsampleFramebuffers: gfx.Framebuffer[];
            upsampleFramebuffers: gfx.Framebuffer[];
            combineFramebuffer: gfx.Framebuffer;
        }
        export class _cocos_core_pipeline_render_pipeline__PipelineRenderData {
            outputFrameBuffer: gfx.Framebuffer;
            outputRenderTargets: gfx.Texture[];
            outputDepth: gfx.Texture;
            sampler: gfx.Sampler;
            bloom: _cocos_core_pipeline_render_pipeline__BloomRenderData | null;
        }
        export class _cocos_core_pipeline_pipeline_ubo__PipelineUBO {
            static updateGlobalUBOView(window: _cocos_core_renderer_core_render_window__RenderWindow, bufferView: Float32Array): void;
            static updateCameraUBOView(pipeline: _cocos_core_pipeline_custom_pipeline__PipelineRuntime, bufferView: Float32Array, camera: renderer.scene.Camera): void;
            static getPCFRadius(shadowInfo: renderer.scene.Shadows, mainLight: renderer.scene.DirectionalLight): number;
            static updatePlanarNormalAndDistance(shadowInfo: renderer.scene.Shadows, shadowUBO: Float32Array): void;
            static updateShadowUBOView(pipeline: _cocos_core_pipeline_custom_pipeline__PipelineRuntime, shadowBufferView: Float32Array, csmBufferView: Float32Array, camera: renderer.scene.Camera): void;
            static updateShadowUBOLightView(pipeline: _cocos_core_pipeline_custom_pipeline__PipelineRuntime, shadowBufferView: Float32Array, light: renderer.scene.Light, level: number): void;
            protected _globalUBO: Float32Array;
            protected _cameraUBO: Float32Array;
            protected _shadowUBO: Float32Array;
            protected _csmUBO: Float32Array;
            static _combineSignY: number;
            protected _device: gfx.Device;
            protected _pipeline: _cocos_core_pipeline_custom_pipeline__PipelineRuntime;
            /**
             *|combinedSignY|clipSpaceSignY|screenSpaceSignY| Backends |
             *|    :--:     |    :--:      |      :--:      |   :--:   |
             *|      0      |      -1      |      -1        |  Vulkan  |
             *|      1      |       1      |      -1        |  Metal   |
             *|      2      |      -1      |       1        |          |
             *|      3      |       1      |       1        |  GL-like |
             */
            static getCombineSignY(): number;
            activate(device: gfx.Device, pipeline: _cocos_core_pipeline_custom_pipeline__PipelineRuntime): void;
            /**
             * @en Update all UBOs
             * @zh 更新全部 UBO。
             */
            updateGlobalUBO(window: _cocos_core_renderer_core_render_window__RenderWindow): void;
            updateCameraUBO(camera: renderer.scene.Camera): void;
            updateShadowUBO(camera: renderer.scene.Camera): void;
            updateShadowUBOLight(globalDS: gfx.DescriptorSet, light: renderer.scene.Light, level?: number): void;
            updateShadowUBORange(offset: number, data: math.Mat4 | math.Color): void;
            destroy(): void;
        }
        /**
         * @en Render pipeline information descriptor
         * @zh 渲染管线描述信息。
         */
        export interface _cocos_core_pipeline_render_pipeline__IRenderPipelineInfo {
            flows: RenderFlow[];
            tag?: number;
        }
        export class _cocos_core_pipeline_render_pipeline__PipelineInputAssemblerData {
            quadIB: gfx.Buffer | null;
            quadVB: gfx.Buffer | null;
            quadIA: gfx.InputAssembler | null;
        }
        /**
         * @en Render flow information descriptor
         * @zh 渲染流程描述信息。
         */
        export interface _cocos_core_pipeline_render_flow__IRenderFlowInfo {
            name: string;
            priority: number;
            stages: RenderStage[];
            tag?: number;
        }
        export enum _cocos_core_pipeline_pipeline_serialization__RenderQueueSortMode {
            FRONT_TO_BACK = 0,
            BACK_TO_FRONT = 1
        }
        /**
         * @en The render queue descriptor
         * @zh 渲染队列描述信息
         */
        export class _cocos_core_pipeline_pipeline_serialization__RenderQueueDesc {
            /**
             * @en Whether the render queue is a transparent queue
             * @zh 当前队列是否是半透明队列
             */
            isTransparent: boolean;
            /**
             * @en The sort mode of the render queue
             * @zh 渲染队列的排序模式
             */
            sortMode: _cocos_core_pipeline_pipeline_serialization__RenderQueueSortMode;
            /**
             * @en The stages using this queue
             * @zh 使用当前渲染队列的阶段列表
             */
            stages: string[];
        }
        /**
         * @en The render stage information descriptor
         * @zh 渲染阶段描述信息。
         */
        export interface _cocos_core_pipeline_render_stage__IRenderStageInfo {
            name: string;
            priority: number;
            tag?: number;
            renderQueues?: _cocos_core_pipeline_pipeline_serialization__RenderQueueDesc[];
        }
        export class _cocos_core_pipeline_shadow_csm_layers__ShadowLayerVolume {
            protected _shadowObjects: pipeline.IRenderObject[];
            protected _shadowCameraFar: number;
            protected _level: number;
            protected _matShadowView: math.Mat4;
            protected _matShadowProj: math.Mat4;
            protected _matShadowViewProj: math.Mat4;
            protected _validFrustum: geometry.Frustum;
            protected _splitFrustum: geometry.Frustum;
            protected _lightViewFrustum: geometry.Frustum;
            protected _castLightViewBoundingBox: geometry.AABB;
            constructor(level: number);
            get level(): number;
            get shadowObjects(): pipeline.IRenderObject[];
            get shadowCameraFar(): number;
            set shadowCameraFar(val: number);
            get matShadowView(): math.Mat4;
            set matShadowView(val: math.Mat4);
            get matShadowProj(): math.Mat4;
            set matShadowProj(val: math.Mat4);
            get matShadowViewProj(): math.Mat4;
            set matShadowViewProj(val: math.Mat4);
            get validFrustum(): Readonly<geometry.Frustum>;
            get splitFrustum(): Readonly<geometry.Frustum>;
            get lightViewFrustum(): Readonly<geometry.Frustum>;
            get castLightViewBoundingBox(): Readonly<geometry.AABB>;
            copyToValidFrustum(validFrustum: Readonly<geometry.Frustum>): void;
            calculateValidFrustumOrtho(width: number, height: number, near: number, far: number, transform: math.Mat4): void;
            calculateSplitFrustum(camera: renderer.scene.Camera, m: math.Mat4, start: number, end: number): void;
            destroy(): void;
            createMatrix(dirLight: renderer.scene.DirectionalLight, shadowMapWidth: number, onlyForCulling: boolean): void;
        }
        export class _cocos_core_pipeline_shadow_csm_layers__CSMShadowLayer extends _cocos_core_pipeline_shadow_csm_layers__ShadowLayerVolume {
            protected _splitCameraNear: number;
            protected _splitCameraFar: number;
            protected _csmAtlas: math.Vec4;
            constructor(level: number);
            get splitCameraNear(): number;
            set splitCameraNear(val: number);
            get splitCameraFar(): number;
            set splitCameraFar(val: number);
            get csmAtlas(): math.Vec4;
            set csmAtlas(val: math.Vec4);
            destroy(): void;
        }
        /**
         * @en Shadow CSM layer manager
         * @zh CSM阴影图层管理
         */
        export class _cocos_core_pipeline_shadow_csm_layers__CSMLayers {
            protected _castShadowObjects: pipeline.IRenderObject[];
            protected _layerObjects: memop.CachedArray<pipeline.IRenderObject>;
            protected _layers: _cocos_core_pipeline_shadow_csm_layers__CSMShadowLayer[];
            protected _levelCount: number;
            protected _specialLayer: _cocos_core_pipeline_shadow_csm_layers__ShadowLayerVolume;
            protected _shadowDistance: number;
            get castShadowObjects(): pipeline.IRenderObject[];
            get layerObjects(): memop.CachedArray<pipeline.IRenderObject>;
            get layers(): _cocos_core_pipeline_shadow_csm_layers__CSMShadowLayer[];
            get specialLayer(): _cocos_core_pipeline_shadow_csm_layers__ShadowLayerVolume;
            constructor();
            update(sceneData: PipelineSceneData, camera: renderer.scene.Camera): void;
            destroy(): void;
        }
        export class _cocos_core_pipeline_pipeline_serialization__RenderTextureConfig {
            name: string;
            texture: RenderTexture | null;
        }
        /**
         * @en The render queue. It manages a GFX [[RenderPass]] queue which will be executed by the [[RenderStage]].
         * @zh 渲染队列。它管理一个 GFX [[RenderPass]] 队列，队列中的渲染过程会被 [[RenderStage]] 所执行。
         */
        export class _cocos_core_pipeline_render_queue__RenderQueue {
            /**
             * @en A cached array of render passes
             * @zh 基于缓存数组的渲染过程队列。
             */
            queue: memop.CachedArray<pipeline.IRenderPass>;
            /**
             * @en Construct a RenderQueue with render queue descriptor
             * @zh 利用渲染队列描述来构造一个 RenderQueue。
             * @param desc Render queue descriptor
             */
            constructor(desc: pipeline.IRenderQueueDesc);
            /**
             * @en Clear the render queue
             * @zh 清空渲染队列。
             */
            clear(): void;
            /**
             * @en Insert a render pass into the queue
             * @zh 插入渲染过程。
             * @param renderObj The render object of the pass
             * @param modelIdx The model id
             * @param passIdx The pass id
             * @returns Whether the new render pass is successfully added
             */
            insertRenderPass(renderObj: pipeline.IRenderObject, subModelIdx: number, passIdx: number): boolean;
            /**
             * @en Sort the current queue
             * @zh 排序渲染队列。
             */
            sort(): void;
            recordCommandBuffer(device: gfx.Device, renderPass: gfx.RenderPass, cmdBuff: gfx.CommandBuffer): void;
        }
        /**
         * @en Render queue for instanced batching
         * @zh 渲染合批队列。
         */
        export class _cocos_core_pipeline_render_instanced_queue__RenderInstancedQueue {
            /**
             * @en A set of instanced buffer
             * @zh Instance 合批缓存集合。
             */
            queue: Set<InstancedBuffer>;
            /**
             * @en Clear the render queue
             * @zh 清空渲染队列。
             */
            clear(): void;
            sort(): void;
            uploadBuffers(cmdBuff: gfx.CommandBuffer): void;
            /**
             * @en Record command buffer for the current queue
             * @zh 记录命令缓冲。
             * @param cmdBuff The command buffer to store the result
             */
            recordCommandBuffer(device: gfx.Device, renderPass: gfx.RenderPass, cmdBuff: gfx.CommandBuffer, descriptorSet?: gfx.DescriptorSet | null, dynamicOffsets?: Readonly<number[]>): void;
        }
        export class _cocos_core_pipeline_deferred_deferred_pipeline__DeferredRenderData extends _cocos_core_pipeline_render_pipeline__PipelineRenderData {
            gbufferFrameBuffer: gfx.Framebuffer;
            gbufferRenderTargets: gfx.Texture[];
        }
        export interface _cocos_core_pipeline_instanced_buffer__IInstancedItem {
            count: number;
            capacity: number;
            vb: gfx.Buffer;
            data: Uint8Array;
            ia: gfx.InputAssembler;
            stride: number;
            shader: gfx.Shader | null;
            descriptorSet: gfx.DescriptorSet;
            lightingMap: gfx.Texture;
        }
        /**
         * @zh
         * 渲染单项调试模式
         * @en
         * Rendering single debug mode
         * @readonly
         */
        export const enum _cocos_core_pipeline_debug_view__DebugViewSingleType {
            NONE = 0,
            VERTEX_COLOR = 1,
            VERTEX_NORMAL = 2,
            VERTEX_TANGENT = 3,
            WORLD_POS = 4,
            VERTEX_MIRROR = 5,
            FACE_SIDE = 6,
            UV0 = 7,
            UV1 = 8,
            UV_LIGHTMAP = 9,
            PROJ_DEPTH = 10,
            LINEAR_DEPTH = 11,
            FRAGMENT_NORMAL = 12,
            FRAGMENT_TANGENT = 13,
            FRAGMENT_BINORMAL = 14,
            BASE_COLOR = 15,
            DIFFUSE_COLOR = 16,
            SPECULAR_COLOR = 17,
            TRANSPARENCY = 18,
            METALLIC = 19,
            ROUGHNESS = 20,
            SPECULAR_INTENSITY = 21,
            DIRECT_DIFFUSE = 22,
            DIRECT_SPECULAR = 23,
            DIRECT_ALL = 24,
            ENV_DIFFUSE = 25,
            ENV_SPECULAR = 26,
            ENV_ALL = 27,
            EMISSIVE = 28,
            LIGHT_MAP = 29,
            SHADOW = 30,
            AO = 31,
            FOG = 32
        }
        /**
         * @zh
         * 渲染组合调试模式
         * @en
         * Rendering composite debug mode
         * @readonly
         */
        export const enum _cocos_core_pipeline_debug_view__DebugViewCompositeType {
            DIRECT_DIFFUSE = 0,
            DIRECT_SPECULAR = 1,
            ENV_DIFFUSE = 2,
            ENV_SPECULAR = 3,
            EMISSIVE = 4,
            LIGHT_MAP = 5,
            SHADOW = 6,
            AO = 7,
            NORMAL_MAP = 8,
            FOG = 9,
            TONE_MAPPING = 10,
            GAMMA_CORRECTION = 11,
            MAX_BIT_COUNT = 12
        }
        export interface _cocos_core_asset_manager_cache__ICache<T> {
            add(key: string, val: T): T;
            get(key: string): T | undefined | null;
            has(key: string): boolean;
            remove(key: string): T | undefined | null;
            clear(): void;
            forEach(func: (val: T, key: string) => void): void;
            find(predicate: (val: T, key: string) => boolean): T | null;
            readonly count: number;
            destroy(): void;
        }
        export interface _cocos_core_asset_manager_depend_util__IDependencies {
            nativeDep?: Record<string, any>;
            deps: string[];
            parsedFromExistAsset?: boolean;
            persistDeps?: string[];
        }
        /**
         * @en
         * Control asset's dependency list, it is a singleton. All member can be accessed with `assetManager.dependUtil`
         *
         * @zh
         * 控制资源的依赖列表，这是一个单例, 所有成员能通过 `assetManager.dependUtil` 访问
         *
         */
        export class _cocos_core_asset_manager_depend_util__DependUtil {
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _depends: AssetManager.Cache<_cocos_core_asset_manager_depend_util__IDependencies>;
            init(): void;
            /**
             * @en
             * Get asset's native dependency. For example, Texture's native dependency is image.
             *
             * @zh
             * 获取资源的原生依赖，例如 Texture 的原生依赖是图片
             *
             * @param uuid - asset's uuid
             * @returns native dependency
             *
             * @example
             * var dep = dependUtil.getNativeDep('fcmR3XADNLgJ1ByKhqcC5Z');
             */
            getNativeDep(uuid: string): Record<string, any> | null;
            /**
             * @en
             * Get asset's direct referencing non-native dependency list. For example, Material's non-native dependencies are Texture.
             *
             * @zh
             * 获取资源直接引用的非原生依赖列表，例如，材质的非原生依赖是 Texture
             *
             * @param uuid - asset's uuid
             * @returns direct referencing non-native dependency list
             *
             * @example
             * var deps = dependUtil.getDeps('fcmR3XADNLgJ1ByKhqcC5Z');
             *
             */
            getDeps(uuid: string): string[];
            /**
             * @en
             * Get non-native dependency list of the loaded asset, include indirect reference.
             * The returned array stores the dependencies with their uuid, after retrieve dependencies,
             *
             * @zh
             * 获取某个已经加载好的资源的所有非原生依赖资源列表，包括间接引用的资源，并保存在数组中返回。
             * 返回的数组将仅保存依赖资源的 uuid。
             *
             * @param uuid - The asset's uuid
             * @returns non-native dependency list
             *
             * @example
             * var deps = dependUtil.getDepsRecursively('fcmR3XADNLgJ1ByKhqcC5Z');
             *
             */
            getDepsRecursively(uuid: string): string[];
            remove(uuid: string): void;
            /**
             * @en
             * Extract dependency list from serialized data or asset and then store in cache.
             *
             * @zh
             * 从序列化数据或资源中提取出依赖列表，并且存储在缓存中。
             *
             * @param uuid - The uuid of serialized data or asset
             * @param json - Serialized data or asset
             * @returns dependency list, include non-native and native dependency
             *
             * @example
             * downloader.downloadFile('test.json', { xhrResponseType: 'json'}, null, (err, file) => {
             *     var dependencies = parse('fcmR3XADNLgJ1ByKhqcC5Z', file);
             * });
             *
             */
            parse(uuid: string, json: any): _cocos_core_asset_manager_depend_util__IDependencies;
        }
        export interface _cocos_core_asset_manager_shared__IXHROptions extends Record<string, any> {
            xhrResponseType?: XMLHttpRequestResponseType;
            xhrWithCredentials?: boolean;
            xhrTimeout?: number;
            xhrHeader?: Record<string, string>;
            xhrMimeType?: string;
        }
        export interface _cocos_core_asset_manager_shared__IDownloadParseOptions extends _cocos_core_asset_manager_shared__IXHROptions {
            priority?: number;
            audioLoadMode?: number;
            onFileProgress?: (loaded: number, total: number) => void;
            maxConcurrency?: number;
            maxRequestsPerFrame?: number;
            maxRetryCount?: number;
            cacheEnabled?: boolean;
        }
        export interface _cocos_core_asset_manager_shared__INativeAssetOptions extends _cocos_core_asset_manager_shared__IDownloadParseOptions {
            preset?: string;
        }
        export interface _cocos_core_asset_manager_shared__IBundleOptions extends _cocos_core_asset_manager_shared__INativeAssetOptions {
            version?: string;
            scriptAsyncLoading?: boolean;
        }
        export interface _cocos_core_asset_manager_shared__IAssetOptions extends _cocos_core_asset_manager_shared__INativeAssetOptions {
            reloadAsset?: boolean;
            cacheAsset?: boolean;
        }
        export interface _cocos_core_asset_manager_shared__IRemoteOptions extends _cocos_core_asset_manager_shared__IAssetOptions {
            ext?: string;
        }
        export interface _cocos_core_asset_manager_shared__IOptions extends _cocos_core_asset_manager_shared__IBundleOptions, _cocos_core_asset_manager_shared__IRemoteOptions {
            type?: typeof Asset;
            bundle?: string;
        }
        export interface _cocos_core_asset_manager_shared__IRequest extends _cocos_core_asset_manager_shared__IOptions {
            uuid?: string;
            url?: string;
            path?: string;
            dir?: string;
            scene?: string;
        }
        export type _cocos_core_asset_manager_shared__Request = string | string[] | _cocos_core_asset_manager_shared__IRequest | Array<_cocos_core_asset_manager_shared__IRequest>;
        namespace _cocos_core_asset_manager_helper {
            export function getUuidFromURL(url: string): string;
            export function getUrlWithUuid(uuid: string, options?: {
                [k: string]: any;
                isNative: boolean;
                nativeExt?: string;
            } | null): string;
            export function isScene(asset: any): boolean;
            export function normalize(url: string): string;
            export function transform(input: _cocos_core_asset_manager_shared__Request, options?: _cocos_core_asset_manager_shared__IOptions | null): string | string[];
        }
        export type _cocos_core_asset_manager_shared__CompleteCallback<T = any> = (err: Error | null, data?: T | null) => void;
        export function _cocos_core_asset_manager_download_dom_image__default(url: string, options: _cocos_core_asset_manager_shared__IDownloadParseOptions, onComplete: _cocos_core_asset_manager_shared__CompleteCallback<HTMLImageElement>): HTMLImageElement;
        export type _cocos_core_asset_manager_downloader__DownloadHandler = (url: string, options: _cocos_core_asset_manager_shared__IDownloadParseOptions, onComplete: _cocos_core_asset_manager_shared__CompleteCallback) => void;
        export type _cocos_core_asset_manager_download_file__FileProgressCallback = (loaded: number, total: number) => void;
        export function _cocos_core_asset_manager_download_file__default(url: string, options: _cocos_core_asset_manager_shared__IXHROptions, onProgress: _cocos_core_asset_manager_download_file__FileProgressCallback | null | undefined, onComplete: _cocos_core_asset_manager_shared__CompleteCallback): XMLHttpRequest;
        export function _cocos_core_asset_manager_download_script__default(url: string, options: _cocos_core_asset_manager_shared__IBundleOptions, onComplete: _cocos_core_asset_manager_shared__CompleteCallback): HTMLScriptElement | null;
        export type _cocos_core_asset_manager_shared__CompleteCallbackNoData = (err?: Error | null) => void;
        /**
         * @en
         * Control all download process, it is a singleton.
         * All member can be accessed with `assetManager.downloader`, it can download several types of files:
         * 1. Text
         * 2. Image
         * 3. Audio
         * 4. Assets
         * 5. Scripts
         *
         * @zh
         * 管理所有下载过程，downloader 是个单例，所有成员能通过 `assetManager.downloader` 访问，它能下载以下几种类型的文件：
         * 1. 文本
         * 2. 图片
         * 3. 音频
         * 4. 资源
         * 5. 脚本
         *
         */
        export class _cocos_core_asset_manager_downloader__Downloader {
            /**
             * @en
             * The maximum number of concurrent when downloading
             *
             * @zh
             * 下载时的最大并发数
             */
            maxConcurrency: number;
            /**
             * @en
             * The maximum number of request can be launched per frame when downloading
             *
             * @zh
             * 下载时每帧可以启动的最大请求数
             *
             */
            maxRequestsPerFrame: number;
            /**
             * @en
             * The address of remote server
             *
             * @zh
             * 远程服务器地址
             *
             */
            get remoteServerAddress(): string;
            /**
             * @en
             * The max number of retries when fail
             *
             * @zh
             * 失败重试次数
             *
             * @property maxRetryCount
             * @type {Number}
             */
            maxRetryCount: number;
            appendTimeStamp: boolean;
            limited: boolean;
            /**
             * @en
             * Wait for while before another retry, unit: ms
             *
             * @zh
             * 重试的间隔时间
             *
             */
            retryInterval: number;
            bundleVers: Record<string, string> | null;
            remoteBundles: string[];
            downloadDomImage: typeof _cocos_core_asset_manager_download_dom_image__default;
            downloadDomAudio: _cocos_core_asset_manager_downloader__DownloadHandler | null;
            downloadFile: typeof _cocos_core_asset_manager_download_file__default;
            downloadScript: typeof _cocos_core_asset_manager_download_script__default;
            init(remoteServerAddress?: string, bundleVers?: Record<string, string>, remoteBundles?: string[]): void;
            /**
             * @en
             * Register custom handler if you want to change default behavior or extend downloader to download other format file
             *
             * @zh
             * 当你想修改默认行为或者拓展 downloader 来下载其他格式文件时可以注册自定义的 handler
             *
             * @param type - Extension likes '.jpg' or map likes {'.jpg': jpgHandler, '.png': pngHandler}
             * @param handler - handler
             * @param handler.url - url
             * @param handler.options - some optional parameters will be transferred to handler.
             * @param handler.onComplete - callback when finishing downloading
             *
             * @example
             * downloader.register('.tga', (url, options, onComplete) => onComplete(null, null));
             * downloader.register({'.tga': (url, options, onComplete) => onComplete(null, null),
             *                      '.ext': (url, options, onComplete) => onComplete(null, null)});
             *
             */
            register(type: string, handler: _cocos_core_asset_manager_downloader__DownloadHandler): void;
            register(map: Record<string, _cocos_core_asset_manager_downloader__DownloadHandler>): void;
            /**
             * @en
             * Use corresponding handler to download file under limitation
             *
             * @zh
             * 在限制下使用对应的 handler 来下载文件
             *
             * @param id - The unique id of this download
             * @param url - The url should be downloaded
             * @param type - The type indicates that which handler should be used to download, such as '.jpg'
             * @param options - some optional parameters will be transferred to the corresponding handler.
             * @param options.onFileProgress - progressive callback will be transferred to handler.
             * @param options.maxRetryCount - How many times should retry when download failed
             * @param options.maxConcurrency - The maximum number of concurrent when downloading
             * @param options.maxRequestsPerFrame - The maximum number of request can be launched per frame when downloading
             * @param options.priority - The priority of this url, default is 0, the greater number is higher priority.
             * @param onComplete - callback when finishing downloading
             * @param onComplete.err - The occurred error, null indicates success
             * @param onComplete.content - The downloaded file
             *
             * @example
             * download('http://example.com/test.tga', '.tga', { onFileProgress: (loaded, total) => console.log(loaded/total) },
             *      onComplete: (err) => console.log(err));
             */
            download(id: string, url: string, type: string, options: _cocos_core_asset_manager_shared__IDownloadParseOptions, onComplete: _cocos_core_asset_manager_shared__CompleteCallback): void;
            /**
             * @en Load sub package with name.
             * @zh 通过子包名加载子包代码。
             * @param name - Sub package name
             * @param completeCallback -  Callback invoked when sub package loaded
             * @param {Error} completeCallback.error - error information
             *
             * @deprecated loader.downloader.loadSubpackage is deprecated, please use AssetManager.loadBundle instead
             */
            loadSubpackage(name: string, completeCallback?: _cocos_core_asset_manager_shared__CompleteCallbackNoData): void;
        }
        export type _cocos_core_asset_manager_parser__ParseHandler = (file: any, options: _cocos_core_asset_manager_shared__IDownloadParseOptions, onComplete: _cocos_core_asset_manager_shared__CompleteCallback) => void;
        /**
         * @en
         * Parse the downloaded file, it's a singleton, all member can be accessed with `assetManager.parser`
         *
         * @zh
         * 解析已下载的文件，parser 是一个单例, 所有成员能通过 `assetManaager.parser` 访问
         *
         */
        export class _cocos_core_asset_manager_parser__Parser {
            parseImage(file: HTMLImageElement | Blob, options: _cocos_core_asset_manager_shared__IDownloadParseOptions, onComplete: _cocos_core_asset_manager_shared__CompleteCallback<HTMLImageElement | ImageBitmap>): void;
            parsePVRTex(file: ArrayBuffer | ArrayBufferView, options: _cocos_core_asset_manager_shared__IDownloadParseOptions, onComplete: _cocos_core_asset_manager_shared__CompleteCallback<_cocos_core_assets_image_asset__IMemoryImageSource>): void;
            parsePKMTex(file: ArrayBuffer | ArrayBufferView, options: _cocos_core_asset_manager_shared__IDownloadParseOptions, onComplete: _cocos_core_asset_manager_shared__CompleteCallback<_cocos_core_assets_image_asset__IMemoryImageSource>): void;
            parseASTCTex(file: ArrayBuffer | ArrayBufferView, options: _cocos_core_asset_manager_shared__IDownloadParseOptions, onComplete: _cocos_core_asset_manager_shared__CompleteCallback<_cocos_core_assets_image_asset__IMemoryImageSource>): void;
            parsePlist(file: string, options: _cocos_core_asset_manager_shared__IDownloadParseOptions, onComplete: _cocos_core_asset_manager_shared__CompleteCallback): void;
            parseImport(file: Record<string, any> | CCON, options: _cocos_core_asset_manager_shared__IDownloadParseOptions, onComplete: _cocos_core_asset_manager_shared__CompleteCallback<Asset>): void;
            init(): void;
            /**
             * @en
             * Register custom handler if you want to change default behavior or extend parser to parse other format file
             *
             * @zh
             * 当你想修改默认行为或者拓展 parser 来解析其他格式文件时可以注册自定义的handler
             *
             * @param type - Extension likes '.jpg' or map likes {'.jpg': jpgHandler, '.png': pngHandler}
             * @param handler - The corresponding handler
             * @param handler.file - File
             * @param handler.options - Some optional paramter
             * @param handler.onComplete - callback when finishing parsing
             *
             * @example
             * parser.register('.tga', (file, options, onComplete) => onComplete(null, null));
             * parser.register({'.tga': (file, options, onComplete) => onComplete(null, null),
             *                  '.ext': (file, options, onComplete) => onComplete(null, null)});
             *
             */
            register(type: string, handler: _cocos_core_asset_manager_parser__ParseHandler): void;
            register(map: Record<string, _cocos_core_asset_manager_parser__ParseHandler>): void;
            /**
             * @en
             * Use corresponding handler to parse file
             *
             * @zh
             * 使用对应的handler来解析文件
             *
             * @param id - The id of file
             * @param file - File
             * @param type - The corresponding type of file, likes '.jpg'.
             * @param options - Some optional parameters will be transferred to the corresponding handler.
             * @param onComplete - callback when finishing downloading
             * @param onComplete.err - The occurred error, null indicates success
             * @param onComplete.content - The parsed file
             *
             * @example
             * downloader.download('test.jpg', 'test.jpg', '.jpg', {}, (err, file) => {
             *      parser.parse('test.jpg', file, '.jpg', null, (err, img) => console.log(err));
             * });
             *
             */
            parse(id: string, file: any, type: string, options: _cocos_core_asset_manager_shared__IDownloadParseOptions, onComplete: _cocos_core_asset_manager_shared__CompleteCallback): void;
        }
        export type _cocos_core_asset_manager_pack_manager__Unpacker = (packUuid: string[], data: any, options: _cocos_core_asset_manager_shared__IDownloadParseOptions, onComplete: _cocos_core_asset_manager_shared__CompleteCallback) => void;
        /**
         * @en
         * Handle the packed asset, include unpacking, loading, cache and so on. It is a singleton. All member can be accessed with `assetManager.packManager`
         *
         * @zh
         * 处理打包资源，包括拆包，加载，缓存等等，这是一个单例, 所有成员能通过 `assetManager.packManager` 访问
         *
         */
        export class _cocos_core_asset_manager_pack_manager__PackManager {
            /**
             * @en
             * Unpack the json, revert to what it was before packing
             *
             * @zh
             * 拆解 json 包，恢复为打包之前的内容
             *
             * @param pack - The pack
             * @param json - The content of pack
             * @param options - Some optional parameters
             * @param onComplete - Callback when finish unpacking
             * @param onComplete.err - The occurred error, null indicates success
             * @param onComplete.content - The unpacked assets
             *
             * @example
             * downloader.downloadFile('pack.json', { xhrResponseType: 'json'}, null, (err, file) => {
             *      packManager.unpackJson(['a', 'b'], file, null, (err, data) => console.log(err));
             * });
             *
             */
            unpackJson(pack: string[], json: any, options: _cocos_core_asset_manager_shared__IDownloadParseOptions, onComplete: _cocos_core_asset_manager_shared__CompleteCallback<Record<string, any>>): void;
            init(): void;
            /**
             * @en
             * Register custom handler if you want to change default behavior or extend packManager to unpack other format pack
             *
             * @zh
             * 当你想修改默认行为或者拓展 packManager 来拆分其他格式的包时可以注册自定义的 handler
             *
             * @param type - Extension likes '.bin' or map likes {'.bin': binHandler, '.ab': abHandler}
             * @param handler - handler
             * @param handler.packUuid - The uuid of pack
             * @param handler.data - The content of pack
             * @param handler.options - Some optional parameters
             * @param handler.onComplete - Callback when finishing unpacking
             *
             * @example
             * packManager.register('.bin', (packUuid, file, options, onComplete) => onComplete(null, null));
             * packManager.register({
             *  '.bin': (packUuid, file, options, onComplete) => onComplete(null, null),
             *  '.ab': (packUuid, file, options, onComplete) => onComplete(null, null),
             * });
             */
            register(type: string, handler: _cocos_core_asset_manager_pack_manager__Unpacker): void;
            register(map: Record<string, _cocos_core_asset_manager_pack_manager__Unpacker>): void;
            /**
             * @en
             * Use corresponding handler to unpack package
             *
             * @zh
             * 用对应的 handler 来进行解包
             *
             * @method unpack
             * @param pack - The uuid of packed assets
             * @param data - The packed data
             * @param type - The type indicates that which handler should be used to download, such as '.jpg'
             * @param options - Some optional parameter
             * @param onComplete - callback when finishing unpacking
             * @param onComplete.err -  The occurred error, null indicates success
             * @param onComplete.data - Original assets
             *
             * @example
             * downloader.downloadFile('pack.json', {xhrResponseType: 'json'}, null, (err, file) => {
             *      packManager.unpack(['2fawq123d', '1zsweq23f'], file, '.json', null, (err, data) => console.log(err));
             * });
             *
             */
            unpack(pack: string[], data: any, type: string, options: _cocos_core_asset_manager_shared__IDownloadParseOptions, onComplete: _cocos_core_asset_manager_shared__CompleteCallback): void;
            /**
             * @en
             * Download request item, If item is not in any package, download as usual. Otherwise, download the corresponding package and unpack it.
             * And then retrieve the corresponding content form it.
             *
             * @zh
             * 下载请求对象，如果请求对象不在任何包内，则正常下载，否则下载对应的 package 并进行拆解，并取回包内对应的内容
             *
             * @param item - Some item you want to download
             * @param options - Some optional parameters
             * @param onComplete - Callback when finished
             * @param onComplete.err - The occurred error, null indicates success
             * @param onComplete.data - The unpacked data retrieved from package
             *
             * @example
             * var requestItem = AssetManager.RequestItem.create();
             * requestItem.uuid = 'fcmR3XADNLgJ1ByKhqcC5Z';
             * requestItem.info = config.getAssetInfo('fcmR3XADNLgJ1ByKhqcC5Z');
             * packManager.load(requestItem, null, (err, data) => console.log(err));
             *
             */
            load(item: AssetManager.RequestItem, options: _cocos_core_asset_manager_shared__IDownloadParseOptions | null, onComplete: _cocos_core_asset_manager_shared__CompleteCallback): void;
        }
        /**
         * @en
         * Cache manager is a module which controls all caches downloaded from server in non-web platform, it is a singleton
         * All member can be accessed with `assetManager.cacheManager`.
         *
         * @zh
         * 缓存管理器是一个模块，在非 WEB 平台上，用于管理所有从服务器上下载下来的缓存，这是一个单例，所有成员能通过 `assetManager.cacheManager` 访问。
         *
         */
        export abstract class _cocos_core_asset_manager_cache_manager__default {
            /**
             * @en
             * The name of cacheDir
             *
             * @zh
             * 缓存目录的名称
             */
            abstract cacheDir: string;
            /**
             * @en
             * Whether or not cache asset into user's storage space, this property only works on mini-game platforms
             *
             * @zh
             * 是否缓存资源到用户存储空间，此属性只在小游戏平台有效
             *
             */
            abstract cacheEnabled: boolean;
            /**
             * @en
             * Whether or not auto clear cache when storage ran out, this property only works on mini-game platforms
             *
             * @zh
             * 是否在存储空间满了后自动清理缓存，此属性只在小游戏平台有效
             *
             */
            abstract autoClear: boolean;
            /**
             * @en
             * The interval between caching resources, this property only works on mini-game platforms, unit: ms
             *
             * @zh
             * 缓存资源的间隔时间，此属性只在小游戏平台有效，单位：毫秒
             *
             */
            abstract cacheInterval: number;
            /**
             * @en
             * The interval between deleting resources, when you use `cleanLRU`, the resources will be deleted as this interval, unit: ms
             *
             * @zh
             * 清理资源的间隔时间，当你使用 `cleanLRU` 时，资源将以此间隔被删除，单位：毫秒
             *
             */
            abstract deleteInterval: number;
            /**
             * @en
             * List of all cached files
             *
             * @zh
             * 所有缓存文件列表
             *
             */
            abstract cachedFiles: AssetManager.Cache<{
                bundle: string;
                url: string;
                lastTime: number;
            }>;
            /**
             * @en
             * Get cached path with origin url
             *
             * @zh
             * 通过原始 url 获取缓存后的路径
             *
             * @param originUrl
             * @returns The cached path
             */
            abstract getCache(originUrl: string): string;
            /**
             * @en
             * Get temporary path with origin url, this method only works on mini-game platforms
             *
             * @zh
             * 通过原始 url 获取临时文件的路径，此方法只在小游戏平台有效
             *
             * @param originUrl
             * @returns The temp path
             */
            abstract getTemp(originUrl: string): string;
            /**
             * @en
             * Clear all caches, please use with caution, If necessary, we recommend using it before the game is launched
             *
             * @zh
             * 清空所有缓存，请谨慎使用，如果必要的话，我们建议在游戏启动之前使用
             *
             */
            abstract clearCache(): void;
            /**
             * @en
             * Clear part of caches with LRU strategy
             *
             * @zh
             * 使用 LRU 策略清空部分缓存
             *
             */
            abstract clearLRU(): void;
            /**
             * @en
             * Remove cache with origin url
             *
             * @zh
             * 通过原始 url 移除缓存
             *
             */
            abstract removeCache(originUrl: string): void;
        }
        export type _cocos_core_asset_manager_factory__CreateHandler = (id: string, data: any, options: _cocos_core_asset_manager_shared__IDownloadParseOptions, onComplete: _cocos_core_asset_manager_shared__CompleteCallback<Asset | AssetManager.Bundle>) => void;
        export class _cocos_core_asset_manager_factory__Factory {
            register(type: string | Record<string, _cocos_core_asset_manager_factory__CreateHandler>, handler?: _cocos_core_asset_manager_factory__CreateHandler): void;
            create(id: string, data: any, type: string, options: _cocos_core_asset_manager_shared__IRemoteOptions, onComplete: _cocos_core_asset_manager_shared__CompleteCallback<Asset | AssetManager.Bundle>): void;
        }
        export type _cocos_core_asset_manager_pipeline__IAsyncPipe = (task: AssetManager.Task, done: _cocos_core_asset_manager_shared__CompleteCallbackNoData) => void;
        export type _cocos_core_asset_manager_pipeline__ISyncPipe = (task: AssetManager.Task) => Error | void;
        export type _cocos_core_asset_manager_pipeline__IPipe = _cocos_core_asset_manager_pipeline__IAsyncPipe | _cocos_core_asset_manager_pipeline__ISyncPipe;
        export type _cocos_core_asset_manager_shared__ProgressCallback = (finished: number, total: number, item: AssetManager.RequestItem) => void;
        export type _cocos_core_asset_manager_shared__CompleteCallbackWithData<T = any> = (err: Error | null, data: T) => void;
        export interface _cocos_core_asset_manager_shared__IJsonAssetOptions extends _cocos_core_asset_manager_shared__IAssetOptions {
            assetId?: string;
        }
        export type _cocos_core_asset_manager_task__TaskCompleteCallback = (err: Error | null | undefined, data: any) => void;
        export type _cocos_core_asset_manager_task__TaskProgressCallback = (...args: any[]) => void;
        export type _cocos_core_asset_manager_task__TaskErrorCallback = (...args: any[]) => void;
        export interface _cocos_core_asset_manager_task__ITaskOption {
            onComplete?: _cocos_core_asset_manager_task__TaskCompleteCallback | null;
            onProgress?: _cocos_core_asset_manager_task__TaskProgressCallback | null;
            onError?: _cocos_core_asset_manager_task__TaskErrorCallback | null;
            input: any;
            progress?: any;
            options?: Record<string, any> | null;
        }
        export interface _cocos_core_asset_manager_config__IPackInfo extends _cocos_core_asset_manager_config__IAssetInfo {
            packedUuids: string[];
            ext: string;
        }
        export interface _cocos_core_asset_manager_config__IAssetInfo {
            uuid: string;
            packs?: _cocos_core_asset_manager_config__IPackInfo[];
            redirect?: string;
            ver?: string;
            nativeVer?: string;
            extension?: string;
        }
        export interface _cocos_core_asset_manager_config__ISceneInfo extends _cocos_core_asset_manager_config__IAssetInfo {
            url: string;
        }
        export type _cocos_core_asset_manager_shared__AssetType<T = Asset> = _types_globals__Constructor<T>;
        export interface _cocos_core_asset_manager_config__IAddressableInfo extends _cocos_core_asset_manager_config__IAssetInfo {
            path: string;
            ctor: _cocos_core_asset_manager_shared__AssetType;
        }
        export interface _cocos_core_asset_manager_config__IConfigOption {
            importBase: string;
            nativeBase: string;
            base: string;
            name: string;
            deps: string[];
            uuids: string[];
            paths: Record<string, any[]>;
            scenes: Record<string, string>;
            packs: Record<string, string[]>;
            versions: {
                import: string[];
                native: string[];
            };
            redirect: string[];
            debug: boolean;
            types: string[];
            extensionMap: Record<string, string[]>;
        }
        export class _cocos_core_asset_manager_config__default {
            name: string;
            base: string;
            importBase: string;
            nativeBase: string;
            deps: string[] | null;
            assetInfos: AssetManager.Cache<_cocos_core_asset_manager_config__IAssetInfo>;
            scenes: AssetManager.Cache<_cocos_core_asset_manager_config__ISceneInfo>;
            paths: AssetManager.Cache<_cocos_core_asset_manager_config__IAddressableInfo[]>;
            init(options: _cocos_core_asset_manager_config__IConfigOption): void;
            getInfoWithPath(path: string, type?: _cocos_core_asset_manager_shared__AssetType | null): _cocos_core_asset_manager_config__IAddressableInfo | null;
            getDirWithPath(path: string, type?: _cocos_core_asset_manager_shared__AssetType | null, out?: _cocos_core_asset_manager_config__IAddressableInfo[]): _cocos_core_asset_manager_config__IAddressableInfo[];
            getAssetInfo(uuid: string): _cocos_core_asset_manager_config__IAssetInfo | null;
            getSceneInfo(name: string): _cocos_core_asset_manager_config__ISceneInfo | null;
            destroy(): void;
        }
        export type _cocos_core_asset_manager_deprecated__LoadProgressCallback = (completedCount: number, totalCount: number, item: any) => void;
        export type _cocos_core_asset_manager_deprecated__LoadCompleteCallback<T> = (error: Error | null, asset: T) => void;
        export type _cocos_core_asset_manager_deprecated__LoadDirCompleteCallback<T> = (error: Error | null, asset: T[], urls: string[]) => void;
        export type _types_globals__AbstractedConstructor<T = unknown> = new (...args: any[]) => T;
        /**
         * @en Node's UI properties abstraction
         * @zh 节点上 UI 相关的属性抽象类
         */
        export class _cocos_core_scene_graph_node_ui_properties__NodeUIProperties {
            /**
             * @en The UI transform component
             * @zh UI 变换组件
             */
            get uiTransformComp(): UITransform | null;
            set uiTransformComp(value: UITransform | null);
            /**
             * @en The base UI component
             * @zh UI 基类组件
             */
            get uiComp(): UIMeshRenderer | UIRenderer | null;
            set uiComp(comp: UIMeshRenderer | UIRenderer | null);
            get opacity(): number;
            get localOpacity(): number;
            set localOpacity(val: number);
            colorDirty: boolean;
            protected _uiTransformComp: UITransform | null;
            constructor(node: any);
            /**
             * @deprecated since v3.4
             */
            applyOpacity(effectOpacity: any): void;
            /**
             * @en Make the opacity state of node tree is dirty, not effect anymore
             * @zh 为结点树的透明度状态设置脏标签，不再有效果
             * @deprecated since v3.4
             */
            static markOpacityTree(node: any, isDirty?: boolean): void;
        }
        /**
         * @en The projection type.
         * @zh 投影类型。
         */
        export const _cocos_core_components_camera_component__ProjectionType: typeof renderer.scene.CameraProjection;
        export const _cocos_core_components_camera_component__FOVAxis: typeof renderer.scene.CameraFOVAxis;
        export const _cocos_core_components_camera_component__ClearFlag: {
            SKYBOX: number;
            SOLID_COLOR: gfx.ClearFlagBit;
            DEPTH_ONLY: gfx.ClearFlagBit;
            DONT_CLEAR: gfx.ClearFlagBit;
        };
        export const _cocos_core_components_camera_component__Aperture: typeof renderer.scene.CameraAperture;
        export const _cocos_core_components_camera_component__Shutter: typeof renderer.scene.CameraShutter;
        export const _cocos_core_components_camera_component__ISO: typeof renderer.scene.CameraISO;
        export class _cocos_core_builtin_builtin_res_mgr__BuiltinResMgr {
            protected _resources: Record<string, Asset>;
            protected _materialsToBeCompiled: Material[];
            init(): void;
            addAsset(key: string, asset: Asset): void;
            get<T extends Asset>(uuid: string): T;
            /**
             * @internal
             */
            loadBuiltinAssets(): Promise<void>;
            compileBuiltinMaterial(): void;
        }
        /**
         * @en
         * The parameter describing a real keyframe value.
         * In the case of partial keyframe value,
         * each component of the keyframe value is taken from the parameter.
         * For unspecified components, default values are taken:
         * - Interpolation mode: `InterpolationMode.Linear`
         * - Tangent weight mode: `TangentWeightMode.None`
         * - Value/Tangents/Tangent weights: `0.0`
         * @zh
         * 用于描述实数关键帧值的参数。
         * 若是部分关键帧的形式，关键帧值的每个分量都是从该参数中取得。
         * 对于未指定的分量，使用默认值：
         * - 插值模式：`InterpolationMode.Linear`
         * - 切线权重模式：`TangentWeightMode.None`
         * - 值/切线/切线权重：`0.0`
         */
        export type _cocos_core_curves_curve__RealKeyframeValueParameters = number | Partial<RealKeyframeValue>;
        export type _cocos_core_curves_keyframe_curve__KeyFrame<TKeyframeValue> = [
            number,
            TKeyframeValue
        ];
        export interface _cocos_core_curves_curve_base__CurveBase {
            readonly rangeMin: number;
            readonly rangeMax: number;
        }
        /**
         * @en
         * Keyframe curve.
         * @zh
         * 关键帧曲线。
         */
        export class _cocos_core_curves_keyframe_curve__KeyframeCurve<TKeyframeValue> implements _cocos_core_curves_curve_base__CurveBase, Iterable<_cocos_core_curves_keyframe_curve__KeyFrame<TKeyframeValue>> {
            /**
             * @en
             * Gets the count of keyframes.
             * @zh
             * 获取关键帧数量。
             */
            get keyFramesCount(): number;
            /**
             * @en
             * Gets the minimal keyframe time on this curve.
             * @zh
             * 获取此曲线上最小的关键帧时间。
             */
            get rangeMin(): number;
            /**
             * @en
             * Gets the maximum keyframe time on this curve.
             * @zh
             * 获取此曲线上最大的关键帧时间。
             */
            get rangeMax(): number;
            /**
             * @en
             * Returns an iterator to keyframe pairs.
             * @zh
             * 返回关键帧对的迭代器。
             */
            [Symbol.iterator](): {
                next: () => IteratorResult<_cocos_core_curves_keyframe_curve__KeyFrame<TKeyframeValue>>;
            };
            /**
             * @en
             * Returns an iterator to keyframe pairs.
             * @zh
             * 返回关键帧对的迭代器。
             */
            keyframes(): Iterable<_cocos_core_curves_keyframe_curve__KeyFrame<TKeyframeValue>>;
            /**
             * @en
             * Returns an iterator to keyframe times.
             * @zh
             * 返回关键帧时间的迭代器。
             */
            times(): Iterable<number>;
            /**
             * @en
             * Returns an iterator to keyframe values.
             * @zh
             * 返回关键帧值的迭代器。
             */
            values(): Iterable<TKeyframeValue>;
            /**
             * @en
             * Gets the time of specified keyframe.
             * @zh
             * 获取指定关键帧上的时间。
             * @param index Index to the keyframe.
             * @returns The keyframe 's time.
             */
            getKeyframeTime(index: number): number;
            /**
             * @en
             * Gets the value of specified keyframe.
             * @zh
             * 获取指定关键帧上的值。
             * @param index Index to the keyframe.
             * @returns The keyframe 's value.
             */
            getKeyframeValue(index: number): TKeyframeValue;
            /**
             * @en
             * Adds a keyframe into this curve.
             * @zh
             * 添加一个关键帧到此曲线中。
             * @param time Time of the keyframe.
             * @param keyframeValue Value of the keyframe.
             * @returns The index to the new keyframe.
             */
            addKeyFrame(time: number, keyframeValue: TKeyframeValue): number;
            /**
             * @en
             * Removes a keyframe from this curve.
             * @zh
             * 移除此曲线的一个关键帧。
             * @param index Index to the keyframe.
             */
            removeKeyframe(index: number): void;
            /**
             * @en
             * Searches for the keyframe at specified time.
             * @zh
             * 搜索指定时间上的关键帧。
             * @param time Time to search.
             * @returns Index to the keyframe or negative number if not found.
             */
            indexOfKeyframe(time: number): number;
            /**
             * @en
             * Updates the time of a keyframe.
             * @zh
             * 更新关键帧的时间。
             * @param index Index to the keyframe.
             * @param time New time.
             */
            updateTime(index: number, time: number): void;
            /**
             * @en
             * Assigns all keyframes.
             * @zh
             * 赋值所有关键帧。
             * @param keyframes An iterable to keyframes. The keyframes should be sorted by their time.
             */
            assignSorted(keyframes: Iterable<[
                number,
                TKeyframeValue
            ]>): void;
            /**
             * @en
             * Assigns all keyframes.
             * @zh
             * 赋值所有关键帧。
             * @param times Times array. Should be sorted.
             * @param values Values array. Corresponding to each time in `times`.
             */
            assignSorted(times: readonly number[], values: TKeyframeValue[]): void;
            /**
             * @en
             * Removes all key frames.
             * @zh
             * 移除所有关键帧。
             */
            clear(): void;
            protected searchKeyframe(time: number): number;
            protected setKeyframes(times: number[], values: TKeyframeValue[]): void;
            protected _times: number[];
            protected _values: TKeyframeValue[];
        }
        export enum _cocos_core_curves_easing_method__EasingMethod {
            LINEAR = 0,
            CONSTANT = 1,
            QUAD_IN = 2,
            QUAD_OUT = 3,
            QUAD_IN_OUT = 4,
            QUAD_OUT_IN = 5,
            CUBIC_IN = 6,
            CUBIC_OUT = 7,
            CUBIC_IN_OUT = 8,
            CUBIC_OUT_IN = 9,
            QUART_IN = 10,
            QUART_OUT = 11,
            QUART_IN_OUT = 12,
            QUART_OUT_IN = 13,
            QUINT_IN = 14,
            QUINT_OUT = 15,
            QUINT_IN_OUT = 16,
            QUINT_OUT_IN = 17,
            SINE_IN = 18,
            SINE_OUT = 19,
            SINE_IN_OUT = 20,
            SINE_OUT_IN = 21,
            EXPO_IN = 22,
            EXPO_OUT = 23,
            EXPO_IN_OUT = 24,
            EXPO_OUT_IN = 25,
            CIRC_IN = 26,
            CIRC_OUT = 27,
            CIRC_IN_OUT = 28,
            CIRC_OUT_IN = 29,
            ELASTIC_IN = 30,
            ELASTIC_OUT = 31,
            ELASTIC_IN_OUT = 32,
            ELASTIC_OUT_IN = 33,
            BACK_IN = 34,
            BACK_OUT = 35,
            BACK_IN_OUT = 36,
            BACK_OUT_IN = 37,
            BOUNCE_IN = 38,
            BOUNCE_OUT = 39,
            BOUNCE_IN_OUT = 40,
            BOUNCE_OUT_IN = 41,
            SMOOTH = 42,
            FADE = 43
        }
        /**
         * The parameter describing a real keyframe value.
         * In the case of partial keyframe value,
         * each component of the keyframe value is taken from the parameter.
         * For unspecified components, default values are taken:
         * - Interpolation mode: slerp
         * - Value: Identity quaternion
         * @zh
         * 用于描述实数关键帧值的参数。
         * 若是部分关键帧的形式，关键帧值的每个分量都是从该参数中取得。
         * 对于未指定的分量，使用默认值：
         * - 插值模式：球面线性插值
         * - 值：单位四元数
         */
        export type _cocos_core_curves_quat_curve__QuatKeyframeValueParameters = Partial<QuatKeyframeValue>;
        /**
         * @zh
         * Settings 中的默认分组，通常与模块一一对应。
         *
         * @en
         * The default grouping in Settings, which usually corresponds to the module.
         */
        export enum _cocos_core_settings__Category {
            PATH = "path",
            ENGINE = "engine",
            ASSETS = "assets",
            SCRIPTING = "scripting",
            PHYSICS = "physics",
            RENDERING = "rendering",
            LAUNCH = "launch",
            SCREEN = "screen",
            SPLASH_SCREEN = "splashScreen",
            ANIMATION = "animation",
            PROFILING = "profiling",
            PLUGINS = "plugins"
        }
        export class _cocos_core_pipeline_custom_builtin_pipelines__CameraInfo {
            shadowEnabled: boolean;
            mainLightShadowNames: string[];
            spotLightShadowNames: string[];
        }
        export abstract class _cocos_core_pipeline_custom_pipeline__PipelineBuilder {
            abstract setup(cameras: renderer.scene.Camera[], pipeline: _cocos_core_pipeline_custom_pipeline__Pipeline): void;
        }
        export class _cocos_core_pipeline_custom_builtin_pipelines__DeferredData {
            constructor();
            readonly _deferredLightingMaterial: Material;
            readonly _deferredPostMaterial: Material;
            _antiAliasing: AntiAliasing;
        }
        export interface _extensions_ccpool_node_pool__IPoolHandlerComponent extends Component {
            unuse(): void;
            reuse(args: any): void;
        }
        export type _extensions_ccpool_node_pool__Constructor<T = {}> = new (...args: any[]) => T;
        /**
         * @en The input event type
         * @zh 输入事件类型
         */
        export enum _cocos_input_types_event_enum__InputEventType {
            /**
             * @en
             * The event type for touch start event
             *
             * @zh
             * 手指开始触摸事件。
             */
            TOUCH_START = "touch-start",
            /**
             * @en
             * The event type for touch move event
             *
             * @zh
             * 当手指在屏幕上移动时。
             */
            TOUCH_MOVE = "touch-move",
            /**
             * @en
             * The event type for touch end event
             *
             * @zh
             * 手指结束触摸事件。
             */
            TOUCH_END = "touch-end",
            /**
             * @en
             * The event type for touch end event
             *
             * @zh
             * 当手指在目标节点区域外离开屏幕时。
             */
            TOUCH_CANCEL = "touch-cancel",
            /**
             * @en
             * The event type for mouse down events
             *
             * @zh
             * 当鼠标按下时触发一次。
             */
            MOUSE_DOWN = "mouse-down",
            /**
             * @en
             * The event type for mouse move events
             *
             * @zh
             * 当鼠标在目标节点在目标节点区域中移动时，不论是否按下。
             */
            MOUSE_MOVE = "mouse-move",
            /**
             * @en
             * The event type for mouse up events
             *
             * @zh
             * 当鼠标从按下状态松开时触发一次。
             */
            MOUSE_UP = "mouse-up",
            /**
             * @en
             * The event type for mouse wheel events
             *
             * @zh 手指开始触摸事件
             */
            MOUSE_WHEEL = "mouse-wheel",
            /**
             * @en The event type for the key down event
             * @zh 当按下按键时触发的事件
             */
            KEY_DOWN = "keydown",
            /**
             * @en The event type for the key pressing event, the event will be continuously dispatched in the key pressed state
             * @zh 当按着按键时触发的事件, 该事件在按下状态会持续派发
             */
            KEY_PRESSING = "key-pressing",
            /**
             * @en The event type for the key up event
             * @zh 当松开按键时触发的事件
             */
            KEY_UP = "keyup",
            /**
             * @en
             * The event type for the devicemotion event
             *
             * @zh
             * 重力感应
             */
            DEVICEMOTION = "devicemotion",
            /**
             * @en The event type for gamepad input
             * @zh 手柄输入事件
             */
            GAMEPAD_INPUT = "gamepad-input",
            /**
             * @en The event type for gamepad device change, including gamepad connecting and disconnecting
             * @zh 手柄设备改变时触发的事件，包括手柄连接，手柄断开连接
             */
            GAMEPAD_CHANGE = "gamepad-change",
            /**
             * @en The event type for 6DOF handle input
             * @zh 6DOF手柄输入事件
             */
            HANDLE_INPUT = "handle-input",
            /**
             * @en The event type for handle pose input
             * @zh 手柄姿态输入事件
             */
            HANDLE_POSE_INPUT = "handle-pose-input",
            /**
             * @en The event type for hmd pose input
             * @zh 头戴显示器姿态输入事件
             */
            HMD_POSE_INPUT = "hmd-pose-input"
        }
        export type _cocos_input_types_event_enum__SystemEventTypeUnion = SystemEventType | NodeEventType | _cocos_input_types_event_enum__InputEventType | string;
        export type _pal_input__GamepadCallback = (res: import('cocos/input/types/event').EventGamepad) => void;
        export type _pal_input__InputSourceButton = import('pal/input/input-source').InputSourceButton;
        export type _pal_input__InputSourceDpad = import('pal/input/input-source').InputSourceDpad;
        export type _pal_input__InputSourceStick = import('pal/input/input-source').InputSourceStick;
        /**
         * Class designed for gamepad input
         */
        export class _pal_input__GamepadInputDevice {
            public static all: _pal_input__GamepadInputDevice[];
            /**
             * @en The gamepad device id
             * @zh 手柄设备 id
             */
            public get deviceId(): number;
            /**
             * @en whether the gamepad is connected
             * @zh 手柄是否处于连接状态
             */
            public get connected(): boolean;
            /**
             * @en  The control button in the north direction which is generally the button Y
             * @zh 处于北向的控制按键，一般是按键 Y
             */
            public get buttonNorth(): _pal_input__InputSourceButton;
            /**
             * @en  The control button in the east direction which is generally the button B
             * @zh 处于东向的控制按键，一般是按键 B
             */
            public get buttonEast(): _pal_input__InputSourceButton;
            /**
             * @en  The control button in the west direction which is generally the button X
             * @zh 处于西向的控制按键，一般是按键 X
             */
            public get buttonWest(): _pal_input__InputSourceButton;
            /**
             * @en  The control button in the south direction which is generally the button A
             * @zh 处于南向的控制按键，一般是按键 A
             */
            public get buttonSouth(): _pal_input__InputSourceButton;
            /**
             * @en The button L1
             * @zh 按键 L1
             */
            public get buttonL1(): _pal_input__InputSourceButton;
            /**
             * @en The button L2
             * @zh 按键 L2
             */
            public get buttonL2(): _pal_input__InputSourceButton;
            /**
             * @en The button L3
             * @zh 按键 L3
             */
            public get buttonL3(): _pal_input__InputSourceButton;
            /**
             * @en The button R1
             * @zh 按键 R1
             */
            public get buttonR1(): _pal_input__InputSourceButton;
            /**
             * @en The button R2
             * @zh 按键 R2
             */
            public get buttonR2(): _pal_input__InputSourceButton;
            /**
             * @en The button R3
             * @zh 按键 R3
             */
            public get buttonR3(): _pal_input__InputSourceButton;
            // public get buttonTouchPad (): InputSourceButton;
            // public get buttonHome (): InputSourceButton;
            /**
             * @en The button Share
             * @zh 分享按键
             */
            public get buttonShare(): _pal_input__InputSourceButton;
            /**
             * @en The button Options
             * @zh 选项按键
             */
            public get buttonOptions(): _pal_input__InputSourceButton;
            /**
             * @en The dpad buttons
             * @zh 方向按键
             */
            public get dpad(): _pal_input__InputSourceDpad;
            /**
             * @en The left stick
             * @zh 左摇杆
             */
            public get leftStick(): _pal_input__InputSourceStick;
            /**
             * @en The right stick
             * @zh 右摇杆
             */
            public get rightStick(): _pal_input__InputSourceStick;
            /**
             * @en The button Start
             * @zh 开始按键
             */
            public get buttonStart(): _pal_input__InputSourceButton;
        }
        export type _pal_input__HandleCallback = (res: import('cocos/input/types').EventHandle) => void;
        export type _pal_input__InputSourcePosition = import('pal/input/input-source').InputSourcePosition;
        export type _pal_input__InputSourceOrientation = import('pal/input/input-source').InputSourceOrientation;
        /**
         * Class designed for handle input.
         */
        export class _pal_input__HandleInputDevice {
            /**
             * @en  The control button in the north direction which is generally the button Y
             * @zh 处于北向的控制按键，一般是按键 Y
             */
            public get buttonNorth(): _pal_input__InputSourceButton;
            /**
             * @en  The control button in the east direction which is generally the button B
             * @zh 处于东向的控制按键，一般是按键 B
             */
            public get buttonEast(): _pal_input__InputSourceButton;
            /**
             * @en  The control button in the west direction which is generally the button X
             * @zh 处于西向的控制按键，一般是按键 X
             */
            public get buttonWest(): _pal_input__InputSourceButton;
            /**
             * @en  The control button in the south direction which is generally the button A
             * @zh 处于南向的控制按键，一般是按键 A
             */
            public get buttonSouth(): _pal_input__InputSourceButton;
            /**
             * @en The button Left Trigger
             * @zh 左扳机按键
             */
            public get buttonTriggerLeft(): _pal_input__InputSourceButton;
            /**
             * @en The button Right Trigger
             * @zh 右扳机按键
             */
            public get buttonTriggerRight(): _pal_input__InputSourceButton;
            /**
             * @en The grab Left Trigger
             * @zh 左扳机扣动
             */
            public get triggerLeft(): _pal_input__InputSourceButton;
            /**
             * @en The grab Right Trigger
             * @zh 右扳机扣动
             */
            public get triggerRight(): _pal_input__InputSourceButton;
            /**
             * @en The grab Left Grip
             * @zh 左手柄握住
             */
            public get gripLeft(): _pal_input__InputSourceButton;
            /**
             * @en The grab Right Grip
             * @zh 右手柄握住
             */
            public get gripRight(): _pal_input__InputSourceButton;
            /**
             * @en The left stick
             * @zh 左摇杆
             */
            public get leftStick(): _pal_input__InputSourceStick;
            /**
             * @en The right stick
             * @zh 右摇杆
             */
            public get rightStick(): _pal_input__InputSourceStick;
            /**
             * @en The button Left Stick
             * @zh 左摇杆按键
             */
            public get buttonLeftStick(): _pal_input__InputSourceButton;
            /**
             * @en The button Right Stick
             * @zh 右摇杆按键
             */
            public get buttonRightStick(): _pal_input__InputSourceButton;
            /**
             * @en The position Left hand
             * @zh 左手位置
             */
            public get handLeftPosition(): _pal_input__InputSourcePosition;
            /**
             * @en The orientation Left hand
             * @zh 左手方向
             */
            public get handLeftOrientation(): _pal_input__InputSourceOrientation;
            /**
             * @en The position Right hand
             * @zh 右手位置
             */
            public get handRightPosition(): _pal_input__InputSourcePosition;
            /**
             * @en The orientation Right hand
             * @zh 右手方向
             */
            public get handRightOrientation(): _pal_input__InputSourceOrientation;
            /**
             * @en The position Left aim
             * @zh 左射线位置
             */
            public get aimLeftPosition(): _pal_input__InputSourcePosition;
            /**
             * @en The orientation Left aim
             * @zh 左射线方向
             */
            public get aimLeftOrientation(): _pal_input__InputSourceOrientation;
            /**
             * @en The position Right aim
             * @zh 右射线位置
             */
            public get aimRightPosition(): _pal_input__InputSourcePosition;
            /**
             * @en The orientation Right aim
             * @zh 右射线方向
             */
            public get aimRightOrientation(): _pal_input__InputSourceOrientation;
        }
        export type _pal_input__HMDCallback = (res: import('cocos/input/types').EventHMD) => void;
        /**
         * Class designed for HMD input.
         */
        export class _pal_input__HMDInputDevice {
            /**
             * @en The position Left view
             * @zh 左窗口位置
             */
            public get viewLeftPosition(): _pal_input__InputSourcePosition;
            /**
             * @en The orientation Left view
             * @zh 左窗口方向
             */
            public get viewLeftOrientation(): _pal_input__InputSourceOrientation;
            /**
             * @en The position Right view
             * @zh 右窗口位置
             */
            public get viewRightPosition(): _pal_input__InputSourcePosition;
            /**
             * @en The orientation Right view
             * @zh 右窗口方向
             */
            public get viewRightOrientation(): _pal_input__InputSourceOrientation;
            /**
             * @en The position Middle head
             * @zh 头部中间位置
             */
            public get headMiddlePosition(): _pal_input__InputSourcePosition;
            /**
             * @en The orientation Middle head
             * @zh 头部中间方向
             */
            public get headMiddleOrientation(): _pal_input__InputSourceOrientation;
        }
        export interface _cocos_input_input__InputEventMap {
            [Input.EventType.MOUSE_DOWN]: (event: EventMouse) => void;
            [Input.EventType.MOUSE_MOVE]: (event: EventMouse) => void;
            [Input.EventType.MOUSE_UP]: (event: EventMouse) => void;
            [Input.EventType.MOUSE_WHEEL]: (event: EventMouse) => void;
            [Input.EventType.TOUCH_START]: (event: EventTouch) => void;
            [Input.EventType.TOUCH_MOVE]: (event: EventTouch) => void;
            [Input.EventType.TOUCH_END]: (event: EventTouch) => void;
            [Input.EventType.TOUCH_CANCEL]: (event: EventTouch) => void;
            [Input.EventType.KEY_DOWN]: (event: EventKeyboard) => void;
            [Input.EventType.KEY_PRESSING]: (event: EventKeyboard) => void;
            [Input.EventType.KEY_UP]: (event: EventKeyboard) => void;
            [Input.EventType.DEVICEMOTION]: (event: EventAcceleration) => void;
            [Input.EventType.GAMEPAD_CHANGE]: (event: EventGamepad) => void;
            [Input.EventType.GAMEPAD_INPUT]: (event: EventGamepad) => void;
            [Input.EventType.HANDLE_INPUT]: (event: EventHandle) => void;
            [Input.EventType.HANDLE_POSE_INPUT]: (event: EventHandle) => void;
            [Input.EventType.HMD_POSE_INPUT]: (event: EventHMD) => void;
        }
        export interface _cocos_input_system_event__SystemEventMap {
            [SystemEvent.EventType.MOUSE_DOWN]: (event: EventMouse) => void;
            [SystemEvent.EventType.MOUSE_MOVE]: (event: EventMouse) => void;
            [SystemEvent.EventType.MOUSE_UP]: (event: EventMouse) => void;
            [SystemEvent.EventType.MOUSE_WHEEL]: (event: EventMouse) => void;
            [SystemEvent.EventType.TOUCH_START]: (touch: Touch, event: EventTouch) => void;
            [SystemEvent.EventType.TOUCH_MOVE]: (touch: Touch, event: EventTouch) => void;
            [SystemEvent.EventType.TOUCH_END]: (touch: Touch, event: EventTouch) => void;
            [SystemEvent.EventType.TOUCH_CANCEL]: (touch: Touch, event: EventTouch) => void;
            [SystemEvent.EventType.KEY_DOWN]: (event: EventKeyboard) => void;
            [SystemEvent.EventType.KEY_UP]: (event: EventKeyboard) => void;
            [SystemEvent.EventType.DEVICEMOTION]: (event: EventAcceleration) => void;
        }
        export enum _cocos_dragon_bones_ArmatureDisplay__DefaultArmaturesEnum {
            default = "Bad expression <-1>"
        }
        export enum _cocos_dragon_bones_ArmatureDisplay__DefaultAnimsEnum {
            '<None>' = 0
        }
        export interface _cocos_dragon_bones_ArmatureDisplay__BoneIndex extends Number {
            _any: number;
        }
        export interface ____node_modules_store_typescript495_node_modules_typescript_lib_libdom__EXT_color_buffer_half_float {
            readonly FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: GLenum;
            readonly RGB16F_EXT: GLenum;
            readonly RGBA16F_EXT: GLenum;
            readonly UNSIGNED_NORMALIZED_EXT: GLenum;
        }
        export interface ____node_modules_store_typescript495_node_modules_typescript_lib_libdom__EXT_color_buffer_half_float {
            readonly RGBA16F_EXT: GLenum;
            readonly RGB16F_EXT: GLenum;
            readonly FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: GLenum;
            readonly UNSIGNED_NORMALIZED_EXT: GLenum;
        }
        export interface ____node_modules_store_typescript495_node_modules_typescript_lib_libdom__WEBGL_multi_draw {
            multiDrawArraysInstancedWEBGL(mode: GLenum, firstsList: Int32Array | GLint[], firstsOffset: GLuint, countsList: Int32Array | GLsizei[], countsOffset: GLuint, instanceCountsList: Int32Array | GLsizei[], instanceCountsOffset: GLuint, drawcount: GLsizei): void;
            multiDrawArraysWEBGL(mode: GLenum, firstsList: Int32Array | GLint[], firstsOffset: GLuint, countsList: Int32Array | GLsizei[], countsOffset: GLuint, drawcount: GLsizei): void;
            multiDrawElementsInstancedWEBGL(mode: GLenum, countsList: Int32Array | GLsizei[], countsOffset: GLuint, type: GLenum, offsetsList: Int32Array | GLsizei[], offsetsOffset: GLuint, instanceCountsList: Int32Array | GLsizei[], instanceCountsOffset: GLuint, drawcount: GLsizei): void;
            multiDrawElementsWEBGL(mode: GLenum, countsList: Int32Array | GLsizei[], countsOffset: GLuint, type: GLenum, offsetsList: Int32Array | GLsizei[], offsetsOffset: GLuint, drawcount: GLsizei): void;
        }
        export interface ____node_modules_store_typescript495_node_modules_typescript_lib_libdom__WEBGL_multi_draw {
            multiDrawArraysWEBGL(mode: GLenum, firstsList: GLint[] | Int32Array, firstsOffset: GLuint, countsList: GLsizei[] | Int32Array, countsOffset: GLuint, drawCount: GLsizei): void;
            multiDrawElementsWEBGL(mode: GLenum, countsList: GLint[] | Int32Array, countsOffset: GLuint, type: GLenum, offsetsList: GLsizei[] | Int32Array, OffsetsOffset: GLuint, drawCount: GLsizei): void;
            multiDrawArraysInstancedWEBGL(mode: GLenum, firstsList: GLint[] | Int32Array, firstsOffset: GLuint, countsList: GLsizei[] | Int32Array, countsOffset: GLuint, instanceCountsList: GLsizei[] | Int32Array, instanceCountsOffset: GLuint, drawCount: GLsizei): void;
            multiDrawElementsInstancedWEBGL(mode: GLenum, countsList: GLint[] | Int32Array, countsOffset: GLuint, type: GLenum, offsetsList: GLsizei[] | Int32Array, OffsetsOffset: GLuint, instanceCountsList: GLsizei[] | Int32Array, instanceCountsOffset: GLuint, drawCount: GLsizei): void;
        }
        export interface ____node_modules_store_typescript495_node_modules_typescript_lib_libdom__WEBGL_compressed_texture_etc1 {
            readonly COMPRESSED_RGB_ETC1_WEBGL: GLenum;
        }
        // note that ETC1 is not supported with the compressedTexSubImage2D() method
        export interface ____node_modules_store_typescript495_node_modules_typescript_lib_libdom__WEBGL_compressed_texture_etc1 {
            readonly COMPRESSED_RGB_ETC1_WEBGL: GLenum;
        }
        export interface ____node_modules_store_typescript495_node_modules_typescript_lib_libdom__WEBGL_compressed_texture_etc {
            readonly COMPRESSED_R11_EAC: GLenum;
            readonly COMPRESSED_RG11_EAC: GLenum;
            readonly COMPRESSED_RGB8_ETC2: GLenum;
            readonly COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: GLenum;
            readonly COMPRESSED_RGBA8_ETC2_EAC: GLenum;
            readonly COMPRESSED_SIGNED_R11_EAC: GLenum;
            readonly COMPRESSED_SIGNED_RG11_EAC: GLenum;
            readonly COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: GLenum;
            readonly COMPRESSED_SRGB8_ETC2: GLenum;
            readonly COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: GLenum;
        }
        export interface ____node_modules_store_typescript495_node_modules_typescript_lib_libdom__WEBGL_compressed_texture_etc {
            readonly COMPRESSED_R11_EAC: GLenum;
            readonly COMPRESSED_SIGNED_R11_EAC: GLenum;
            readonly COMPRESSED_RG11_EAC: GLenum;
            readonly COMPRESSED_SIGNED_RG11_EAC: GLenum;
            readonly COMPRESSED_RGB8_ETC2: GLenum;
            readonly COMPRESSED_RGBA8_ETC2_EAC: GLenum;
            readonly COMPRESSED_SRGB8_ETC2: GLenum;
            readonly COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: GLenum;
            readonly COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: GLenum;
            readonly COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: GLenum;
        }
        export interface _types_webGLextras__WEBGL_compressed_texture_pvrtc {
            readonly COMPRESSED_RGB_PVRTC_4BPPV1_IMG: GLenum;
            readonly COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: GLenum;
            readonly COMPRESSED_RGB_PVRTC_2BPPV1_IMG: GLenum;
            readonly COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: GLenum;
        }
        export interface _cocos_core_gfx_webgl_webgl_define__IWebGLExtensions {
            EXT_texture_filter_anisotropic: EXT_texture_filter_anisotropic | null;
            EXT_blend_minmax: EXT_blend_minmax | null;
            EXT_frag_depth: EXT_frag_depth | null;
            EXT_shader_texture_lod: EXT_shader_texture_lod | null;
            EXT_sRGB: EXT_sRGB | null;
            OES_vertex_array_object: OES_vertex_array_object | null;
            EXT_color_buffer_half_float: ____node_modules_store_typescript495_node_modules_typescript_lib_libdom__EXT_color_buffer_half_float | null;
            WEBGL_multi_draw: ____node_modules_store_typescript495_node_modules_typescript_lib_libdom__WEBGL_multi_draw | null;
            WEBGL_color_buffer_float: WEBGL_color_buffer_float | null;
            WEBGL_compressed_texture_etc1: ____node_modules_store_typescript495_node_modules_typescript_lib_libdom__WEBGL_compressed_texture_etc1 | null;
            WEBGL_compressed_texture_etc: ____node_modules_store_typescript495_node_modules_typescript_lib_libdom__WEBGL_compressed_texture_etc | null;
            WEBGL_compressed_texture_pvrtc: _types_webGLextras__WEBGL_compressed_texture_pvrtc | null;
            WEBGL_compressed_texture_astc: WEBGL_compressed_texture_astc | null;
            WEBGL_compressed_texture_s3tc: WEBGL_compressed_texture_s3tc | null;
            WEBGL_compressed_texture_s3tc_srgb: WEBGL_compressed_texture_s3tc_srgb | null;
            WEBGL_debug_shaders: WEBGL_debug_shaders | null;
            WEBGL_draw_buffers: WEBGL_draw_buffers | null;
            WEBGL_lose_context: WEBGL_lose_context | null;
            WEBGL_depth_texture: WEBGL_depth_texture | null;
            WEBGL_debug_renderer_info: WEBGL_debug_renderer_info | null;
            OES_texture_half_float: OES_texture_half_float | null;
            OES_texture_half_float_linear: OES_texture_half_float_linear | null;
            OES_texture_float: OES_texture_float | null;
            OES_texture_float_linear: OES_texture_float_linear | null;
            OES_standard_derivatives: OES_standard_derivatives | null;
            OES_element_index_uint: OES_element_index_uint | null;
            ANGLE_instanced_arrays: ANGLE_instanced_arrays | null;
            destroyShadersImmediately: boolean;
            noCompressedTexSubImage2D: boolean;
            isLocationActive: (glLoc: unknown) => glLoc is WebGLUniformLocation;
            useVAO: boolean;
        }
        export interface _cocos_core_gfx_webgl_webgl_state_cache__IWebGLTexUnit {
            glTexture: WebGLTexture | null;
        }
        export class _cocos_core_gfx_webgl_webgl_state_cache__WebGLStateCache {
            glArrayBuffer: WebGLBuffer | null;
            glElementArrayBuffer: WebGLBuffer | null;
            glVAO: WebGLVertexArrayObjectOES | null;
            texUnit: number;
            glTexUnits: _cocos_core_gfx_webgl_webgl_state_cache__IWebGLTexUnit[];
            glRenderbuffer: WebGLRenderbuffer | null;
            glFramebuffer: WebGLFramebuffer | null;
            viewport: gfx.Viewport;
            scissorRect: gfx.Rect;
            rs: gfx.RasterizerState;
            dss: gfx.DepthStencilState;
            bs: gfx.BlendState;
            glProgram: WebGLProgram | null;
            glEnabledAttribLocs: boolean[];
            glCurrentAttribLocs: boolean[];
            texUnitCacheMap: Record<string, number>;
            initialize(texUnit: number, vertexAttributes: number): void;
        }
        export interface _cocos_core_gfx_webgl_webgl_gpu_objects__IWebGLGPUTexture {
            type: gfx.TextureType;
            format: gfx.Format;
            usage: gfx.TextureUsage;
            width: number;
            height: number;
            depth: number;
            size: number;
            arrayLayer: number;
            mipLevel: number;
            samples: gfx.SampleCount;
            flags: gfx.TextureFlags;
            isPowerOf2: boolean;
            glTarget: GLenum;
            glInternalFmt: GLenum;
            glFormat: GLenum;
            glType: GLenum;
            glUsage: GLenum;
            glTexture: WebGLTexture | null;
            glRenderbuffer: WebGLRenderbuffer | null;
            glWrapS: GLenum;
            glWrapT: GLenum;
            glMinFilter: GLenum;
            glMagFilter: GLenum;
            isSwapchainTexture: boolean;
        }
        export class _cocos_core_gfx_webgl_webgl_texture__WebGLTexture extends gfx.Texture {
            get gpuTexture(): _cocos_core_gfx_webgl_webgl_gpu_objects__IWebGLGPUTexture;
            get lodLevel(): number;
            initialize(info: Readonly<gfx.TextureInfo> | Readonly<gfx.TextureViewInfo>, isSwapchainTexture?: boolean): void;
            destroy(): void;
            resize(width: number, height: number): void;
            protected initAsSwapchainTexture(info: Readonly<gfx.ISwapchainTextureInfo>): void;
        }
        export interface _cocos_core_gfx_webgl_webgl_gpu_objects__IWebGLBindingMapping {
            blockOffsets: number[];
            samplerTextureOffsets: number[];
            flexibleSet: number;
        }
        export interface ____node_modules_store_typescript495_node_modules_typescript_lib_libdom__EXT_color_buffer_float {
        }
        export interface ____node_modules_store_typescript495_node_modules_typescript_lib_libdom__EXT_color_buffer_float {
        }
        export interface _cocos_core_gfx_webgl2_webgl2_define__IWebGL2Extensions {
            EXT_texture_filter_anisotropic: EXT_texture_filter_anisotropic | null;
            EXT_color_buffer_half_float: ____node_modules_store_typescript495_node_modules_typescript_lib_libdom__EXT_color_buffer_half_float | null;
            EXT_color_buffer_float: ____node_modules_store_typescript495_node_modules_typescript_lib_libdom__EXT_color_buffer_float | null;
            WEBGL_multi_draw: ____node_modules_store_typescript495_node_modules_typescript_lib_libdom__WEBGL_multi_draw | null;
            WEBGL_compressed_texture_etc1: ____node_modules_store_typescript495_node_modules_typescript_lib_libdom__WEBGL_compressed_texture_etc1 | null;
            WEBGL_compressed_texture_etc: ____node_modules_store_typescript495_node_modules_typescript_lib_libdom__WEBGL_compressed_texture_etc | null;
            WEBGL_compressed_texture_pvrtc: _types_webGLextras__WEBGL_compressed_texture_pvrtc | null;
            WEBGL_compressed_texture_astc: WEBGL_compressed_texture_astc | null;
            WEBGL_compressed_texture_s3tc: WEBGL_compressed_texture_s3tc | null;
            WEBGL_compressed_texture_s3tc_srgb: WEBGL_compressed_texture_s3tc_srgb | null;
            WEBGL_debug_shaders: WEBGL_debug_shaders | null;
            WEBGL_lose_context: WEBGL_lose_context | null;
            WEBGL_debug_renderer_info: WEBGL_debug_renderer_info | null;
            OES_texture_half_float_linear: OES_texture_half_float_linear | null;
            OES_texture_float_linear: OES_texture_float_linear | null;
            useVAO: boolean;
        }
        export interface _cocos_core_gfx_webgl2_webgl2_state_cache__IWebGL2TexUnit {
            glTexture: WebGLTexture | null;
        }
        export class _cocos_core_gfx_webgl2_webgl2_state_cache__WebGL2StateCache {
            glArrayBuffer: WebGLBuffer | null;
            glElementArrayBuffer: WebGLBuffer | null;
            glUniformBuffer: WebGLBuffer | null;
            glBindUBOs: (WebGLBuffer | null)[];
            glBindUBOOffsets: number[];
            glVAO: WebGLVertexArrayObject | null;
            texUnit: number;
            glTexUnits: _cocos_core_gfx_webgl2_webgl2_state_cache__IWebGL2TexUnit[];
            glSamplerUnits: (WebGLSampler | null)[];
            glRenderbuffer: WebGLRenderbuffer | null;
            glFramebuffer: WebGLFramebuffer | null;
            glReadFramebuffer: WebGLFramebuffer | null;
            viewport: gfx.Viewport;
            scissorRect: gfx.Rect;
            rs: gfx.RasterizerState;
            dss: gfx.DepthStencilState;
            bs: gfx.BlendState;
            glProgram: WebGLProgram | null;
            glEnabledAttribLocs: boolean[];
            glCurrentAttribLocs: boolean[];
            texUnitCacheMap: Record<string, number>;
            initialize(texUnit: number, bufferBindings: number, vertexAttributes: number): void;
        }
        export interface _cocos_core_gfx_webgl2_webgl2_gpu_objects__IWebGL2GPUTexture {
            type: gfx.TextureType;
            format: gfx.Format;
            usage: gfx.TextureUsage;
            width: number;
            height: number;
            depth: number;
            size: number;
            arrayLayer: number;
            mipLevel: number;
            samples: gfx.SampleCount;
            flags: gfx.TextureFlags;
            isPowerOf2: boolean;
            glTarget: GLenum;
            glInternalFmt: GLenum;
            glFormat: GLenum;
            glType: GLenum;
            glUsage: GLenum;
            glTexture: WebGLTexture | null;
            glRenderbuffer: WebGLRenderbuffer | null;
            glWrapS: GLenum;
            glWrapT: GLenum;
            glMinFilter: GLenum;
            glMagFilter: GLenum;
            isSwapchainTexture: boolean;
        }
        export interface _cocos_core_gfx_webgl2_webgl2_gpu_objects__IWebGL2GPUTextureView {
            gpuTexture: _cocos_core_gfx_webgl2_webgl2_gpu_objects__IWebGL2GPUTexture;
            type: gfx.TextureType;
            format: gfx.Format;
            baseLevel: number;
            levelCount: number;
        }
        export class _cocos_core_gfx_webgl2_webgl2_texture__WebGL2Texture extends gfx.Texture {
            get gpuTexture(): _cocos_core_gfx_webgl2_webgl2_gpu_objects__IWebGL2GPUTexture;
            get gpuTextureView(): _cocos_core_gfx_webgl2_webgl2_gpu_objects__IWebGL2GPUTextureView;
            initialize(info: Readonly<gfx.TextureInfo> | Readonly<gfx.TextureViewInfo>, isSwapchainTexture?: boolean): void;
            destroy(): void;
            resize(width: number, height: number): void;
            protected initAsSwapchainTexture(info: Readonly<gfx.ISwapchainTextureInfo>): void;
        }
        export interface _cocos_core_gfx_webgl2_webgl2_gpu_objects__IWebGL2BindingMapping {
            blockOffsets: number[];
            samplerTextureOffsets: number[];
            flexibleSet: number;
        }
        /**
         * @en Test line and line
         * @zh 测试线段与线段是否相交
         */
        function _cocos_physics_2d_builtin_intersection_2d__lineLine(a1: Readonly<math.Vec2>, a2: Readonly<math.Vec2>, b1: Readonly<math.Vec2>, b2: math.Vec2): boolean;
        /**
         * @en Test line and rect
         * @zh 测试线段与矩形是否相交
         */
        function _cocos_physics_2d_builtin_intersection_2d__lineRect(a1: Readonly<math.Vec2>, a2: Readonly<math.Vec2>, b: math.Rect): boolean;
        /**
         * @en Test line and polygon
         * @zh 测试线段与多边形是否相交
         */
        function _cocos_physics_2d_builtin_intersection_2d__linePolygon(a1: Readonly<math.Vec2>, a2: Readonly<math.Vec2>, b: readonly math.Vec2[]): boolean;
        /**
         * @en Test rect and rect
         * @zh 测试矩形与矩形是否相交
         */
        function _cocos_physics_2d_builtin_intersection_2d__rectRect(a: math.Rect, b: math.Rect): boolean;
        /**
         * @en Test rect and polygon
         * @zh 测试矩形与多边形是否相交
         */
        function _cocos_physics_2d_builtin_intersection_2d__rectPolygon(a: Readonly<math.Rect>, b: readonly math.Vec2[]): boolean;
        /**
         * @en Test rect and circle
         * @zh 测试矩形与圆形是否相交
         */
        function _cocos_physics_2d_builtin_intersection_2d__rectCircle(rect: math.Rect, cp: Readonly<math.Vec2>, cr: number): boolean;
        /**
         * @en Test polygon and polygon
         * @zh 测试多边形与多边形是否相交
         */
        function _cocos_physics_2d_builtin_intersection_2d__polygonPolygon(a: readonly math.Vec2[], b: readonly math.Vec2[]): boolean;
        /**
         * @en Test circle and circle
         * @zh 测试圆形与圆形是否相交
         */
        function _cocos_physics_2d_builtin_intersection_2d__circleCircle(c1p: Readonly<math.Vec2>, c1r: number, c2p: Readonly<math.Vec2>, c2r: number): boolean;
        /**
         * @en Test polygon and circle
         * @zh 测试多边形与圆形是否相交
         */
        function _cocos_physics_2d_builtin_intersection_2d__polygonCircle(polygon: readonly math.Vec2[], cp: Readonly<math.Vec2>, cr: number): boolean;
        /**
         * @en Test whether the point is in the polygon
         * @zh 测试一个点是否在一个多边形中
         */
        function _cocos_physics_2d_builtin_intersection_2d__pointInPolygon(point: Readonly<math.Vec2>, polygon: readonly math.Vec2[]): boolean;
        /**
         * @en Calculate the distance of point to line.
         * @zh 计算点到直线的距离。如果这是一条线段并且垂足不在线段内，则会计算点到线段端点的距离。
         */
        function _cocos_physics_2d_builtin_intersection_2d__pointLineDistance(point: Readonly<math.Vec2>, start: Readonly<math.Vec2>, end: Readonly<math.Vec2>, isSegment: boolean): number;
        export class _cocos_particle_2d_particle_simulator_2d__Particle {
            pos: math.Vec2;
            startPos: math.Vec2;
            color: math.Color;
            deltaColor: {
                r: number;
                g: number;
                b: number;
                a: number;
            };
            size: number;
            deltaSize: number;
            rotation: number;
            deltaRotation: number;
            timeToLive: number;
            drawPos: math.Vec2;
            aspectRatio: number;
            dir: math.Vec2;
            radialAccel: number;
            tangentialAccel: number;
            angle: number;
            degreesPerSecond: number;
            radius: number;
            deltaRadius: number;
        }
        export class _cocos_particle_2d_particle_simulator_2d__Simulator {
            particles: _cocos_particle_2d_particle_simulator_2d__Particle[];
            active: boolean;
            uvFilled: number;
            finished: boolean;
            renderData: MeshRenderData;
            constructor(system: any);
            stop(): void;
            reset(): void;
            emitParticle(pos: any): void;
            updateUVs(force?: boolean): void;
            updateParticleBuffer(particle: any, pos: any, buffer: any, offset: number): void;
            step(dt: any): void;
            requestData(vertexCount: number, indexCount: number): void;
            initDrawInfo(): void;
        }
        export class _cocos_particle_2d_motion_streak_2d__Point {
            point: math.Vec2;
            dir: math.Vec2;
            distance: number;
            time: number;
            constructor(point?: math.Vec2, dir?: math.Vec2);
            setPoint(x: any, y: any): void;
            setDir(x: any, y: any): void;
        }
        export class _cocos_particle_particle__Particle {
            static INDENTIFY_NEG_QUAT: number;
            static R2D: number;
            particleSystem: ParticleSystem;
            position: math.Vec3;
            velocity: math.Vec3;
            animatedVelocity: math.Vec3;
            ultimateVelocity: math.Vec3;
            angularVelocity: math.Vec3;
            axisOfRotation: math.Vec3;
            rotation: math.Vec3;
            startEuler: math.Vec3;
            startRotation: math.Quat;
            startRotated: boolean;
            deltaQuat: math.Quat;
            deltaMat: math.Mat4;
            localMat: math.Mat4;
            startSize: math.Vec3;
            size: math.Vec3;
            startColor: math.Color;
            color: math.Color;
            randomSeed: number;
            remainingLifetime: number;
            loopCount: number;
            lastLoop: number;
            trailDelay: number;
            startLifetime: number;
            emitAccumulator0: number;
            emitAccumulator1: number;
            frameIndex: number;
            startRow: number;
            constructor(particleSystem: any);
            reset(): void;
        }
        export class _cocos_particle_renderer_particle_system_renderer_data__default {
            /**
             * @zh 设定粒子生成模式。
             */
            get renderMode(): number;
            set renderMode(val: number);
            /**
             * @zh 在粒子生成方式为 StrecthedBillboard 时,对粒子在运动方向上按速度大小进行拉伸。
             */
            get velocityScale(): number;
            set velocityScale(val: number);
            /**
             * @zh 在粒子生成方式为 StrecthedBillboard 时,对粒子在运动方向上按粒子大小进行拉伸。
             */
            get lengthScale(): number;
            set lengthScale(val: number);
            /**
             * @zh 粒子发射的模型。
             */
            get mesh(): Mesh | null;
            set mesh(val: Mesh | null);
            /**
             * @zh 粒子使用的材质。
             */
            get particleMaterial(): Material | null;
            set particleMaterial(val: Material | null);
            /**
             * @en particle cpu material
             * @zh 粒子使用的cpu材质。
             */
            get cpuMaterial(): Material | null;
            set cpuMaterial(val: Material | null);
            /**
             * @en particle gpu material
             * @zh 粒子使用的gpu材质。
             */
            get gpuMaterial(): Material | null;
            set gpuMaterial(val: Material | null);
            /**
             * @en particle trail material
             * @zh 拖尾使用的材质。
             */
            get trailMaterial(): Material | null;
            set trailMaterial(val: Material | null);
            get mainTexture(): Texture2D | null;
            set mainTexture(val: Texture2D | null);
            get useGPU(): boolean;
            set useGPU(val: boolean);
            /**
             * @en Particle alignment space option. Includes world, local and view.
             * @zh 粒子对齐空间选择。包括世界空间，局部空间和视角空间。
             */
            get alignSpace(): number;
            set alignSpace(val: number);
            static AlignmentSpace: {
                World: number;
                Local: number;
                View: number;
            };
            create(ps: any): void;
            onInit(ps: any): void;
        }
        export class _cocos_particle_models_particle_batch_model__default extends renderer.scene.Model {
            constructor();
            setCapacity(capacity: number): void;
            setVertexAttributes(mesh: Mesh | null, attrs: gfx.Attribute[]): void;
            updateMaterial(mat: Material): void;
            addParticleVertexData(index: number, pvdata: any[]): void;
            addGPUParticleVertexData(p: _cocos_particle_particle__Particle, num: number, time: number): void;
            updateGPUParticles(num: number, time: number, dt: number): number;
            constructAttributeIndex(): void;
            updateIA(count: number): void;
            clear(): void;
            destroy(): void;
            doDestroy(): void;
            set useInstance(value: boolean);
            get useInstance(): boolean;
        }
        export interface _cocos_particle_particle__IParticleModule {
            target: _cocos_particle_renderer_particle_system_renderer_base__IParticleSystemRenderer | null;
            needUpdate: boolean;
            needAnimate: boolean;
            name: string;
            bindTarget(target: any): void;
            update(space: number, trans: math.Mat4): void;
            animate(p: _cocos_particle_particle__Particle, dt?: number): void;
        }
        export interface _cocos_particle_renderer_particle_system_renderer_base__IParticleSystemRenderer {
            onInit(ps: Component): void;
            getInfo(): _cocos_particle_renderer_particle_system_renderer_data__default;
            onEnable(): void;
            onDisable(): void;
            onDestroy(): void;
            clear(): void;
            getModel(): _cocos_particle_models_particle_batch_model__default | null;
            attachToScene(): void;
            detachFromScene(): void;
            updateMaterialParams(): void;
            updateVertexAttrib(): void;
            setVertexAttributes(): void;
            updateRenderMode(): void;
            onMaterialModified(index: number, material: Material): void;
            onRebuildPSO(index: number, material: Material): void;
            getParticleCount(): number;
            getFreeParticle(): _cocos_particle_particle__Particle | null;
            setNewParticle(p: _cocos_particle_particle__Particle): void;
            getDefaultMaterial(): Material | null;
            updateRotation(pass: renderer.Pass | null): void;
            updateScale(pass: renderer.Pass | null): void;
            updateParticles(dt: number): number;
            updateRenderData(): void;
            enableModule(name: string, val: boolean, pm: _cocos_particle_particle__IParticleModule): void;
            updateTrailMaterial(): void;
            getDefaultTrailMaterial(): any;
            beforeRender(): void;
            setUseInstance(value: boolean): void;
            getUseInstance(): boolean;
            getNoisePreview(out: number[], width: number, height: number): void;
        }
        export abstract class _cocos_particle_particle__ParticleModuleBase implements _cocos_particle_particle__IParticleModule {
            target: _cocos_particle_renderer_particle_system_renderer_base__IParticleSystemRenderer | null;
            needUpdate: boolean;
            needAnimate: boolean;
            bindTarget(target: _cocos_particle_renderer_particle_system_renderer_base__IParticleSystemRenderer): void;
            update(space: number, trans: math.Mat4): void;
            abstract name: string;
            abstract animate(p: _cocos_particle_particle__Particle, dt?: number): void;
        }
        export class _cocos_particle_animator_color_overtime__default extends _cocos_particle_particle__ParticleModuleBase {
            _enable: boolean;
            /**
             * @zh 是否启用。
             */
            get enable(): boolean;
            set enable(val: boolean);
            /**
             * @zh 颜色随时间变化的参数，各个 key 之间线性差值变化。
             */
            color: GradientRange;
            name: string;
            animate(particle: _cocos_particle_particle__Particle): void;
        }
        export class _cocos_particle_emitter_shape_module__default {
            /**
             * @zh 粒子发射器位置。
             */
            get position(): math.Vec3;
            set position(val: math.Vec3);
            /**
             * @zh 粒子发射器旋转角度。
             */
            get rotation(): math.Vec3;
            set rotation(val: math.Vec3);
            /**
             * @zh 粒子发射器缩放比例。
             */
            get scale(): math.Vec3;
            set scale(val: math.Vec3);
            /**
             * @zh 粒子发射器在一个扇形范围内发射。
             */
            get arc(): number;
            set arc(val: number);
            /**
             * @zh 圆锥的轴与母线的夹角<bg>。
             * 决定圆锥发射器的开合程度。
             */
            get angle(): number;
            set angle(val: number);
            /**
             * @zh 是否启用。
             */
            get enable(): boolean;
            set enable(val: boolean);
            /**
             * @zh 粒子发射器类型 [[ShapeType]]。
             *
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _shapeType: number;
            get shapeType(): number;
            set shapeType(val: number);
            /**
             * @zh 粒子从发射器哪个部位发射 [[EmitLocation]]。
             */
            emitFrom: number;
            /**
             * @zh 根据粒子的初始方向决定粒子的移动方向。
             */
            alignToDirection: boolean;
            /**
             * @zh 粒子生成方向随机设定。
             */
            randomDirectionAmount: number;
            /**
             * @zh 表示当前发射方向与当前位置到结点中心连线方向的插值。
             */
            sphericalDirectionAmount: number;
            /**
             * @zh 粒子生成位置随机设定（设定此值为非 0 会使粒子生成位置超出生成器大小范围）。
             */
            randomPositionAmount: number;
            /**
             * @zh 粒子发射器半径。
             */
            radius: number;
            /**
             * @zh 粒子发射器发射位置（对 Box 类型的发射器无效）：<bg>
             * - 0 表示从表面发射；
             * - 1 表示从中心发射；
             * - 0 ~ 1 之间表示在中心到表面之间发射。
             */
            radiusThickness: number;
            /**
             * @zh 粒子在扇形范围内的发射方式 [[ArcMode]]。
             */
            arcMode: number;
            /**
             * @zh 控制可能产生粒子的弧周围的离散间隔。
             */
            arcSpread: number;
            /**
             * @zh 粒子沿圆周发射的速度。
             */
            arcSpeed: CurveRange;
            /**
             * @zh 圆锥顶部截面距离底部的轴长<bg>。
             * 决定圆锥发射器的高度。
             */
            length: number;
            /**
             * @zh 粒子发射器发射位置（针对 Box 类型的粒子发射器）。
             */
            boxThickness: math.Vec3;
            constructor();
            onInit(ps: ParticleSystem): void;
            emit(p: any): void;
        }
        export class _cocos_particle_animator_size_overtime__default extends _cocos_particle_particle__ParticleModuleBase {
            _enable: boolean;
            /**
             * @zh 是否启用。
             */
            get enable(): boolean;
            set enable(val: boolean);
            /**
             * @zh 决定是否在每个轴上独立控制粒子大小。
             */
            separateAxes: boolean;
            /**
             * @zh 定义一条曲线来决定粒子在其生命周期中的大小变化。
             */
            size: CurveRange;
            /**
             * @zh 定义一条曲线来决定粒子在其生命周期中 X 轴方向上的大小变化。
             */
            x: CurveRange;
            /**
             * @zh 定义一条曲线来决定粒子在其生命周期中 Y 轴方向上的大小变化。
             */
            y: CurveRange;
            /**
             * @zh 定义一条曲线来决定粒子在其生命周期中 Z 轴方向上的大小变化。
             */
            z: CurveRange;
            name: string;
            animate(particle: _cocos_particle_particle__Particle, dt: number): void;
        }
        export class _cocos_particle_animator_velocity_overtime__default extends _cocos_particle_particle__ParticleModuleBase {
            _enable: boolean;
            /**
             * @zh 是否启用。
             */
            get enable(): boolean;
            set enable(val: boolean);
            /**
             * @zh X 轴方向上的速度分量。
             */
            x: CurveRange;
            /**
             * @zh Y 轴方向上的速度分量。
             */
            y: CurveRange;
            /**
             * @zh Z 轴方向上的速度分量。
             */
            z: CurveRange;
            /**
             * @zh 速度修正系数（只支持 CPU 粒子）。
             */
            speedModifier: CurveRange;
            /**
             * @zh 速度计算时采用的坐标系[[Space]]。
             */
            space: number;
            name: string;
            constructor();
            update(space: number, worldTransform: math.Mat4): void;
            animate(p: _cocos_particle_particle__Particle, dt: number): void;
        }
        export class _cocos_particle_animator_force_overtime__default extends _cocos_particle_particle__ParticleModuleBase {
            _enable: boolean;
            /**
             * @zh 是否启用。
             */
            get enable(): boolean;
            set enable(val: boolean);
            /**
             * @zh X 轴方向上的加速度分量。
             */
            x: CurveRange;
            /**
             * @zh Y 轴方向上的加速度分量。
             */
            y: CurveRange;
            /**
             * @zh Z 轴方向上的加速度分量。
             */
            z: CurveRange;
            /**
             * @zh 加速度计算时采用的坐标系 [[Space]]。
             */
            space: number;
            randomized: boolean;
            name: string;
            constructor();
            update(space: any, worldTransform: any): void;
            animate(p: any, dt: any): void;
        }
        export class _cocos_particle_animator_limit_velocity_overtime__default extends _cocos_particle_particle__ParticleModuleBase {
            _enable: boolean;
            /**
             * @zh 是否启用。
             */
            get enable(): boolean;
            set enable(val: boolean);
            /**
             * @zh X 轴方向上的速度下限。
             */
            limitX: CurveRange;
            /**
             * @zh Y 轴方向上的速度下限。
             */
            limitY: CurveRange;
            /**
             * @zh Z 轴方向上的速度下限。
             */
            limitZ: CurveRange;
            /**
             * @zh 速度下限。
             */
            limit: CurveRange;
            /**
             * @zh 当前速度与速度下限的插值。
             */
            dampen: number;
            /**
             * @zh 是否三个轴分开限制。
             */
            separateAxes: boolean;
            /**
             * @zh 计算速度下限时采用的坐标系 [[Space]]。
             */
            space: number;
            drag: null;
            multiplyDragByParticleSize: boolean;
            multiplyDragByParticleVelocity: boolean;
            name: string;
            constructor();
            update(space: number, worldTransform: math.Mat4): void;
            animate(p: _cocos_particle_particle__Particle, dt: number): void;
        }
        export class _cocos_particle_animator_rotation_overtime__default extends _cocos_particle_particle__ParticleModuleBase {
            _enable: boolean;
            /**
             * @zh 是否启用。
             */
            get enable(): boolean;
            set enable(val: boolean);
            /**
             * @zh 是否三个轴分开设定旋转（暂不支持）。
             */
            get separateAxes(): boolean;
            set separateAxes(val: boolean);
            /**
             * @zh 绕 X 轴设定旋转。
             */
            x: CurveRange;
            /**
             * @zh 绕 Y 轴设定旋转。
             */
            y: CurveRange;
            /**
             * @zh 绕 Z 轴设定旋转。
             */
            z: CurveRange;
            name: string;
            animate(p: _cocos_particle_particle__Particle, dt: number): void;
        }
        export class _cocos_particle_animator_texture_animation__default extends _cocos_particle_particle__ParticleModuleBase {
            /**
             * @zh 是否启用。
             */
            get enable(): boolean;
            set enable(val: boolean);
            /**
             * @zh 设定粒子贴图动画的类型（暂只支持 Grid 模式）[[Mode]]。
             */
            get mode(): number;
            set mode(val: number);
            /**
             * @zh X 方向动画帧数。
             */
            get numTilesX(): number;
            set numTilesX(val: number);
            /**
             * @zh Y 方向动画帧数。
             */
            get numTilesY(): number;
            set numTilesY(val: number);
            /**
             * @zh 动画播放方式 [[Animation]]。
             */
            animation: number;
            /**
             * @zh 一个周期内动画播放的帧与时间变化曲线。
             */
            frameOverTime: CurveRange;
            /**
             * @zh 从第几帧开始播放，时间为整个粒子系统的生命周期。
             */
            startFrame: CurveRange;
            /**
             * @zh 一个生命周期内播放循环的次数。
             */
            cycleCount: number;
            /**
             * @ignore
             */
            get flipU(): number;
            set flipU(val: number);
            get flipV(): number;
            set flipV(val: number);
            get uvChannelMask(): number;
            set uvChannelMask(val: number);
            /**
             * @zh 随机从动画贴图中选择一行以生成动画。<br>
             * 此选项仅在动画播放方式为 SingleRow 时生效。
             */
            randomRow: boolean;
            /**
             * @zh 从动画贴图中选择特定行以生成动画。<br>
             * 此选项仅在动画播放方式为 SingleRow 时且禁用 randomRow 时可用。
             */
            rowIndex: number;
            name: string;
            init(p: _cocos_particle_particle__Particle): void;
            animate(p: _cocos_particle_particle__Particle, dt: number): void;
        }
        export class _cocos_particle_animator_noise_module__NoiseModule extends _cocos_particle_particle__ParticleModuleBase {
            _enable: boolean;
            /**
             * @zh 是否启用。
             */
            get enable(): boolean;
            set enable(val: boolean);
            get strengthX(): number;
            set strengthX(value: number);
            get strengthY(): number;
            set strengthY(value: number);
            get strengthZ(): number;
            set strengthZ(value: number);
            get noiseSpeedX(): number;
            set noiseSpeedX(value: number);
            get noiseSpeedY(): number;
            set noiseSpeedY(value: number);
            get noiseSpeedZ(): number;
            set noiseSpeedZ(value: number);
            get noiseFrequency(): number;
            set noiseFrequency(value: number);
            get remapX(): number;
            set remapX(value: number);
            get remapY(): number;
            set remapY(value: number);
            get remapZ(): number;
            set remapZ(value: number);
            get octaves(): number;
            set octaves(value: number);
            get octaveMultiplier(): number;
            set octaveMultiplier(value: number);
            get octaveScale(): number;
            set octaveScale(value: number);
            name: string;
            animate(particle: _cocos_particle_particle__Particle, dt: number): void;
            getNoisePreview(out: number[], ps: any, width: number, height: number): void;
        }
        export class _cocos_particle_renderer_trail__default {
            /**
             * 是否启用。
             */
            get enable(): boolean;
            set enable(val: boolean);
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _enable: boolean;
            /**
             * 设定粒子生成轨迹的方式。
             */
            mode: number;
            /**
             * 轨迹存在的生命周期。
             */
            lifeTime: CurveRange;
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _minParticleDistance: number;
            /**
             * 每个轨迹粒子之间的最小间距。
             */
            get minParticleDistance(): number;
            set minParticleDistance(val: number);
            get space(): number;
            set space(val: number);
            /**
             * 粒子本身是否存在。
             */
            existWithParticles: boolean;
            /**
             * 设定纹理填充方式。
             */
            textureMode: number;
            widthFromParticle: boolean;
            /**
             * 控制轨迹长度的曲线。
             */
            widthRatio: CurveRange;
            colorFromParticle: boolean;
            colorOverTrail: GradientRange;
            colorOvertime: GradientRange;
            /**
             * @en Get trail model
             * @zh 获取拖尾模型
             * @return Model of this trail and type is scene.Model
             */
            getModel(): renderer.scene.Model | null;
            constructor();
            onInit(ps: any): void;
            onEnable(): void;
            onDisable(): void;
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _attachToScene(): void;
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _detachFromScene(): void;
            destroy(): void;
            play(): void;
            clear(): void;
            updateMaterial(): void;
            update(): void;
            animate(p: _cocos_particle_particle__Particle, scaledDt: number): void;
            removeParticle(p: _cocos_particle_particle__Particle): void;
            updateRenderData(): void;
            updateIA(count: number): void;
            beforeRender(): void;
        }
        namespace _cocos_physics_2d_framework_utils_polygon_separator {
            export function ConvexPartition(vertices: math.IVec2Like[]): math.IVec2Like[][];
            export function ForceCounterClockWise(vertices: any): void;
            export function IsCounterClockWise(vertices: any): boolean;
        }
        namespace _cocos_physics_2d_framework_utils_polygon_partition {
            export function ConvexPartition(polygon: math.IVec2Like[]): math.IVec2Like[][] | null;
        }
        export interface _cocos_physics_2d_spec_i_physics_world__IPhysicsWorld {
            readonly impl: any;
            debugDrawFlags: number;
            setGravity: (v: math.IVec2Like) => void;
            setAllowSleep: (v: boolean) => void;
            step(deltaTime: number, velocityIterations?: number, positionIterations?: number): void;
            syncPhysicsToScene(): void;
            syncSceneToPhysics(): void;
            raycast(p1: math.IVec2Like, p2: math.IVec2Like, type: ERaycast2DType, mask: number): RaycastResult2D[];
            testPoint(p: math.Vec2): readonly Collider2D[];
            testAABB(rect: math.Rect): readonly Collider2D[];
            drawDebug(): void;
        }
        export const _cocos_physics_2d_framework_physics_system__PhysicsSystem2D_base: new (...args: any[]) => System & _cocos_core_event_eventify__IEventified;
        export interface _cocos_physics_spec_i_lifecycle__ILifecycle {
            /**
             * @en Update is called every frame, if the Component is enabled.<br/>
             * This is a lifecycle method. It may not be implemented in the super class.<br/>
             * You can only call its super class method inside it. It should not be called manually elsewhere.
             * @zh 如果该组件启用，则每帧调用 update。<br/>
             * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
             * @param dt - the delta time in seconds it took to complete the last frame
             */
            update?(dt: number): void;
            /**
             * @en LateUpdate is called every frame, if the Component is enabled.<br/>
             * This is a lifecycle method. It may not be implemented in the super class.<br/>
             * You can only call its super class method inside it. It should not be called manually elsewhere.
             * @zh 如果该组件启用，则每帧调用 LateUpdate。<br/>
             * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
             * @param dt - the delta time in seconds it took to complete the last frame
             */
            lateUpdate?(dt: number): void;
            /**
             * @en `__preload` is called before every onLoad.<br/>
             * It is used to initialize the builtin components internally,<br/>
             * to avoid checking whether onLoad is called before every public method calls.<br/>
             * This method should be removed if script priority is supported.
             * @zh `__preload` 在每次onLoad之前调用。<br/>
             * 它用于在内部初始化内置组件，<br/>
             * 以避免在每次公有方法调用之前检查是否调用了onLoad。<br/>
             * 如果支持脚本优先级，则应删除此方法。
             * @private
             */
            __preload?(component: any): void;
            /**
             * @en
             * When attaching to an active node or its node first activated.<br/>
             * onLoad is always called before any start functions, this allows you to order initialization of scripts.<br/>
             * This is a lifecycle method. It may not be implemented in the super class.<br/>
             * You can only call its super class method inside it. It should not be called manually elsewhere.
             * @zh
             * 当附加到一个激活的节点上或者其节点第一次激活时候调用。onLoad 总是会在任何 start 方法调用前执行，这能用于安排脚本的初始化顺序。<br/>
             * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
             */
            onLoad?(): void;
            /**
             * @en
             * Called before all scripts' update if the Component is enabled the first time.<br/>
             * Usually used to initialize some logic which need to be called after all components' `onload` methods called.<br/>
             * This is a lifecycle method. It may not be implemented in the super class.<br/>
             * You can only call its super class method inside it. It should not be called manually elsewhere.
             * @zh
             * 如果该组件第一次启用，则在所有组件的 update 之前调用。通常用于需要在所有组件的 onLoad 初始化完毕后执行的逻辑。<br/>
             * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
             */
            start?(): void;
            /**
             * @en Called when this component becomes enabled and its node is active.<br/>
             * This is a lifecycle method. It may not be implemented in the super class.
             * You can only call its super class method inside it. It should not be called manually elsewhere.
             * @zh 当该组件被启用，并且它的节点也激活时。<br/>
             * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
             */
            onEnable?(): void;
            /**
             * @en Called when this component becomes disabled or its node becomes inactive.<br/>
             * This is a lifecycle method. It may not be implemented in the super class.
             * You can only call its super class method inside it. It should not be called manually elsewhere.
             * @zh 当该组件被禁用或节点变为无效时调用。<br/>
             * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
             */
            onDisable?(): void;
            /**
             * @en Called when this component will be destroyed.<br/>
             * This is a lifecycle method. It may not be implemented in the super class.<br/>
             * You can only call its super class method inside it. It should not be called manually elsewhere.
             * @zh 当该组件被销毁时调用<br/>
             * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
             */
            onDestroy?(): void;
            onFocusInEditor?(): void;
            onLostFocusInEditor?(): void;
            /**
             * @en Called to initialize the component or node’s properties when adding the component the first time or when the Reset command is used.
             * This function is only called in editor.<br/>
             * @zh 用来初始化组件或节点的一些属性，当该组件被第一次添加到节点上或用户点击了它的 Reset 菜单时调用。这个回调只会在编辑器下调用。
             */
            resetInEditor?(): void;
            /**
             * @en
             * onRestore is called after the user clicks the Reset item in the Inspector's context menu or performs
             * an undo operation on this component.<br/>
             * <br/>
             * If the component contains the "internal state", short for "temporary member variables which not included<br/>
             * in its CCClass properties", then you may need to implement this function.<br/>
             * <br/>
             * The editor will call the getset accessors of your component to record/restore the component's state<br/>
             * for undo/redo operation. However, in extreme cases, it may not works well. Then you should implement<br/>
             * this function to manually synchronize your component's "internal states" with its public properties.<br/>
             * Once you implement this function, all the getset accessors of your component will not be called when<br/>
             * the user performs an undo/redo operation. Which means that only the properties with default value<br/>
             * will be recorded or restored by editor.<br/>
             * <br/>
             * Similarly, the editor may failed to reset your component correctly in extreme cases. Then if you need<br/>
             * to support the reset menu, you should manually synchronize your component's "internal states" with its<br/>
             * properties in this function. Once you implement this function, all the getset accessors of your component<br/>
             * will not be called during reset operation. Which means that only the properties with default value<br/>
             * will be reset by editor.
             *
             * This function is only called in editor mode.
             * @zh
             * onRestore 是用户在检查器菜单点击 Reset 时，对此组件执行撤消操作后调用的。<br/>
             * <br/>
             * 如果组件包含了“内部状态”（不在 CCClass 属性中定义的临时成员变量），那么你可能需要实现该方法。<br/>
             * <br/>
             * 编辑器执行撤销/重做操作时，将调用组件的 get set 来录制和还原组件的状态。
             * 然而，在极端的情况下，它可能无法良好运作。<br/>
             * 那么你就应该实现这个方法，手动根据组件的属性同步“内部状态”。
             * 一旦你实现这个方法，当用户撤销或重做时，组件的所有 get set 都不会再被调用。
             * 这意味着仅仅指定了默认值的属性将被编辑器记录和还原。<br/>
             * <br/>
             * 同样的，编辑可能无法在极端情况下正确地重置您的组件。<br/>
             * 于是如果你需要支持组件重置菜单，你需要在该方法中手工同步组件属性到“内部状态”。<br/>
             * 一旦你实现这个方法，组件的所有 get set 都不会在重置操作时被调用。
             * 这意味着仅仅指定了默认值的属性将被编辑器重置。
             * <br/>
             * 此方法仅在编辑器下会被调用。
             */
            onRestore?(): void;
        }
        export interface _cocos_physics_2d_spec_i_rigid_body__IRigidBody2D extends _cocos_physics_spec_i_lifecycle__ILifecycle {
            readonly impl: any;
            readonly rigidBody: RigidBody2D;
            readonly isAwake: boolean;
            readonly isSleeping: boolean;
            initialize(v: RigidBody2D): void;
            setType(v: ERigidBody2DType): void;
            setLinearDamping: (v: number) => void;
            setAngularDamping: (v: number) => void;
            setGravityScale: (v: number) => void;
            setFixedRotation: (v: boolean) => void;
            setAllowSleep: (v: boolean) => void;
            isActive: () => boolean;
            setActive: (v: boolean) => void;
            wakeUp(): void;
            sleep(): void;
            getMass(): number;
            getInertia(): number;
            getLinearVelocity<Out extends math.IVec2Like>(out: Out): Out;
            setLinearVelocity(value: math.IVec2Like): void;
            getLinearVelocityFromWorldPoint<Out extends math.IVec2Like>(worldPoint: math.IVec2Like, out: Out): Out;
            getAngularVelocity(): number;
            setAngularVelocity(value: number): void;
            getLocalVector<Out extends math.IVec2Like>(worldVector: math.IVec2Like, out: Out): Out;
            getWorldVector<Out extends math.IVec2Like>(localVector: math.IVec2Like, out: Out): Out;
            getLocalPoint<Out extends math.IVec2Like>(worldPoint: math.IVec2Like, out: Out): Out;
            getWorldPoint<Out extends math.IVec2Like>(localPoint: math.IVec2Like, out: Out): Out;
            getLocalCenter<Out extends math.IVec2Like>(out: Out): Out;
            getWorldCenter<Out extends math.IVec2Like>(out: Out): Out;
            applyForce(force: math.Vec2, point: math.Vec2, wake: boolean): any;
            applyForceToCenter(force: math.Vec2, wake: boolean): any;
            applyTorque(torque: number, wake: boolean): any;
            applyLinearImpulse(impulse: math.Vec2, point: math.Vec2, wake: boolean): any;
            applyLinearImpulseToCenter(impulse: math.Vec2, wake: boolean): any;
            applyAngularImpulse(impulse: number, wake: boolean): any;
        }
        export interface _cocos_physics_2d_spec_i_physics_shape__IBaseShape extends _cocos_physics_spec_i_lifecycle__ILifecycle {
            readonly impl: any;
            readonly collider: Collider2D;
            readonly worldAABB: Readonly<math.Rect>;
            initialize(v: Collider2D): void;
            apply(): void;
            onGroupChanged(): void;
        }
        export const _cocos_physics_2d_framework_components_colliders_collider_2d__Collider2D_base: new (...args: any[]) => Component & _cocos_core_event_eventify__IEventified;
        export interface _cocos_physics_2d_spec_i_physics_joint__IJoint2D extends _cocos_physics_spec_i_lifecycle__ILifecycle {
            readonly impl: any;
            initialize(v: Joint2D): void;
        }
        export interface _cocos_physics_spec_i_physics_world__IRaycastOptions {
            mask: number;
            group: number;
            queryTrigger: boolean;
            maxDistance: number;
        }
        export interface _cocos_physics_spec_i_physics_world__IPhysicsWorld {
            readonly impl: any;
            setGravity: (v: math.IVec3Like) => void;
            setAllowSleep: (v: boolean) => void;
            setDefaultMaterial: (v: physics.PhysicsMaterial) => void;
            step(fixedTimeStep: number, timeSinceLastCalled?: number, maxSubSteps?: number): void;
            raycast(worldRay: geometry.Ray, options: _cocos_physics_spec_i_physics_world__IRaycastOptions, pool: memop.RecyclePool<physics.PhysicsRayResult>, results: physics.PhysicsRayResult[]): boolean;
            raycastClosest(worldRay: geometry.Ray, options: _cocos_physics_spec_i_physics_world__IRaycastOptions, out: physics.PhysicsRayResult): boolean;
            emitEvents(): void;
            syncSceneToPhysics(): void;
            syncAfterEvents(): void;
            destroy(): void;
        }
        export interface _cocos_physics_framework_physics_selector__IWorldInitData {
            gravity: math.IVec3Like;
            allowSleep: boolean;
            defaultMaterial: physics.PhysicsMaterial;
        }
        export interface _cocos_physics_spec_i_group_mask__IGroupMask {
            setGroup(v: number): void;
            getGroup(): number;
            addGroup(v: number): void;
            removeGroup(v: number): void;
            setMask(v: number): void;
            getMask(): number;
            addMask(v: number): void;
            removeMask(v: number): void;
        }
        export interface _cocos_physics_spec_i_physics_shape__IBaseShape extends _cocos_physics_spec_i_lifecycle__ILifecycle, _cocos_physics_spec_i_group_mask__IGroupMask {
            readonly impl: any;
            readonly collider: physics.Collider;
            readonly attachedRigidBody: physics.RigidBody | null;
            initialize(v: physics.Collider): void;
            setMaterial: (v: physics.PhysicsMaterial | null) => void;
            setAsTrigger: (v: boolean) => void;
            setCenter: (v: math.IVec3Like) => void;
            getAABB: (v: geometry.AABB) => void;
            getBoundingSphere: (v: geometry.Sphere) => void;
            updateEventListener: () => void;
        }
        export const _cocos_physics_framework_components_colliders_collider__Collider_base: new (...args: any[]) => Component & _cocos_core_event_eventify__IEventified;
        export interface _cocos_physics_spec_i_physics_shape__IBoxShape extends _cocos_physics_spec_i_physics_shape__IBaseShape {
            updateSize: () => void;
        }
        export interface _cocos_physics_spec_i_physics_shape__ISphereShape extends _cocos_physics_spec_i_physics_shape__IBaseShape {
            updateRadius: () => void;
        }
        export interface _cocos_physics_spec_i_physics_shape__ICapsuleShape extends _cocos_physics_spec_i_physics_shape__IBaseShape {
            setRadius: (v: number) => void;
            setCylinderHeight: (v: number) => void;
            setDirection: (v: number) => void;
        }
        export interface _cocos_physics_spec_i_physics_shape__ITrimeshShape extends _cocos_physics_spec_i_physics_shape__IBaseShape {
            setMesh: (v: Mesh | null) => void;
        }
        export interface _cocos_physics_spec_i_physics_shape__ICylinderShape extends _cocos_physics_spec_i_physics_shape__IBaseShape {
            setRadius: (v: number) => void;
            setHeight: (v: number) => void;
            setDirection: (v: number) => void;
        }
        export interface _cocos_physics_spec_i_physics_shape__IConeShape extends _cocos_physics_spec_i_physics_shape__IBaseShape {
            setRadius: (v: number) => void;
            setHeight: (v: number) => void;
            setDirection: (v: number) => void;
        }
        export interface _cocos_physics_spec_i_physics_shape__IConeShape extends _cocos_physics_spec_i_physics_shape__IBaseShape {
            setRadius: (v: number) => void;
            setHeight: (v: number) => void;
            setDirection: (v: number) => void;
        }
        export interface _cocos_physics_spec_i_external__ITerrainAsset {
            _uuid: string;
            tileSize: number;
            getVertexCountI: () => number;
            getVertexCountJ: () => number;
            getHeight: (i: number, j: number) => number;
        }
        export interface _cocos_physics_spec_i_physics_shape__ITerrainShape extends _cocos_physics_spec_i_physics_shape__IBaseShape {
            setTerrain: (v: _cocos_physics_spec_i_external__ITerrainAsset | null) => void;
        }
        export interface _cocos_physics_spec_i_physics_shape__ISimplexShape extends _cocos_physics_spec_i_physics_shape__IBaseShape {
            setShapeType: (v: physics.SimplexCollider.ESimplexType) => void;
            setVertices: (v: math.IVec3Like[]) => void;
        }
        export interface _cocos_physics_spec_i_physics_shape__IPlaneShape extends _cocos_physics_spec_i_physics_shape__IBaseShape {
            setNormal: (v: math.IVec3Like) => void;
            setConstant: (v: number) => void;
        }
        export interface _cocos_physics_spec_i_physics_constraint__IBaseConstraint extends _cocos_physics_spec_i_lifecycle__ILifecycle {
            readonly impl: any;
            initialize(v: physics.Constraint): void;
            setConnectedBody(v: physics.RigidBody | null): void;
            setEnableCollision(v: boolean): void;
        }
        export const _cocos_physics_framework_components_constraints_constraint__Constraint_base: new (...args: any[]) => Component & _cocos_core_event_eventify__IEventified;
        export interface _cocos_physics_spec_i_physics_constraint__IHingeConstraint extends _cocos_physics_spec_i_physics_constraint__IBaseConstraint {
            setPivotA(v: math.IVec3Like): void;
            setPivotB(v: math.IVec3Like): void;
            setAxis(v: math.IVec3Like): void;
        }
        export interface _cocos_physics_spec_i_physics_constraint__IPointToPointConstraint extends _cocos_physics_spec_i_physics_constraint__IBaseConstraint {
            setPivotA(v: math.IVec3Like): void;
            setPivotB(v: math.IVec3Like): void;
        }
        export interface _cocos_physics_spec_i_rigid_body__IRigidBody extends _cocos_physics_spec_i_lifecycle__ILifecycle, _cocos_physics_spec_i_group_mask__IGroupMask {
            readonly impl: any;
            readonly rigidBody: physics.RigidBody;
            readonly isAwake: boolean;
            readonly isSleepy: boolean;
            readonly isSleeping: boolean;
            initialize(v: physics.RigidBody): void;
            setType: (v: physics.ERigidBodyType) => void;
            setMass: (v: number) => void;
            setLinearDamping: (v: number) => void;
            setAngularDamping: (v: number) => void;
            useGravity: (v: boolean) => void;
            setLinearFactor: (v: math.IVec3Like) => void;
            setAngularFactor: (v: math.IVec3Like) => void;
            setAllowSleep: (v: boolean) => void;
            wakeUp(): void;
            sleep(): void;
            clearState(): void;
            clearForces(): void;
            clearVelocity(): void;
            setSleepThreshold(v: number): void;
            getSleepThreshold(): number;
            useCCD: (v: boolean) => void;
            isUsingCCD: () => boolean;
            getLinearVelocity(out: math.IVec3Like): void;
            setLinearVelocity(value: math.IVec3Like): void;
            getAngularVelocity(out: math.IVec3Like): void;
            setAngularVelocity(value: math.IVec3Like): void;
            applyForce(force: math.IVec3Like, relativePoint?: math.IVec3Like): void;
            applyLocalForce(force: math.IVec3Like, relativePoint?: math.IVec3Like): void;
            applyImpulse(force: math.IVec3Like, relativePoint?: math.IVec3Like): void;
            applyLocalImpulse(force: math.IVec3Like, relativePoint?: math.IVec3Like): void;
            applyTorque(torque: math.IVec3Like): void;
            applyLocalTorque(torque: math.IVec3Like): void;
        }
        export type _cocos_physics_framework_physics_selector__IPhysicsEngineId = "builtin" | "cannon.js" | "ammo.js" | "physx" | string;
        export type _cocos_physics_spec_i_physics_constraint__IConeTwistConstraint = _cocos_physics_spec_i_physics_constraint__IBaseConstraint;
        export interface _cocos_physics_framework_physics_selector__IPhysicsWrapperObject {
            PhysicsWorld?: _types_globals__Constructor<_cocos_physics_spec_i_physics_world__IPhysicsWorld>;
            RigidBody?: _types_globals__Constructor<_cocos_physics_spec_i_rigid_body__IRigidBody>;
            BoxShape?: _types_globals__Constructor<_cocos_physics_spec_i_physics_shape__IBoxShape>;
            SphereShape?: _types_globals__Constructor<_cocos_physics_spec_i_physics_shape__ISphereShape>;
            CapsuleShape?: _types_globals__Constructor<_cocos_physics_spec_i_physics_shape__ICapsuleShape>;
            TrimeshShape?: _types_globals__Constructor<_cocos_physics_spec_i_physics_shape__ITrimeshShape>;
            CylinderShape?: _types_globals__Constructor<_cocos_physics_spec_i_physics_shape__ICylinderShape>;
            ConeShape?: _types_globals__Constructor<_cocos_physics_spec_i_physics_shape__IConeShape>;
            TerrainShape?: _types_globals__Constructor<_cocos_physics_spec_i_physics_shape__ITerrainShape>;
            SimplexShape?: _types_globals__Constructor<_cocos_physics_spec_i_physics_shape__ISimplexShape>;
            PlaneShape?: _types_globals__Constructor<_cocos_physics_spec_i_physics_shape__IPlaneShape>;
            PointToPointConstraint?: _types_globals__Constructor<_cocos_physics_spec_i_physics_constraint__IPointToPointConstraint>;
            HingeConstraint?: _types_globals__Constructor<_cocos_physics_spec_i_physics_constraint__IHingeConstraint>;
            ConeTwistConstraint?: _types_globals__Constructor<_cocos_physics_spec_i_physics_constraint__IConeTwistConstraint>;
        }
        export type _cocos_physics_framework_physics_selector__IPhysicsBackend = {
            [key: string]: _cocos_physics_framework_physics_selector__IPhysicsWrapperObject;
        };
        export interface _cocos_physics_framework_physics_selector__IPhysicsSelector {
            /**
             * @en
             * The id of the physics engine being used by the physics system.
             * @zh
             * 物理系统正在使用的物理引擎的唯一标志。
             */
            readonly id: _cocos_physics_framework_physics_selector__IPhysicsEngineId;
            /**
             * @en
             * The wrapper of the physics engine being used by the physics system.
             * @zh
             * 物理系统使用的物理引擎的封装层。
             */
            readonly wrapper: _cocos_physics_framework_physics_selector__IPhysicsWrapperObject;
            /**
             * @en
             * All physics engine backends that the physics module has registered.
             * @zh
             * 物理模块已注册的所有物理引擎后端。
             */
            readonly backend: _cocos_physics_framework_physics_selector__IPhysicsBackend;
            /**
             * @en
             * An instance of the physical world through which you can access the lowlevel objects.
             * @zh
             * 物理世界实例，通过它可以访问到底层对象。
             */
            readonly physicsWorld: _cocos_physics_spec_i_physics_world__IPhysicsWorld | null;
            /**
             * @en
             * To register the backend, the system will use the last backend registered before initialization,
             * and the registration after that needs to be switched manually.
             * @zh
             * 注册后端，系统将使用在初始化前注册的最后一个后端，此后注册的需要手动切换。
             */
            register: (id: _cocos_physics_framework_physics_selector__IPhysicsEngineId, wrapper: _cocos_physics_framework_physics_selector__IPhysicsWrapperObject) => void;
            /**
             * @en
             * Switch to the physics backend corresponding to the id in the registry.
             * @zh
             * 切换为注册表里对应 id 的物理后端。
             */
            switchTo: (id: _cocos_physics_framework_physics_selector__IPhysicsEngineId) => void;
            [x: string]: any;
        }
        /**
         * @en
         * The definition of the parameter for building a cylinder.
         * @zh
         * 圆柱参数选项。
         */
        export interface _cocos_primitive_cylinder__ICylinderOptions extends primitives.IGeometryOptions {
            radialSegments: number;
            heightSegments: number;
            capped: boolean;
            arc: number;
        }
        /**
         * @en
         * The definition of the parameter for building a box.
         * @zh
         * 立方体参数选项。
         */
        export interface _cocos_primitive_box__IBoxOptions extends _types_globals__RecursivePartial<primitives.IGeometryOptions> {
            /**
             * @en
             * Box extent on X-axis.
             * @zh
             * 立方体宽度。
             */
            width?: number;
            /**
             * @en
             * Box extent on Y-axis.
             * @zh
             * 立方体高度。
             */
            height?: number;
            /**
             * @en
             * Box extent on Z-axis.
             * @zh
             * 立方体长度。
             */
            length?: number;
            /**
             * @en
             * Segment count on X-axis.
             * @zh
             * 宽度线段数。
             */
            widthSegments?: number;
            /**
             * @en
             * Segment count on Y-axis.
             * @zh
             * 高度线段数。
             */
            heightSegments?: number;
            /**
             * @en
             * Segment count on Z-axis.
             * @zh
             * 长度线段数。
             */
            lengthSegments?: number;
        }
        export type _cocos_primitive_cone__IConeOptions = _cocos_primitive_cylinder__ICylinderOptions;
        /**
         * @en
         * The definition of the parameter for building a plane.
         * @zh
         * 平面参数选项。
         */
        export interface _cocos_primitive_plane__IPlaneOptions extends _types_globals__RecursivePartial<primitives.IGeometryOptions> {
            /**
             * Plane extent on X-axis.
             */
            width: number;
            /**
             * Plane extent on Z-axis.
             */
            length: number;
            /**
             * Segment count on X-axis.
             */
            widthSegments: number;
            /**
             * Segment count on Z-axis.
             */
            lengthSegments: number;
        }
        /**
         * @zh
         * 球参数选项。
         * @en
         * The options of sphere
         */
        export interface _cocos_primitive_sphere__ISphereOptions extends primitives.IGeometryOptions {
            segments: number;
        }
        /**
         * @zh
         * 环面参数选项。
         * @en
         * The options about torus
         */
        export interface _cocos_primitive_torus__ITorusOptions extends primitives.IGeometryOptions {
            radialSegments: number;
            tubularSegments: number;
            arc: number;
        }
        /**
         * @en
         * The definition of the parameter for building a capsule.
         * @zh
         * 胶囊体参数选项。
         */
        export interface _cocos_primitive_capsule__ICapsuteOptions {
            sides: number;
            heightSegments: number;
            capped: boolean;
            arc: number;
        }
        /**
         * @en
         * The definition of the parameter for building a circle.
         * @zh
         * 圆形参数选项。
         */
        export interface _cocos_primitive_circle__ICircleOptions extends primitives.IGeometryOptions {
            segments: number;
        }
        export enum _cocos_primitive_primitive__PrimitiveType {
            BOX = 0,
            SPHERE = 1,
            CYLINDER = 2,
            CONE = 3,
            CAPSULE = 4,
            TORUS = 5,
            PLANE = 6,
            QUAD = 7
        }
        export class _cocos_profiler_counter__Counter {
            get value(): number;
            set value(val: number);
            protected _id: string;
            protected _opts: _cocos_profiler_counter__ICounterOption;
            protected _accumStart: number;
            protected _total: number;
            protected _value: number;
            protected _averageValue: number;
            protected _accumValue: number;
            protected _accumSamples: number;
            constructor(id: string, opts: _cocos_profiler_counter__ICounterOption, now: number);
            sample(now: number): void;
            human(): number;
            alarm(): boolean | 0 | undefined;
            protected _average(v: number, now?: number): void;
        }
        export interface _cocos_profiler_counter__ICounterOption {
            desc: string;
            counter: _cocos_profiler_counter__Counter;
            min?: number;
            max?: number;
            average?: number;
            below?: number;
            over?: number;
            color?: string;
            isInteger?: boolean;
        }
        export interface _cocos_profiler_profiler__IProfilerState {
            frame: _cocos_profiler_counter__ICounterOption;
            fps: _cocos_profiler_counter__ICounterOption;
            draws: _cocos_profiler_counter__ICounterOption;
            instances: _cocos_profiler_counter__ICounterOption;
            tricount: _cocos_profiler_counter__ICounterOption;
            logic: _cocos_profiler_counter__ICounterOption;
            physics: _cocos_profiler_counter__ICounterOption;
            render: _cocos_profiler_counter__ICounterOption;
            textureMemory: _cocos_profiler_counter__ICounterOption;
            bufferMemory: _cocos_profiler_counter__ICounterOption;
        }
        export type _cocos_3d_skeletal_animation_skeletal_animation_data_hub__BakeData = ReturnType<AnimationClip[typeof _cocos_core_animation_internal_symbols__BAKE_SKELETON_CURVE_SYMBOL]>;
        export interface _cocos_3d_skeletal_animation_skeletal_animation_state__ITransform {
            pos: math.Vec3;
            rot: math.Quat;
            scale: math.Vec3;
        }
        export interface _cocos_3d_skeletal_animation_skeletal_animation_state__ISocketData {
            target: Node;
            frames: _cocos_3d_skeletal_animation_skeletal_animation_state__ITransform[];
        }
        export interface _cocos_spine_skeleton_cache__FrameSegment {
            indexCount: number;
            vfCount: number;
            vertexCount: number;
            tex?: Texture2D;
            blendMode?: sp.spine.BlendMode;
        }
        export interface _cocos_spine_skeleton_cache__FrameColor {
            fr: number;
            fg: number;
            fb: number;
            fa: number;
            dr: number;
            dg: number;
            db: number;
            da: number;
            vfOffset: number;
        }
        export interface _cocos_spine_skeleton_cache__FrameBoneInfo extends sp.spine.Bone {
            a: number;
            b: number;
            c: number;
            d: number;
            worldX: number;
            worldY: number;
        }
        export interface _cocos_spine_skeleton_cache__AnimationFrame {
            segments: _cocos_spine_skeleton_cache__FrameSegment[];
            colors: _cocos_spine_skeleton_cache__FrameColor[];
            boneInfos: _cocos_spine_skeleton_cache__FrameBoneInfo[];
            vertices: Float32Array;
            indices: Uint16Array;
        }
        export class _cocos_spine_track_entry_listeners__TrackEntryListeners {
            start?: ((entry: sp.spine.TrackEntry) => void);
            interrupt?: ((entry: sp.spine.TrackEntry) => void);
            end?: ((entry: sp.spine.TrackEntry) => void);
            dispose?: ((entry: sp.spine.TrackEntry) => void);
            complete?: ((entry: sp.spine.TrackEntry) => void);
            event?: ((entry: sp.spine.TrackEntry, event: Event) => void);
            static getListeners(entry: sp.spine.TrackEntry): sp.spine.AnimationStateListener;
        }
        export interface _cocos_spine_skeleton_cache__SkeletonCacheItemInfo {
            skeleton: sp.spine.Skeleton;
            clipper: sp.spine.SkeletonClipping;
            state: sp.spine.AnimationState;
            listener: _cocos_spine_track_entry_listeners__TrackEntryListeners;
            curAnimationCache: _cocos_spine_skeleton_cache__AnimationCache | null;
            animationsCache: {
                [key: string]: _cocos_spine_skeleton_cache__AnimationCache;
            };
        }
        export class _cocos_spine_skeleton_cache__AnimationCache {
            frames: _cocos_spine_skeleton_cache__AnimationFrame[];
            totalTime: number;
            isCompleted: boolean;
            maxVertexCount: number;
            maxIndexCount: number;
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _privateMode: boolean;
            protected _inited: boolean;
            protected _invalid: boolean;
            protected _enableCacheAttachedInfo: boolean;
            protected _frameIdx: number;
            protected _skeletonInfo: _cocos_spine_skeleton_cache__SkeletonCacheItemInfo | null;
            protected _animationName: string | null;
            protected _tempSegments: _cocos_spine_skeleton_cache__FrameSegment[] | null;
            protected _tempColors: _cocos_spine_skeleton_cache__FrameColor[] | null;
            protected _tempBoneInfos: _cocos_spine_skeleton_cache__FrameBoneInfo[] | null;
            constructor();
            init(skeletonInfo: _cocos_spine_skeleton_cache__SkeletonCacheItemInfo, animationName: string): void;
            clear(): void;
            bind(listener: _cocos_spine_track_entry_listeners__TrackEntryListeners): void;
            unbind(listener: _cocos_spine_track_entry_listeners__TrackEntryListeners): void;
            begin(): void;
            end(): void;
            updateToFrame(toFrameIdx?: number): void;
            isInited(): boolean;
            isInvalid(): boolean;
            invalidAllFrame(): void;
            updateAllFrame(): void;
            enableCacheAttachedInfo(): void;
            fillVertices(skeletonColor: sp.spine.Color, attachmentColor: sp.spine.Color, slotColor: sp.spine.Color, clipper: sp.spine.SkeletonClipping, slot: sp.spine.Slot): void;
            protected updateFrame(skeleton: sp.spine.Skeleton, clipper: sp.spine.SkeletonClipping, index: number): void;
            protected needToUpdate(toFrameIdx?: number): boolean;
            protected traverseSkeleton(skeleton: sp.spine.Skeleton, clipper: sp.spine.SkeletonClipping): void;
        }
        /**
         * @en Attach node tool
         * @zh 挂点工具类
         * @class sp.AttachUtil
         */
        export class _cocos_spine_attach_util__AttachUtil {
            protected _inited: boolean;
            protected _skeleton: sp.spine.Skeleton | null;
            protected _skeletonNode: Node | null;
            protected _skeletonComp: sp.Skeleton | null;
            constructor();
            init(skeletonComp: sp.Skeleton): void;
            reset(): void;
            _syncAttachedNode(): void;
        }
        export class _cocos_spine_skeleton_cache__SkeletonCache {
            static readonly FrameTime: number;
            static sharedCache: _cocos_spine_skeleton_cache__SkeletonCache;
            protected _privateMode: boolean;
            protected _skeletonCache: {
                [key: string]: _cocos_spine_skeleton_cache__SkeletonCacheItemInfo;
            };
            protected _animationPool: {
                [key: string]: _cocos_spine_skeleton_cache__AnimationCache;
            };
            constructor();
            enablePrivateMode(): void;
            clear(): void;
            removeSkeleton(uuid: string): void;
            getSkeletonCache(uuid: string, skeletonData: sp.spine.SkeletonData): _cocos_spine_skeleton_cache__SkeletonCacheItemInfo;
            getAnimationCache(uuid: string, animationName: string): _cocos_spine_skeleton_cache__AnimationCache | null;
            invalidAnimationCache(uuid: string): void;
            initAnimationCache(uuid: string, animationName: string): null | _cocos_spine_skeleton_cache__AnimationCache;
            updateAnimationCache(uuid: string, animationName: string): void;
        }
        export interface _cocos_spine_skeleton__AnimationItem {
            animationName: string;
            loop: boolean;
            delay: number;
        }
        export type _cocos_spine_skeleton__TrackListener = (x: sp.spine.TrackEntry) => void;
        export type _cocos_spine_skeleton__TrackListener2 = (x: sp.spine.TrackEntry, ev: sp.spine.Event | number) => void;
        export class _cocos_terrain_terrain_lod__TerrainIndexPool {
            size: number;
            indices: Uint16Array | null;
        }
        export class _cocos_terrain_terrain_lod__TerrainLodKey {
            level: number;
            north: number;
            south: number;
            west: number;
            east: number;
            equals(rk: _cocos_terrain_terrain_lod__TerrainLodKey): boolean;
        }
        export class _cocos_terrain_terrain_lod__TerrainIndexData {
            key: _cocos_terrain_terrain_lod__TerrainLodKey;
            start: number;
            size: number;
            buffer: Uint16Array | null;
            primCount: number;
        }
        export class _cocos_terrain_terrain_lod__TerrainLod {
            static mapIndex(i: number, j: number, k: number): number;
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _bodyIndexPool: _cocos_terrain_terrain_lod__TerrainIndexPool[];
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _connecterIndexPool: _cocos_terrain_terrain_lod__TerrainIndexPool[];
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _indexMap: _cocos_terrain_terrain_lod__TerrainIndexData[];
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _indexBuffer: Uint16Array;
            constructor();
            getIndexData(k: _cocos_terrain_terrain_lod__TerrainLodKey): _cocos_terrain_terrain_lod__TerrainIndexData | null;
        }
        export type _cocos_tiledmap_tiled_types__GID = number;
        export type _cocos_tiledmap_tiled_types__MixedGID = number;
        /**
         * Size in pixels of the image
         * @property {cc.Size} imageSize
         */
        /**
         * <p>cc.TMXTilesetInfo contains the information about the tilesets like: <br />
         * - Tileset name<br />
         * - Tileset spacing<br />
         * - Tileset margin<br />
         * - size of the tiles<br />
         * - Image used for the tiles<br />
         * - Image size<br />
         *
         * This information is obtained from the TMX file. </p>
         * @class TMXTilesetInfo
         */
        export class _cocos_tiledmap_tiled_types__TMXTilesetInfo {
            /**
             * Tileset name
             * @property {string} name
             */
            name: string;
            /**
             * First grid
             * @property {number} firstGid
             */
            firstGid: _cocos_tiledmap_tiled_types__GID;
            /**
             * Spacing
             * @property {number} spacing
             */
            spacing: number;
            /**
             * Margin
             * @property {number} margin
             */
            margin: number;
            /**
             * Texture containing the tiles (should be sprite sheet / texture atlas)
             * @property {cc.SpriteFrame} sourceImage
             */
            sourceImage?: SpriteFrame;
            imageName: string | null;
            imageSize: math.Size;
            tileOffset: math.Vec2;
            _tileSize: math.Size;
            collection: boolean;
            rectForGID(gid_: _cocos_tiledmap_tiled_types__MixedGID | _cocos_tiledmap_tiled_types__GID, result?: _cocos_tiledmap_tiled_types__TiledGrid): math.Rect | _cocos_tiledmap_tiled_types__TiledGrid;
        }
        export interface _cocos_tiledmap_tiled_types__TiledGrid {
            tileset: _cocos_tiledmap_tiled_types__TMXTilesetInfo;
            x: number;
            y: number;
            width: number;
            height: number;
            t: number;
            l: number;
            r: number;
            b: number;
            cx: number;
            cy: number;
            offsetX: number;
            offsetY: number;
            rotated: boolean;
            gid: _cocos_tiledmap_tiled_types__GID;
            spriteFrame: SpriteFrame;
            texture: Texture2D;
            _name?: string;
            _rect?: math.Rect;
            _rotated?: boolean;
        }
        export type _cocos_tiledmap_tiled_types__TiledTextureGrids = Map<_cocos_tiledmap_tiled_types__GID, _cocos_tiledmap_tiled_types__TiledGrid>;
        export interface _cocos_tiledmap_tiled_types__TiledAnimation {
            frames: {
                grid: _cocos_tiledmap_tiled_types__TiledGrid | null;
                tileid: _cocos_tiledmap_tiled_types__GID;
                duration: number;
            }[];
            dt: number;
            frameIdx: number;
        }
        export type _cocos_tiledmap_tiled_types__TiledAnimationType = Map<_cocos_tiledmap_tiled_types__GID, _cocos_tiledmap_tiled_types__TiledAnimation>;
        /**
         * cc.TMXImageLayerInfo contains the information about the image layers.
         * This information is obtained from the TMX file.
         * @class TMXImageLayerInfo
         */
        export class _cocos_tiledmap_tiled_types__TMXImageLayerInfo {
            name: string;
            visible: boolean;
            width: number;
            height: number;
            offset: math.Vec2;
            opacity: number;
            trans: math.Color;
            sourceImage?: SpriteFrame;
            tintColor: math.Color | null;
        }
        export interface _cocos_tiledmap_tiled_map__ImageExtendedNode extends Node {
            layerInfo: _cocos_tiledmap_tiled_types__TMXImageLayerInfo;
            _offset: math.Vec2;
        }
        export type _cocos_tiledmap_tiled_types__PropertiesInfo = {
            [key: string]: number | string;
        };
        /**
         * @en The orientation of tiled map.
         * @zh Tiled Map 地图方向。
         * @enum TiledMap.Orientation
         * @static
         */
        export enum _cocos_tiledmap_tiled_types__Orientation {
            /**
             * @en Orthogonal orientation.
             * @zh 直角鸟瞰地图（90°地图）。
             * @property ORTHO
             * @type {Number}
             * @static
             */
            ORTHO = 0,
            /**
             * @en Hexagonal orientation.
             * @zh 六边形地图
             * @property HEX
             * @type {Number}
             * @static
             */
            HEX = 1,
            /**
             * Isometric orientation.
             * 等距斜视地图（斜45°地图）。
             * @property ISO
             * @type {Number}
             * @static
             */
            ISO = 2
        }
        /**
         * @en The render order of tiled map.
         * @zh 地图的渲染顺序
         * @enum TiledMap.RenderOrder
         * @static
         */
        export enum _cocos_tiledmap_tiled_types__RenderOrder {
            /**
             * @property RightDown
             * @type {Number}
             * @static
             */
            RightDown = 0,
            /**
             * @property RightUp
             * @type {Number}
             * @static
             */
            RightUp = 1,
            /**
             * @property LeftDown
             * @type {Number}
             * @static
             */
            LeftDown = 2,
            /**
             * @property LeftUp
             * @type {Number}
             * @static
             */
            LeftUp = 3
        }
        /**
         * @en TiledMap Object Type
         * @zh 地图物体类型
         * @enum TiledMap.TMXObjectType
         * @static
         */
        export enum _cocos_tiledmap_tiled_types__TMXObjectType {
            /**
             * @property RECT
             * @type {Number}
             * @static
             */
            RECT = 0,
            /**
             * @property ELLIPSE
             * @type {Number}
             * @static
             */
            ELLIPSE = 1,
            /**
             * @property POLYGON
             * @type {Number}
             * @static
             */
            POLYGON = 2,
            /**
             * @property POLYLINE
             * @type {Number}
             * @static
             */
            POLYLINE = 3,
            /**
             * @property IMAGE
             * @type {Number}
             * @static
             */
            IMAGE = 4,
            /**
             * @property TEXT
             * @type {Number}
             * @static
             */
            TEXT = 5
        }
        export interface _cocos_tiledmap_tiled_types__TMXObject {
            id: number | string;
            name: string;
            width: number;
            height: number;
            x: number;
            y: number;
            rotation: number;
            type: _cocos_tiledmap_tiled_types__TMXObjectType;
            visible: boolean;
            wrap: boolean;
            color: math.Color;
            halign: HorizontalTextAlignment;
            valign: VerticalTextAlignment;
            pixelsize: number;
            text: string;
            gid: _cocos_tiledmap_tiled_types__MixedGID;
            points: {
                x: number;
                y: number;
            }[];
            polylinePoints: {
                x: number;
                y: number;
            }[] | null;
            offset?: math.Vec2;
        }
        export type _cocos_tiledmap_tiled_types__DrawOrder = "topdown" | "bottomup";
        /**
         * <p>cc.TMXObjectGroupInfo contains the information about the object group like:
         * - group name
         * - group size
         * - group opacity at creation time (it can be modified at runtime)
         * - Whether the group is visible
         *
         * This information is obtained from the TMX file.</p>
         * @class TMXObjectGroupInfo
         */
        export class _cocos_tiledmap_tiled_types__TMXObjectGroupInfo {
            /**
             * Properties of the ObjectGroup info.
             * @property {Array} properties
             */
            properties: _cocos_tiledmap_tiled_types__PropertiesInfo;
            name: string;
            objects: _cocos_tiledmap_tiled_types__TMXObject[];
            visible: boolean;
            opacity: number;
            color: math.Color;
            offset: math.Vec2;
            draworder: _cocos_tiledmap_tiled_types__DrawOrder;
            tintColor: math.Color | null;
            /**
             * Gets the Properties.
             * @return {Array}
             */
            getProperties(): _cocos_tiledmap_tiled_types__PropertiesInfo;
            /**
             * Set the Properties.
             * @param {object} value
             */
            setProperties(value: _cocos_tiledmap_tiled_types__PropertiesInfo): void;
        }
        /**
         * cc.TMXLayerInfo contains the information about the layers like:
         * - Layer name
         * - Layer size
         * - Layer opacity at creation time (it can be modified at runtime)
         * - Whether the layer is visible (if it's not visible, then the CocosNode won't be created)
         * This information is obtained from the TMX file.
         * @class TMXLayerInfo
         */
        export class _cocos_tiledmap_tiled_types__TMXLayerInfo {
            /**
             * Properties of the layer info.
             * @property {Object} properties
             */
            properties: _cocos_tiledmap_tiled_types__PropertiesInfo;
            name: string;
            layerSize: math.Size | null;
            tiles: number[] | Uint32Array;
            visible: boolean;
            opacity: number;
            ownTiles: boolean;
            minGID: _cocos_tiledmap_tiled_types__GID;
            maxGID: _cocos_tiledmap_tiled_types__GID;
            offset: math.Vec2;
            tintColor: math.Color | null;
            /**
             * Gets the Properties.
             * @return {Object}
             */
            getProperties(): _cocos_tiledmap_tiled_types__PropertiesInfo;
            /**
             * Set the Properties.
             * @param {object} value
             */
            setProperties(value: _cocos_tiledmap_tiled_types__PropertiesInfo): void;
            /**
             * @property ATTRIB_NONE
             * @constant
             * @static
             * @type {Number}
             * @default 1
             */
            static ATTRIB_NONE: number;
            /**
             * @property ATTRIB_BASE64
             * @constant
             * @static
             * @type {Number}
             * @default 2
             */
            static ATTRIB_BASE64: number;
            /**
             * @property ATTRIB_GZIP
             * @constant
             * @static
             * @type {Number}
             * @default 4
             */
            static ATTRIB_GZIP: number;
            /**
             * @property ATTRIB_ZLIB
             * @constant
             * @static
             * @type {Number}
             * @default 8
             */
            static ATTRIB_ZLIB: number;
        }
        /**
         * @en The stagger axis of Hex tiled map.
         * @zh 六边形地图的 stagger axis 值
         * @enum TiledMap.StaggerAxis
         * @static
         */
        export enum _cocos_tiledmap_tiled_types__StaggerAxis {
            /**
             * @property STAGGERAXIS_X
             * @type {Number}
             * @static
             */
            STAGGERAXIS_X = 0,
            /**
             * @property STAGGERAXIS_Y
             * @type {Number}
             * @static
             */
            STAGGERAXIS_Y = 1
        }
        /**
         * @en The stagger index of Hex tiled map.
         * @zh 六边形地图的 stagger index 值
         * @enum TiledMap.RenderOrder
         * @static
         */
        export enum _cocos_tiledmap_tiled_types__StaggerIndex {
            /**
             * @property STAGGERINDEX_ODD
             * @type {Number}
             * @static
             */
            STAGGERINDEX_ODD = 0,
            /**
             * @property STAGGERINDEX_EVEN
             * @type {Number}
             * @static
             */
            STAGGERINDEX_EVEN = 1
        }
        /**
         * <p>cc.TMXMapInfo contains the information about the map like: <br/>
         * - Map orientation (hexagonal, isometric or orthogonal)<br/>
         * - Tile size<br/>
         * - Map size</p>
         *
         * <p>And it also contains: <br/>
         * - Layers (an array of TMXLayerInfo objects)<br/>
         * - Tilesets (an array of TMXTilesetInfo objects) <br/>
         * - ObjectGroups (an array of TMXObjectGroupInfo objects) </p>
         *
         * <p>This information is obtained from the TMX file. </p>
         * @class TMXMapInfo
         */
        export class _cocos_tiledmap_tmx_xml_parser__TMXMapInfo {
            /**
             * Properties of the map info.
             * @property {Array}    properties
             */
            properties: _cocos_tiledmap_tiled_types__PropertiesInfo;
            /**
             * Map orientation.
             * @property {Number}   orientation
             */
            orientation: _cocos_tiledmap_tiled_types__Orientation | null;
            /**
             * Parent element.
             * @property {Object}   parentElement
             */
            parentElement: Record<string, unknown> | null;
            /**
             * Parent GID.
             * @property {Number}   parentGID
             */
            parentGID: _cocos_tiledmap_tiled_types__MixedGID;
            /**
             * Layer attributes.
             * @property {Object}   layerAttrs
             */
            layerAttrs: number;
            /**
             * Is reading storing characters stream.
             * @property {Boolean}  storingCharacters
             */
            storingCharacters: boolean;
            /**
             * Current string stored from characters stream.
             * @property {String}   currentString
             */
            currentString: string | null;
            renderOrder: _cocos_tiledmap_tiled_types__RenderOrder;
            protected _supportVersion: number[];
            protected _objectGroups: _cocos_tiledmap_tiled_types__TMXObjectGroupInfo[];
            protected _allChildren: (_cocos_tiledmap_tiled_types__TMXLayerInfo | _cocos_tiledmap_tiled_types__TMXImageLayerInfo | _cocos_tiledmap_tiled_types__TMXObjectGroupInfo)[];
            protected _mapSize: math.Size;
            get mapSize(): math.Size;
            protected _tileSize: math.Size;
            get tileSize(): math.Size;
            protected _layers: _cocos_tiledmap_tiled_types__TMXLayerInfo[];
            protected _tilesets: _cocos_tiledmap_tiled_types__TMXTilesetInfo[];
            protected _imageLayers: _cocos_tiledmap_tiled_types__TMXImageLayerInfo[];
            protected _tileProperties: Map<_cocos_tiledmap_tiled_types__GID, _cocos_tiledmap_tiled_types__PropertiesInfo>;
            protected _tileAnimations: _cocos_tiledmap_tiled_types__TiledAnimationType;
            protected _tsxContentMap: {
                [key: string]: string;
            } | null;
            protected _spriteFrameMap: {
                [key: string]: SpriteFrame;
            } | null;
            protected _spfSizeMap: {
                [key: string]: math.Size;
            };
            protected _staggerAxis: _cocos_tiledmap_tiled_types__StaggerAxis | null;
            protected _staggerIndex: _cocos_tiledmap_tiled_types__StaggerIndex | null;
            protected _hexSideLength: number;
            protected _imageLayerSPF: {
                [key: string]: SpriteFrame;
            } | null;
            constructor(tmxFile: string, tsxContentMap: {
                [key: string]: string;
            }, spfTexturesMap: {
                [key: string]: SpriteFrame;
            }, textureSizes: {
                [key: string]: math.Size;
            }, imageLayerTextures: {
                [key: string]: SpriteFrame;
            });
            getOrientation(): _cocos_tiledmap_tiled_types__Orientation | null;
            /**
             * Set the Map orientation.
             * @param {Number} value
             */
            setOrientation(value: _cocos_tiledmap_tiled_types__Orientation): void;
            /**
             * Gets the staggerAxis of map.
             * @return {TiledMap.StaggerAxis}
             */
            getStaggerAxis(): _cocos_tiledmap_tiled_types__StaggerAxis | null;
            /**
             * Set the staggerAxis of map.
             * @param {TiledMap.StaggerAxis} value
             */
            setStaggerAxis(value: _cocos_tiledmap_tiled_types__StaggerAxis): void;
            /**
             * Gets stagger index
             * @return {TiledMap.StaggerIndex}
             */
            getStaggerIndex(): _cocos_tiledmap_tiled_types__StaggerIndex | null;
            /**
             * Set the stagger index.
             * @param {TiledMap.StaggerIndex} value
             */
            setStaggerIndex(value: any): void;
            /**
             * Gets Hex side length.
             * @return {Number}
             */
            getHexSideLength(): number;
            /**
             * Set the Hex side length.
             * @param {Number} value
             */
            setHexSideLength(value: number): void;
            /**
             * Map width & height
             * @return {Size}
             */
            getMapSize(): math.Size;
            /**
             * Map width & height
             * @param {Size} value
             */
            setMapSize(value: math.Size): void;
            get mapWidth(): number;
            set mapWidth(width: number);
            get mapHeight(): number;
            set mapHeight(height: number);
            /**
             * Tiles width & height
             * @return {Size}
             */
            getTileSize(): math.Size;
            /**
             * Tiles width & height
             * @param {Size} value
             */
            setTileSize(value: math.Size): void;
            get tileWidth(): number;
            set tileWidth(width: number);
            /**
             * Height of a tile
             */
            get tileHeight(): number;
            set tileHeight(height: number);
            /**
             * Layers
             * @return {Array}
             */
            getLayers(): _cocos_tiledmap_tiled_types__TMXLayerInfo[];
            /**
             * Layers
             * @param {cc.TMXLayerInfo} value
             */
            setLayers(value: _cocos_tiledmap_tiled_types__TMXLayerInfo): void;
            /**
             * ImageLayers
             * @return {Array}
             */
            getImageLayers(): _cocos_tiledmap_tiled_types__TMXImageLayerInfo[];
            /**
             * ImageLayers
             * @param {cc.TMXImageLayerInfo} value
             */
            setImageLayers(value: _cocos_tiledmap_tiled_types__TMXImageLayerInfo): void;
            /**
             * tilesets
             * @return {Array}
             */
            getTilesets(): _cocos_tiledmap_tiled_types__TMXTilesetInfo[];
            /**
             * tilesets
             * @param {cc.TMXTilesetInfo} value
             */
            setTilesets(value: _cocos_tiledmap_tiled_types__TMXTilesetInfo): void;
            /**
             * ObjectGroups
             * @return {Array}
             */
            getObjectGroups(): _cocos_tiledmap_tiled_types__TMXObjectGroupInfo[];
            /**
             * ObjectGroups
             * @param {cc.TMXObjectGroup} value
             */
            setObjectGroups(value: _cocos_tiledmap_tiled_types__TMXObjectGroupInfo): void;
            getAllChildren(): (_cocos_tiledmap_tiled_types__TMXObjectGroupInfo | _cocos_tiledmap_tiled_types__TMXLayerInfo | _cocos_tiledmap_tiled_types__TMXImageLayerInfo)[];
            /**
             * parent element
             * @return {Object}
             */
            getParentElement(): Record<string, unknown> | null;
            /**
             * parent element
             * @param {Object} value
             */
            setParentElement(value: any): void;
            /**
             * parent GID
             * @return {Number}
             */
            getParentGID(): number;
            /**
             * parent GID
             * @param {Number} value
             */
            setParentGID(value: any): void;
            /**
             * Layer attribute
             * @return {Object}
             */
            getLayerAttribs(): number;
            /**
             * Layer attribute
             * @param {Object} value
             */
            setLayerAttribs(value: any): void;
            /**
             * Is reading storing characters stream
             * @return {Boolean}
             */
            getStoringCharacters(): boolean;
            /**
             * Is reading storing characters stream
             * @param {Boolean} value
             */
            setStoringCharacters(value: any): void;
            /**
             * Properties
             * @return {Array}
             */
            getProperties(): _cocos_tiledmap_tiled_types__PropertiesInfo;
            /**
             * Properties
             * @param {object} value
             */
            setProperties(value: any): void;
            /**
             * initializes a TMX format with an XML string and a TMX resource path
             * @param {String} tmxString
             * @param {Object} tsxMap
             * @param {Object} spfTextureMap
             * @return {Boolean}
             */
            initWithXML(tmxString: string, tsxMap: {
                [key: string]: string;
            }, spfTextureMap: {
                [key: string]: SpriteFrame;
            }, textureSizes: {
                [key: string]: math.Size;
            }, imageLayerTextures: {
                [key: string]: SpriteFrame;
            }): HTMLElement;
            /**
             * Initializes parsing of an XML string, either a tmx (Map) string or tsx (Tileset) string
             * @param {String} xmlString
             * @param {Number} tilesetFirstGid
             * @return {Element}
             */
            parseXMLString(xmlStr: string, tilesetFirstGid?: number): HTMLElement;
            protected _shouldIgnoreNode(node: ChildNode): boolean;
            protected _parseImageLayer(selLayer: Element): _cocos_tiledmap_tiled_types__TMXImageLayerInfo | null;
            protected _parseLayer(selLayer: Element): _cocos_tiledmap_tiled_types__TMXLayerInfo | null;
            protected _parseObjectGroup(selGroup: Element): _cocos_tiledmap_tiled_types__TMXObjectGroupInfo;
            protected _parsePointsString(pointsString?: string): {
                x: number;
                y: number;
            }[] | null;
            /**
             * Sets the tile animations.
             * @return {Object}
             */
            setTileAnimations(animations: _cocos_tiledmap_tiled_types__TiledAnimationType): void;
            /**
             * Gets the tile animations.
             * @return {Object}
             */
            getTileAnimations(): _cocos_tiledmap_tiled_types__TiledAnimationType;
            /**
             * Gets the tile properties.
             * @return {Object}
             */
            getTileProperties(): Map<number, _cocos_tiledmap_tiled_types__PropertiesInfo>;
            /**
             * Set the tile properties.
             * @param {Object} tileProperties
             */
            setTileProperties(tileProperties: Map<_cocos_tiledmap_tiled_types__GID, _cocos_tiledmap_tiled_types__PropertiesInfo>): void;
            /**
             * Gets the currentString
             * @return {String}
             */
            getCurrentString(): string | null;
            /**
             * Set the currentString
             * @param {String} currentString
             */
            setCurrentString(currentString: string): void;
            static getNameWithPostfix(name: string): string;
            static getShortName(name: string): string;
        }
        /**
         * The property type of tiled map.
         * @enum TiledMap.Property
         * @static
         */
        export enum _cocos_tiledmap_tiled_types__Property {
            /**
             * @property NONE
             * @type {Number}
             * @static
             */
            NONE = 0,
            /**
             * @property MAP
             * @type {Number}
             * @static
             */
            MAP = 1,
            /**
             * @property LAYER
             * @type {Number}
             * @static
             */
            LAYER = 2,
            /**
             * @property OBJECTGROUP
             * @type {Number}
             * @static
             */
            OBJECTGROUP = 3,
            /**
             * @property OBJECT
             * @type {Number}
             * @static
             */
            OBJECT = 4,
            /**
             * @property TILE
             * @type {Number}
             * @static
             */
            TILE = 5
        }
        /**
         * The tile flags of tiled map.
         * @enum TiledMap.TileFlag
         * @static
         */
        export enum _cocos_tiledmap_tiled_types__TileFlag {
            /**
             * @property HORIZONTAL
             * @type {Number}
             * @static
             */
            HORIZONTAL = 2147483648,
            /**
             * @property VERTICAL
             * @type {Number}
             * @static
             */
            VERTICAL = 1073741824,
            /**
             * @property DIAGONAL
             * @type {Number}
             * @static
             */
            DIAGONAL = 536870912,
            /**
             * @property FLIPPED_ALL
             * @type {Number}
             * @static
             */
            FLIPPED_ALL = 4026531840,
            /**
             * @property FLIPPED_MASK
             * @type {Number}
             * @static
             */
            FLIPPED_MASK = 268435455
        }
        export interface _cocos_tiledmap_tiled_layer__TiledSubNodeData {
            subNodes: (null | TiledUserNodeData)[];
        }
        export type _cocos_tiledmap_tiled_layer__TiledDataArray = (TiledRenderData | _cocos_tiledmap_tiled_layer__TiledSubNodeData)[];
        /**
         * @en Base classAction for action classes.
         * @zh Action 类是所有动作类型的基类。
         * @class Action
         */
        export class _cocos_tween_actions_action__Action {
            /**
             * @en Default Action tag.
             * @zh 默认动作标签。
             * @constant
             * @static
             * @default -1
             */
            static TAG_INVALID: number;
            protected originalTarget: Node | null;
            protected target: Node | null;
            protected tag: number;
            /**
             * @en
             * to copy object with deep copy.
             * returns a clone of action.
             * @zh 返回一个克隆的动作。
             * @method clone
             * @return {Action}
             */
            clone(): _cocos_tween_actions_action__Action;
            /**
             * @en
             * return true if the action has finished.
             * @zh 如果动作已完成就返回 true。
             * @method isDone
             * @return {Boolean}
             */
            isDone(): boolean;
            startWithTarget(target: any): void;
            stop(): void;
            step(dt: number): void;
            update(dt: number): void;
            /**
             * @en get the target.
             * @zh 获取当前目标节点。
             * @method getTarget
             * @return {object}
             */
            getTarget(): Node | null;
            /**
             * @en The action will modify the target properties.
             * @zh 设置目标节点。
             * @method setTarget
             * @param {object} target
             */
            setTarget(target: Node): void;
            /**
             * @en get the original target.
             * @zh 获取原始目标节点。
             * @method getOriginalTarget
             * @return {object}
             */
            getOriginalTarget(): Node | null;
            setOriginalTarget(originalTarget: any): void;
            /**
             * @en get tag number.
             * @zh 获取用于识别动作的标签。
             * @method getTag
             * @return {Number}
             */
            getTag(): number;
            /**
             * @en set tag number.
             * @zh 设置标签，用于识别动作。
             * @method setTag
             * @param {Number} tag
             */
            setTag(tag: number): void;
            /**
             * @en
             * Returns a reversed action. <br />
             * For example: <br />
             * - The action will be x coordinates of 0 move to 100. <br />
             * - The reversed action will be x of 100 move to 0.
             * - Will be rewritten
             * @zh 返回一个新的动作，执行与原动作完全相反的动作。
             * @method reverse
             * @return {Action | null}
             */
            reverse(): _cocos_tween_actions_action__Action | null;
            retain(): void;
            release(): void;
        }
        /**
         * @en
         * `ActionManager` is a class that can manage actions.<br/>
         * Normally you won't need to use this class directly. 99% of the cases you will use the CCNode interface,
         * which uses this class's singleton object.
         * But there are some cases where you might need to use this class. <br/>
         * Examples:<br/>
         * - When you want to run an action where the target is different from a CCNode.<br/>
         * - When you want to pause / resume the actions<br/>
         * @zh
         * `ActionManager` 是可以管理动作的单例类。<br/>
         * 通常你并不需要直接使用这个类，99%的情况您将使用 CCNode 的接口。<br/>
         * 但也有一些情况下，您可能需要使用这个类。 <br/>
         * 例如：
         *  - 当你想要运行一个动作，但目标不是 CCNode 类型时。 <br/>
         *  - 当你想要暂停/恢复动作时。 <br/>
         * @class ActionManager
         * @example {@link cocos2d/core/CCActionManager/ActionManager.js}
         */
        export class _cocos_tween_actions_action_manager__ActionManager {
            /**
             * @en
             * Adds an action with a target.<br/>
             * If the target is already present, then the action will be added to the existing target.
             * If the target is not present, a new instance of this target will be created either paused or not,
             * and the action will be added to the newly created target.
             * When the target is paused, the queued actions won't be 'ticked'.
             * @zh
             * 增加一个动作，同时还需要提供动作的目标对象，目标对象是否暂停作为参数。<br/>
             * 如果目标已存在，动作将会被直接添加到现有的节点中。<br/>
             * 如果目标不存在，将为这一目标创建一个新的实例，并将动作添加进去。<br/>
             * 当目标状态的 paused 为 true，动作将不会被执行
             *
             * @method addAction
             * @param {Action} action
             * @param {object} target
             * @param {Boolean} paused
             */
            addAction(action: _cocos_tween_actions_action__Action, target: Node, paused: boolean): void;
            /**
             * @en Removes all actions from all the targets.
             * @zh 移除所有对象的所有动作。
             * @method removeAllActions
             */
            removeAllActions(): void;
            /**
             * @en
             * Removes all actions from a certain target. <br/>
             * All the actions that belongs to the target will be removed.
             * @zh
             * 移除指定对象上的所有动作。<br/>
             * 属于该目标的所有的动作将被删除。
             * @method removeAllActionsFromTarget
             * @param {Node} target
             */
            removeAllActionsFromTarget(target: Node): void;
            /**
             * @en Removes an action given an action reference.
             * @zh 移除指定的动作。
             * @method removeAction
             * @param {Action} action
             */
            removeAction(action: _cocos_tween_actions_action__Action): void;
            /**
             * @internal
             */
            _removeActionByTag(tag: number, element: any, target?: Node): void;
            /**
             * @internal
             */
            _removeAllActionsByTag(tag: number, element: any, target?: Node): void;
            /**
             * @en Removes an action given its tag and the target.
             * @zh 删除指定对象下特定标签的一个动作，将删除首个匹配到的动作。
             * @method removeActionByTag
             * @param {Number} tag
             * @param {Node} target
             */
            removeActionByTag(tag: number, target?: Node): void;
            /**
             * @en Removes all actions given the tag and the target.
             * @zh 删除指定对象下特定标签的所有动作。
             * @method removeAllActionsByTag
             * @param {Number} tag
             * @param {Node} target
             */
            removeAllActionsByTag(tag: number, target?: Node): void;
            /**
             * @en Gets an action given its tag an a target.
             * @zh 通过目标对象和标签获取一个动作。
             * @method getActionByTag
             * @param {Number} tag
             * @param {Node} target
             * @return {Action|null}  return the Action with the given tag on success
             */
            getActionByTag(tag: number, target: Node): _cocos_tween_actions_action__Action | null;
            /**
             * @en
             * Returns the numbers of actions that are running in a certain target. <br/>
             * Composable actions are counted as 1 action. <br/>
             * Example: <br/>
             * - If you are running 1 Sequence of 7 actions, it will return 1. <br/>
             * - If you are running 7 Sequences of 2 actions, it will return 7.
             * @zh
             * 返回指定对象下所有正在运行的动作数量。 <br/>
             * 组合动作被算作一个动作。<br/>
             * 例如：<br/>
             *  - 如果您正在运行 7 个动作组成的序列动作（Sequence），这个函数将返回 1。<br/>
             *  - 如果你正在运行 2 个序列动作（Sequence）和 5 个普通动作，这个函数将返回 7。<br/>
             *
             * @method getNumberOfRunningActionsInTarget
             * @param {Node} target
             * @return {Number}
             */
            getNumberOfRunningActionsInTarget(target: Node): number;
            /**
             * @en Pauses the target: all running actions and newly added actions will be paused.
             * @zh 暂停指定对象：所有正在运行的动作和新添加的动作都将会暂停。
             * @method pauseTarget
             * @param {Node} target
             */
            pauseTarget(target: Node): void;
            /**
             * @en Resumes the target. All queued actions will be resumed.
             * @zh 让指定目标恢复运行。在执行序列中所有被暂停的动作将重新恢复运行。
             * @method resumeTarget
             * @param {Node} target
             */
            resumeTarget(target: Node): void;
            /**
             * @en Pauses all running actions, returning a list of targets whose actions were paused.
             * @zh 暂停所有正在运行的动作，返回一个包含了那些动作被暂停了的目标对象的列表。
             * @method pauseAllRunningActions
             * @return {Array}  a list of targets whose actions were paused.
             */
            pauseAllRunningActions(): Array<any>;
            /**
             * @en Resume a set of targets (convenience function to reverse a pauseAllRunningActions or pauseTargets call).
             * @zh 让一组指定对象恢复运行（用来逆转 pauseAllRunningActions 效果的便捷函数）。
             * @method resumeTargets
             * @param {Array} targetsToResume
             */
            resumeTargets(targetsToResume: Array<any>): void;
            /**
             * @en Pause a set of targets.
             * @zh 暂停一组指定对象。
             * @method pauseTargets
             * @param {Array} targetsToPause
             */
            pauseTargets(targetsToPause: Array<any>): void;
            /**
             * @en
             * purges the shared action manager. It releases the retained instance. <br/>
             * because it uses this, so it can not be static.
             * @zh
             * 清除共用的动作管理器。它释放了持有的实例。 <br/>
             * 因为它使用 this，因此它不能是静态的。
             * @method purgeSharedManager
             */
            purgeSharedManager(): void;
            /**
             * @en The ActionManager update。
             * @zh ActionManager 主循环。
             * @method update
             * @param {Number} dt delta time in seconds
             */
            update(dt: number): void;
        }
        export type _cocos_tween_tween__FlagExcludedType<Base, Type> = {
            [Key in keyof Base]: Base[Key] extends Type ? never : Key;
        };
        export type _cocos_tween_tween__AllowedNames<Base, Type> = _cocos_tween_tween__FlagExcludedType<Base, Type>[keyof Base];
        export type _cocos_tween_tween__KeyPartial<T, K extends keyof T> = {
            [P in K]?: T[P];
        };
        export type _cocos_tween_tween__OmitType<Base, Type> = _cocos_tween_tween__KeyPartial<Base, _cocos_tween_tween__AllowedNames<Base, Type>>;
        export type _cocos_tween_tween__ConstructorType<T> = _cocos_tween_tween__OmitType<T, Function>;
        /**
         * @en
         * Base class actions that do have a finite time duration. <br/>
         * Possible actions: <br/>
         * - An action with a duration of 0 seconds. <br/>
         * - An action with a duration of 35.5 seconds.
         *
         * Infinite time actions are valid
         * @zh 有限时间动作，这种动作拥有时长 duration 属性。
         * @class FiniteTimeAction
         * @extends Action
         */
        export class _cocos_tween_actions_action__FiniteTimeAction extends _cocos_tween_actions_action__Action {
            _duration: number;
            _timesForRepeat: number;
            /**
             * @en get duration of the action. (seconds).
             * @zh 获取动作以秒为单位的持续时间。
             * @method getDuration
             * @return {Number}
             */
            getDuration(): number;
            /**
             * @en set duration of the action. (seconds).
             * @zh 设置动作以秒为单位的持续时间。
             * @method setDuration
             * @param {Number} duration
             */
            setDuration(duration: number): void;
            /**
             * @en
             * to copy object with deep copy.
             * returns a clone of action.
             * @zh 返回一个克隆的动作。
             * @method clone
             * @return {FiniteTimeAction}
             */
            clone(): _cocos_tween_actions_action__FiniteTimeAction;
        }
        /**
         * @en
         * <p> An interval action is an action that takes place within a certain period of time. <br/>
         * It has an start time, and a finish time. The finish time is the parameter<br/>
         * duration plus the start time.</p>
         *
         * <p>These CCActionInterval actions have some interesting properties, like:<br/>
         * - They can run normally (default)  <br/>
         * - They can run reversed with the reverse method   <br/>
         * - They can run with the time altered with the Accelerate, AccelDeccel and Speed actions. </p>
         *
         * <p>For example, you can simulate a Ping Pong effect running the action normally and<br/>
         * then running it again in Reverse mode. </p>
         * @zh 时间间隔动作，这种动作在已定时间内完成，继承 FiniteTimeAction。
         * @class ActionInterval
         * @extends FiniteTimeAction
         * @param {Number} d duration in seconds
         */
        export class _cocos_tween_actions_action_interval__ActionInterval extends _cocos_tween_actions_action__FiniteTimeAction {
            protected MAX_VALUE: number;
            protected _elapsed: number;
            protected _firstTick: boolean;
            protected _easeList: Function[];
            protected _speed: number;
            protected _repeatForever: boolean;
            _repeatMethod: boolean;
            protected _speedMethod: boolean;
            constructor(d?: number);
            getElapsed(): number;
            initWithDuration(d: number): boolean;
            isDone(): boolean;
            _cloneDecoration(action: _cocos_tween_actions_action_interval__ActionInterval): void;
            _reverseEaseList(action: _cocos_tween_actions_action_interval__ActionInterval): void;
            clone(): _cocos_tween_actions_action_interval__ActionInterval;
            /**
             * @en Implementation of ease motion.
             * @zh 缓动运动。
             * @method easing
             * @param {Object} easeObj
             * @returns {ActionInterval}
             * @example
             * import { easeIn } from 'cc';
             * action.easing(easeIn(3.0));
             */
            easing(easeObj: any): _cocos_tween_actions_action_interval__ActionInterval;
            _computeEaseTime(dt: any): any;
            step(dt: number): void;
            startWithTarget(target: any): void;
            reverse(): this;
            setAmplitudeRate(amp: any): void;
            getAmplitudeRate(): number;
            /**
             * @en
             * Changes the speed of an action, making it take longer (speed>1)
             * or less (speed<1) time. <br/>
             * Useful to simulate 'slow motion' or 'fast forward' effect.
             * @zh
             * 改变一个动作的速度，使它的执行使用更长的时间（speed > 1）<br/>
             * 或更少（speed < 1）可以有效得模拟“慢动作”或“快进”的效果。
             * @param {Number} speed
             * @returns {Action}
             */
            speed(speed: number): _cocos_tween_actions_action__Action;
            /**
             * @en
             * Get this action speed.
             * @zh
             * 返回此动作速度
             * @return {Number}
             */
            getSpeed(): number;
            /**
             * @en
             * Set this action speed.
             * @zh
             * 设置此动作速度
             * @param {Number} speed
             * @returns {ActionInterval}
             */
            setSpeed(speed: number): _cocos_tween_actions_action_interval__ActionInterval;
            /**
             * @en
             * Repeats an action a number of times.
             * To repeat an action forever use the CCRepeatForever action.
             * @zh 重复动作可以按一定次数重复一个动作，使用 RepeatForever 动作来永远重复一个动作。
             * @method repeat
             * @param {Number} times
             * @returns {ActionInterval}
             */
            repeat(times: number): _cocos_tween_actions_action_interval__ActionInterval;
            /**
             * @en
             * Repeats an action for ever.  <br/>
             * To repeat the an action for a limited number of times use the Repeat action. <br/>
             * @zh 永远地重复一个动作，有限次数内重复一个动作请使用 Repeat 动作。
             * @method repeatForever
             * @returns {ActionInterval}
             */
            repeatForever(): _cocos_tween_actions_action_interval__ActionInterval;
        }
        /**
         * @en Enum for transition type.
         *
         * @zh 过渡类型。
         */
        export enum _cocos_ui_button__Transition {
            /**
             * @en The none type.
             *
             * @zh 不做任何过渡。
             */
            NONE = 0,
            /**
             * @en The color type.
             *
             * @zh 颜色过渡。
             */
            COLOR = 1,
            /**
             * @en The sprite type.
             *
             * @zh 精灵过渡。
             */
            SPRITE = 2,
            /**
             * @en The scale type.
             *
             * @zh 缩放过渡。
             */
            SCALE = 3
        }
        /**
         * @en The event types of [[Button]]. All button events are distributed by the owner Node, not the component
         * @zh [[Button]] 的事件类型，注意：事件是从该组件所属的 Node 上面派发出来的，需要用 node.on 来监听。
         */
        export enum _cocos_ui_button__EventType {
            /**
             * @event click
             * @param {Event.EventCustom} event
             * @param {Button} button - The Button component.
             */
            CLICK = "click"
        }
        /**
         * 定义了一些用于设置文本显示和文本格式化的标志位。
         * @readonly
         * @enum EditBox.InputFlag
         */
        export enum _cocos_ui_editbox_types__InputFlag {
            /**
             * 表明输入的文本是保密的数据，任何时候都应该隐藏起来，它隐含了 EDIT_BOX_INPUT_FLAG_SENSITIVE。
             */
            PASSWORD = 0,
            /**
             * 表明输入的文本是敏感数据，它禁止存储到字典或表里面，也不能用来自动补全和提示用户输入。
             * 一个信用卡号码就是一个敏感数据的例子。
             */
            SENSITIVE = 1,
            /**
             * 这个标志用来指定在文本编辑的时候，是否把每一个单词的首字母大写。
             */
            INITIAL_CAPS_WORD = 2,
            /**
             * 这个标志用来指定在文本编辑是否每个句子的首字母大写。
             */
            INITIAL_CAPS_SENTENCE = 3,
            /**
             * 自动把输入的所有字符大写。
             */
            INITIAL_CAPS_ALL_CHARACTERS = 4,
            /**
             * Don't do anything with the input text.
             */
            DEFAULT = 5
        }
        /**
         * 输入模式。
         * @readonly
         * @enum EditBox.InputMode
         */
        export enum _cocos_ui_editbox_types__InputMode {
            /**
             * 用户可以输入任何文本，包括换行符。
             */
            ANY = 0,
            /**
             * 允许用户输入一个电子邮件地址。
             */
            EMAIL_ADDR = 1,
            /**
             * 允许用户输入一个整数值。
             */
            NUMERIC = 2,
            /**
             * 允许用户输入一个电话号码。
             */
            PHONE_NUMBER = 3,
            /**
             * 允许用户输入一个 URL。
             */
            URL = 4,
            /**
             * 允许用户输入一个实数。
             */
            DECIMAL = 5,
            /**
             * 除了换行符以外，用户可以输入任何文本。
             */
            SINGLE_LINE = 6
        }
        /**
         * 键盘的返回键类型。
         * @readonly
         * @enum EditBox.KeyboardReturnType
         */
        export enum _cocos_ui_editbox_types__KeyboardReturnType {
            /**
             * 默认。
             */
            DEFAULT = 0,
            /**
             * 完成类型。
             */
            DONE = 1,
            /**
             * 发送类型。
             */
            SEND = 2,
            /**
             * 搜索类型。
             */
            SEARCH = 3,
            /**
             * 跳转类型。
             */
            GO = 4,
            /**
             * 下一个类型。
             */
            NEXT = 5
        }
        export class _cocos_ui_editbox_edit_box_impl_base__EditBoxImplBase {
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _editing: boolean;
            /**
             * @deprecated since v3.5.0, this is an engine private interface that will be removed in the future.
             */
            _delegate: EditBox | null;
            init(delegate: EditBox): void;
            onEnable(): void;
            update(): void;
            onDisable(): void;
            clear(): void;
            setTabIndex(index: number): void;
            setSize(width: number, height: number): void;
            setFocus(value: any): void;
            isFocused(): boolean;
            beginEditing(): void;
            endEditing(): void;
        }
        export enum _cocos_ui_editbox_edit_box__EventType {
            EDITING_DID_BEGAN = "editing-did-began",
            EDITING_DID_ENDED = "editing-did-ended",
            TEXT_CHANGED = "text-changed",
            EDITING_RETURN = "editing-return",
            XR_EDITING_DID_BEGAN = "xr-editing-did-began",
            XR_EDITING_DID_ENDED = "xr-editing-did-ended"
        }
        /**
         * @en Layout type.
         *
         * @zh 布局类型。
         */
        export enum _cocos_ui_layout__Type {
            /**
             * @en No layout.
             *
             * @zh 禁用布局。
             */
            NONE = 0,
            /**
             * @en Horizontal layout.
             *
             * @zh 水平布局。
             */
            HORIZONTAL = 1,
            /**
             * @en Vertical layout.
             *
             * @zh 垂直布局。
             */
            VERTICAL = 2,
            /**
             * @en Grid layout.
             *
             * @zh 网格布局。
             */
            GRID = 3
        }
        /**
         * @en Layout Resize Mode.
         *
         * @zh 缩放模式。
         */
        export enum _cocos_ui_layout__ResizeMode {
            /**
             * @en Don't scale.
             *
             * @zh 不做任何缩放。
             */
            NONE = 0,
            /**
             * @en The container size will be expanded with its children's size.
             *
             * @zh 容器的大小会根据子节点的大小自动缩放。
             */
            CONTAINER = 1,
            /**
             * @en Child item size will be adjusted with the container's size.
             *
             * @zh 子节点的大小会随着容器的大小自动缩放。
             */
            CHILDREN = 2
        }
        /**
         * @en Grid Layout start axis direction.
         *
         * @zh 布局轴向，只用于 GRID 布局。
         */
        export enum _cocos_ui_layout__AxisDirection {
            /**
             * @en The horizontal axis.
             *
             * @zh 进行水平方向布局。
             */
            HORIZONTAL = 0,
            /**
             * @en The vertical axis.
             *
             * @zh 进行垂直方向布局。
             */
            VERTICAL = 1
        }
        /**
         * @en Vertical layout direction.
         *
         * @zh 垂直方向布局方式。
         */
        export enum _cocos_ui_layout__VerticalDirection {
            /**
             * @en Items arranged from bottom to top.
             *
             * @zh 从下到上排列。
             */
            BOTTOM_TO_TOP = 0,
            /**
             * @en Items arranged from top to bottom.
             * @zh 从上到下排列。
             */
            TOP_TO_BOTTOM = 1
        }
        /**
         * @en Horizontal layout direction.
         *
         * @zh 水平方向布局方式。
         */
        export enum _cocos_ui_layout__HorizontalDirection {
            /**
             * @en Items arranged from left to right.
             *
             * @zh 从左往右排列。
             */
            LEFT_TO_RIGHT = 0,
            /**
             * @en Items arranged from right to left.
             * @zh 从右往左排列。
             */
            RIGHT_TO_LEFT = 1
        }
        /**
         * @en Layout constraint.
         *
         * @zh 布局约束。
         */
        export enum _cocos_ui_layout__Constraint {
            /**
             * @en Constraint free.
             *
             * @zh 自由排布。
             */
            NONE = 0,
            /**
             * @en Keep the number of rows fixed.
             *
             * @zh 固定行。
             */
            FIXED_ROW = 1,
            /**
             * @en Keep the number of rows fixed columns.
             *
             * @zh 固定列。
             */
            FIXED_COL = 2
        }
        /**
         * @en
         * Enum for ProgressBar mode.
         *
         * @zh
         * 进度条模式。
         */
        export enum _cocos_ui_progress_bar__Mode {
            /**
             * @en
             * The mode of horizontal.
             *
             * @zh
             * 水平方向模式。
             */
            HORIZONTAL = 0,
            /**
             * @en
             * The mode of vertical.
             *
             * @zh
             *  垂直方向模式。
             */
            VERTICAL = 1,
            /**
             * @en
             * The mode of fill.
             *
             * @zh
             * 填充模式。
             */
            FILLED = 2
        }
        /**
         * @en
         * Enum for ScrollBar direction.
         *
         * @zh
         * 滚动条方向。
         */
        export enum _cocos_ui_scroll_bar__Direction {
            /**
             * @en
             * Horizontal scroll.
             *
             * @zh
             * 横向滚动。
             */
            HORIZONTAL = 0,
            /**
             * @en
             * Vertical scroll.
             *
             * @zh
             * 纵向滚动。
             */
            VERTICAL = 1
        }
        /**
         * @en
         * Enum for ScrollView event type.
         *
         * @zh
         * 滚动视图事件类型
         */
        export enum _cocos_ui_scroll_view__EventType {
            /**
             * @en
             * The event emitted when ScrollView scroll to the top boundary of inner container.
             *
             * @zh
             * 滚动视图滚动到顶部边界事件。
             */
            SCROLL_TO_TOP = "scroll-to-top",
            /**
             * @en
             * The event emitted when ScrollView scroll to the bottom boundary of inner container.
             *
             * @zh
             * 滚动视图滚动到底部边界事件。
             */
            SCROLL_TO_BOTTOM = "scroll-to-bottom",
            /**
             * @en
             * The event emitted when ScrollView scroll to the left boundary of inner container.
             *
             * @zh
             * 滚动视图滚动到左边界事件。
             */
            SCROLL_TO_LEFT = "scroll-to-left",
            /**
             * @en
             * The event emitted when ScrollView scroll to the right boundary of inner container.
             *
             * @zh
             * 滚动视图滚动到右边界事件。
             */
            SCROLL_TO_RIGHT = "scroll-to-right",
            /**
             * @en
             * The event emitted when ScrollView scroll began.
             *
             * @zh
             * 滚动视图滚动开始时发出的事件。
             */
            SCROLL_BEGAN = "scroll-began",
            /**
             * @en
             * The event emitted when ScrollView auto scroll ended.
             *
             * @zh
             * 滚动视图滚动结束的时候发出的事件。
             */
            SCROLL_ENDED = "scroll-ended",
            /**
             * @en
             * The event emitted when ScrollView scroll to the top boundary of inner container and start bounce.
             *
             * @zh
             * 滚动视图滚动到顶部边界并且开始回弹时发出的事件。
             */
            BOUNCE_TOP = "bounce-top",
            /**
             * @en
             * The event emitted when ScrollView scroll to the bottom boundary of inner container and start bounce.
             *
             * @zh
             * 滚动视图滚动到底部边界并且开始回弹时发出的事件。
             */
            BOUNCE_BOTTOM = "bounce-bottom",
            /**
             * @en
             * The event emitted when ScrollView scroll to the left boundary of inner container and start bounce.
             *
             * @zh
             * 滚动视图滚动到左边界并且开始回弹时发出的事件。
             */
            BOUNCE_LEFT = "bounce-left",
            /**
             * @en
             * The event emitted when ScrollView scroll to the right boundary of inner container and start bounce.
             *
             * @zh
             * 滚动视图滚动到右边界并且开始回弹时发出的事件。
             */
            BOUNCE_RIGHT = "bounce-right",
            /**
             * @en
             * The event emitted when ScrollView is scrolling.
             *
             * @zh
             * 滚动视图正在滚动时发出的事件。
             */
            SCROLLING = "scrolling",
            /**
             * @en
             * The event emitted when ScrollView auto scroll ended with a threshold.
             *
             * @zh
             * 滚动视图自动滚动快要结束的时候发出的事件。
             */
            SCROLL_ENG_WITH_THRESHOLD = "scroll-ended-with-threshold",
            /**
             * @en
             * The event emitted when user release the touch.
             *
             * @zh
             * 当用户松手的时候会发出一个事件。
             */
            TOUCH_UP = "touch-up"
        }
        export enum _cocos_ui_scroll_view__XrhoverType {
            NONE = 0,
            LEFT = 1,
            RIGHT = 2
        }
        /**
         * @en
         * The Slider Direction.
         *
         * @zh
         * 滑动器方向。
         */
        export enum _cocos_ui_slider__Direction {
            /**
             * @en
             * The horizontal direction.
             *
             * @zh
             * 水平方向。
             */
            Horizontal = 0,
            /**
             * @en
             * The vertical direction.
             *
             * @zh
             * 垂直方向。
             */
            Vertical = 1
        }
        export enum _cocos_ui_toggle__EventType {
            TOGGLE = "toggle"
        }
        /**
         * @en Enum for Widget's alignment mode, indicating when the widget should refresh.
         *
         * @zh Widget 的对齐模式，表示 Widget 应该何时刷新。
         */
        export enum _cocos_ui_widget__AlignMode {
            /**
             * @en Only align once when the Widget is enabled for the first time.
             * This will allow the script or animation to continue controlling the current node.
             * It will only be aligned once before the end of frame when onEnable is called,then immediately disables the Widget.
             *
             * @zh 仅在 Widget 第一次激活时对齐一次，便于脚本或动画继续控制当前节点。<br/>
             * 开启后会在 onEnable 时所在的那一帧结束前对齐一次，然后立刻禁用该 Widget。
             */
            ONCE = 0,
            /**
             * @en Keep aligning all the way.
             *
             * @zh  始终保持对齐。
             */
            ALWAYS = 1,
            /**
             * @en
             * At the beginning, the widget will be aligned as the method 'ONCE'.
             * After that the widget will be aligned only when the size of screen is modified.
             *
             * @zh
             * 一开始会像 ONCE 一样对齐一次，之后每当窗口大小改变时还会重新对齐。
             */
            ON_WINDOW_RESIZE = 2
        }
        /**
         * @en Enum for Widget's alignment flag, indicating when the widget select alignment.
         *
         * @zh Widget 的对齐标志，表示 Widget 选择对齐状态。
         */
        export enum _cocos_ui_widget__AlignFlags {
            /**
             * @en Align top.
             *
             * @zh 上边对齐。
             */
            TOP = 1,
            /**
             * @en Align middle.
             *
             * @zh 垂直中心对齐。
             */
            MID = 2,
            /**
             * @en Align bottom.
             *
             * @zh 下边对齐。
             */
            BOT = 4,
            /**
             * @en Align left.
             *
             * @zh 左边对齐。
             */
            LEFT = 8,
            /**
             * @en Align center.
             *
             * @zh 横向中心对齐。
             */
            CENTER = 16,
            /**
             * @en Align right.
             *
             * @zh 右边对齐。
             */
            RIGHT = 32,
            /**
             * @en Align horizontal.
             *
             * @zh 横向对齐。
             */
            HORIZONTAL = 56,
            /**
             * @en Align vertical.
             *
             * @zh 纵向对齐。
             */
            VERTICAL = 7
        }
        /**
         * @en Enum for Page View Size Mode.
         *
         * @zh 页面视图每个页面统一的大小类型
         */
        export enum _cocos_ui_page_view__SizeMode {
            /**
             * @en Each page is unified in size
             * @zh 每个页面统一大小
             */
            Unified = 0,
            /**
             * @en Each page is in free size
             * @zh 每个页面大小随意
             */
            Free = 1
        }
        /**
         * @en Enum for Page View Direction.
         *
         * @zh 页面视图滚动类型
         */
        export enum _cocos_ui_page_view__Direction {
            /**
             * @en Horizontal scroll.
             * @zh 水平滚动
             */
            Horizontal = 0,
            /**
             * @en Vertical scroll.
             * @zh 垂直滚动
             */
            Vertical = 1
        }
        /**
         * @en Enum for ScrollView event type.
         *
         * @zh 滚动视图事件类型
         */
        export enum _cocos_ui_page_view__EventType {
            PAGE_TURNING = "page-turning"
        }
        /**
         * @en Enum for PageView Indicator direction.
         *
         * @zh 页面视图指示器的摆放方向
         *
         * @enum PageViewIndicator.Direction
         */
        export enum _cocos_ui_page_view_indicator__Direction {
            /**
             * @en The horizontal direction.
             *
             * @zh 水平方向
             */
            HORIZONTAL = 0,
            /**
             * @en The vertical direction.
             *
             * @zh 垂直方向
             */
            VERTICAL = 1
        }
        function _cocos_ui_widget_manager__updateAlignment(node: Node): void;
        export enum _cocos_video_video_player_enums__EventType {
            /**
             * @en None
             * @zh 无
             */
            NONE = "none",
            /**
             * @en The video is playing.
             * @zh 视频播放中
             */
            PLAYING = "playing",
            /**
             * @en Video paused
             * @zh 视频暂停中
             */
            PAUSED = "paused",
            /**
             * @en Video stopped
             * @zh 视频停止中
             */
            STOPPED = "stopped",
            /**
             * @en End of video
             * @zh 视频播放完毕
             */
            COMPLETED = "completed",
            /**
             * @en Video metadata loading complete
             * @zh 视频元数据加载完毕
             */
            META_LOADED = "meta-loaded",
            /**
             * @en The video is ready to play when loaded
             * @zh 视频加载完毕可播放
             */
            READY_TO_PLAY = "ready-to-play",
            /**
             * @en Video Trigger Error
             * @zh 处理视频时触发的错误
             */
            ERROR = "error",
            /**
             * @en Video clicked
             * @zh 视频被点击
             */
            CLICKED = "clicked"
        }
        export abstract class _cocos_video_video_player_impl__VideoPlayerImpl {
            protected _componentEventList: Map<string, () => void>;
            protected _state: _cocos_video_video_player_enums__EventType;
            protected _video: HTMLVideoElement | null;
            protected _onHide: () => void;
            protected _onShow: () => void;
            protected _interrupted: boolean;
            protected _loaded: boolean;
            protected _loadedMeta: boolean;
            protected _ignorePause: boolean;
            protected _fullScreenOnAwake: boolean;
            protected _visible: boolean;
            protected _playing: boolean;
            protected _cachedCurrentTime: number;
            protected _waitingFullscreen: boolean;
            protected _waitingPlay: boolean;
            protected _keepAspectRatio: boolean;
            protected _component: VideoPlayer | null;
            protected _uiTrans: UITransform | null;
            protected _node: Node | null;
            protected _stayOnBottom: boolean;
            protected _dirty: boolean;
            protected _forceUpdate: boolean;
            protected _w: number;
            protected _h: number;
            protected _m00: number;
            protected _m01: number;
            protected _m04: number;
            protected _m05: number;
            protected _m12: number;
            protected _m13: number;
            constructor(component: any);
            abstract canPlay(): void;
            abstract canFullScreen(enabled: boolean): void;
            abstract pause(): void;
            abstract resume(): void;
            abstract stop(): void;
            abstract seekTo(val: number): void;
            abstract createVideoPlayer(url: string): void;
            abstract removeVideoPlayer(): void;
            abstract enable(): void;
            abstract disable(noPause?: boolean): void;
            abstract syncClip(clip: any): void;
            abstract syncURL(url: string): void;
            abstract syncStayOnBottom(enabled: boolean): void;
            abstract syncKeepAspectRatio(enabled: boolean): void;
            abstract syncPlaybackRate(val: number): void;
            abstract syncVolume(val: number): void;
            abstract syncMute(enabled: boolean): void;
            abstract syncLoop(enabled: boolean): void;
            abstract syncMatrix(): void;
            abstract getDuration(): number;
            abstract getCurrentTime(): number;
            get fullScreenOnAwake(): boolean;
            get loaded(): boolean;
            get componentEventList(): Map<string, () => void>;
            get video(): HTMLVideoElement | null;
            get state(): _cocos_video_video_player_enums__EventType;
            get isPlaying(): boolean;
            get UICamera(): renderer.scene.Camera | null;
            onLoadedMetadata(e: Event): void;
            onCanPlay(e: Event): void;
            onPlay(e: Event): void;
            onPlaying(e: Event): void;
            onPause(e: Event): void;
            onStoped(e: Event): void;
            onEnded(e: Event): void;
            onClick(e: Event): void;
            onError(e: Event): void;
            play(): void;
            delayedPlay(): void;
            syncFullScreenOnAwake(enabled: boolean): void;
            delayedFullScreen(): void;
            protected dispatchEvent(key: any): void;
            protected syncUITransform(width: any, height: any): void;
            protected syncCurrentTime(): void;
            destroy(): void;
        }
        export class _cocos_video_video_player_impl_web__VideoPlayerImplWeb extends _cocos_video_video_player_impl__VideoPlayerImpl {
            protected _eventList: Map<string, ((e: Event) => void)>;
            protected _clearColorA: number;
            protected _clearFlag: any;
            constructor(component: any);
            protected addListener(type: string, handler: (e: Event) => void): void;
            protected removeAllListeners(): void;
            canPlay(): void;
            pause(): void;
            resume(): void;
            stop(): void;
            syncClip(clip: any): void;
            syncURL(url: string): void;
            syncPlaybackRate(val: number): void;
            syncVolume(val: number): void;
            syncMute(enabled: boolean): void;
            syncLoop(enabled: boolean): void;
            getDuration(): number;
            getCurrentTime(): number;
            seekTo(val: number): void;
            canFullScreen(enabled: boolean): void;
            syncStayOnBottom(enabled: boolean): void;
            syncKeepAspectRatio(enabled: boolean): void;
            removeVideoPlayer(): void;
            createVideoPlayer(url: string): void;
            protected _bindDomEvent(): void;
            onCanPlay(e: Event): void;
            enable(): void;
            disable(noPause?: boolean): void;
            syncMatrix(): void;
        }
        export enum _cocos_web_view_web_view_enums__EventType {
            /**
             * @en None
             * @zh 无
             */
            NONE = "none",
            /**
             * @en Web page Load completed.
             * @zh 网页加载完成
             */
            LOADING = "loading",
            /**
             * @en Web page is loading.
             * @zh 网页加载中
             */
            LOADED = "loaded",
            /**
             * @en Web page error occurs when loading.
             * @zh 网页加载出错
             */
            ERROR = "error"
        }
        export abstract class _cocos_web_view_web_view_impl__WebViewImpl {
            protected _componentEventList: Map<_cocos_web_view_web_view_enums__EventType, (...args: any[any]) => void>;
            protected _state: _cocos_web_view_web_view_enums__EventType;
            protected _wrapper: any;
            protected _webview: HTMLIFrameElement | null;
            protected _loaded: boolean;
            protected _forceUpdate: boolean;
            protected _component: WebView | null;
            protected _uiTrans: UITransform | null;
            protected _node: Node | null;
            protected _w: number;
            protected _h: number;
            protected _m00: number;
            protected _m01: number;
            protected _m04: number;
            protected _m05: number;
            protected _m12: number;
            protected _m13: number;
            constructor(component: WebView);
            reset(): void;
            abstract loadURL(url: string): void;
            abstract createWebView(): void;
            abstract removeWebView(): void;
            abstract enable(): void;
            abstract disable(): void;
            abstract syncMatrix(): void;
            abstract evaluateJS(str: string): void;
            abstract setOnJSCallback(callback: () => void): void;
            abstract setJavascriptInterfaceScheme(scheme: string): void;
            get loaded(): boolean;
            get componentEventList(): Map<_cocos_web_view_web_view_enums__EventType, (...args: any) => void>;
            get webview(): HTMLIFrameElement | null;
            get state(): _cocos_web_view_web_view_enums__EventType;
            get UICamera(): renderer.scene.Camera | null;
            protected dispatchEvent(key: _cocos_web_view_web_view_enums__EventType, ...args: any[any]): void;
            destroy(): void;
        }
    }
    import { exoticAnimationTag, ExoticAnimation } from "cc/editor/exotic-animation";
    import { EmbeddedPlayer, embeddedPlayerCountTag, getEmbeddedPlayersTag, addEmbeddedPlayerTag, removeEmbeddedPlayerTag, clearEmbeddedPlayersTag } from "cc/editor/embedded-player";
    import { AnimationMask } from "cc/editor/new-gen-anim";
    import { CCON } from "cc/editor/serialization";
    export { Canvas as CanvasComponent, UIRenderer as RenderComponent, UIRenderer as UIRenderable, UIRenderer as Renderable2D, UITransform as UITransformComponent, Mask as MaskComponent, RichText as RichTextComponent, Sprite as SpriteComponent, UIMeshRenderer as UIModelComponent, LabelOutline as LabelOutlineComponent, Graphics as GraphicsComponent, UIStaticBatch as UIStaticBatchComponent, UIOpacity as UIOpacityComponent, Label as LabelComponent, MeshRenderer as ModelComponent, DirectionalLight as DirectionalLightComponent, Light as LightComponent, SphereLight as SphereLightComponent, SpotLight as SpotLightComponent, SkinnedMeshRenderer as SkinningModelComponent, SkinnedMeshBatchRenderer as BatchedSkinningModelComponent, SkinnedMeshUnit as SkinningModelUnit, Animation as AnimationComponent, AudioSource as AudioSourceComponent, Camera as CameraComponent, ModelRenderer as RenderableComponent, Billboard as BillboardComponent, Line as LineComponent, ParticleSystem as ParticleSystemComponent, SkeletalAnimation as SkeletalAnimationComponent, Button as ButtonComponent, EditBox as EditBoxComponent, Layout as LayoutComponent, ProgressBar as ProgressBarComponent, ScrollBar as ScrollBarComponent, ScrollView as ScrollViewComponent, Slider as SliderComponent, Toggle as ToggleComponent, ToggleContainer as ToggleContainerComponent, Widget as WidgetComponent, PageView as PageViewComponent, PageViewIndicator as PageViewIndicatorComponent, SafeArea as SafeAreaComponent, UICoordinateTracker as UICoordinateTrackerComponent, BlockInputEvents as BlockInputEventsComponent } from "cc";
    import { Details as _Details } from "cc";
    export {};
}
